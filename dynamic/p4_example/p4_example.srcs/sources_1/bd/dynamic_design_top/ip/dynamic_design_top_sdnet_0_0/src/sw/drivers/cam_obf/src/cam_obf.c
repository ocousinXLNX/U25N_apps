/////////////////////////////////////////////////////////////////////////////
// 
// Copyright 2018 Xilinx, Inc. All rights reserved.
// This file contains confidential and proprietary information of Xilinx, Inc.
// and is protected under U.S. and international copyright and other
// intellectual property laws.
//
// DISCLAIMER
// This disclaimer is not a license and does not grant any
// rights to the materials distributed herewith. Except as
// otherwise provided in a valid license issued to you by
// Xilinx, and to the maximum extent permitted by applicable
// law: (1) THESE MATERIALS ARE MADE AVAILABLE "AS IS" AND
// WITH ALL FAULTS, AND XILINX HEREBY DISCLAIMS ALL WARRANTIES
// AND CONDITIONS, EXPRESS, IMPLIED, OR STATUTORY, INCLUDING
// BUT NOT LIMITED TO WARRANTIES OF MERCHANTABILITY, NON-
// INFRINGEMENT, OR FITNESS FOR ANY PARTICULAR PURPOSE; and
// (2) Xilinx shall not be liable (whether in contract or tort,
// including negligence, or under any other theory of
// liability) for any loss or damage of any kind or nature
// related to, arising under or in connection with these
// materials, including for any direct, or any indirect,
// special, incidental, or consequential loss or damage
// (including loss of data, profits, goodwill, or any type of
// loss or damage suffered as a result of any action brought
// by a third party) even if such damage or loss was
// reasonably foreseeable or Xilinx had been advised of the
// possibility of the same.
//
// CRITICAL APPLICATIONS
// Xilinx products are not designed or intended to be fail-
// safe, or for use in any application requiring fail-safe
// performance, such as life-support or safety devices or
// systems, Class III medical devices, nuclear facilities,
// applications related to the deployment of airbags, or any
// other applications that could lead to death, personal
// injury, or severe property or environmental damage
// (individually and collectively, "Critical
// Applications"). Customer assumes the sole risk and
// liability of any use of Xilinx products in Critical
// Applications, subject only to applicable laws and
// regulations governing limitations on product liability.
//
// THIS COPYRIGHT NOTICE AND DISCLAIMER MUST BE RETAINED AS
// PART OF THIS FILE AT ALL TIMES.
//
#include <stdint.h>
#include <stddef.h>
#include <string.h>
#include <stdio.h>
#include <stdlib.h>
#include <stdarg.h>
#include <alloca.h>
#ifndef _BCAM_H_
#define _BCAM_H_
#ifndef _CAM_H_
#define _CAM_H_
#include <stdbool.h>
#ifdef __cplusplus
extern "C" {
#endif
enum cam_errnos {
CAM_OK = 0,
CAM_ERROR_FULL = 1,
CAM_ERROR_NO_OPEN = 2,
CAM_ERROR_INVALID_ARG = 3,
CAM_ERROR_WRONG_KEY_WIDTH = 5,
CAM_ERROR_TOO_MANY_INSTANCES = 6,
CAM_ERROR_WRONG_BIT_FIELD_MASK = 7,
CAM_ERROR_WRONG_CONST_FIELD_MASK = 8,
CAM_ERROR_WRONG_UNUSED_FIELD_MASK = 9,
CAM_ERROR_INVALID_TERNARY_FIELD_LEN = 10,
CAM_ERROR_WRONG_PRIO_WIDTH = 11,
CAM_ERROR_WRONG_MAX = 12,
CAM_ERROR_DUPLICATE_FOUND = 13,
CAM_ERROR_WRONG_PREFIX = 14,
CAM_ERROR_WRONG_PREFIX_MASK = 15,
CAM_ERROR_WRONG_RANGE = 16,
CAM_ERROR_WRONG_RANGE_MASK = 17,
CAM_ERROR_KEY_NOT_FOUND = 18,
CAM_ERROR_WRONG_MIN = 19,
CAM_ERROR_WRONG_PRIO = 20,
CAM_ERROR_WRONG_LIST_LENGTH = 21,
CAM_ERROR_WRONG_NUMBER_OF_SLOTS = 22,
CAM_ERROR_INVALID_MEM_TYPE = 23,
CAM_ERROR_TOO_HIGH_FREQUENCY = 24,
CAM_ERROR_WRONG_TERNARY_MASK = 25,
CAM_ERROR_MASKED_KEY_BIT_IS_SET = 26,
CAM_ERROR_INVALID_MODE = 28,
CAM_ERROR_WRONG_RESPONSE_WIDTH = 29,
CAM_ERROR_FORMAT_SYNTAX = 30, 
CAM_ERROR_TOO_MANY_FIELDS = 31, 
CAM_ERROR_TOO_MANY_RANGES = 32, 
CAM_ERROR_INVALID_RANGE_LEN = 33, 
CAM_ERROR_INVALID_RANGE_START = 34, 
CAM_ERROR_INVALID_PREFIX_LEN = 35, 
CAM_ERROR_INVALID_PREFIX_START = 36, 
CAM_ERROR_INVALID_PREFIX_KEY = 37, 
CAM_ERROR_INVALID_BIT_FIELD_LEN = 38, 
CAM_ERROR_INVALID_BIT_FIELD_START = 39, 
CAM_ERROR_INVALID_CONST_FIELD_LEN = 40, 
CAM_ERROR_INVALID_CONST_FIELD_START = 41, 
CAM_ERROR_INVALID_UNUSED_FIELD_LEN = 42, 
CAM_ERROR_INVALID_UNUSED_FIELD_START = 43, 
CAM_ERROR_MAX_KEY_LEN_EXCEED = 44, 
CAM_ERROR_INVALID_aaaaaaaaaaaaaa1aaaINDEX_WIDTH = 45, 
CAM_ERROR_TOO_MANY_UNITS = 46, 
CAM_ERROR_NO_MASK = 47,
CAM_ERROR_INVALID_MEMORY_WIDTH = 48, 
CAM_ERROR_UNSUPPORTED_COMMAND = 49, 
CAM_ERROR_ENVIRONMENT = 50, 
CAM_ERROR_UNSUPPORTED_CAM_TYPE = 51, 
CAM_ERROR_NULL_POINTER = 52, 
CAM_ERROR_TOO_MANY_PCS = 53, 
CAM_ERROR_CONFIGURATION = 54, 
CAM_ERROR_ENVIRONMENT_FSMBUSY = 55, 
CAM_ERROR_ENVIRONMENT_POLLED_OUT = 56, 
CAM_ERROR_SEGMENT_COUNT_ZERO = 57, 
CAM_ERROR_VC_UNSUPPORTED_COMMAND = 58, 
CAM_ERROR_WRONG_VIRTUAL_CAM_ID = 59, 
CAM_ERROR_WRONG_SEGMENT_NUMBER = 60, 
CAM_ERROR_FATAL_BASE_START = 100,
CAM_ERROR_FATAL_BASE_END = 199,
CAM_ERROR_NOMEM = CAM_ERROR_FATAL_BASE_END,
CAM_ERROR_MALLOC_FAILED = CAM_ERROR_FATAL_BASE_END - 1,
};
#define CAM_DEBUG_NONE 0x00000000 
#define CAM_DEBUG_NO_ERROR_MSG 0x00000001 
#define CAM_DEBUG_ARGS 0x00000002 
#define CAM_DEBUG_VERIFY_WR 0x00000004 
#define CAM_DEBUG_VERIFY_SHADOW 0x00000008 
#define CAM_DEBUG_VERBOSE_VERIFY 0x00000010 
#define CAM_DEBUG_SKIP_MEM_INIT 0x00000020 
#define CAM_DEBUG_CONFIG 0x00000040 
#define CAM_DEBUG_VERIFY_CONFIG 0x00000080 
#define CAM_DEBUG_KEY_MASKING 0x00000100 
#define CAM_DEBUG_STATS 0x00000200 
#define CAM_DEBUG_HW_WR 0x00010000 
#define CAM_DEBUG_HW_RD 0x00020000 
#define CAM_DEBUG_HW_LOOKUP 0x00040000 
#define CAM_OPTIMIZE_NONE 0x00000000 
#define CAM_OPTIMIZE_RAM 0x00000001 
#define CAM_OPTIMIZE_LOGIC 0x00000002 
typedef struct cam_arg_t cam_arg_t;
int cam_arg_create(cam_arg_t **out_cam_arg);
void cam_arg_init(cam_arg_t *out_cam_arg);
size_t cam_arg_size(void);
void cam_arg_destroy(cam_arg_t *cam_arg);
int cam_arg_set_format(cam_arg_t *cam_arg, char *format);
void cam_arg_set_inst_ctx(cam_arg_t *cam_arg, void *inst_ctx);
void cam_arg_set_hw_write_function(cam_arg_t *cam_arg, void (*hw_write_function)(void*, uint32_t, uint32_t));
void cam_arg_set_hw_read_function(cam_arg_t *cam_arg, void (*hw_read_function)(void*, uint32_t, uint32_t*));
void cam_arg_set_num_entries(cam_arg_t *cam_arg, uint32_t num_entries);
void cam_arg_set_hw_assist(struct cam_arg_t *cam_arg, bool hw_assist);
void cam_arg_set_engine_lookup_rate(struct cam_arg_t *cam_arg, float lookup_rate);
void cam_arg_set_lookup_interface_freq(struct cam_arg_t *cam_arg, float freq);
void cam_arg_set_ram_freq(struct cam_arg_t *cam_arg, float freq);
void cam_arg_set_response_width(struct cam_arg_t *cam_arg, uint16_t response_width);
void cam_arg_force_prio_width(struct cam_arg_t *cam_arg, uint8_t prio_width);
void cam_arg_set_key_width(struct cam_arg_t *cam_arg, uint16_t key_width);
void cam_arg_set_num_masks(struct cam_arg_t *cam_arg, uint8_t num_masks);
void cam_arg_force_num_units(struct cam_arg_t *cam_arg, uint16_t num_units);
void cam_arg_force_mem_type(struct cam_arg_t *cam_arg, bool uram);
void cam_arg_force_hbm(struct cam_arg_t *cam_arg);
void cam_arg_set_narrow_key_width(struct cam_arg_t *cam_arg, uint16_t narrow_key_width);
void cam_arg_set_max_hw_writes(struct cam_arg_t *cam_arg, uint16_t max_hw_writes);
void cam_arg_set_flow_control(struct cam_arg_t *cam_arg, bool flow_control);
void cam_arg_set_default_response(struct cam_arg_t *cam_arg, const uint8_t *default_response);
void cam_arg_set_narrow_default_response(struct cam_arg_t *cam_arg, const uint8_t *narrow_default_response);
void cam_arg_set_vcid(struct cam_arg_t* cam_arg, uint8_t vcid);
void cam_arg_set_seg(struct cam_arg_t* cam_arg, uint16_t segment_id);
void cam_arg_set_hw_write_sequence_functions(cam_arg_t *cam_arg, void (*start_function)(void*),
void (*end_function)(void*));
void cam_arg_set_debug_flags(cam_arg_t *cam_arg, uint32_t debug_flags);
void cam_arg_set_optimization_flags(cam_arg_t *cam_arg, uint32_t optimization_flags);
void cam_arg_enable_options(cam_arg_t *cam_arg);
void cam_arg_set_error_print_function(struct cam_arg_t *cam_arg, void (*error_print_function)(void *, char*));
void cam_arg_set_info_print_function(struct cam_arg_t *cam_arg, void (*info_print_function)(void *, char*));
void cam_arg_set_malloc_function(struct cam_arg_t* cam_arg, void* (*malloc_function)(size_t size));
void cam_arg_set_calloc_function(struct cam_arg_t* cam_arg, void* (*calloc_function)(size_t num, size_t size));
void cam_arg_set_free_function(struct cam_arg_t* cam_arg, void (*free_function)(void* ptr));
char *cam_error_string(int error_code);
void cam_print_error(int error_code);
typedef struct cam_options_t cam_options_t;
int cam_options_create(cam_options_t** out_cam_options);
size_t cam_options_size(void);
void cam_options_init(cam_options_t *out_options);
void cam_options_destroy(cam_options_t *cam_options);
void cam_options_set_narrow_key(struct cam_options_t *cam_options, bool narrow);
void cam_options_set_precomputed_hash_value(struct cam_options_t *cam_options, uint8_t hash_value[32]);
void cam_options_clear_precomputed_hash_value(struct cam_options_t *cam_options);
#ifdef __cplusplus
}
#endif
#endif
#ifdef __cplusplus
extern "C" {
#endif
struct bcam;
int bcam_create(const cam_arg_t *cam_arg, struct bcam **out_bcam);
int bcam_insert(struct bcam *bcam, const uint8_t key[], const uint8_t response[], ...);
int bcam_update(struct bcam *bcam, const uint8_t key[], const uint8_t response[], ...);
int bcam_get_by_response(struct bcam *bcam, const uint8_t response[], const uint8_t response_mask[], uint32_t *pos,
uint8_t out_key[], ...);
int bcam_get_by_key(struct bcam *bcam, const uint8_t key[], uint8_t response[], ...);
int bcam_delete(struct bcam *bcam, const uint8_t key[], ...);
int bcam_read_and_clear_ecc_counters(struct bcam *bcam, uint32_t *corrected_single_bit_errors,
uint32_t *detected_double_bit_errors);
int bcam_read_and_clear_ecc_addresses(struct bcam *bcam, uint32_t *failing_address_single_bit_error,
uint32_t *failing_address_double_bit_error);
int bcam_destroy(struct bcam *bcam);
#ifdef __cplusplus
}
#endif
#endif
#ifndef aaaaaa1aaaH
#define aaaaaa1aaaH
#define aaaaaa1aaaaaaaaaaaaaaaabaaaaaaaaaaaaaaaaaaaaaaaaaa3aaaaaaaaaaaaaaaabaaaaaaaaaaaaaaaaaaaaaaaaaaaa3aaaaaaaaaaaaaaaabaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaa3aaaaaaaaaaaaaaaabaaaaaaaaaaaaaaaaaaaaaaaaaaaa4aaaaaaaaaaaabaaaaaaaaaaaaaaaaa5aaaS 256
#define aaaaaa1aaaaaaaaaaaaaaaabaaaaaaaaaaaaaaaaaaaaaaaaaa3aaaaaaaaaaaaaaaabaaaaaaaaaaaaaaaaaaaaaaaaaaaa3bbbbbbbbbbbbbbbbbbbbbbbbbbbbbbbbbbbb3aaaS 32
#define aaaaaa1aaaaaaaaaaaaaaaabaaaaaaaaaaaaaaaaaaaaaaaaaa3aaaaaaaaaaaaaaaabaaaaaaaaaaaaaaaaaaaaaaaaaaaa3bbbbbbbbbbbbbbbbbbbbbbbbbbbbbbbbbbb3aaaaaaaaaaaaaaaabaaaaaaaaaaaaaaaaaaaaaaaaaaaa4aaaaaaaaaaaabaaaaaaaaaaaaaaaaa5aaaS 256
#define aaaaaa1aaaaaaaaaabaaaaaaaaaaa3aaaaaaaaaaaaaaaabaaaaaaaaaaaaaaaaaaaaaaaaaaaa3aaaaaaaaaaaaaaaabaaaaaaaaaaaaaaaaaaaaaaaaaaaaa3aaaaaaaaaaaaaaaabaaaaaaaaaaaaaaaaaaaaaaaaaaaa4aaaaaaaaaaaaabaaaaaaaaaaaaaaaaa5aaaaaaaaaaaaaaaabaaaaaaaaaaaaaaaaaaaaaaaaaaaa5aaaRATIO 4
#define aaaaaa1aaaaaaaaaaaaaaaabaaaaaaaaaaaaaaaaaaaaaaaaaa3aaaaaaaaaaaaaaaabaaaaaaaaaaaaaaaaaaaaaaaaaaaa3aaaaaaaaaaaaaaaabaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaa3aaaS 32
#define aaaaaa1aaaaaaaaaaaaaaaabaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaa3aaaaaaaaaaaaaaaabaaaaaaaaaaaaaaaaaaaaaaaaaaaa4aaaaaaaaaaaaaaaabaaaaaaaaaaaaaaaaaaaaaaaaaa5aaaaaaaaaaaaaaaabaaaaaaaaaaaaaaaaaaaaaaaaaaaa5aaaaaaaaaaaaaaaabaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaa5aaaS 5
#define aaaaaa1aaaaaaaaaaaaaaaabaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaa3aaaaaaaaaaaaaaaabaaaaaaaaaaaaaaaaaaaaaaaaaaaa4bbbbbbbbbbbbbbbbbbbbbbbbbbbbbbbbbb4aaaaaaaaaaaaaaaabaaaaaaaaaaaaaaaaaaaaaaaaaaaa5aaaRATIO 1
#define aaaaaa1aaaBCAM_FILL_RATIO 0.95
#define aaaaaa1aaaHBMBCAM_FILL_RATIO 0.9
#define aaaaaa1aaaHBMBCAM_MAX_LIST_SIZE 1024
#define aaaaaa1aaa1W_FILL_RATIO 0.1
#define aaaaaa1aaa2W_CUCKOO_FILL_RATIO 0.5
#define aaaaaa1aaa3W_CUCKOO_FILL_RATIO 0.9
#define aaaaaa1aaaaaaaaaaaaaaaabaaaaaaaaaaaaaaaaaaaaaaaaaa3aaaaaaaaaaaaaaaabaaaaaaaaaaaaaaaaaaaaaaaaaaaa3aaaaaaaaaaaaaaaabaaaaaaaaaaaaaaaaaaaaa4aaaaaaaaaaaaaaaabaaaaaaaaaaaaaaaaaaaaaaaaaaaa4aaaPER_UNIT 16*1024*1024
#define aaaaaa1aaaaaaaaaaaaaaaabaaaaaaaaaaaaaaaaaaaaaaaaaa3aaaaaaaaaaaaaaaabaaaaaaaaaaaaaaaaaaaaaaaaaaaa3aaaPCS 32 
#define aaaaaa1aaaaaaaaaaaaaaaabaaaaaaaaaaaaaaaaaaaaaaaaaa3aaaaaaaaaaaaaaaabaaaaaaaaaaaaaaaaaaaaaaaaaaaa3aaaHaa1aaaaaaaaaaaabaaaaaaaaaaaaaaaaa3aaaS 32 
#define aaaaaa1bbbbbbbbbbbbbbbbbbbbbbbbbbbbbbbbbbbbbbb3aaaaaaaaaaaaaaaabaaaaaaaaaaaaaaaaaaaaaaaaaaaa4aaaWORD 0x04
#define aaaaaa1aaaCA_WORD 0x08
#define aaaaaa1aaaECC_CNT_WORD 0x04
#define aaaaaa1aaaECC_ADDR_WORD 0x04
#define aaaaaa1aaaaaaaaaaaaaaa1aaaWORD 0x80
#define aaaaaa1aaaaa1aaaWORD 0x08
#define aaaaaa1aaaaaaa1aaaWORD 0x100
#define aaaaaa1bbbbbbbbbbbbbbbbbbbbbbbbbbbbbbbbbbbbbbb3aaaaaaaaaaaaaaaabaaaaaaaaaaaaaaaaaaaaaaaaaaaa4aaaaaaaaaaaaaaaabaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaa4aaa 0x000100
#define aaaaaa1aaaCA_BASE 0x000200
#define aaaaaa1aaaECC_CNT_BASE 0x000300
#define aaaaaa1aaaECC_ADDR_BASE 0x080000
#define aaaaaa1aaaaaaaaaaaaaaa1aaaaaaaaaaaaaaaabaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaa3aaa 0x100000
#define aaaaaa1aaaaa1aaaaaaaaaaaaaaaabaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaa3aaa 0x200000
#define aaaaaa1aaaaaaa1aaaaaaaaaaaaaaaabaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaa3aaa 0x400000
#define aaaaaa1bbbbbbbbbbbbbbbbbbbbbbbbbbbbbbbbbbbbbbb3aaaaaaaaaaaaaaaabaaaaaaaaaaaaaaaaaaaaaaaaaaaa4aaaaaaaaaaaaaaaabaaaaaaaaaaaaaaaaaaaaaaa5aaa 0x0fff00
#define aaaaaa1aaaCA_MASK 0x0ffff0
#define aaaaaa1aaaECC_CNT_MASK 0x0ffff0
#define aaaaaa1aaaECC_ADDR_MASK 0x780000
#define aaaaaa1aaaaaaaaaaaaaaa1aaaaaaaaaaaaaaaabaaaaaaaaaaaaaaaaaaaaaaa3aaa 0x700000
#define aaaaaa1aaaaa1aaaaaaaaaaaaaaaabaaaaaaaaaaaaaaaaaaaaaaa3aaa 0x600000
#define aaaaaa1aaaaaaa1aaaaaaaaaaaaaaaabaaaaaaaaaaaaaaaaaaaaaaa3aaa 0x400000
#define aaaaaa1aaaaaaaaaaaabaaaaaaaaaaaaaaaaa3aaaaaaaaaaaaaaaabaaaaaaaaaaaaaaaaaaaaaaaaaaaa3aaaaaaaaaaaaaaaabaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaa3aaa 0x00800000
#define aaaaaa1aaaaaaaaaaaabaaaaaaaaaaaaaaaaa3aaaaaaaaaaaaaaaabaaaaaaaaaaaaaaaaaaaaaaaaaaaa3aaaaaaaaaaaaaaaabaaaaaaaaaaaaaaaaaaaaaaa4aaa 0xff800000
#define aaaaaa1bbbbbbbbbbbbbbbbbbbbbb3aaaaaaaaaaaaaaaabaaaaaaaaaaaaaaaaaaaaaaaaaaaa4bbbbbbbbbbbbbbbbbbbbbbbbbbbbbbbb4aaaR_MASK 0x00000fff
#define aaaaaa1bbbbbbbbbbbbbbbbbbbbb3aaaaaaaaaaaaaaaabaaaaaaaaaaaaaaaaaaaaaaaaaaaa4bbbbbbbbbbbbbbbbbbbbbbbbbbbbbbbb4aaaR_MASK 0xfffff000
#define aaaaaa1bbbbbbbbbbbbbbbbbbbbb3aaaaaaaaaaaaaaaabaaaaaaaaaaaaaaaaaaaaaaaaaaaa4bbbbbbbbbbbbbbbbbbbbbbbbbbbbbbbb4aaaR_OFFSET 12
#define aaaaaa1aaaHA_BASE 0x01000
#define aaaaaa1aaaHA_MASK 0x01800
#define aaaaaa1aaaHD_BASE 0x01800
#define aaaaaa1aaaHD_MASK 0x01800
#endif
#ifndef _CAM_CONFIGP_H_
#define _CAM_CONFIGP_H_
#ifndef _CAMP_H_
#define _CAMP_H_
#ifndef _VBCAM_H_
#define _VBCAM_H_
#ifdef __cplusplus
extern "C" {
#endif
struct vbcam;
int vbcam_create(const cam_arg_t *cam_arg, struct vbcam **out_vbcam);
int vbcam_insert(struct vbcam* vbcam, const uint8_t key[], const uint8_t response[], const cam_options_t *options);
int vbcam_update(struct vbcam *vbcam, const uint8_t key[], const uint8_t response[], const cam_options_t *options);
int vbcam_get_by_response(struct vbcam *vbcam, const uint8_t response[],
const uint8_t response_mask[], uint32_t *pos,
uint8_t out_key[], const cam_options_t *options);
int vbcam_get_by_key(struct vbcam *vbcam, const uint8_t key[], uint8_t response[], const cam_options_t *options);
int vbcam_delete(struct vbcam *vbcam, const uint8_t key[], const cam_options_t *options);
int vbcam_compute_hash_value(const struct vbcam *vbcam, const uint8_t key[], uint8_t hash_value[32],
const cam_options_t *options);
int vbcam_get_segment(const struct vbcam *vbcam, const uint8_t hash_value[32], uint16_t *segment);
int vbcam_destroy(struct vbcam *vbcam);
typedef struct {
void *ctx;
int16_t segment;
} segment_ctx_t;
#ifdef __cplusplus
}
#endif
#endif
#define CAM_VERSION_MAJOR 2
#define CAM_VERSION_MINOR 3
#define CAM_MIN_KEY_WIDTH 10
#define CAM_MAX_KEY_WIDTH 992
#define CAM_MAX_KEY_WIDTH_MEM ((CAM_MAX_KEY_WIDTH + 31) / 32)
#define CAM_MIN_PRIO_WIDTH 0
#define CAM_MAX_PRIO_WIDTH 32
#define CAM_MIN_RESPONSE_WIDTH 1
#define CAM_MAX_RESPONSE_WIDTH 1024
#define CAM_MAX_aaaaaaaaaaaaaa1aaaaaaaaaaaaaaaabaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaa3aaaaaaaaaaaaaaaabaaaaaaaaaaaaaaaaaaaaaaaaaaaa4aaaWIDTH (CAM_MAX_PRIO_WIDTH + CAM_MAX_RESPONSE_WIDTH)
#define CAM_MAX_aaaaaaaaaaaaaa1aaaaaaaaaaaaaaaabaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaa3aaaaaaaaaaaaaaaabaaaaaaaaaaaaaaaaaaaaaaaaaaaa4aaaWIDTH_MEM ((CAM_MAX_aaaaaaaaaaaaaa1aaaaaaaaaaaaaaaabaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaa3aaaaaaaaaaaaaaaabaaaaaaaaaaaaaaaaaaaaaaaaaaaa4aaaWIDTH + 31) / 32)
#define CAM_AGING_BITS (5 + 1 + 1)
#define ASIC 0
#define CAM_MAX_BRAMS 24
#define CAM_MAX_URAMS 32
#define CAM_MAX_FREQ (ASIC ? 800 : 600)
#define CAM_BRAM_DEPTH_WIDTH64 512
#define CAM_URAM_DEPTH_WIDTH64 4096
#define CAM_BRAM_DEPTH_MIN CAM_BRAM_DEPTH_WIDTH64
#define CAM_BRAM_DEPTH_MAX (4 * CAM_BRAM_DEPTH_MIN)
#define CAM_URAM_DEPTH_MIN (CAM_URAM_DEPTH_WIDTH64 / 2)
#define CAM_URAM_DEPTH_MAX (2 * CAM_URAM_DEPTH_MIN)
typedef struct {
uint32_t word[CAM_MAX_KEY_WIDTH_MEM];
} aaaaaaaaaaaaa1aaat;
typedef struct {
uint32_t word[CAM_MAX_aaaaaaaaaaaaaa1aaaaaaaaaaaaaaaabaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaa3aaaaaaaaaaaaaaaabaaaaaaaaaaaaaaaaaaaaaaaaaaaa4aaaWIDTH_MEM];
} aaaaaaaaaaaaaaaa1aaaaaaaaaaaaaaaabaaaaaaaaaaaaaaaaaaaaaaaaaaaa3aaat;
#define aaaaaaaaaaa1aaaaaaaaaaaaaaaabaaaaaaaaaaaaaaaaaaaaaaaaaaaa3aaaaaaaaaaaaaaaabaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaa3aaaaaaaaaaaaaaaabaaaaaaaaaaaaaaaaaaaaaaaaaaaa4aaaWIDTH_128 128
#define aaaaaaaaaaa1aaaaaaaaaaaaaaaabaaaaaaaaaaaaaaaaaaaaaaaaaaaa3aaaaaaaaaaaaaaaabaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaa3aaaaaaaaaaaaaaaabaaaaaaaaaaaaaaaaaaaaaaaaaaaa4aaaWIDTH_MEM_128 ((aaaaaaaaaaa1aaaaaaaaaaaaaaaabaaaaaaaaaaaaaaaaaaaaaaaaaaaa3aaaaaaaaaaaaaaaabaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaa3aaaaaaaaaaaaaaaabaaaaaaaaaaaaaaaaaaaaaaaaaaaa4aaaWIDTH_128 + 7) / 8)
#define CAM_MAX_SEGMENT_HASH_ENTRIES 256 
#define CAM_HASH_VAL_SIZE_IN_BYTES 4 
#define CAM_MAX_SEGMENT_HASH_ENTRIES_WIDTH 8
#define CAM_MAX_VC_SEGMENTS 256
#define CAM_MAX_VC_SEGMENTS_MEM ((CAM_MAX_VC_SEGMENTS + 7) / 8)
#define CAM_MAX_VCS 128 
#define CAM_MAX_NUM_FIELDS 32
#define CAM_ARG_FORMAT_LEN 1024
#define NULL_CHECK(ptr) if (ptr == NULL) return CAM_ERROR_NULL_POINTER
enum cam_mem_type_t {
AUTO, URAM, BRAM
};
typedef struct {
int16_t vcid; 
uint8_t bit_map[CAM_MAX_VC_SEGMENTS_MEM]; 
}vc_cam_segment_map_t;
typedef void* (*cam_malloc_func)(size_t sz); 
typedef void* (*cam_calloc_func)(size_t num, size_t size);
typedef void (*cam_free_func)(void* ptr); 
struct cam_arg_t {
uint32_t num_entries;
uint16_t num_units;
enum cam_mem_type_t mem_type;
int16_t priority_width;
uint16_t response_width;
float lookup_interface_freq;
float engine_lookup_rate;
bool hbm;
uint32_t ram_size;
uint16_t dram_read_size;
float ram_freq;
char format[CAM_ARG_FORMAT_LEN];
uint16_t key_width;
uint8_t num_masks;
bool hw_assist;
uint16_t narrow_key_width;
bool flow_control;
uint8_t default_response[sizeof(aaaaaaaaaaaaaaaa1aaaaaaaaaaaaaaaabaaaaaaaaaaaaaaaaaaaaaaaaaaaa3aaat)];
uint8_t narrow_default_response[sizeof(aaaaaaaaaaaaaaaa1aaaaaaaaaaaaaaaabaaaaaaaaaaaaaaaaaaaaaaaaaaaa3aaat)];
void (*hw_write_function)(void*, uint32_t, uint32_t);
void (*hw_read_function)(void*, uint32_t, uint32_t*);
void (*hw_write_start_sequence_function)(void*);
void (*hw_write_end_sequence_function)(void*);
uint32_t debug_flags;
void (*error_print_function)(void*, char*);
void (*info_print_function)(void*, char*);
cam_malloc_func malloc_function;
cam_free_func free_function;
cam_calloc_func calloc_function;
vc_cam_segment_map_t vc_seg_map; 
segment_ctx_t segment_ctx;
uint8_t vc_id;
uint16_t max_hw_writes;
bool options; 
uint32_t optimization_flags;
};
struct cam_options_t {
bool narrow; 
bool precomp_hash;
uint32_t hash_value;
};
void cam_arg_set_ram_size(struct cam_arg_t *cam_arg, uint32_t size);
void camp_arg_set_seg(struct cam_arg_t *cam_arg, uint16_t segment);
void camp_arg_set_vcid(struct cam_arg_t *cam_arg, uint8_t vcid);
#endif
#ifndef _CAM_CONFIG_H_
#define _CAM_CONFIG_H_
#ifdef __cplusplus
extern "C" {
#endif
#ifndef _CAM_CONFIG_T_
#define _CAM_CONFIG_T_
typedef struct cam_config_t cam_config_t;
#endif
typedef enum {
TCAM, BCAM, STCAM, HBMBCAM, COMPBCAM
} cam_instance_type_t;
int cam_config_create(const cam_arg_t *cam_arg, cam_instance_type_t cam_instance_type, cam_config_t **cam_config);
void cam_config_destroy(cam_config_t *cam_config);
uint16_t cam_config_get_key_width(const cam_config_t *cam_config);
uint16_t cam_config_get_narrow_key_width(const cam_config_t *cam_config);
uint8_t cam_config_get_num_masks(const cam_config_t *cam_config);
uint8_t cam_config_get_prio_width(const cam_config_t *cam_config);
uint16_t cam_config_get_response_width(const cam_config_t *cam_config);
uint16_t cam_config_get_num_units(const cam_config_t *cam_config);
uint8_t cam_config_get_num_slots(const cam_config_t *cam_config);
uint16_t cam_config_get_num_physical_units(const cam_config_t *cam_config);
uint16_t cam_config_get_list_length(const cam_config_t *cam_config);
uint32_t cam_config_get_num_lists(const cam_config_t *cam_config);
uint8_t cam_config_get_latency(const cam_config_t *cam_config);
uint16_t cam_config_get_num_brams(const cam_config_t *cam_config);
uint16_t cam_config_get_num_urams(const cam_config_t *cam_config);
uint8_t cam_config_get_num_ranges(const cam_config_t *cam_config);
bool cam_config_is_tcam_instance(const cam_config_t *cam_config);
bool cam_config_is_bcam_instance(const cam_config_t *cam_config);
bool cam_config_is_hbmbcam_instance(const cam_config_t *cam_config);
bool cam_config_is_uram_instance(const cam_config_t *cam_config);
bool cam_config_is_mixed_mode(const cam_config_t *cam_config);
void cam_config_get_default_response(const cam_config_t *cam_config, uint8_t *default_response);
void cam_config_get_narrow_default_response(const cam_config_t *cam_config, uint8_t *narrow_default_response);
bool cam_config_has_flow_control(const cam_config_t *cam_config);
bool cam_config_is_single_clock(const cam_config_t *cam_config);
int cam_config_get_range_start_pos(const cam_config_t *cam_config, uint8_t range_number,
uint16_t *start_pos);
int cam_config_get_range_width(const cam_config_t *cam_config, uint8_t range_number, uint8_t *width);
uint8_t cam_config_get_field_width(const cam_config_t *cam_config, uint8_t field_num);
uint8_t cam_config_get_num_pcs(const cam_config_t *cam_config);
uint8_t cam_config_get_replication(const cam_config_t *cam_config);
uint16_t cam_config_get_field_pos(const cam_config_t *cam_config, uint8_t field_num);
char *cam_config_get_header(const cam_config_t *cam_config);
char *cam_config_get_values(const cam_config_t *cam_config);
char *cam_config_get_lookup_clock_info(const cam_config_t *cam_config);
char *cam_config_get_ram_clock_info(const cam_config_t *cam_config);
char *cam_config_get_tdm_info(const cam_config_t *cam_config);
char *cam_config_get_ram_utilization_info(const cam_config_t *cam_config);
char *cam_config_get_memory_units_info(const cam_config_t *cam_config);
void cam_config_print(const cam_config_t *cam_config);
#ifdef __cplusplus
}
#endif
#endif
#define CAM_CONFIG_MAX_RANGES 8
typedef enum {
aaaaaaaaaaa1aaaaaaaaaaaaaaaabaaaaaaaaaaaaaaaaaaaaaaaaaaaa3aaaR16, 
aaaaaaaaaaa1aaaaaaaaaaaaaaaabaaaaaaaaaaaaaaaaaaaaaaaaaaaa3aaaP128, 
aaaaaaaaaaa1aaaaaaaaaaaaaaaabaaaaaaaaaaaaaaaaaaaaaaaaaaaa3aaaB128, 
aaaaaaaaaaa1aaaaaaaaaaaaaaaabaaaaaaaaaaaaaaaaaaaaaaaaaaaa3aaaT64, 
aaaaaaaaaaa1aaaaaaaaaaaaaaaabaaaaaaaaaaaaaaaaaaaaaaaaaaaa3aaaC128, 
aaaaaaaaaaa1aaaaaaaaaaaaaaaabaaaaaaaaaaaaaaaaaaaaaaaaaaaa3aaaU128, 
} aaaaaaaaaaa1aaaaaaaaaaaaaaaabaaaaaaaaaaaaaaaaaaaaaaaaaaaa3aaatypes;
typedef struct {
aaaaaaaaaaa1aaaaaaaaaaaaaaaabaaaaaaaaaaaaaaaaaaaaaaaaaaaa3aaatypes type;
uint8_t instance;
uint16_t start_pos;
uint16_t len;
} aaaaaaaaaaa1aaaaaaaaaaaaaaaabaaaaaaaaaaaaaaaaaaaaaaaaaaaa3aaadesc;
struct cam_config_t {
cam_arg_t arg;
uint16_t key_width;
uint16_t num_units;
uint8_t num_slots;
uint16_t num_physical_units;
uint16_t list_length;
uint32_t num_lists;
bool uram;
uint8_t num_ranges;
uint16_t range_start_pos[CAM_CONFIG_MAX_RANGES];
uint8_t range_width[CAM_CONFIG_MAX_RANGES];
uint32_t num_entries_per_unit;
aaaaaaaaaaa1aaaaaaaaaaaaaaaabaaaaaaaaaaaaaaaaaaaaaaaaaaaa3aaadesc aaaaaaaaaaaaaaaaaa1aaa[CAM_MAX_NUM_FIELDS];
uint8_t num_fields;
uint8_t latency;
uint8_t prio_width;
uint8_t replication;
cam_instance_type_t instance_type;
uint8_t num_lists_per_read;
uint8_t num_pcs;
bool flow_control;
uint16_t version;
uint16_t segment; 
void *ctx;
};
#ifndef _CAM_CONFIG_T_
#define _CAM_CONFIG_T_
typedef struct cam_config_t cam_config_t;
#endif
int cam_config_get_aaaaaaaaaaaaaaaaaa1aaa(const cam_config_t *cam_config, uint8_t field_number, aaaaaaaaaaa1aaaaaaaaaaaaaaaabaaaaaaaaaaaaaaaaaaaaaaaaaaaa3aaadesc *desc);
uint16_t cam_config_get_num_entries_per_unit(const cam_config_t *cam_config);
uint8_t cam_config_get_num_fields(const cam_config_t *cam_config);
uint32_t cam_config_get_num_entries(const cam_config_t *cam_config);
uint32_t cam_config_get_ram_size(const cam_config_t *cam_config);
uint16_t cam_config_get_segment(const cam_config_t *cam_config);
uint32_t cam_config_get_num_lists_per_read(const cam_config_t * const cam_config);
void cam_config_print(const cam_config_t *cam_config);
#endif
#ifndef COMP_BCAM_IP
#ifndef a1aaaH
#define a1aaaH
#ifndef aaa1aaaH
#define aaa1aaaH
#ifndef aaaa1aaaH
#define aaaa1aaaH
#ifndef aaaaaaaaaaaaaaa1aaaH
#define aaaaaaaaaaaaaaa1aaaH
#ifndef _aaaaaaaaaaaaaaa1aaaT_
#define _aaaaaaaaaaaaaaa1aaaT_
typedef struct aaaaaaaaaaaaaaa1aaat aaaaaaaaaaaaaaa1aaat;
#endif
size_t aaaaaaaaaaaaaaa1aaaaaaaaaaaaaabaaaaaaaaaa3aaa(void);
void aaaaaaaaaaaaaaa1bbbbbbbbbbbbbbbbbbbbbbbbbbbbbbbb3aaa(aaaaaaaaaaaaaaa1aaat *pointer_list, const aaaaaaaaaaaaaaaa1aaaaaaaaaaaaaaaabaaaaaaaaaaaaaaaaaaaaaaaaaaaa3aaat *prio, const aaaaaaaaaaaaa1aaat *aaaaaaaaa1aaa,
const aaaaaaaaaaaaa1aaat *ternary_mask, bool narrow_key);
uint32_t aaaaaaaaaaaaaaa1aaaaaaaaaaaaaaaabaaaaaaaaaaaa3aaaaaaaaaaaaaaaabaaaaaaaaaaaaaaaaaaaaaaaaaaaa3aaaaaaaaaabaaaaaaaaaaa4aaa(const aaaaaaaaaaaaaaa1aaat *pointer_list);
uint8_t aaaaaaaaaaaaaaa1aaaaaaaaaaaaaaaabaaaaaaaaaaaa3aaaaaaaaaaaaaaaabaaaaaaaaaaaaaaaaaaaaaaaaaaaa3aaaaaaaaaaaaaaabaaaaaaaaaaaaaaaa4aaaber_of_keys(const struct aaaaaaaaaaaaaaa1aaat *pointer_list);
const aaaaaaaaaaaaa1aaat *aaaaaaaaaaaaaaa1aaaaaaaaaaaaaaaabaaaaaaaaaaaa3aaaaaaaaaaaaaaaabaaaaaaaaaaaaaaaaaaaaaaaaaaaa3aaaaaaaaaaaa1aaa(const aaaaaaaaaaaaaaa1aaat *pointer_list, uint8_t key_number);
const aaaaaaaaaaaaaaaa1aaaaaaaaaaaaaaaabaaaaaaaaaaaaaaaaaaaaaaaaaaaa3aaat *aaaaaaaaaaaaaaa1aaaaaaaaaaaaaaaabaaaaaaaaaaaa3aaaaaaaaaaaaaaaabaaaaaaaaaaaaaaaaaaaaaaaaaaaa3aaaaaaaaaaaaaaabaaaaaaaaaaaaaaaaa4aaa(const aaaaaaaaaaaaaaa1aaat *pointer_list, uint8_t key_number);
void aaaaaaaaaaaaaaa1aaaaaaaaaaaaaabaaaaaaaaaaa3aaa(aaaaaaaaaaaaaaa1aaat *pointer_list, uint32_t bucket, bool is_direct_pointer_list, bool ternary_list);
void aaaaaaaaaaaaaaa1aaaaaaaaaaaaaaaabaaaaaaaaaaaaaaaaaaa3aaaaaaaaaaaaaaaabaaaaaaaaaaaaaaaaaaaaaaaaaaaa3aaaall(aaaaaaaaaaaaaaa1aaat *pointer_list);
bool aaaaaaaaaaaaaaa1aaaaaaaaaaaaaaabaaaaaaaaaaaa3aaaaaaaaaaaaaaaabaaaaaaaaaaaaaaaaaaaaaaaaaaaa3aaaaaaaaaaaaaaaabaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaa3aaaaaaaaaaaaaaaabaaaaaaaaaaaaaaaaaaaaaaaaaaaa4aaapointer(const aaaaaaaaaaaaaaa1aaat *pointer_list);
const aaaaaaaaaaaaa1aaat *aaaaaaaaaaaaaaa1aaaaaaaaaaaaaaaabaaaaaaaaaaaa3aaaaaaaaaaaaaaaabaaaaaaaaaaaaaaaaaaaaaaaaaaaa3aaaternary_mask(const aaaaaaaaaaaaaaa1aaat *pointer_list, uint8_t key_number);
bool aaaaaaaaaaaaaaa1aaaaaaaaaaaaaaabaaaaaaaaaaaa3aaaaaaaaaaaaaaaabaaaaaaaaaaaaaaaaaaaaaaaaaaaa3aaanarrow_key(const aaaaaaaaaaaaaaa1aaat *pointer_list, uint8_t key_number);
#endif
#ifndef _aaaa1aaaT_
#define _aaaa1aaaT_
typedef struct aaaa1aaat aaaa1aaat;
#endif
#ifndef _a1aaaT_
#define _a1aaaT_
typedef struct a1aaat a1aaat;
#endif
size_t aaaa1aaaaaaaaaaaaaabaaaaaaaaaa3aaa(void);
bool aaaa1aaaaaaaaaaaaaabaaaaaaaaaaa3aaa(aaaa1aaat *km, a1aaat *client, uint16_t unit, uint8_t slot_number, bool flush);
void aaaa1aaaaaaaaaaaaaabaaaaaaaaaaaa3aaa(aaaa1aaat* km, cam_free_func free_function);
void aaaa1aaaaaaaaaaaaaaaabaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaa3aaa(aaaa1aaat *km, uint32_t aaaaaaaaaa1aaaaaaaaaaaaaaaabaaaaaaaaaaaaaaaaaaaaaaaaaaaa3aaaaaaaaaaaaaaabaaaaaaaaaaaaaaaa4aaaber, const aaaaaaaaaaaaaaa1aaat *pointer_list, uint8_t narrow, uint8_t narrow_element);
uint32_t aaaa1aaaaaaaaaaaaaaaabaaaaaaaaaaaa3aaaaaaaaaaaaaaaabaaaaaaaaaaaaaaaaaaaaaaaaaaaa3aaaaaaaaaaaaa1aaaaaaaaaaaaaaaabaaaaaaaaaaaaaaaaaaaaaaaaaaaa3aaaaaaaaaaaaaabaaaaaaaaaa4aaa(const aaaa1aaat *km);
void aaaa1bbbbbbbbbbbbbbbbbb3aaaaaaaaaaaaaaaabaaaaaaaaaaaaaaaaaaaaaaaaaaaa4aaaaaaaaaaaaa1aaa(aaaa1aaat *km, void *ptr);
void *aaaa1aaaaaaaaaaaaaaaabaaaaaaaaaaaa3aaaaaaaaaaaaaaaabaaaaaaaaaaaaaaaaaaaaaaaaaaaa3aaaaaaaaaaaaa1aaa(aaaa1aaat *km);
bool aaaa1aaafind_first_fit_for_pointer_list(const aaaa1aaat *km, const aaaaaaaaaaaaaaa1aaat *pointer_list,
uint32_t *aaaaaaaaaa1aaaaaaaaaaaaaaaabaaaaaaaaaaaaaaaaaaaaaaaaaaaa3aaaaaaaaaaaaaaabaaaaaaaaaaaaaaaa4aaaber);
void aaaa1aaaread(const aaaa1aaat *km, uint32_t aaaaaaaaaa1aaaaaaaaaaaaaaaabaaaaaaaaaaaaaaaaaaaaaaaaaaaa3aaaaaaaaaaaaaaabaaaaaaaaaaaaaaaa4aaaber, aaaaaaaaaaaaaaa1aaat *pointer_list);
void aaaa1bbbbbbbbbbbbbbbbb3aaa(aaaa1aaat *km, uint32_t aaaaaaaaaa1aaaaaaaaaaaaaaaabaaaaaaaaaaaaaaaaaaaaaaaaaaaa3aaaaaaaaaaaaaaabaaaaaaaaaaaaaaaa4aaaber);
bool aaaa1aaaaaaaaaaaaaaabaaaaaaaaaaaa3aaaaaaaaaaaaaaaabaaaaaaaaaaaaaaaaaaaaaaaaaaaa3aaaaaaaaaaaaaaaabaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaa3aaa(const aaaa1aaat *km, uint32_t aaaaaaaaaa1aaaaaaaaaaaaaaaabaaaaaaaaaaaaaaaaaaaaaaaaaaaa3aaaaaaaaaaaaaaabaaaaaaaaaaaaaaaa4aaaber);
bool aaaa1aaaaaaaaaaaaaaabaaaaaaaaaaaa3aaaaaaaaaaaaaaaabaaaaaaaaaaaaaaaaaaaaaaaaaaaa3aaapresent(const aaaa1aaat *km, uint32_t aaaaaaaaaa1aaaaaaaaaaaaaaaabaaaaaaaaaaaaaaaaaaaaaaaaaaaa3aaaaaaaaaaaaaaabaaaaaaaaaaaaaaaa4aaaber, uint8_t narrow, uint8_t narrow_element);
void aaaa1aaaaaaaaaaaaaaaabaaaaaaaaaaaa3aaaaaaaaaaaaaaaabaaaaaaaaaaaaaaaaaaaaaaaaaaaa3aaaaaaaaaaaaaaaabaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaa3aaaaaaaaaaaaaaaabaaaaaaaaaaaaaaaaaaaaaaaaaaaa4aaabits(const aaaa1aaat *km, uint32_t aaaaaaaaaa1aaaaaaaaaaaaaaaabaaaaaaaaaaaaaaaaaaaaaaaaaaaa3aaaaaaaaaaaaaaabaaaaaaaaaaaaaaaa4aaaber, bool *wide_valid, bool *narrow1_valid,
bool *narrow0_valid);
bool aaaa1aaaaaaaaaaaaaaabaaaaaaaaaaaa3aaaaaaaaaaaaaaaabaaaaaaaaaaaaaaaaaaaaaaaaaaaa3aaaaaaaaaaaaaaaabaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaa3aaaaaaaaaaaaaaaabaaaaaaaaaaaaaaaaaaaaaaaaaaaa4aaapointer(const aaaa1aaat *km, uint32_t aaaaaaaaaa1aaaaaaaaaaaaaaaabaaaaaaaaaaaaaaaaaaaaaaaaaaaa3aaaaaaaaaaaaaaabaaaaaaaaaaaaaaaa4aaaber);
bool aaaa1aaaaaaaaaaaaaaabaaaaaaaaaaaa3aaaaaaaaaaaaaaaabaaaaaaaaaaaaaaaaaaaaaaaaaaaa3aaaaaaaaaaaaaaaabaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaa3aaaaaaaaaaaaaaaabaaaaaaaaaaaaaaaaaaaaaaaaaaaa4aaapointer(const aaaa1aaat *km, uint32_t aaaaaaaaaa1aaaaaaaaaaaaaaaabaaaaaaaaaaaaaaaaaaaaaaaaaaaa3aaaaaaaaaaaaaaabaaaaaaaaaaaaaaaa4aaaber);
uint32_t aaaa1aaaaaaaaaaaaaaaabaaaaaaaaaaaa3aaaaaaaaaaaaaaaabaaaaaaaaaaaaaaaaaaaaaaaaaaaa3aaaaaaaaaabaaaaaaaaaaa4aaa(const aaaa1aaat *km, uint32_t aaaaaaaaaa1aaaaaaaaaaaaaaaabaaaaaaaaaaaaaaaaaaaaaaaaaaaa3aaaaaaaaaaaaaaabaaaaaaaaaaaaaaaa4aaaber);
void aaaa1bbbbbbbbbbbbbbbbbb3aaaaaaaaaaaaaaaabaaaaaaaaaaaaaaaaaaaaaaaaaaaa4bbbbbbbbbbbbbbbbbbb4aaa(aaaa1aaat *km);
void aaaa1bbbbbbbbbbbbbbbbb3aaaaaaaaaaaaaaaabaaaaaaaaaaaaaaaaaaaaaaaaaaaa4bbbbbbbbbbbbbbbbbbb4aaa(aaaa1aaat *km);
void aaaa1aaaaaaaaaaaaaaaabaaaaaaaaaaaaaaaaaaa3aaa(aaaa1aaat *km);
void aaaa1aaaaaaaaaaaaaaaabaaaaaaaaaaaaaaaaaaa3aaaaaaaaaaaaaaaabaaaaaaaaaaaaaaaaaaaaaaaaaaaa3aaaelement(aaaa1aaat *km, uint32_t aaaaaaaaaa1aaaaaaaaaaaaaaaabaaaaaaaaaaaaaaaaaaaaaaaaaaaa3aaaaaaaaaaaaaaabaaaaaaaaaaaaaaaa4aaaber, uint8_t narrow, uint8_t narrow_element);
bool aaaa1aaaread_element(aaaa1aaat *km, uint32_t aaaaaaaaaa1aaaaaaaaaaaaaaaabaaaaaaaaaaaaaaaaaaaaaaaaaaaa3aaaaaaaaaaaaaaabaaaaaaaaaaaaaaaa4aaaber, aaaaaaaaaaaaaaa1aaat *pointer_list, bool verify, uint8_t narrow,
uint8_t narrow_element);
void aaaa1bbbbbbbbbbbbbbbb3aaaaaaaaaaaaaaaabaaaaaaaaaaaaaaaaaaaaaaaaaaaa4aaaand_flush(aaaa1aaat *target_km, aaaa1aaat *source_km, uint32_t list);
void aaaa1bbbbbbbbbbbbbbbbbbbb3aaaaaaaaaaaaaaaabaaaaaaaaaaaaaaaaaaaaaaaaaaaa4aaaaaaaaaaaaaaaaa1aaaaaaaaaaaaaaaabaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaa3aaa(aaaa1aaat *km, uint32_t aaaaaaaaaa1aaaaaaaaaaaaaaaabaaaaaaaaaaaaaaaaaaaaaaaaaaaa3aaaaaaaaaaaaaaabaaaaaaaaaaaaaaaa4aaaber, const aaaaaaaaaaaaaaaa1aaaaaaaaaaaaaaaabaaaaaaaaaaaaaaaaaaaaaaaaaaaa3aaat *prio, uint8_t narrow,
uint8_t narrow_element);
void aaaa1bbbbbbbbbbbbbbbbbbbb3aaaaaaaaaaaaaaaabaaaaaaaaaaaaaaaaaaaaaaaaaaaa4aaaaaaaaaaaaaaaabaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaa4aaa(aaaa1aaat *km, uint32_t aaaaaaaaaa1aaaaaaaaaaaaaaaabaaaaaaaaaaaaaaaaaaaaaaaaaaaa3aaaaaaaaaaaaaaabaaaaaaaaaaaaaaaa4aaaber, const aaaaaaaaaaaaaaaa1aaaaaaaaaaaaaaaabaaaaaaaaaaaaaaaaaaaaaaaaaaaa3aaat *prio, uint8_t narrow,
uint8_t narrow_element);
void aaaa1bbbbbbbbbbbbbbbb3aaa(aaaa1aaat *target_km, const aaaa1aaat *source_km);
void aaaa1bbbbbbbbbbbbbbbbbbb3aaaaaaaaaaaaaaaabaaaaaaaaaaaaaaaaaaaaaaaaaaaa4aaaall(aaaa1aaat *km);
uint64_t aaaa1aaaread_and_clear_ecc_addresses(aaaa1aaat *km);
#endif
#ifndef _aaaaaaaaaaaaaaa1aaaT_
#define _aaaaaaaaaaaaaaa1aaaT_
typedef struct aaaaaaaaaaaaaaa1aaat aaaaaaaaaaaaaaa1aaat;
#endif
#ifndef _aaa1aaaT_
#define _aaa1aaaT_
typedef struct aaa1aaat aaa1aaat;
#endif
#ifndef _a1aaaT_
#define _a1aaaT_
typedef struct a1aaat a1aaat;
#endif
#ifndef _aaaa1aaaT_
#define _aaaa1aaaT_
typedef struct aaaa1aaat aaaa1aaat;
#endif
typedef enum {
aaa1aaaaaaaaaaaaaaaabaaaaaaaaaaaaaaaaaaa3aaa = 0, aaa1aaaREAD = 1, aaa1bbbbbbbbbbbbbbbbbbbb3aaa = 2
} aaa1bbbbbbbbbbbbbbbbbbbbbbbbbbbb3aaaaaaaaaaaaaaaabaaaaaaaaaaaaaaaaaaaaaaaaaaaa4aaat;
bool aaa1aaaaaaaaaaaaaabaaaaaaaaaaa3aaa(aaa1aaat *phm, a1aaat *client, uint16_t unit, uint8_t slot_number);
void aaa1aaaaaaaaaaaaaabaaaaaaaaaaaa3aaa(aaa1aaat* phm, cam_free_func free_function);
size_t aaa1aaaaaaaaaaaaaabaaaaaaaaaa3aaa(void);
bool aaa1aaaaaaaaaaaaaaabaaaaaaaaaaaaaaaaaaa3aaa(aaa1aaat *phm, const aaaaaaaaaaaaa1aaat *key, const aaaaaaaaaaaaa1aaat *ternary_mask,
const aaaaaaaaaaaaaaaa1aaaaaaaaaaaaaaaabaaaaaaaaaaaaaaaaaaaaaaaaaaaa3aaat *response,
bool true_first_fit,
uint8_t recover_start_function);
uint32_t aaa1aaaaaaaaaaaaaaaabaaaaaaaaaaaa3aaaaaaaaaaaaaaaabaaaaaaaaaaaaaaaaaaaaaaaaaaaa3aaaaaaaaaaaaaaaabaaaaaaaaaaaaaaaaaaaaaaaaaaaaa3aaatal_number_of_bucket_keys(const aaa1aaat *phm);
uint32_t aaa1aaaaaaaaaaaaaaaabaaaaaaaaaaaa3aaaaaaaaaaaaaaaabaaaaaaaaaaaaaaaaaaaaaaaaaaaa3aaaaaaaaaaaaaaaabaaaaaaaaaaaaaaaaaaaaaaaaaaaaa3aaatal_number_of_aaaaaaaaa1aaas(const aaa1aaat *phm);
uint32_t aaa1aaaaaaaaaaaaaaaabaaaaaaaaaaaa3aaaaaaaaaaaaaaaabaaaaaaaaaaaaaaaaaaaaaaaaaaaa3aaaaaaaaaaaaaaabaaaaaaaaaaaaaaaa4aaaber_of_aaaaaaaaa1aaas(const aaa1aaat *phm);
uint32_t aaa1aaaaaaaaaaaaaaaabaaaaaaaaaaaa3aaaaaaaaaaaaaaaabaaaaaaaaaaaaaaaaaaaaaaaaaaaa3aaaaaaaaaaaaaaaabaaaaaaaaaaaaaaaaaaaaaaaaaaaaa3aaatal_number_of_elements(const aaa1aaat *phm);
void aaa1aaaaaaaaaaaaaaaabaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaa3aaa(const aaa1aaat *phm);
void aaa1aaaaaaaaaaaaaaaabaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaa3aaaaaaaaaaaaaaaabaaaaaaaaaaaaaaaaaaaaaaaaaaaa4aaaaaaaaaaaaaaaabaaaaaaaaaaaaaaaaaaaaaaa5aaaaaaaaaaaaaaaabaaaaaaaaaaaaaaaaaaaaaaaaaaaa5aaaaaaaaaaaabaaaaaaaaaaa6aaa(aaa1aaat *phm, const aaaaaaaaaaaaa1aaat *mask,
uint16_t seed, uint8_t range_valid, uint8_t mask_id);
bool aaa1aaaaaaaaaaaaaaabaaaaaaaaaaaa3aaaaaaaaaaaaaaaabaaaaaaaaaaaaaaaaaaaaaaaaaaaa3aaaaaaaaaaaaaaaabaaaaaaaaaaaaaaaaaaaaaaa4aaaaaaaaaaaaaaaabaaaaaaaaaaaaaaaaaaaaaaaaaaaa4aaaequal(const aaa1aaat *phm, const aaaaaaaaaaaaa1aaat *mask, uint8_t range_valid,
uint8_t mask_id);
bool aaa1aaaaaaaaaaaaaaabaaaaaaaaaaaa3aaaaaaaaaaaaaaaabaaaaaaaaaaaaaaaaaaaaaaaaaaaa3aaaaaaaaaaaaaaaabaaaaaaaaaaaaaaaaaaaaaaa4aaaaaaaaaaaaaaaabaaaaaaaaaaaaaaaaaaaaaaaaaaaa4aaaaaaaaaaaabaaaaaaaaaaa5aaaaaaaaaaaaaaaabaaaaaaaaaaaaaaaaaaaaaaaaaaaa5aaavalid(const aaa1aaat *phm);
void aaa1bbbbbbbbbbbbbbbbb3aaaaaaaaaaaaaaaabaaaaaaaaaaaaaaaaaaaaaaaaaaaa4aaaaaaaaaaaaaaaabaaaaaaaaaaaaaaaaaaaaaaa5aaaaaaaaaaaaaaaabaaaaaaaaaaaaaaaaaaaaaaaaaaaa5aaaaaaaaaaaabaaaaaaaaaaa6aaa(const aaa1aaat *phm);
bool aaa1bbbbbbbbbbbbbbbbbbbbbbbb3aaaaaaaaaaaaaaaabaaaaaaaaaaaaaaaaaaaaaaaaaaaa4aaaone_element(aaa1aaat *target_phm, aaa1aaat *source_phm);
void aaa1aaaread_mask(const aaa1aaat *phm, aaaaaaaaaaaaa1aaat *mask, uint8_t *range_valid,
uint8_t *mask_id);
uint32_t aaa1aaaaaaaaaaaaaaaabaaaaaaaaaaaa3aaaaaaaaaaaaaaaabaaaaaaaaaaaaaaaaaaaaaaaaaaaa3aaaaaaaaaaaaaaabaaaaaaaaaaaaaaaa4aaaber_of_keys(const aaa1aaat *phm);
uint8_t aaa1aaaaaaaaaaaaaaaabaaaaaaaaaaaa3aaaaaaaaaaaaaaaabaaaaaaaaaaaaaaaaaaaaaaaaaaaa3bbbbbbbbbbbbbbbbbbbbbbbbbbbbbbbbbbbb3aaaaaaaaaaaaaaaabaaaaaaaaaaaaaaaaaaaaaaaaaaaa4aaaaaaaaaaaaaaabaaaaaaaaaaaaaaaa5aaaber(const aaa1aaat *phm);
bool aaa1aaafind_response(aaa1aaat *phm, const aaaaaaaaaaaaaaaa1aaaaaaaaaaaaaaaabaaaaaaaaaaaaaaaaaaaaaaaaaaaa3aaat *response, const aaaaaaaaaaaaaaaa1aaaaaaaaaaaaaaaabaaaaaaaaaaaaaaaaaaaaaaaaaaaa3aaat *response_mask,
uint32_t *start_value,
aaaaaaaaaaaaa1aaat *aaaaaaaaa1aaa,
aaaaaaaaaaaaa1aaat *ternary_mask, uint8_t *narrow,
uint8_t *narrow_element, bool narrow_key);
uint16_t aaa1aaaaaaaaaaaaaaaabaaaaaaaaaaaa3aaaaaaaaaaaaaaaabaaaaaaaaaaaaaaaaaaaaaaaaaaaa3aaaaaaaaaaaabaaaaaaaaaaaaaaaaa4aaa(const aaa1aaat *phm);
aaaa1aaat* aaa1aaaaaaaaaaaaaaaabaaaaaaaaaaaa3aaaaaaaaaaaaaaaabaaaaaaaaaaaaaaaaaaaaaaaaaaaa3aaakm(const aaa1aaat *phm);
uint16_t aaa1aaaaaaaaaaaaaaaabaaaaaaaaaaaa3aaaaaaaaaaaaaaaabaaaaaaaaaaaaaaaaaaaaaaaaaaaa3aaaseed(const aaa1aaat *phm);
void aaa1aaaaaaaaaaaaaaaabaaaaaaaaaaaaaaaaaaaaaaa3aaaaaaaaaaaaaaaabaaaaaaaaaaaaaaaaaaaaaaaaaaaa3aaaaaaaaaaaaaaaabaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaa3aaa(const aaa1aaat *phm, const aaaaaaaaaaaaa1aaat *key, aaaaaaaaaaaaa1aaat *masked_key);
bool aaa1bbbbbbbbbbbbbbbbbbbbbbbbbbbb3aaa(aaa1aaat *phm, const aaaaaaaaaaaaa1aaat *key, const aaaaaaaaaaaaa1aaat *ternary_mask, aaa1bbbbbbbbbbbbbbbbbbbbbbbbbbbb3aaaaaaaaaaaaaaaabaaaaaaaaaaaaaaaaaaaaaaaaaaaa4aaat execute,
bool *unresolvable_collision_found, bool match_prio, aaaaaaaaaaaaaaaa1aaaaaaaaaaaaaaaabaaaaaaaaaaaaaaaaaaaaaaaaaaaa3aaat *comp_prio);
bool aaa1bbbbbbbbbbbbbbbbbbbbbb3aaaokup(const aaa1aaat *phm, const aaaaaaaaaaaaa1aaat *key, aaaaaaaaaaaaaaaa1aaaaaaaaaaaaaaaabaaaaaaaaaaaaaaaaaaaaaaaaaaaa3aaat *out_prio_response);
int aaa1aaacheck_ternary_mask(const a1aaat *client, const aaaaaaaaaaaaa1aaat *key, const aaaaaaaaaaaaa1aaat *ternary_mask,
const aaaaaaaaaaaaa1aaat *mask, uint8_t range_valid);
const a1aaat *aaa1aaaaaaaaaaaaaaaabaaaaaaaaaaaa3aaaaaaaaaaaaaaaabaaaaaaaaaaaaaaaaaaaaaaaaaaaa3aaaclient(const aaa1aaat *phm);
void aaa1aaaread_and_clear_recover_stats(uint8_t *highest_recover_function, uint8_t *highest_recover_seed_increment,
uint32_t *num_recovers);
bool aaa1bbbbbbbbbbbbbbbbbbbbbbbbbbbbbbbbbbbbbb3aaaaaaaaaaaaaaaabaaaaaaaaaaaaaaaaaaaaaaaaaaaa4bbbbbbbbbbbbbbbbbbbbbbbbbbbb4aaa(aaa1aaat *phm, const aaaaaaaaaaaaa1aaat *key, aaa1bbbbbbbbbbbbbbbbbbbbbbbbbbbb3aaaaaaaaaaaaaaaabaaaaaaaaaaaaaaaaaaaaaaaaaaaa4aaat execute,
bool match_response, aaaaaaaaaaaaaaaa1aaaaaaaaaaaaaaaabaaaaaaaaaaaaaaaaaaaaaaaaaaaa3aaat *response, uint32_t murmur_bucket, bool narrow_key);
bool aaa1bbbbbbbbbbbbbbbbbbbbbbbbbbbbbbbbbbbbbb3aaaaaaaaaaaaaaaabaaaaaaaaaaaaaaaaaaaaaaaaaaaa4aaaaaaaaaaaaaaabaaaaaaaaaaaaaaaaaaa5aaa(aaa1aaat *phm, const aaaaaaaaaaaaa1aaat *key, const aaaaaaaaaaaaaaaa1aaaaaaaaaaaaaaaabaaaaaaaaaaaaaaaaaaaaaaaaaaaa3aaat *response, uint32_t bucket,
aaaaaaaaaaaaaaa1aaat *evicted_entry, bool narrow_key);
bool aaa1aaaif_invalid_insert(aaa1aaat *phm, const aaaaaaaaaaaaa1aaat *key, const aaaaaaaaaaaaaaaa1aaaaaaaaaaaaaaaabaaaaaaaaaaaaaaaaaaaaaaaaaaaa3aaat *response, uint32_t bucket,
bool narrow_key);
bool aaa1bbbbbbbbbbbbbbbbbbbbbbbbbbbbbbbbbbbbbb3aaaaaaaaaaaaaaaabaaaaaaaaaaaaaaaaaaaaaaaaaaaa4bbbbbbbbbbbbbbbbbbbbbb4aaaokup(const aaa1aaat *phm, const aaaaaaaaaaaaa1aaat *key, aaaaaaaaaaaaaaaa1aaaaaaaaaaaaaaaabaaaaaaaaaaaaaaaaaaaaaaaaaaaa3aaat *out_prio_resp, bool narrow_key);
void aaa1bbbbbbbbbbbbbbbbbbb3aaa(const aaa1aaat *phm, const a1aaat *client);
uint64_t aaa1aaaread_and_clear_ecc_addresses(const aaa1aaat *phm);
void aaa1bbbbbbbbbbbbbbbbbbbbbbbbbbbbbbbbbbbbbb3aaaaaaaaaaaaaaaabaaaaaaaaaaaaaaaaaaaaaaaaaaaa4aaaaaaaaaaaaaaaabaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaa4aaa(const aaa1aaat *phm);
uint32_t aaa1aaaaaaaaaaaaaaaabaaaaaaaaaaaa3aaaaaaaaaaaaaaaabaaaaaaaaaaaaaaaaaaaaaaaaaaaa3aaaaaaaaaaaaabaaaaaaaaaaaaaaaaa4aaaaaaaaaaaaaaaabaaaaaaaaaaaaaaaaaaaaaaaaaaaa4aaafrom_murmur(const aaa1aaat *phm, uint32_t murmur_bucket);
bool aaa1aaaread_element(aaa1aaat *phm, uint32_t aaaaaaaaaa1aaaaaaaaaaaaaaaabaaaaaaaaaaaaaaaaaaaaaaaaaaaa3aaaaaaaaaaaaaaabaaaaaaaaaaaaaaaa4aaaber, aaaaaaaaaaaaaaa1aaat *pointer_list, bool verify, uint8_t narrow,
uint8_t narrow_element);
bool aaa1aaaaaaaaaaaaaaaabaaaaaaaaaaaaaaaaaaa3aaaaaaaaaaaaaaaabaaaaaaaaaaaaaaaaaaaaaaaaaaaa3aaaelement(aaa1aaat *phm, uint32_t aaaaaaaaaa1aaaaaaaaaaaaaaaabaaaaaaaaaaaaaaaaaaaaaaaaaaaa3aaaaaaaaaaaaaaabaaaaaaaaaaaaaaaa4aaaber, uint8_t narrow, uint8_t narrow_element);
#endif
#ifndef HTABLE_H
#define HTABLE_H
#include <math.h>
#ifndef _HTABLE_T_
#define _HTABLE_T_
typedef struct htable_t htable_t;
#endif
#define HTABLE_MAX_KEY_SIZE (CAM_MAX_KEY_WIDTH_MEM * 2)
#ifndef _HTABLE_KEY_T_
#define _HTABLE_KEY_T_
typedef struct
{
uint32_t word[HTABLE_MAX_KEY_SIZE];
} htable_key_t;
#endif
size_t htable_size();
void htable_free(htable_t *htable, cam_free_func free_function);
void htable_write(htable_t *htable, uint32_t hash_value, uint16_t value);
bool htable_init(htable_t* htable, uint32_t size, cam_calloc_func calloc_function);
void htable_inc(htable_t *htable, uint32_t hash_value);
void htable_read(const htable_t *htable, uint32_t hash_value, uint8_t *counter, uint16_t *value, bool *value_unknown);
void htable_dec(htable_t *htable, uint32_t hash_value, uint16_t value);
void htable_calc_stats(htable_t *htable, uint32_t *size, uint32_t *zeroes, uint32_t *ones, uint32_t *twoplussum,
uint32_t *onetwoeightplus, uint32_t *sumfirsthalf);
#endif
#ifndef _a1aaaT_
#define _a1aaaT_
typedef struct a1aaat a1aaat;
typedef struct comp_cam_a1aaat comp_cam_a1aaat;
#endif
#ifndef _aaa1aaaT_
#define _aaa1aaaT_
typedef struct aaa1aaat aaa1aaat;
#endif
#ifndef _aaaa1aaaT_
#define _aaaa1aaaT_
typedef struct aaaa1aaat aaaa1aaat;
#endif
int a1bbbbbbbbbbbbbbbbbbbbbbbbbbbbbbbbbbbbbbb3aaaeate(const cam_arg_t *cam_arg, cam_instance_type_t cam_instance_type, a1aaat **client);
bool a1aaaaaaaaaaaaaaabaaaaaaaaaaaa3aaaaaaaaaaaaaaaabaaaaaaaaaaaaaaaaaaaaaaaaaaaa3aaawide_instance(const a1aaat *client);
uint8_t a1aaaaaaaaaaaaaaaabaaaaaaaaaaaa3aaaaaaaaaaaaaaaabaaaaaaaaaaaaaaaaaaaaaaaaaaaa3aaaa1aaaaaaaaaaaaaaabaaaaaaaaaaaaaaaa3aaaber(const a1aaat *client);
uint16_t a1aaaaaaaaaaaaaaaabaaaaaaaaaaaa3aaaaaaaaaaaaaaaabaaaaaaaaaaaaaaaaaaaaaaaaaaaa3aaaaaaaaaaaaabaaaaaaaaaaaaaaaaa4aaaaaaaaaaaaaaaabaaaaaaaaaaaaaaaaaaaaaaaaaaaa4aaalength(const a1aaat *client);
uint16_t a1aaaaaaaaaaaaaaaabaaaaaaaaaaaa3aaaaaaaaaaaaaaaabaaaaaaaaaaaaaaaaaaaaaaaaaaaa3aaaaaaaaaaaaaaabaaaaaaaaaaaaaaaa4aaaaaaaaaaaaaaaabaaaaaaaaaaaaaaaaaaaaaaaaaaaa4aaaaaaaaaaaabaaaaaaaaaaaaaaaaa5aaas(const a1aaat *client);
uint32_t a1aaaaaaaaaaaaaaaabaaaaaaaaaaaa3aaaaaaaaaaaaaaaabaaaaaaaaaaaaaaaaaaaaaaaaaaaa3aaaaaaaaaaaaaaabaaaaaaaaaaaaaaaa4aaaaaaaaaaaaaaaabaaaaaaaaaaaaaaaaaaaaaaaaaaaa4aaaaaaaaaaaaabaaaaaaaaaaaaaaaaa5aaas(const a1aaat *client);
bool a1aaaaaaaaaaaaaaabaaaaaaaaaaaa3aaaaaaaaaaaaaaaabaaaaaaaaaaaaaaaaaaaaaaaaaaaa3aaaoverwritten(const a1aaat *client, const aaa1aaat *phm, uint32_t list);
void a1bbbbbbbbbbbbbbbbbbbbbbbbbbbbbbbb3aaaaaaaaaaaaaaaabaaaaaaaaaaaaaaaaaaaaaaaaaaaa4aaaoverwrite(a1aaat *client, aaa1aaat *phm, uint32_t list, aaaaaaaaaaaaaaa1aaat *pointer_list, uint8_t narrow,
uint8_t narrow_element);
int a1aaaaaaaaaaaaaaaabaaaaaaaaaaaa3aaaaaaaaaaaaaaaabaaaaaaaaaaaaaaaaaaaaaaaaaaaa3aaawidths(const a1aaat *client, uint16_t *key_width, uint16_t *response_width,
bool narrow_key);
uint8_t a1aaaaaaaaaaaaaaaabaaaaaaaaaaaa3aaaaaaaaaaaaaaaabaaaaaaaaaaaaaaaaaaaaaaaaaaaa3aaaaaaaaaaaaaaabaaaaaaaaaaaaaaaa4aaaaaaaaaaaaaaaabaaaaaaaaaaaaaaaaaaaaaaaaaaaa4bbbbbbbbbbbbbbbbbbbbbbbbbbbbbbbbbbbb4aaas(const a1aaat *client);
uint16_t a1aaaaaaaaaaaaaaaabaaaaaaaaaaaa3aaaaaaaaaaaaaaaabaaaaaaaaaaaaaaaaaaaaaaaaaaaa3aaaaaaaaaaaaaaaabaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaa3aaaaaaaaaaaaaaaabaaaaaaaaaaaaaaaaaaaaaaaaaaaa4aaawidth(const a1aaat *client);
uint16_t a1aaaaaaaaaaaaaaaabaaaaaaaaaaaa3aaaaaaaaaaaaaaaabaaaaaaaaaaaaaaaaaaaaaaaaaaaa3aaanarrow_key_width(const a1aaat *client);
uint8_t a1aaaaaaaaaaaaaaaabaaaaaaaaaaaa3aaaaaaaaaaaaaaaabaaaaaaaaaaaaaaaaaaaaaaaaaaaa3aaaaaaaaaaaaaaabaaaaaaaaaaaaaaaaa4aaaaaaaaaaaaaaaabaaaaaaaaaaaaaaaaaaaaaaaaaaaa4aaawidth(const a1aaat *client);
uint16_t a1aaaaaaaaaaaaaaaabaaaaaaaaaaaa3aaaaaaaaaaaaaaaabaaaaaaaaaaaaaaaaaaaaaaaaaaaa3aaaaaaaaaaaaaaaabaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaa3aaaaaaaaaaaaaaaabaaaaaaaaaaaaaaaaaaaaaaaaaaaa4aaawidth(const a1aaat *client);
uint16_t a1aaaaaaaaaaaaaaaabaaaaaaaaaaaa3aaaaaaaaaaaaaaaabaaaaaaaaaaaaaaaaaaaaaaaaaaaa3aaaaaaaaaaaaaaabaaaaaaaaaaaaaaaa4aaaaaaaaaaaaaaaabaaaaaaaaaaaaaaaaaaaaaaaaaaaa4aaaaaaaaaaaaaaaabaaaaaaaaaaaaaaaaaaaaa5aaaaaaaaaaaaaaaabaaaaaaaaaaaaaaaaaaaaaaaaaaaa5aaaper_unit(const a1aaat *client);
uint8_t a1aaaaaaaaaaaaaaaabaaaaaaaaaaaa3aaaaaaaaaaaaaaaabaaaaaaaaaaaaaaaaaaaaaaaaaaaa3aaaaaaaaaaaaaaabaaaaaaaaaaaaaaaa4aaaaaaaaaaaaaaaabaaaaaaaaaaaaaaaaaaaaaaaaaaaa4aaaaaaaaaaaaaaabaaaaaaaaaaaaaaaaaa5aaas(const a1aaat *client);
uint32_t a1aaaaaaaaaaaaaaaabaaaaaaaaaaaa3aaaaaaaaaaaaaaaabaaaaaaaaaaaaaaaaaaaaaaaaaaaa3aaaaaaaaaaaaaaabaaaaaaaaaaaaaaaa4aaaaaaaaaaaaaaaabaaaaaaaaaaaaaaaaaaaaaaaaaaaa4aaaaaaaaaaaaaaaabaaaaaaaaaaaaaaaaaaaaa5aaa(const a1aaat *client);
uint8_t a1aaaaaaaaaaaaaaaabaaaaaaaaaaaa3aaaaaaaaaaaaaaaabaaaaaaaaaaaaaaaaaaaaaaaaaaaa3aaaaaaaaaaaaaaabaaaaaaaaaaaaaaaa4aaaaaaaaaaaaaaaabaaaaaaaaaaaaaaaaaaaaaaaaaaaa4aaaaaaaaaaaaaaaabaaaaaaaaaaaaaaaaaaaaaaa5aaas(const a1aaat *client);
uint8_t a1aaaaaaaaaaaaaaaabaaaaaaaaaaaa3aaaaaaaaaaaaaaaabaaaaaaaaaaaaaaaaaaaaaaaaaaaa3aaaaaaaaaaaaaaabaaaaaaaaaaaaaaaa4aaaaaaaaaaaaaaaabaaaaaaaaaaaaaaaaaaaaaaaaaaaa4aaaaaaaaaaaaaaaabaaaaaaaaaaaaaaaaaaaa5aaas(const a1aaat *client);
int a1aaaaaaaaaaaaaaaabaaaaaaaaaaaa3aaaaaaaaaaaaaaaabaaaaaaaaaaaaaaaaaaaaaaaaaaaa3aaaaaaaaaaaaaaaabaaaaaaaaaaaaaaaaaaaa4aaaaaaaaaaaaaaaabaaaaaaaaaaaaaaaaaaaaaaaaaaaa4aaastart_pos(const a1aaat *client, uint8_t range_number, uint16_t *start_pos);
int a1aaaaaaaaaaaaaaaabaaaaaaaaaaaa3aaaaaaaaaaaaaaaabaaaaaaaaaaaaaaaaaaaaaaaaaaaa3aaaaaaaaaaaaaaaabaaaaaaaaaaaaaaaaaaaa4aaaaaaaaaaaaaaaabaaaaaaaaaaaaaaaaaaaaaaaaaaaa4aaawidth(const a1aaat *client, uint8_t range_number, uint8_t *width);
int a1aaaaaaaaaaaaaaaabaaaaaaaaaaaa3aaaaaaaaaaaaaaaabaaaaaaaaaaaaaaaaaaaaaaaaaaaa3aaaaaaaaaaaaaaaaaaaaa1aaa(const a1aaat *client, uint8_t field_number, aaaaaaaaaaa1aaaaaaaaaaaaaaaabaaaaaaaaaaaaaaaaaaaaaaaaaaaa3aaadesc *desc);
void a1aaaaaaaaaaaaaaaabaaaaaaaaaaaaaaaaaaaaaaaaa3aaa(a1aaat *client);
void a1aaaaaaaaaaaaaaaabaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaa3aaa(const a1aaat *client);
void a1aaatable_print(const a1aaat *client);
int a1bbbbbbbbbbbbbbbbbbbb3aaaaaaaaaaaaaaaabaaaaaaaaaaaaaaaaaaaaaaaaaaaa4aaaaaaaaaaaaaaaabaaaaaaaaaaaaaaaaaaaa5aaaaaaaaaaaaaaaabaaaaaaaaaaaaaaaaaaaaaaaaaaaa5aaaaaaaaaaaaaaaabaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaa5aaa(a1aaat *client, const aaaaaaaaaaaaa1aaat *key, const aaaaaaaaaaaaa1aaat *ternary_mask,
const aaaaaaaaaaaaaaaa1aaaaaaaaaaaaaaaabaaaaaaaaaaaaaaaaaaaaaaaaaaaa3aaat *key_prio,
const aaaaaaaaaaaaa1aaat *mask, uint8_t range_valid, uint8_t mask_id);
int a1aaaaaaaaaaaaaaaabaaaaaaaaaaaaaaaaaaa3aaaaaaaaaaaaaaaabaaaaaaaaaaaaaaaaaaaaaaaaaaaa3aaaaaaaaaaaaaaaabaaaaaaaaaaaaaaaaaaaa4aaaaaaaaaaaaaaaabaaaaaaaaaaaaaaaaaaaaaaaaaaaa4aaaaaaaaaaaaaaaabaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaa4aaa(a1aaat *client, const aaaaaaaaaaaaa1aaat *key, const aaaaaaaaaaaaa1aaat *ternary_mask,
const aaaaaaaaaaaaa1aaat *mask, uint8_t range_valid, uint8_t mask_id);
int a1aaaread_prio_for_range_key(const a1aaat *client, const aaaaaaaaaaaaaaaa1aaaaaaaaaaaaaaaabaaaaaaaaaaaaaaaaaaaaaaaaaaaa3aaat *response,
const aaaaaaaaaaaaaaaa1aaaaaaaaaaaaaaaabaaaaaaaaaaaaaaaaaaaaaaaaaaaa3aaat *response_mask,
uint32_t *pos,
aaaaaaaaaaaaa1aaat *key, aaaaaaaaaaaaa1aaat *ternary_mask, aaaaaaaaaaaaa1aaat *mask, uint8_t *range_valid,
uint8_t *mask_id);
int a1aaaread_response_for_key(const a1aaat *client, aaaaaaaaaaaaaaaa1aaaaaaaaaaaaaaaabaaaaaaaaaaaaaaaaaaaaaaaaaaaa3aaat *response, aaaaaaaaaaaaaaaa1aaaaaaaaaaaaaaaabaaaaaaaaaaaaaaaaaaaaaaaaaaaa3aaat *prio_mask,
uint32_t *pos,
aaaaaaaaaaaaa1aaat *key,
aaaaaaaaaaaaa1aaat *mask, bool narrow_key);
int a1bbbbbbbbbbbbbbbbbbbb3aaaaaaaaaaaaaaaabaaaaaaaaaaaaaaaaaaaaaaaaaaaa4aaaaaaaaaaaaaaaabaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaa4aaa(a1aaat *client, const aaaaaaaaaaaaa1aaat *key, const aaaaaaaaaaaaaaaa1aaaaaaaaaaaaaaaabaaaaaaaaaaaaaaaaaaaaaaaaaaaa3aaat *response, const aaaaaaaaaaaaa1aaat *mask,
const cam_options_t *options);
int a1aaaaaaaaaaaaaaabaaaaaaaaaaaaaaaaaaa3aaaaaaaaaaaaaaaabaaaaaaaaaaaaaaaaaaaaaaaaaaaa3aaaaaaaaaaaaaaaabaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaa3aaa(a1aaat *client, const aaaaaaaaaaaaa1aaat *key, const aaaaaaaaaaaaaaaa1aaaaaaaaaaaaaaaabaaaaaaaaaaaaaaaaaaaaaaaaaaaa3aaat *response, const aaaaaaaaaaaaa1aaat *mask,
const cam_options_t *options);
int a1aaaaaaaaaaaaaaaabaaaaaaaaaaaaaaaaaaa3aaaaaaaaaaaaaaaabaaaaaaaaaaaaaaaaaaaaaaaaaaaa3aaaaaaaaaaaaaaaabaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaa3aaa(a1aaat *client, const aaaaaaaaaaaaa1aaat *key, const aaaaaaaaaaaaa1aaat *mask, const cam_options_t *options);
int a1aaaread_key(const a1aaat *client, const aaaaaaaaaaaaa1aaat *key, aaaaaaaaaaaaaaaa1aaaaaaaaaaaaaaaabaaaaaaaaaaaaaaaaaaaaaaaaaaaa3aaat *response, const aaaaaaaaaaaaa1aaat *mask,
const cam_options_t *options);
int a1aaaread_range_key(const a1aaat *client, const aaaaaaaaaaaaa1aaat *key, const aaaaaaaaaaaaa1aaat *ternary_mask,
aaaaaaaaaaaaaaaa1aaaaaaaaaaaaaaaabaaaaaaaaaaaaaaaaaaaaaaaaaaaa3aaat *response, const aaaaaaaaaaaaa1aaat *mask, uint8_t range_valid,
uint8_t mask_id);
int a1bbbbbbbbbbbbbbbbbbbbbb3aaaokup(a1aaat *client, const aaaaaaaaaaaaa1aaat *key, aaaaaaaaaaaaaaaa1aaaaaaaaaaaaaaaabaaaaaaaaaaaaaaaaaaaaaaaaaaaa3aaat *response, bool narrow_key);
void a1aaaaaaaaaaaaaaaabaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaa3aaaaaaaaaaaaaaaabaaaaaaaaaaaaaaaaaaaaaaaaaaaa4aaaaaaaaaaaaaaabaaaaaaaaaaaaaaaaa5aaa(const a1aaat *client, uint32_t prio, uint32_t prio_mask);
aaa1aaat *a1aaaaaaaaaaaaaaaabaaaaaaaaaaaa3aaaaaaaaaaaaaaaabaaaaaaaaaaaaaaaaaaaaaaaaaaaa3aaarecover_phm(const a1aaat *client);
aaaa1aaat *a1aaaaaaaaaaaaaaaabaaaaaaaaaaaa3aaaaaaaaaaaaaaaabaaaaaaaaaaaaaaaaaaaaaaaaaaaa3aaatest_km(const a1aaat *client);
uint8_t a1aaaaaaaaaaaaaaaabaaaaaaaaaaaa3aaaaaaaaaaaaaaaabaaaaaaaaaaaaaaaaaaaaaaaaaaaa3aaaaaaaaaaaaaaabaaaaaaaaaaaaaaaa4aaaaaaaaaaaaaaaabaaaaaaaaaaaaaaaaaaaaaaaaaaaa4aaaaaaaaaaaaaaaabaaaaaaaaaaaaaaaaaaaa5aaas(const a1aaat *client);
bool a1aaaaaaaaaaaaaaabaaaaaaaaaaaa3aaaaaaaaaaaaaaaabaaaaaaaaaaaaaaaaaaaaaaaaaaaa3aaaaaaaaaaaaaaaabaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaa3aaa(const a1aaat *client);
bool a1aaaaaaaaaaaaaaabaaaaaaaaaaaa3aaaaaaaaaaaaaaaabaaaaaaaaaaaaaaaaaaaaaaaaaaaa3aaabcam(const a1aaat *client);
bool a1aaaaaaaaaaaaaaabaaaaaaaaaaaa3aaaaaaaaaaaaaaaabaaaaaaaaaaaaaaaaaaaaaaaaaaaa3aaahbmbcam(const a1aaat *client);
uint8_t a1aaaaaaaaaaaaaaaabaaaaaaaaaaaa3aaaaaaaaaaaaaaaabaaaaaaaaaaaaaaaaaaaaaaaaaaaa3aaaaaaaaaaaaaaabaaaaaaaaaaaaaaaa4aaaaaaaaaaaaaaaabaaaaaaaaaaaaaaaaaaaaaaaaaaaa4aaapcs(const a1aaat *client);
uint8_t a1aaaaaaaaaaaaaaaabaaaaaaaaaaaa3aaaaaaaaaaaaaaaabaaaaaaaaaaaaaaaaaaaaaaaaaaaa3aaareplication(const a1aaat *client);
uint32_t a1aaaaaaaaaaaaaaaabaaaaaaaaaaaa3aaaaaaaaaaaaaaaabaaaaaaaaaaaaaaaaaaaaaaaaaaaa3aaaram_size(const a1aaat *client);
uint16_t a1aaaaaaaaaaaaaaaabaaaaaaaaaaaa3aaaaaaaaaaaaaaaabaaaaaaaaaaaaaaaaaaaaaaaaaaaa3aaasegment(const a1aaat *client);
uint32_t a1aaaaaaaaaaaaaaaabaaaaaaaaaaaa3aaaaaaaaaaaaaaaabaaaaaaaaaaaaaaaaaaaaaaaaaaaa3aaaaaaaaaaaaaaabaaaaaaaaaaaaaaaa4aaaaaaaaaaaaaaaabaaaaaaaaaaaaaaaaaaaaaaaaaaaa4aaaaaaaaaaaaabaaaaaaaaaaaaaaaaa5aaas_per_read(const a1aaat * const client);
bool a1aaaaaaaaaaaaaaabaaaaaaaaaaaa3aaaaaaaaaaaaaaaabaaaaaaaaaaaaaaaaaaaaaaaaaaaa3aaamixed_mode(const a1aaat *client);
uint32_t a1aaaaaaaaaaaaaaaabaaaaaaaaaaaa3aaaaaaaaaaaaaaaabaaaaaaaaaaaaaaaaaaaaaaaaaaaa3aaacurrent_num_entries(const a1aaat *client);
typedef enum {
DELETE, UPDATE, OTHER
} operation_t;
void a1aaahaa1aaaaaaaaaaaaaaaabaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaa3aaaaaaaaaaaaaaaabaaaaaaaaaaaaaaaaaaaaaaaaaaaa4aaaaaaaaaaaaaaaabaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaa4aaaaaaaaaaaaaaaabaaaaaaaaaaaaaaaaaaaaaaaaaaaa5aaaaaaaaaaaaaaaabaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaa5aaa(a1aaat *client, uint32_t address, uint32_t data[], uint8_t write_mask,
operation_t delete_oprn,
bool bit511or255);
void a1aaahaa1aaaaaaaaaaaaaaaabaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaa3aaaaaaaaaaaaaaaabaaaaaaaaaaaaaaaaaaaaaaaaaaaa4aaaaaaaaaaaaaaaabaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaa4aaaaaaaaaaaaaaaabaaaaaaaaaaaaaaaaaaaaaaaaaaaa5aaaread(a1aaat *client, uint32_t address, uint32_t data[]);
void a1aaaaaaaaaaaaaaaabaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaa3aaaaaaaaaaaaaaaabaaaaaaaaaaaaaaaaaaaaaaaaaaaa4aaaaaaaaaaaaaaaabaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaa4aaa(a1aaat *client, uint32_t address, uint64_t data);
void a1aaaaaaaaaaaaaaaabaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaa3aaaaaaaaaaaaaaaabaaaaaaaaaaaaaaaaaaaaaaaaaaaa4aaaread(a1aaat *client, uint32_t address, uint64_t *data);
htable_t *a1aaaaaaaaaaaaaaaabaaaaaaaaaaaa3aaaaaaaaaaaaaaaabaaaaaaaaaaaaaaaaaaaaaaaaaaaa3aaahtable(const a1aaat *client);
void a1aaaaaaaaaaaaaaaabaaaaaaaaaaaa3aaaaaaaaaaaaaaaabaaaaaaaaaaaaaaaaaaaaaaaaaaaa3aaadefault_response(const a1aaat *client, uint8_t *default_response, bool narrow_key);
int a1aaaread_and_clear_ecc_counters(a1aaat *client, uint32_t *corrected_single_bit_errors,
uint32_t *detected_double_bit_errors);
int a1aaaread_and_clear_ecc_addresses(a1aaat *client, uint32_t *failing_address_single_bit_error,
uint32_t *failing_address_double_bit_error);
void a1bbbbbbbbbbbbbbbbbb3aaaaaaaaaaaaaaaabaaaaaaaaaaaaaaaaaaaaaaaaaaaa4bbbbbbbbbbbbbbbbbbbbbbbbbbbbbbbbbbbbb4aaaaaaaaaaaaaaaabaaaaaaaaaaaaaaaaaaaaaaaaaaaa5aaaflags(const a1aaat *client, uint32_t debug_flags);
uint32_t a1aaaaaaaaaaaaaaaabaaaaaaaaaaaa3aaaaaaaaaaaaaaaabaaaaaaaaaaaaaaaaaaaaaaaaaaaa3bbbbbbbbbbbbbbbbbbbbbbbbbbbbbbbbbbbbb3aaaaaaaaaaaaaaaabaaaaaaaaaaaaaaaaaaaaaaaaaaaa4aaaflags(const a1aaat *client);
void a1aaaaaaaaaaaaaaaabaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaa3aaaaaaaaaaaaaaaabaaaaaaaaaaaaaaaaaaaaaaaaaaaa4aaaerror(const a1aaat *client, char *message);
void a1aaaaaaaaaaaaaaaabaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaa3aaaaaaaaaaaaaaaabaaaaaaaaaaaaaaaaaaaaaaaaaaaa4aaainfo(const a1aaat *client, char *message);
int a1aaaread_config(a1aaat *client, cam_config_t *hw_config);
void a1bbbbbbbbbbbbbbbbbbb3aaa(const a1aaat *client);
cam_free_func a1aaaaaaaaaaaaaaaabaaaaaaaaaaaa3aaaaaaaaaaaaaaaabaaaaaaaaaaaaaaaaaaaaaaaaaaaa3aaaaaaaaaaaaaabaaaaaaaaaaaa4aaaaaaaaaaaaaaaabaaaaaaaaaaaaaaaaaaaaaaaaaaaa4aaaaaaaaaaaaaaaabaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaa4aaa(const a1aaat* client);
cam_malloc_func a1aaaaaaaaaaaaaaaabaaaaaaaaaaaa3aaaaaaaaaaaaaaaabaaaaaaaaaaaaaaaaaaaaaaaaaaaa3aaamalloc_function(const a1aaat* client);
cam_calloc_func a1aaaaaaaaaaaaaaaabaaaaaaaaaaaa3aaaaaaaaaaaaaaaabaaaaaaaaaaaaaaaaaaaaaaaaaaaa3aaacalloc_function(const a1aaat* client);
int a1aaaaaaaaaaaaaaaabaaaaaaaaaaaa3aaaaaaaaaaaaaaaabaaaaaaaaaaaaaaaaaaaaaaaaaaaa3aaacurrent_num_units(const a1aaat *client);
bool a1aaahas_options(const a1aaat *client);
void a1bbbbbbbbbbbbbbbbbbbbbbbbbbbbbbbbbbbbbb3aaaaaaaaaaaaaaaabaaaaaaaaaaaaaaaaaaaaaaaaaaaa4aaaaaaaaaaaaaaaabaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaa4aaa(const a1aaat *client);
#endif
#endif
#ifndef a1aaaIF_H
#define a1aaaIF_H
#ifndef COMP_BCAM_IP
#else
#endif
struct bcam {
cam_instance_type_t type; 
struct bcam_client *client; 
};
uint32_t a1aaaif_get_current_num_entries(const struct bcam *bcam);
uint32_t a1aaaif_get_num_lists(const struct bcam *bcam);
uint32_t a1aaaif_get_num_units(const struct bcam *bcam);
uint16_t a1aaaif_get_key_width(const struct bcam *bcam);
uint16_t a1aaaif_get_response_width(const struct bcam *bcam);
uint32_t a1aaaif_get_debug_flags(const struct bcam *bcam);
void a1aaaif_set_debug_flags(struct bcam *bcam, uint32_t debug_flags);
void a1aaaif_print_error(const struct bcam *bcam, char *message);
void a1aaaif_print_info(const struct bcam *bcam, char *message);
uint32_t a1aaaif_get_num_entries(const struct bcam *bcam);
uint32_t a1aaacheck_type(const struct bcam *bcam);
cam_free_func a1aaaif_os_free(const struct bcam* bcam);
cam_malloc_func a1aaaif_os_malloc(const struct bcam* bcam);
cam_calloc_func a1aaaif_os_calloc(const struct bcam* bcam);
void a1aaaif_populate_bcam(struct bcam** bcam, cam_instance_type_t type, void* client, cam_malloc_func malloc_function);
void a1aaaif_get_client(const struct bcam *bcam, void **client);
int a1aaaif_update_key(const struct bcam *bcam, const aaaaaaaaaaaaa1aaat *key, const aaaaaaaaaaaaaaaa1aaaaaaaaaaaaaaaabaaaaaaaaaaaaaaaaaaaaaaaaaaaa3aaat *response,
uint32_t key_width, uint32_t response_width, const cam_options_t *options);
int a1aaaif_insert_key(const struct bcam *bcam, aaaaaaaaaaaaa1aaat *key, const aaaaaaaaaaaaaaaa1aaaaaaaaaaaaaaaabaaaaaaaaaaaaaaaaaaaaaaaaaaaa3aaat *response, uint32_t key_width,
uint32_t response_width, const cam_options_t *options);
int a1aaaif_read_response_for_key(const struct bcam *bcam, aaaaaaaaaaaaaaaa1aaaaaaaaaaaaaaaabaaaaaaaaaaaaaaaaaaaaaaaaaaaa3aaat *response, aaaaaaaaaaaaaaaa1aaaaaaaaaaaaaaaabaaaaaaaaaaaaaaaaaaaaaaaaaaaa3aaat *response_mask,
uint32_t *pos, aaaaaaaaaaaaa1aaat *key, bool narrow_key);
int a1aaaif_get_by_key(const struct bcam *bcam, aaaaaaaaaaaaa1aaat *key, aaaaaaaaaaaaaaaa1aaaaaaaaaaaaaaaabaaaaaaaaaaaaaaaaaaaaaaaaaaaa3aaat *idx, uint32_t key_width,
uint32_t response_width, const cam_options_t *options);
int a1aaaif_bcam_delete_key(const struct bcam *bcam, const aaaaaaaaaaaaa1aaat *key, uint32_t key_width,
const cam_options_t *options);
int a1aaaif_read_and_clear_ecc_counters(const struct bcam *bcam, uint32_t *corrected_single_bit_errors, uint32_t *detected_double_bit_errors);
int a1aaaif_read_and_clear_ecc_addressess(const struct bcam *bcam, uint32_t *failing_address_single_bit_error, uint32_t *failing_address_double_bit_error);
int a1aaaif_get_default_response(const struct bcam *bcam, uint8_t response[], uint16_t response_width,
bool narrow_key);
int a1aaaif_a1aaaaaaaaaaaaaaaabaaaaaaaaaaaaaaaaaaaaaaaaa3aaa(struct bcam *bcam);
int a1aaaif_get_widths(const struct bcam *bcam, uint16_t *key_width, uint16_t *response_width, bool narrow_key);
bool a1aaaif_has_options(const struct bcam *bcam);
#endif
#ifndef COMP_BCAM_API_H_
#define COMP_BCAM_API_H_
#ifdef __cplusplus
extern "C"
{
#endif
#include <stddef.h> 
#ifndef COMP_BCAM_ENV_H_
#define COMP_BCAM_ENV_H_
#ifdef __cplusplus
extern "C"
{
#endif
#ifdef __cplusplus
}
#endif
typedef uint32_t XLNX_ERROR_CODE;
#define XLNX_OK (0)
#define XLNX_ERR_ENVIRONMENT (6)
#define XLNX_ERR_ENVIRONMENT_WRITE_FAIL (7)
#define XLNX_ERR_ENVIRONMENT_READ_FAIL (8)
#define XLNX_ERR_DEVICE_ACCESS_PARAMETER_OUT_OF_RANGE (9)
#define XLNX_ERR_API_NOT_IMPLEMENTED (10)
#define XLNX_ERR_NULL_PTR (11)
#define NUM_BITS_IN_BYTE (8)
#define NUM_BITS_IN_DWORD (32)
#define NUM_BYTES_IN_DWORD (4)
#define BYTE_MASK (0xFF)
#define INDIRECT_ADDR_KEY_WIDTH (0x100)
#define INDIRECT_ADDR_PRIO (0x104)
#define INDIRECT_ADDR_RESP_WIDTH (0x108)
#define INDIRECT_ADDR_UNITS (0x10C)
#define INDIRECT_ADDR_TIME_SLOTS (0x110)
#define INDIRECT_ADDR_aaaa1aaaDATA (0x114)
#define INDIRECT_ADDR_aaaa1bbbbbbbbbbbbbbbbbbbbbbbbbbbbbbbb3aaaR (0x118)
#define INDIRECT_ADDR_MODE (0x11C)
#define INDIRECT_ADDR_ECC_EN (0x120)
#define COMP_BCAM_BASE_MODE_MODE_MASK (0x3)
typedef uint32_t XLNX_COMPONENT_ADDRESS_TYPE;
typedef void * XLNX_USER_CONTEXT_TYPE;
typedef void(*XLNX_ENVIRONMENT_READ32_TYPE) (XLNX_USER_CONTEXT_TYPE pUserContext, uint32_t SourceAddress, uint32_t * pDestinationBuffer);
typedef void(*XLNX_ENVIRONMENT_WRITE32_TYPE) (XLNX_USER_CONTEXT_TYPE pUserContext, uint32_t DestinationAddress, uint32_t Value);
typedef void(*XLNX_ENVIRONMENT_WRITE32_WITH_MASK_TYPE)(XLNX_USER_CONTEXT_TYPE pUserContext, uint32_t DestinationAddress, uint32_t Value, uint32_t Mask);
typedef void(*XLNX_ENVIRONMENT_BLOCK_READ32_TYPE) (XLNX_USER_CONTEXT_TYPE pUserContext, uint32_t SourceAddress, uint32_t * pDestinationBuffer, uint32_t WordsToRead);
typedef struct XLNX_DEVICE_IO_BINDINGS_TYPE
{
XLNX_ENVIRONMENT_READ32_TYPE Read32;
XLNX_ENVIRONMENT_WRITE32_TYPE Write32;
XLNX_ENVIRONMENT_WRITE32_WITH_MASK_TYPE Write32WithMask;
} XLNX_DEVICE_IO_BINDINGS_TYPE;
typedef struct XLNX_USER_ENVIRONMENT_TYPE
{
XLNX_DEVICE_IO_BINDINGS_TYPE Device_IO;
} XLNX_USER_ENVIRONMENT_TYPE;
typedef enum CAM_OPERATION_ENUM
{
CAM_OPERATION_INSERT = 0x00, 
CAM_OPERATION_UPDATE = 0x01, 
CAM_OPERATION_DELETE = 0x02, 
CAM_OPERATION_GETBYKEY = 0x03 
} CAM_OPERATION_ENUM;
typedef enum CAM_OPERATION_STATUS_ENUM
{
CAM_OPERATION_STATUS_SUCCESS = 0x00,
CAM_OPERATION_STATUS_CAMFULL = 0x01,
CAM_OPERATION_STATUS_KEYNOTFOUND = 0x02,
CAM_OPERATION_STATUS_DUPLICATEKEY = 0x03,
CAM_OPERATION_STATUS_FSMBUSY = 0x04,
} CAM_OPERATION_STATUS_ENUM;
XLNX_ERROR_CODE XLNX_Environment_Wrapper_Read32(XLNX_ENVIRONMENT_READ32_TYPE Read32, XLNX_USER_CONTEXT_TYPE pUserContext, uint32_t * pDestinationBuffer, XLNX_COMPONENT_ADDRESS_TYPE SourceAddress);
XLNX_ERROR_CODE XLNX_Environment_Wrapper_Write32(XLNX_ENVIRONMENT_WRITE32_TYPE Write32, XLNX_USER_CONTEXT_TYPE pUserContext, XLNX_COMPONENT_ADDRESS_TYPE DestinationAddress, uint32_t Value);
XLNX_ERROR_CODE XLNX_Environment_Wrapper_Write32_WithMask(XLNX_ENVIRONMENT_WRITE32_WITH_MASK_TYPE Write32_WithMask, XLNX_USER_CONTEXT_TYPE pUserContext, XLNX_COMPONENT_ADDRESS_TYPE DestinationAddress, uint32_t Value, uint32_t Mask);
#endif 
typedef struct
{
XLNX_USER_CONTEXT_TYPE UserContextPtr;
XLNX_USER_ENVIRONMENT_TYPE UserEnvironment;
XLNX_COMPONENT_ADDRESS_TYPE ComponentBaseAddress;
} XLNX_COMP_BCAM_CONTEXT_TYPE;
#ifdef __cplusplus
}
#endif
#endif 
typedef struct comp_cam_a1aaat comp_cam_a1aaat;
int comp_bcam_a1bbbbbbbbbbbbbbbbbbbbbbbbbbbbbbbbbbbbbbb3aaaeate(cam_arg_t *cam_conf_arg, cam_instance_type_t cam_instance_type, comp_cam_a1aaat **client);
int comp_bcam_a1aaaaaaaaaaaaaaaabaaaaaaaaaaaaaaaaaaaaaaaaa3aaa(comp_cam_a1aaat *client);
uint16_t comp_bcam_a1aaaaaaaaaaaaaaaabaaaaaaaaaaaa3aaaaaaaaaaaaaaaabaaaaaaaaaaaaaaaaaaaaaaaaaaaa3aaaaaaaaaaaaaaaabaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaa3aaaaaaaaaaaaaaaabaaaaaaaaaaaaaaaaaaaaaaaaaaaa4aaawidth(const comp_cam_a1aaat *client);
uint32_t comp_bcam_a1aaaaaaaaaaaaaaaabaaaaaaaaaaaa3aaaaaaaaaaaaaaaabaaaaaaaaaaaaaaaaaaaaaaaaaaaa3aaaaaaaaaaaaaaabaaaaaaaaaaaaaaaa4aaaaaaaaaaaaaaaabaaaaaaaaaaaaaaaaaaaaaaaaaaaa4aaaaaaaaaaaabaaaaaaaaaaaaaaaaa5aaas(const comp_cam_a1aaat *client);
uint32_t comp_bcam_a1aaaaaaaaaaaaaaaabaaaaaaaaaaaa3aaaaaaaaaaaaaaaabaaaaaaaaaaaaaaaaaaaaaaaaaaaa3aaaaaaaaaaaaaaabaaaaaaaaaaaaaaaa4aaaaaaaaaaaaaaaabaaaaaaaaaaaaaaaaaaaaaaaaaaaa4aaaaaaaaaaaaabaaaaaaaaaaaaaaaaa5aaas(const comp_cam_a1aaat *client);
uint16_t comp_bcam_a1aaaaaaaaaaaaaaaabaaaaaaaaaaaa3aaaaaaaaaaaaaaaabaaaaaaaaaaaaaaaaaaaaaaaaaaaa3aaaaaaaaaaaaaaaabaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaa3aaaaaaaaaaaaaaaabaaaaaaaaaaaaaaaaaaaaaaaaaaaa4aaawidth(const comp_cam_a1aaat *client);
void comp_bcam_a1bbbbbbbbbbbbbbbbbb3aaaaaaaaaaaaaaaabaaaaaaaaaaaaaaaaaaaaaaaaaaaa4bbbbbbbbbbbbbbbbbbbbbbbbbbbbbbbbbbbbb4aaaaaaaaaaaaaaaabaaaaaaaaaaaaaaaaaaaaaaaaaaaa5aaaflags(const comp_cam_a1aaat *client, uint32_t debug_flags);
uint32_t comp_bcam_a1aaaaaaaaaaaaaaaabaaaaaaaaaaaa3aaaaaaaaaaaaaaaabaaaaaaaaaaaaaaaaaaaaaaaaaaaa3bbbbbbbbbbbbbbbbbbbbbbbbbbbbbbbbbbbbb3aaaaaaaaaaaaaaaabaaaaaaaaaaaaaaaaaaaaaaaaaaaa4aaaflags(const comp_cam_a1aaat *client);
uint32_t comp_bcam_a1aaaaaaaaaaaaaaaabaaaaaaaaaaaa3aaaaaaaaaaaaaaaabaaaaaaaaaaaaaaaaaaaaaaaaaaaa3aaaaaaaaaaaaaaabaaaaaaaaaaaaaaaa4aaaaaaaaaaaaaaaabaaaaaaaaaaaaaaaaaaaaaaaaaaaa4aaaaaaaaaaaaaaaabaaaaaaaaaaaaaaaaaaaaa5aaa(const comp_cam_a1aaat *client);
uint32_t comp_bcam_a1aaaaaaaaaaaaaaaabaaaaaaaaaaaa3aaaaaaaaaaaaaaaabaaaaaaaaaaaaaaaaaaaaaaaaaaaa3aaacurrent_num_entries(const comp_cam_a1aaat *client);
void comp_bcam_a1aaaaaaaaaaaaaaaabaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaa3aaaaaaaaaaaaaaaabaaaaaaaaaaaaaaaaaaaaaaaaaaaa4aaaerror(const comp_cam_a1aaat *client, char *message);
void comp_bcam_a1aaaaaaaaaaaaaaaabaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaa3aaaaaaaaaaaaaaaabaaaaaaaaaaaaaaaaaaaaaaaaaaaa4aaainfo(const comp_cam_a1aaat *cam_conf_arg, char *message);
int comp_bcam_a1bbbbbbbbbbbbbbbbbbbb3aaaaaaaaaaaaaaaabaaaaaaaaaaaaaaaaaaaaaaaaaaaa4aaaaaaaaaaaaaaaabaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaa4aaa(comp_cam_a1aaat *client, const aaaaaaaaaaaaa1aaat *key, const aaaaaaaaaaaaaaaa1aaaaaaaaaaaaaaaabaaaaaaaaaaaaaaaaaaaaaaaaaaaa3aaat *response, uint32_t key_bit_resp, uint32_t resp_bit_size);
int comp_bcam_a1aaaaaaaaaaaaaaabaaaaaaaaaaaaaaaaaaa3aaaaaaaaaaaaaaaabaaaaaaaaaaaaaaaaaaaaaaaaaaaa3aaaaaaaaaaaaaaaabaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaa3aaa(comp_cam_a1aaat *client, const aaaaaaaaaaaaa1aaat *key, const aaaaaaaaaaaaaaaa1aaaaaaaaaaaaaaaabaaaaaaaaaaaaaaaaaaaaaaaaaaaa3aaat *response, uint32_t key_bit_resp, uint32_t resp_bit_size);
int comp_bcam_a1aaaaaaaaaaaaaaaabaaaaaaaaaaaaaaaaaaa3aaaaaaaaaaaaaaaabaaaaaaaaaaaaaaaaaaaaaaaaaaaa3aaaaaaaaaaaaaaaabaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaa3aaa(comp_cam_a1aaat *client, const aaaaaaaaaaaaa1aaat *key, uint32_t key_bit_resp);
int comp_bcam_a1aaaaaaaaaaaaaaaabaaaaaaaaaaaa3aaaaaaaaaaaaaaaabaaaaaaaaaaaaaaaaaaaaaaaaaaaa3aaaby_key(comp_cam_a1aaat *client, const aaaaaaaaaaaaa1aaat *key, aaaaaaaaaaaaaaaa1aaaaaaaaaaaaaaaabaaaaaaaaaaaaaaaaaaaaaaaaaaaa3aaat *response, const uint16_t key_width, const uint16_t response_width);
void comp_bcam_a1aaaaaaaaaaaaaaaabaaaaaaaaaaaa3aaaaaaaaaaaaaaaabaaaaaaaaaaaaaaaaaaaaaaaaaaaa3aaawidths(const comp_cam_a1aaat *client, uint16_t *key_width, uint16_t *response_width);
cam_free_func comp_bcam_a1aaaaaaaaaaaaaaaabaaaaaaaaaaaa3aaaaaaaaaaaaaaaabaaaaaaaaaaaaaaaaaaaaaaaaaaaa3aaaaaaaaaaaaaabaaaaaaaaaaaa4aaaaaaaaaaaaaaaabaaaaaaaaaaaaaaaaaaaaaaaaaaaa4aaaaaaaaaaaaaaaabaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaa4aaa(const comp_cam_a1aaat* client);
cam_malloc_func comp_bcam_a1aaaaaaaaaaaaaaaabaaaaaaaaaaaa3aaaaaaaaaaaaaaaabaaaaaaaaaaaaaaaaaaaaaaaaaaaa3aaamalloc_function(const comp_cam_a1aaat* client);
cam_calloc_func comp_bcam_a1aaaaaaaaaaaaaaaabaaaaaaaaaaaa3aaaaaaaaaaaaaaaabaaaaaaaaaaaaaaaaaaaaaaaaaaaa3aaacalloc_function(const comp_cam_a1aaat* client);
#ifndef _aaaaa1aaaaaaaaaaaaaaaabaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaa3aaaaaaaaaaaaaaaabaaaaaaaaaaaaaaaaaaaaaaaaaaaa4aaaH
#define _aaaaa1aaaaaaaaaaaaaaaabaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaa3aaaaaaaaaaaaaaaabaaaaaaaaaaaaaaaaaaaaaaaaaaaa4aaaH
#include <assert.h>
#ifndef COMP_BCAM_IP
#ifndef _MURMUR3_H_
#define _MURMUR3_H_
#ifdef __cplusplus
extern "C" {
#endif
void murmur3(const void *key, uint16_t len, uint32_t seed, uint32_t *hashv);
void murmur3_bucket(const void *key, uint16_t keylen, uint32_t num_buckets, uint32_t *hashv, uint32_t *bucket);
#ifdef __cplusplus
}
#endif
#endif 
#endif
#ifndef COMP_BCAM_IP
#ifndef _TCAM_H_
#define _TCAM_H_
#ifdef __cplusplus
extern "C" {
#endif
struct tcam;
int
tcam_create(const cam_arg_t *cam_arg, struct tcam **out_tcam);
int tcam_insert(struct tcam *tcam, const uint8_t key[], const uint8_t mask[], uint32_t prio, const uint8_t response[]);
int tcam_update(struct tcam *tcam, const uint8_t key[], const uint8_t mask[], const uint8_t response[]);
int tcam_get_by_response(struct tcam *tcam, const uint8_t response[], const uint8_t response_mask[], uint32_t *pos,
uint8_t out_key[],
uint8_t out_mask[]);
int tcam_get_by_key(struct tcam *tcam, const uint8_t key[], const uint8_t mask[], uint32_t *prio, uint8_t response[]);
int tcam_lookup(struct tcam *tcam, const uint8_t key[], uint8_t response[]);
int tcam_delete(struct tcam *tcam, const uint8_t key[], const uint8_t mask[]);
int tcam_read_and_clear_ecc_counters(struct tcam *tcam, uint32_t *corrected_single_bit_errors,
uint32_t *detected_double_bit_errors);
int tcam_read_and_clear_ecc_addresses(struct tcam *tcam, uint32_t *failing_address_single_bit_error,
uint32_t *failing_address_double_bit_error);
int tcam_destroy(struct tcam *tcam);
#ifdef __cplusplus
}
#endif
#endif
#endif
#ifndef COMP_BCAM_IP
#endif
#ifndef COMP_BCAM_IP
#ifndef _aaaaa1aaaaaaaa1aaaH_
#define _aaaaa1aaaaaaaa1aaaH_
#ifndef _a1aaaT_
#define _a1aaaT_
typedef struct a1aaat a1aaat;
#endif
#define aaaaa1aaaaaaaaaaaaaaaabaaaaaaaaaaaaaaaaaaaaaaa3aaaaaaaaaaaaaaaabaaaaaaaaaaaaaaaaaaaaaaaaaaaa3aaaSCOPE 64
struct aaaaaaaaaaa1aaaaaaaaaaaaaaaabaaaaaaaaaaaaaaaaaaaaaaaaaaaa3aaar16 {
uint16_t start;
uint16_t end;
};
struct aaaaaaaaaaa1aaaaaaaaaaaaaaaabaaaaaaaaaaaaaaaaaaaaaaaaaaaa3aaap128 {
uint8_t key[aaaaaaaaaaa1aaaaaaaaaaaaaaaabaaaaaaaaaaaaaaaaaaaaaaaaaaaa3aaaaaaaaaaaaaaaabaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaa3aaaaaaaaaaaaaaaabaaaaaaaaaaaaaaaaaaaaaaaaaaaa4aaaWIDTH_MEM_128];
uint8_t len;
};
struct aaaaaaaaaaa1aaaaaaaaaaaaaaaabaaaaaaaaaaaaaaaaaaaaaaaaaaaa3aaab128 {
uint8_t key[aaaaaaaaaaa1aaaaaaaaaaaaaaaabaaaaaaaaaaaaaaaaaaaaaaaaaaaa3aaaaaaaaaaaaaaaabaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaa3aaaaaaaaaaaaaaaabaaaaaaaaaaaaaaaaaaaaaaaaaaaa4aaaWIDTH_MEM_128];
uint8_t mask[aaaaaaaaaaa1aaaaaaaaaaaaaaaabaaaaaaaaaaaaaaaaaaaaaaaaaaaa3aaaaaaaaaaaaaaaabaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaa3aaaaaaaaaaaaaaaabaaaaaaaaaaaaaaaaaaaaaaaaaaaa4aaaWIDTH_MEM_128];
};
struct aaaaaaaaaaa1aaaaaaaaaaaaaaaabaaaaaaaaaaaaaaaaaaaaaaaaaaaa3aaat64 {
uint8_t key[aaaaaaaaaaa1aaaaaaaaaaaaaaaabaaaaaaaaaaaaaaaaaaaaaaaaaaaa3aaaaaaaaaaaaaaaabaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaa3aaaaaaaaaaaaaaaabaaaaaaaaaaaaaaaaaaaaaaaaaaaa4aaaWIDTH_MEM_128 / 2];
uint8_t mask[aaaaaaaaaaa1aaaaaaaaaaaaaaaabaaaaaaaaaaaaaaaaaaaaaaaaaaaa3aaaaaaaaaaaaaaaabaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaa3aaaaaaaaaaaaaaaabaaaaaaaaaaaaaaaaaaaaaaaaaaaa4aaaWIDTH_MEM_128 / 2];
};
struct aaaaaaaaaaa1aaaaaaaaaaaaaaaabaaaaaaaaaaaaaaaaaaaaaaaaaaaa3aaac128 {
uint8_t key[aaaaaaaaaaa1aaaaaaaaaaaaaaaabaaaaaaaaaaaaaaaaaaaaaaaaaaaa3aaaaaaaaaaaaaaaabaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaa3aaaaaaaaaaaaaaaabaaaaaaaaaaaaaaaaaaaaaaaaaaaa4aaaWIDTH_MEM_128];
};
struct aaaaaaaaaaa1aaaaaaaaaaaaaaaabaaaaaaaaaaaaaaaaaaaaaaaaaaaa3aaau128 {
};
union aaaaaaaaaaa1aaa {
struct aaaaaaaaaaa1aaaaaaaaaaaaaaaabaaaaaaaaaaaaaaaaaaaaaaaaaaaa3aaar16 r16;
struct aaaaaaaaaaa1aaaaaaaaaaaaaaaabaaaaaaaaaaaaaaaaaaaaaaaaaaaa3aaap128 p128;
struct aaaaaaaaaaa1aaaaaaaaaaaaaaaabaaaaaaaaaaaaaaaaaaaaaaaaaaaa3aaab128 b128;
struct aaaaaaaaaaa1aaaaaaaaaaaaaaaabaaaaaaaaaaaaaaaaaaaaaaaaaaaa3aaat64 t64;
struct aaaaaaaaaaa1aaaaaaaaaaaaaaaabaaaaaaaaaaaaaaaaaaaaaaaaaaaa3aaac128 c128;
struct aaaaaaaaaaa1aaaaaaaaaaaaaaaabaaaaaaaaaaaaaaaaaaaaaaaaaaaa3aaau128 u128;
};
struct aaaaa1aaastats {
uint16_t curr_num_entries;
uint16_t max_num_entries;
uint32_t curr_num_entrysets;
uint32_t max_num_entrysets;
uint16_t curr_num_masks;
uint16_t max_num_masks;
uint16_t curr_closed_masks;
uint16_t max_closed_masks;
uint16_t curr_open_masks;
uint16_t max_open_masks;
uint32_t curr_num_collsets;
uint32_t max_num_collsets;
};
struct tcam {
uint16_t num_entries;
struct aaaaa1aaaaaaaaaaaabaaaaaaaaaaa3aaa *entry_by_fields;
uint8_t prefix_scope;
uint8_t k_combinations;
uint16_t num_masks;
struct aaaaa1aaaaaaaaaaaaaaaabaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaa3aaa *probsols;
struct aaaaa1aaaaaaaaaaaaaaaabaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaa3aaa *open_probsol;
struct aaaaa1aaaaaaaaaaaaaaaabaaaaaaaaaaaaaaaaaaaaaaa3aaaaaaaaaaaaaaaabaaaaaaaaaaaaaaaaaaaaaaaaaaaa3aaainstance *mask_instances_by_mask;
struct aaaaa1bbbbbbbbbbbbbbbbbbbbbbbbbb3aaaaaaaaaaaaaaaabaaaaaaaaaaaaaaaaaaaaaaaaaaaa4aaaop *oparray;
uint8_t max_num_collisions;
uint32_t debug_mask;
a1aaat *client;
struct aaaaa1aaastats stats;
uint8_t do_refill;
struct aaaaa1aaaaaaaaaaaabaaaaaaaaaaa3aaa *entries[];
};
int aaaaa1aaaaaaaa1bbbbbbbbbbbbbbbbbbbbbbbbbbbbbbbbbbbbbbb3aaaeate(a1aaat *client, struct tcam **out_tcam);
int aaaaa1aaaaaaaa1aaaaaaaaaaaaaaaabaaaaaaaaaaaaaaaaaaaaaaaaa3aaa(struct tcam *tcam);
void aaaaa1aaaaaaaaaaaaaaaabaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaa3aaaaaaaaaaaaaaaabaaaaaaaaaaaaaaaaaaaaaaaaaaaa4aaastats(struct tcam *tcam);
#endif
#endif
#define MAX(X,Y) ((X) > (Y) ? (X) : (Y))
#define MIN(X,Y) ((X) < (Y) ? (X) : (Y))
void aaaaa1aaaaaaaaaaaaaaaabaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaa3aaaaaaaaaaaaaaaabaaaaaaaaaaaaaaaaaaaaaaaaaaaa4bbbbbbbbbbbbbbbb4aaaaaaaaaaaaaaaabaaaaaaaaaaaaaaaaaaaaaaaaaaaa5aaauint2bit(uint8_t * dst, uint8_t dst_len_bytes, uint16_t dst_offset_bits, const uint8_t * src,
const uint16_t src_len_bits);
void aaaaa1aaaaaaaaaaaaaaaabaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaa3aaaaaaaaaaaaaaaabaaaaaaaaaaaaaaaaaaaaaaaaaaaa4bbbbbbbbbbbbbbbbbb4aaaaaaaaaaaaaaaabaaaaaaaaaaaaaaaaaaaaaaaaaaaa5aaabits(uint8_t * dst, uint8_t dst_len_bytes,
uint16_t dst_offset_bits, uint16_t len_bits);
void aaaaa1aaaaaaaaaaaaaaaabaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaa3aaaaaaaaaaaaaaaabaaaaaaaaaaaaaaaaaaaaaaaaaaaa4bbbbbbbbbbbbbbbb4aaaaaaaaaaaaaaaabaaaaaaaaaaaaaaaaaaaaaaaaaaaa5aaauint64(uint64_t dst[], uint16_t dst_offset_bits, const uint64_t *src, uint16_t src_offset_bits,
uint16_t src_len_bits);
void cam_copy_bits(uint8_t *target, const uint8_t *source, uint16_t bit_len);
void cam_write_field(uint32_t *target, uint16_t start_pos, uint16_t end_pos, const uint32_t *source,
uint16_t prio_end_pos);
void cam_read_field(const uint32_t *source, uint16_t start_pos, uint16_t end_pos, uint32_t *target);
void cam_read_field8(uint8_t *target, const uint8_t *source, uint16_t start_pos, uint16_t bit_len);
uint16_t cam_get_num_ones(const aaaaaaaaaaaaa1aaat *data);
char *byte_arr_to_str(uint16_t bit_len, const uint8_t *src, cam_malloc_func malloc_function);
void cam_mask_key(aaaaaaaaaaaaa1aaat *key, const aaaaaaaaaaaaa1aaat *mask);
#ifndef mh_fatal
#define mh_fatal(msg) goto error 
#endif
#ifndef mh_malloc
#define mh_malloc(sz, malloc_function) malloc_function(sz) 
#endif
#ifndef mh_free
#define mh_free(ptr,sz,free_func) free_func(ptr) 
#endif
typedef void (ctor_f)(void *dst, const void *src);
typedef void (dtor_f)(void *elt);
typedef void (init_f)(void *elt);
typedef struct {
size_t sz;
init_f *init;
ctor_f *copy;
dtor_f *dtor;
} m_icd;
typedef struct {
unsigned i, n;
m_icd icd; 
char *d; 
} m_array;
typedef struct mh_handle {
struct mh_table *tbl;
void *prev; 
void *next; 
struct mh_handle *mh_handle_prev; 
struct mh_handle *mh_handle_next; 
void *key; 
unsigned keylen; 
unsigned hashv; 
} mh_handle;
typedef struct mh_bucket {
struct mh_handle *mh_handle_head;
unsigned count;
unsigned expand_mult;
} mh_bucket;
typedef struct mh_table {
mh_bucket *buckets;
unsigned num_buckets, log2_num_buckets;
unsigned num_items;
struct mh_handle *tail; 
ptrdiff_t hho; 
unsigned ideal_chain_maxlen;
unsigned nonideal_items;
unsigned ineff_expands, noexpand;
} mh_table;
#define MH_INITIAL_NUM_BUCKETS 32U 
#define MH_INITIAL_NUM_BUCKETS_LOG2 5U 
#define ELMT_FROM_HH(tbl,hhp) ((void*)(((char*)(hhp)) - ((tbl)->hho)))
#define MH_BKT_CAPACITY_THRESH 10U 
#define oom() goto error
#define MH_TO_BKT( hashv, num_bkts, bkt ) \
do { \
bkt = ((hashv) & ((num_bkts) - 1U)); \
} while(0)
#define MH_EXPAND_BUCKETS(tbl,free_func, malloc_func) \
do { \
unsigned _he_bkt; \
unsigned _he_bkt_i; \
struct mh_handle *_he_thh, *_he_hh_nxt; \
mh_bucket *_he_new_buckets, *_he_newbkt; \
_he_new_buckets = (mh_bucket*)mh_malloc( \
2UL * tbl->num_buckets * sizeof(struct mh_bucket), malloc_func); \
   if (!_he_new_buckets) { mh_fatal( "out of memory"); }                    \
memset(_he_new_buckets, 0, \
2UL * tbl->num_buckets * sizeof(struct mh_bucket)); \
tbl->ideal_chain_maxlen = \
(tbl->num_items >> (tbl->log2_num_buckets+1U)) + \
(((tbl->num_items & ((tbl->num_buckets*2U)-1U)) != 0U) ? 1U : 0U); \
tbl->nonideal_items = 0; \
for(_he_bkt_i = 0; _he_bkt_i < tbl->num_buckets; _he_bkt_i++) \
{ \
_he_thh = tbl->buckets[ _he_bkt_i ].mh_handle_head; \
while (_he_thh != NULL) { \
_he_hh_nxt = _he_thh->mh_handle_next; \
MH_TO_BKT( _he_thh->hashv, tbl->num_buckets*2U, _he_bkt); \
_he_newbkt = &(_he_new_buckets[ _he_bkt ]); \
if (++(_he_newbkt->count) > tbl->ideal_chain_maxlen) { \
tbl->nonideal_items++; \
_he_newbkt->expand_mult = _he_newbkt->count / \
tbl->ideal_chain_maxlen; \
} \
_he_thh->mh_handle_prev = NULL; \
_he_thh->mh_handle_next = _he_newbkt->mh_handle_head; \
if (_he_newbkt->mh_handle_head != NULL) { _he_newbkt->mh_handle_head->mh_handle_prev = \
_he_thh; } \
_he_newbkt->mh_handle_head = _he_thh; \
_he_thh = _he_hh_nxt; \
} \
} \
mh_free(tbl->buckets, tbl->num_buckets*sizeof(struct mh_bucket), free_func); \
tbl->num_buckets *= 2U; \
tbl->log2_num_buckets++; \
tbl->buckets = _he_new_buckets; \
tbl->ineff_expands = (tbl->nonideal_items > (tbl->num_items >> 1)) ? \
(tbl->ineff_expands+1U) : 0U; \
if (tbl->ineff_expands > 1U) { \
tbl->noexpand=1; \
}\
} while(0)
#define MH_MAKE_TABLE(mh_handle,head) \
do { \
(head)->mh_handle.tbl = (mh_table*)mh_malloc( \
sizeof(mh_table), malloc_function); \
 if (!((head)->mh_handle.tbl))  { mh_fatal( "out of memory"); }                    \
memset((head)->mh_handle.tbl, 0, sizeof(mh_table)); \
(head)->mh_handle.tbl->tail = &((head)->mh_handle); \
(head)->mh_handle.tbl->num_buckets = MH_INITIAL_NUM_BUCKETS; \
(head)->mh_handle.tbl->log2_num_buckets = MH_INITIAL_NUM_BUCKETS_LOG2; \
(head)->mh_handle.tbl->hho = (char*)(&(head)->mh_handle) - (char*)(head); \
(head)->mh_handle.tbl->buckets = (mh_bucket*)mh_malloc( \
MH_INITIAL_NUM_BUCKETS*sizeof(struct mh_bucket), malloc_function); \
 if (! (head)->mh_handle.tbl->buckets) { mh_fatal( "out of memory"); }             \
memset((head)->mh_handle.tbl->buckets, 0, \
MH_INITIAL_NUM_BUCKETS*sizeof(struct mh_bucket)); \
} while(0)
#define MH_SORT(head,cmpfcn) MH_SRT(mh_handle,head,cmpfcn)
#define MH_SRT(mh_handle,head,cmpfcn) \
do { \
unsigned _hs_i; \
unsigned _hs_looping,_hs_nmerges,_hs_insize,_hs_psize,_hs_qsize; \
struct mh_handle *_hs_p, *_hs_q, *_hs_e, *_hs_list, *_hs_tail; \
if (head != NULL) { \
_hs_insize = 1; \
_hs_looping = 1; \
_hs_list = &((head)->mh_handle); \
while (_hs_looping != 0U) { \
_hs_p = _hs_list; \
_hs_list = NULL; \
_hs_tail = NULL; \
_hs_nmerges = 0; \
while (_hs_p != NULL) { \
_hs_nmerges++; \
_hs_q = _hs_p; \
_hs_psize = 0; \
for ( _hs_i = 0; _hs_i < _hs_insize; _hs_i++ ) { \
_hs_psize++; \
_hs_q = (mh_handle*)((_hs_q->next != NULL) ? \
((void*)((char*)(_hs_q->next) + \
(head)->mh_handle.tbl->hho)) : NULL); \
if (! (_hs_q) ) { break; } \
} \
_hs_qsize = _hs_insize; \
while ((_hs_psize > 0U) || ((_hs_qsize > 0U) && (_hs_q != NULL))) {\
if (_hs_psize == 0U) { \
_hs_e = _hs_q; \
_hs_q = (mh_handle*)((_hs_q->next != NULL) ? \
((void*)((char*)(_hs_q->next) + \
(head)->mh_handle.tbl->hho)) : NULL); \
_hs_qsize--; \
} else if ( (_hs_qsize == 0U) || (_hs_q == NULL) ) { \
_hs_e = _hs_p; \
if (_hs_p != NULL){ \
_hs_p = (mh_handle*)((_hs_p->next != NULL) ? \
((void*)((char*)(_hs_p->next) + \
(head)->mh_handle.tbl->hho)) : NULL); \
} \
_hs_psize--; \
} else if (( \
cmpfcn(DECLTYPE(head)(ELMT_FROM_HH((head)->mh_handle.tbl,_hs_p)), \
DECLTYPE(head)(ELMT_FROM_HH((head)->mh_handle.tbl,_hs_q))) \
) <= 0) { \
_hs_e = _hs_p; \
if (_hs_p != NULL){ \
_hs_p = (mh_handle*)((_hs_p->next != NULL) ? \
((void*)((char*)(_hs_p->next) + \
(head)->mh_handle.tbl->hho)) : NULL); \
} \
_hs_psize--; \
} else { \
_hs_e = _hs_q; \
_hs_q = (mh_handle*)((_hs_q->next != NULL) ? \
((void*)((char*)(_hs_q->next) + \
(head)->mh_handle.tbl->hho)) : NULL); \
_hs_qsize--; \
} \
if ( _hs_tail != NULL ) { \
_hs_tail->next = ((_hs_e != NULL) ? \
ELMT_FROM_HH((head)->mh_handle.tbl,_hs_e) : NULL); \
} else { \
_hs_list = _hs_e; \
} \
if (_hs_e != NULL) { \
_hs_e->prev = ((_hs_tail != NULL) ? \
ELMT_FROM_HH((head)->mh_handle.tbl,_hs_tail) : NULL); \
} \
_hs_tail = _hs_e; \
} \
_hs_p = _hs_q; \
} \
if (_hs_tail != NULL){ \
_hs_tail->next = NULL; \
} \
if ( _hs_nmerges <= 1U ) { \
_hs_looping=0; \
(head)->mh_handle.tbl->tail = _hs_tail; \
DECLTYPE_ASSIGN(head,ELMT_FROM_HH((head)->mh_handle.tbl, _hs_list)); \
} \
_hs_insize *= 2U; \
} \
} \
} while (0)
#define DECLTYPE(x) (__typeof(x))
#define DECLTYPE_ASSIGN(dst,src) \
do { \
(dst) = DECLTYPE(dst)(src); \
} while(0)
#define MH_DEL_IN_BKT(mh_handle,head,hh_del) \
(head).count--; \
if ((head).mh_handle_head == hh_del) { \
(head).mh_handle_head = hh_del->mh_handle_next; \
} \
if (hh_del->mh_handle_prev) { \
hh_del->mh_handle_prev->mh_handle_next = hh_del->mh_handle_next; \
} \
if (hh_del->mh_handle_next) { \
hh_del->mh_handle_next->mh_handle_prev = hh_del->mh_handle_prev; \
}
#define MH_DELETE(mh_handle,head,delptr,free_func) \
do { \
struct mh_handle *_hd_hh_del; \
if ( ((delptr)->mh_handle.prev == NULL) && ((delptr)->mh_handle.next == NULL) ) { \
mh_free((head)->mh_handle.tbl->buckets, \
(head)->mh_handle.tbl->num_buckets*sizeof(struct mh_bucket), free_func); \
mh_free((head)->mh_handle.tbl, sizeof(mh_table), free_func); \
head = NULL; \
} else { \
unsigned _hd_bkt; \
_hd_hh_del = &((delptr)->mh_handle); \
if ((delptr) == ELMT_FROM_HH((head)->mh_handle.tbl,(head)->mh_handle.tbl->tail)) { \
(head)->mh_handle.tbl->tail = \
(mh_handle*)((ptrdiff_t)((delptr)->mh_handle.prev) + \
(head)->mh_handle.tbl->hho); \
} \
if ((delptr)->mh_handle.prev != NULL) { \
((mh_handle*)((ptrdiff_t)((delptr)->mh_handle.prev) + \
(head)->mh_handle.tbl->hho))->next = (delptr)->mh_handle.next; \
} else { \
DECLTYPE_ASSIGN(head,(delptr)->mh_handle.next); \
} \
if (_hd_hh_del->next != NULL) { \
((mh_handle*)((ptrdiff_t)_hd_hh_del->next + \
(head)->mh_handle.tbl->hho))->prev = \
_hd_hh_del->prev; \
} \
MH_TO_BKT( _hd_hh_del->hashv, (head)->mh_handle.tbl->num_buckets, _hd_bkt); \
MH_DEL_IN_BKT(mh_handle,(head)->mh_handle.tbl->buckets[_hd_bkt], _hd_hh_del); \
(head)->mh_handle.tbl->num_items--; \
} \
} while (0)
#define MH_ITER(mh_handle,head,el,tmp) \
for(((el)=(head)), ((tmp)=DECLTYPE(el)((head!=NULL)?(head)->mh_handle.next:NULL)); \
(el) != NULL; ((el)=(tmp)), ((tmp)=DECLTYPE(el)((tmp!=NULL)?(tmp)->mh_handle.next:NULL)))
#define MH_ADD_TO_BKT(head,addhh,free_func,malloc_func) \
do { \
head.count++; \
(addhh)->mh_handle_next = head.mh_handle_head; \
(addhh)->mh_handle_prev = NULL; \
if (head.mh_handle_head != NULL) { (head).mh_handle_head->mh_handle_prev = (addhh); } \
(head).mh_handle_head=addhh; \
if ((head.count >= ((head.expand_mult+1U) * MH_BKT_CAPACITY_THRESH)) \
&& ((addhh)->tbl->noexpand != 1U)) { \
MH_EXPAND_BUCKETS((addhh)->tbl,free_func, malloc_func); \
} \
} while(0)
#define MH_FIND_IN_BKT(tbl,mh_handle,head,keyptr,keylen_in,out) \
do { \
if (head.mh_handle_head != NULL) { DECLTYPE_ASSIGN(out,ELMT_FROM_HH(tbl,head.mh_handle_head)); } \
else { out=NULL; } \
while (out != NULL) { \
if ((out)->mh_handle.keylen == (keylen_in)) { \
if ((MH_KEYCMP((out)->mh_handle.key,keyptr,keylen_in)) == 0) { break; } \
} \
if ((out)->mh_handle.mh_handle_next != NULL) { DECLTYPE_ASSIGN(out,ELMT_FROM_HH(tbl,(out)->mh_handle.mh_handle_next)); } \
else { out = NULL; } \
} \
} while(0)
#define MH_KEYCMP(a,b,len) memcmp(a,b,(unsigned long)(len))
#define MH_FIND(mh_handle,head,keyptr,keylen,out) \
do { \
out=NULL; \
if (head != NULL) { \
uint32_t _hf_bkt,_hf_hashv; \
murmur3_bucket(keyptr,keylen, (head)->mh_handle.tbl->num_buckets, &_hf_hashv, &_hf_bkt); \
MH_FIND_IN_BKT((head)->mh_handle.tbl, mh_handle, (head)->mh_handle.tbl->buckets[ _hf_bkt ], \
keyptr,keylen,out); \
} \
} while (0)
#define MH_ADD(mh_handle,head,fieldname,keylen_in,add,free_func,malloc_func) \
MH_ADD_KEYPTR(mh_handle,head,&((add)->fieldname),keylen_in,add,free_func,malloc_func)
#define MH_ADD_KEYPTR(mh_handle,head,keyptr,keylen_in,add,free_func,malloc_func) \
do { \
uint32_t _ha_bkt; \
(add)->mh_handle.next = NULL; \
(add)->mh_handle.key = (char*)(keyptr); \
(add)->mh_handle.keylen = (unsigned)(keylen_in); \
if (!(head)) { \
head = (add); \
(head)->mh_handle.prev = NULL; \
MH_MAKE_TABLE(mh_handle,head); \
} else { \
(head)->mh_handle.tbl->tail->next = (add); \
(add)->mh_handle.prev = ELMT_FROM_HH((head)->mh_handle.tbl, (head)->mh_handle.tbl->tail); \
(head)->mh_handle.tbl->tail = &((add)->mh_handle); \
} \
(head)->mh_handle.tbl->num_items++; \
(add)->mh_handle.tbl = (head)->mh_handle.tbl; \
murmur3_bucket(keyptr,keylen_in, (head)->mh_handle.tbl->num_buckets, \
&((add)->mh_handle.hashv), &_ha_bkt); \
MH_ADD_TO_BKT((head)->mh_handle.tbl->buckets[_ha_bkt],&(add)->mh_handle, free_func, malloc_func); \
} while(0)
#define _SV(elt,list)
#define _NEXT(elt,list,next) ((elt)->next)
#define _NEXTASGN(elt,list,to,next) ((elt)->next)=(to)
#define _CASTASGN(a,b) (a)=(b)
#define LIST_SORT(list, cmp) \
LIST_SORT2(list, cmp, next)
#define LIST_SORT2(list, cmp, next) \
do { \
LDECLTYPE(list) _ls_p; \
LDECLTYPE(list) _ls_q; \
LDECLTYPE(list) _ls_e; \
LDECLTYPE(list) _ls_tail; \
int _ls_insize, _ls_nmerges, _ls_psize, _ls_qsize, _ls_i, _ls_looping; \
if (list) { \
_ls_insize = 1; \
_ls_looping = 1; \
while (_ls_looping) { \
_CASTASGN(_ls_p,list); \
list = NULL; \
_ls_tail = NULL; \
_ls_nmerges = 0; \
while (_ls_p) { \
_ls_nmerges++; \
_ls_q = _ls_p; \
_ls_psize = 0; \
for (_ls_i = 0; _ls_i < _ls_insize; _ls_i++) { \
_ls_psize++; \
_SV(_ls_q,list); _ls_q = _NEXT(_ls_q,list,next); \
if (!_ls_q) break; \
} \
_ls_qsize = _ls_insize; \
while (_ls_psize > 0 || (_ls_qsize > 0 && _ls_q)) { \
if (_ls_psize == 0) { \
_ls_e = _ls_q; _SV(_ls_q,list); _ls_q = \
_NEXT(_ls_q,list,next); _ls_qsize--; \
} else if (_ls_qsize == 0 || !_ls_q) { \
_ls_e = _ls_p; _SV(_ls_p,list); _ls_p = \
_NEXT(_ls_p,list,next); _ls_psize--; \
} else if (cmp(_ls_p,_ls_q) <= 0) { \
_ls_e = _ls_p; _SV(_ls_p,list); _ls_p = \
_NEXT(_ls_p,list,next); _ls_psize--; \
} else { \
_ls_e = _ls_q; _SV(_ls_q,list); _ls_q = \
_NEXT(_ls_q,list,next); _ls_qsize--; \
} \
if (_ls_tail) { \
_SV(_ls_tail,list); _NEXTASGN(_ls_tail,list,_ls_e,next); \
} else { \
_CASTASGN(list,_ls_e); \
} \
_ls_tail = _ls_e; \
} \
_ls_p = _ls_q; \
} \
if (_ls_tail) { \
_SV(_ls_tail,list); _NEXTASGN(_ls_tail,list,NULL,next); \
} \
if (_ls_nmerges <= 1) { \
_ls_looping=0; \
} \
_ls_insize *= 2; \
} \
} \
} while (0)
#define LIST_COUNT(head,el,counter) \
LIST_COUNT2(head,el,counter,next)
#define LIST_COUNT2(head,el,counter,next) \
{ \
counter = 0; \
LIST_FOREACH2(head,el,next){ ++counter; } \
}
#define LIST_PREPEND(head,add) \
LIST_PREPEND2(head,add,next)
#define LIST_PREPEND2(head,add,next) \
do { \
(add)->next = head; \
head = add; \
} while (0)
#define LIST_DELETE(head,del) \
LIST_DELETE2(head,del,next)
#define LIST_DELETE2(head,del,next) \
do { \
LDECLTYPE(head) _tmp; \
if ((head) == (del)) { \
(head)=(head)->next; \
} else { \
_tmp = head; \
while (_tmp->next && (_tmp->next != (del))) { \
_tmp = _tmp->next; \
} \
if (_tmp->next) { \
_tmp->next = ((del)->next); \
} \
} \
} while (0)
#define LIST_PREPEND_ELEM(head, el, add) \
do { \
LDECLTYPE(head) _tmp; \
assert(head != NULL); \
assert(el != NULL); \
assert(add != NULL); \
(add)->next = (el); \
if ((head) == (el)) { \
(head) = (add); \
} else { \
_tmp = head; \
while (_tmp->next && (_tmp->next != (el))) { \
_tmp = _tmp->next; \
} \
if (_tmp->next) { \
_tmp->next = (add); \
} \
} \
} while (0)
#define LIST_FOREACH2(head,el,next) \
for(el=head;el;el=(el)->next)
#define LIST_FOREACH(head,el) \
LIST_FOREACH2(head,el,next)
#define LIST_FOREACH_SAFE(head,el,tmp) \
LIST_FOREACH_SAFE2(head,el,tmp,next)
#define LIST_FOREACH_SAFE2(head,el,tmp,next) \
for((el)=(head);(el) && (tmp = (el)->next, 1); (el) = tmp)
#define LDECLTYPE(x) __typeof(x)
#define LIST_APPEND(head,add) \
LIST_APPEND2(head,add,next)
#define LIST_APPEND2(head,add,next) \
do { \
LDECLTYPE(head) _tmp; \
(add)->next=NULL; \
if (head) { \
_tmp = head; \
while (_tmp->next) { _tmp = _tmp->next; } \
_tmp->next=(add); \
} else { \
(head)=(add); \
} \
} while (0)
#define array_init(a,_icd) do { \
memset(a,0,sizeof(m_array)); \
(a)->icd=*_icd; \
} while(0)
#define array_free(a, free_function) do { \
array_done(a, free_function); \
free_function(a); \
} while(0)
#define array_push_back(a,p) do { \
array_reserve(a,1); \
if ((a)->icd.copy) { (a)->icd.copy( _array_eltptr(a,(a)->i++), p); } \
else { memcpy(_array_eltptr(a,(a)->i++), p, (a)->icd.sz); }; \
} while(0)
#define array_erase(a,pos,len) do { \
if ((a)->icd.dtor) { \
size_t _ut_i; \
for(_ut_i=0; _ut_i < len; _ut_i++) { \
(a)->icd.dtor(array_eltptr((a),pos+_ut_i)); \
} \
} \
if ((a)->i > (pos+len)) { \
memmove( _array_eltptr((a),pos), _array_eltptr((a),pos+len), \
(((a)->i)-(pos+len))*((a)->icd.sz)); \
} \
(a)->i -= (len); \
} while(0)
#define array_done(a, free_function) do { \
if ((a)->n) { \
if ((a)->icd.dtor) { \
size_t _ut_i; \
for(_ut_i=0; _ut_i < (a)->i; _ut_i++) { \
(a)->icd.dtor(array_eltptr(a,_ut_i)); \
} \
} \
free_function((a)->d); \
} \
(a)->n=0; \
} while(0)
#define array_reserve(a,by) do { \
if (((a)->i+(by)) > ((a)->n)) { \
char *array_tmp; \
while(((a)->i+(by)) > ((a)->n)) { (a)->n = ((a)->n ? (2*(a)->n) : 8); } \
array_tmp=(char*)realloc((a)->d, (a)->n*(a)->icd.sz); \
if (array_tmp == NULL) oom(); \
(a)->d=array_tmp; \
} \
} while(0)
#define array_eltptr(a,j) (((j) < (a)->i) ? _array_eltptr(a,j) : NULL)
#define _array_eltptr(a,j) ((char*)((a)->d + ((a)->icd.sz*(j) )))
#define array_eltidx(a,e) (((char*)(e) >= (char*)((a)->d)) ? (((char*)(e) - (char*)((a)->d))/(size_t)(a)->icd.sz) : -1)
#define array_front(a) (((a)->i) ? (_array_eltptr(a,0)) : NULL)
#define array_next(a,e) (((e)==NULL) ? array_front(a) : ((((a)->i) > (array_eltidx(a,e)+1)) ? _array_eltptr(a,array_eltidx(a,e)+1) : NULL))
#ifndef COMP_BCAM_IP
int cam_key2fields(struct tcam *tcam, union aaaaaaaaaaa1aaa fields[], const uint8_t key[]);
void cam_mask_fields(struct tcam *tcam, union aaaaaaaaaaa1aaa fields[]);
int cam_mask2fields(const a1aaat *client, union aaaaaaaaaaa1aaa fields[], const uint8_t mask[]);
int aaaaaaaaaaa1aaas2key(struct tcam *tcam, const union aaaaaaaaaaa1aaa fields[], uint8_t key[]);
int aaaaaaaaaaa1aaas2mask(struct tcam *tcam, const union aaaaaaaaaaa1aaa fields[], uint8_t mask[]);
int cam_check_fields(struct tcam *tcam, const union aaaaaaaaaaa1aaa fields[]);
#endif 
#endif 
#ifndef aaaaaaaa1aaaH
#define aaaaaaaa1aaaH
#define BIT(n) ( 1<<(n) )
#define BIT_SET(y, mask) ( y |= (mask) )
#define BIT_CLEAR(y, mask) ( y &= ~(mask) )
#define BIT_FLIP(y, mask) ( y ^= (mask) )
#define BIT_MASK(len) (( 1<<(len) )-1)
static inline uint8_t aaaaaaaa1aaaaaaaaaaaaaaaabaaaaaaaaaaaaaaaaaaaaaaa3aaa8(uint8_t len);
static inline uint16_t aaaaaaaa1aaaaaaaaaaaaaaaabaaaaaaaaaaaaaaaaaaaaaaa3aaa16(uint8_t len);
static inline uint32_t aaaaaaaa1aaaaaaaaaaaaaaaabaaaaaaaaaaaaaaaaaaaaaaa3aaa(uint8_t len);
static inline uint64_t aaaaaaaa1aaaaaaaaaaaaaaaabaaaaaaaaaaaaaaaaaaaaaaa3aaa64(uint8_t len);
static inline uint8_t aaaaaaaa1aaaaaaaaaaaaaaaabaaaaaaaaaaaa3aaa8(uint8_t y, uint8_t shift, uint8_t len);
static inline uint16_t aaaaaaaa1aaaaaaaaaaaaaaaabaaaaaaaaaaaa3aaa16(uint16_t y, uint8_t shift, uint8_t len);
static inline uint32_t aaaaaaaa1aaaaaaaaaaaaaaaabaaaaaaaaaaaa3aaa(uint32_t y, uint8_t shift, uint8_t len);
static inline uint64_t aaaaaaaa1aaaaaaaaaaaaaaaabaaaaaaaaaaaa3aaa64(uint64_t y, uint8_t shift, uint8_t len);
static inline uint8_t aaaaaaaa1aaaaaaaaaaaaaaaabaaaaaaaaaaaaaaaaaaaaaa3aaa8(uint8_t y, uint8_t x, uint8_t shift, uint8_t len);
static inline uint16_t aaaaaaaa1aaaaaaaaaaaaaaaabaaaaaaaaaaaaaaaaaaaaaa3aaa16(uint16_t y, uint16_t x, uint8_t shift, uint8_t len);
static inline uint32_t aaaaaaaa1aaaaaaaaaaaaaaaabaaaaaaaaaaaaaaaaaaaaaa3aaa(uint32_t y, uint32_t x, uint8_t shift, uint8_t len);
static inline uint64_t aaaaaaaa1aaaaaaaaaaaaaaaabaaaaaaaaaaaaaaaaaaaaaa3aaa64(uint64_t y, uint64_t x, uint8_t shift, uint8_t len);
static inline uint16_t aaaaaaaa1aaaaaaaaaaaaaaaabaaaaaaaaaaaaaaaaaaaaaaa3aaa16(uint8_t len)
{
assert(len <= 16);
if (len == 16) {
return UINT16_MAX;
} else {
return ~(UINT16_MAX << len);
}
}
static inline uint8_t aaaaaaaa1aaaaaaaaaaaaaaaabaaaaaaaaaaaaaaaaaaaaaaa3aaa8(uint8_t len)
{
assert(len <= 8);
if (len == 8) {
return UINT8_MAX;
} else {
return ~(UINT8_MAX << len);
}
}
static inline uint32_t aaaaaaaa1aaaaaaaaaaaaaaaabaaaaaaaaaaaaaaaaaaaaaaa3aaa(uint8_t len)
{
assert(len <= 32);
if (len == 32) {
return UINT32_MAX;
} else {
return ~(UINT32_MAX << len);
}
}
static inline uint64_t aaaaaaaa1aaaaaaaaaaaaaaaabaaaaaaaaaaaaaaaaaaaaaaa3aaa64(uint8_t len)
{
assert(len <= 64);
if (len == 64) {
return UINT64_MAX;
} else {
return ~(UINT64_MAX << len);
}
}
static inline uint8_t aaaaaaaa1aaaaaaaaaaaaaaaabaaaaaaaaaaaa3aaa8(uint8_t y, uint8_t shift, uint8_t len)
{
assert(len <= 8);
assert(shift <= 7);
assert(shift + len <= 8);
uint8_t mask = aaaaaaaa1aaaaaaaaaaaaaaaabaaaaaaaaaaaaaaaaaaaaaaa3aaa8(len);
return (y >> shift) & mask;
}
static inline uint16_t aaaaaaaa1aaaaaaaaaaaaaaaabaaaaaaaaaaaa3aaa16(uint16_t y, uint8_t shift, uint8_t len)
{
assert(len <= 16);
assert(shift <= 15);
assert(shift + len <= 16);
uint16_t mask = aaaaaaaa1aaaaaaaaaaaaaaaabaaaaaaaaaaaaaaaaaaaaaaa3aaa16(len);
return (y >> shift) & mask;
}
static inline uint32_t aaaaaaaa1aaaaaaaaaaaaaaaabaaaaaaaaaaaa3aaa(uint32_t y, uint8_t shift, uint8_t len)
{
assert(len <= 32);
if ((shift) > 32) {
assert(shift <= 31);
}
if ((shift + len) > 32) {
assert((shift + len) <= 32);
}
uint32_t mask = aaaaaaaa1aaaaaaaaaaaaaaaabaaaaaaaaaaaaaaaaaaaaaaa3aaa(len);
return (y >> shift) & mask;
}
static inline uint64_t aaaaaaaa1aaaaaaaaaaaaaaaabaaaaaaaaaaaa3aaa64(uint64_t y, uint8_t shift, uint8_t len)
{
assert(len <= 64);
assert(shift <= 63);
assert(shift + len <= 64);
uint64_t mask = aaaaaaaa1aaaaaaaaaaaaaaaabaaaaaaaaaaaaaaaaaaaaaaa3aaa64(len);
return (y >> shift) & mask;
}
static inline uint16_t aaaaaaaa1aaaaaaaaaaaaaaaabaaaaaaaaaaaaaaaaaaaaaa3aaa16(uint16_t y, uint16_t x, uint8_t shift, uint8_t len)
{
assert(len <= 16);
assert(shift <= 15);
assert(shift + len <= 16);
uint16_t mask = aaaaaaaa1aaaaaaaaaaaaaaaabaaaaaaaaaaaaaaaaaaaaaaa3aaa16(len);
return (y & ~(mask << shift)) | ((x & mask) << shift);
}
static inline uint8_t aaaaaaaa1aaaaaaaaaaaaaaaabaaaaaaaaaaaaaaaaaaaaaa3aaa8(uint8_t y, uint8_t x, uint8_t shift, uint8_t len)
{
assert(len <= 8);
assert(shift <= 7);
assert(shift + len <= 8);
uint16_t mask = aaaaaaaa1aaaaaaaaaaaaaaaabaaaaaaaaaaaaaaaaaaaaaaa3aaa8(len);
return (y & ~(mask << shift)) | ((x & mask) << shift);
}
static inline uint32_t aaaaaaaa1aaaaaaaaaaaaaaaabaaaaaaaaaaaaaaaaaaaaaa3aaa(uint32_t y, uint32_t x, uint8_t shift, uint8_t len)
{
assert(len <= 32);
assert(shift <= 31);
assert((shift + len) <= 32);
uint32_t mask = aaaaaaaa1aaaaaaaaaaaaaaaabaaaaaaaaaaaaaaaaaaaaaaa3aaa(len);
return (y & ~(mask << shift)) | ((x & mask) << shift);
}
static inline uint64_t aaaaaaaa1aaaaaaaaaaaaaaaabaaaaaaaaaaaaaaaaaaaaaa3aaa64(uint64_t y, uint64_t x, uint8_t shift, uint8_t len)
{
assert(len <= 64);
assert(shift <= 63);
assert(shift + len <= 64);
uint64_t mask = aaaaaaaa1aaaaaaaaaaaaaaaabaaaaaaaaaaaaaaaaaaaaaaa3aaa64(len);
return (y & ~(mask << shift)) | ((x & mask) << shift);
}
static inline uint32_t aaaaaaaa1aaarotate_left32(uint32_t x, uint8_t r)
{
return (x << r) | (x >> (32 - r));
}
#endif
static void bcam_print_entry(int error_code, char* function, const struct bcam* bcam, const uint8_t key[],
const uint8_t response[], const cam_options_t *options, char* match);
int bcam_create(const cam_arg_t* cam_arg, struct bcam** out_bcam)
{
NULL_CHECK(cam_arg);
int rc;
cam_arg_t cam_arg_copy = *cam_arg;
cam_instance_type_t type = BCAM;
cam_malloc_func malloc_function = cam_arg->malloc_function;
if (cam_arg->hbm)
{
#ifdef COMP_BCAM_IP
rc = CAM_ERROR_UNSUPPORTED_CAM_TYPE;;
if ((cam_arg->debug_flags & CAM_DEBUG_NO_ERROR_MSG) == 0)
{
cam_print_error(rc);
}
return rc;
#else
if (cam_arg->hw_assist)
{
rc = CAM_ERROR_INVALID_ARG;
if ((cam_arg->debug_flags & CAM_DEBUG_NO_ERROR_MSG) == 0)
cam_print_error(rc);
return rc;
}
type = HBMBCAM;
#endif
}
if (cam_arg->hw_assist)
{
comp_cam_a1aaat* comp_cam_client;
type = COMPBCAM;
rc = comp_bcam_a1bbbbbbbbbbbbbbbbbbbbbbbbbbbbbbbbbbbbbbb3aaaeate(&cam_arg_copy, type, &comp_cam_client);
if (rc)
{
if ((cam_arg->debug_flags & CAM_DEBUG_NO_ERROR_MSG) == 0)
{
cam_print_error(rc);
}
return rc;
}
a1aaaif_populate_bcam(out_bcam, type, (void*) comp_cam_client, malloc_function);
}
else
#ifdef COMP_BCAM_IP
{
rc = CAM_ERROR_UNSUPPORTED_CAM_TYPE;
if ((cam_arg->debug_flags & CAM_DEBUG_NO_ERROR_MSG) == 0)
{
cam_print_error(rc);
}
return rc;
}
#else
{
a1aaat* client;
rc = a1bbbbbbbbbbbbbbbbbbbbbbbbbbbbbbbbbbbbbbb3aaaeate(&cam_arg_copy, type, &client);
if (rc)
{
if ((cam_arg->debug_flags & CAM_DEBUG_NO_ERROR_MSG) == 0)
{
cam_print_error(rc);
}
return rc;
}
a1aaaif_populate_bcam(out_bcam, type, ( void*) client, malloc_function);
}
#endif
       bcam_print_entry(0, "bcam_create", *out_bcam, NULL, NULL, NULL, "");
return 0;
}
#define OPTIONS_SETUP \
NULL_CHECK(bcam);\
NULL_CHECK(key);\
NULL_CHECK(bcam);\
cam_options_t *options = (cam_options_t *) alloca(cam_options_size());\
if (a1aaaif_has_options(bcam)) {\
va_list ap;\
va_start(ap, response);\
options = va_arg(ap, cam_options_t *);\
va_end(ap);NULL_CHECK(options);\
} else {\
cam_options_init(options);\
}\
int rc = a1aaacheck_type(bcam)
int bcam_update(struct bcam *bcam, const uint8_t key[], const uint8_t response[], ...)
{
OPTIONS_SETUP;
if (rc == CAM_OK)
{
aaaaaaaaaaaaa1aaat new_key;
memset(&new_key, 0, sizeof(aaaaaaaaaaaaa1aaat));
aaaaaaaaaaaaaaaa1aaaaaaaaaaaaaaaabaaaaaaaaaaaaaaaaaaaaaaaaaaaa3aaat new_response;
memset(&new_response, 0, sizeof(aaaaaaaaaaaaaaaa1aaaaaaaaaaaaaaaabaaaaaaaaaaaaaaaaaaaaaaaaaaaa3aaat));
uint16_t key_width;
uint16_t response_width;
rc = a1aaaif_get_widths(bcam, &key_width, &response_width, options->narrow);
if (rc == CAM_OK) {
cam_copy_bits((uint8_t *) &new_key.word[0], key, key_width);
cam_copy_bits((uint8_t *) &new_response.word[0], response, response_width);
rc = a1aaaif_update_key(bcam, &new_key, &new_response, key_width, response_width, options);
}
}
   bcam_print_entry(rc, "bcam_update", bcam, key, response, options, "");
return rc;
}
int bcam_insert(struct bcam *bcam, const uint8_t key[], const uint8_t response[], ...)
{
OPTIONS_SETUP;
if (rc == CAM_OK)
{
aaaaaaaaaaaaaaaa1aaaaaaaaaaaaaaaabaaaaaaaaaaaaaaaaaaaaaaaaaaaa3aaat new_response;
aaaaaaaaaaaaa1aaat new_key;
memset(&new_key, 0, sizeof(aaaaaaaaaaaaa1aaat));
memset(&new_response, 0, sizeof(aaaaaaaaaaaaaaaa1aaaaaaaaaaaaaaaabaaaaaaaaaaaaaaaaaaaaaaaaaaaa3aaat));
uint16_t key_width;
uint16_t response_width;
rc = a1aaaif_get_widths(bcam, &key_width, &response_width, options->narrow);
if (rc == CAM_OK) {
cam_copy_bits((uint8_t *) &new_key.word[0], key, key_width);
cam_copy_bits((uint8_t *) &new_response.word[0], response, response_width);
rc = a1aaaif_insert_key(bcam, &new_key, &new_response, key_width, response_width, options);
}
}
   bcam_print_entry(rc, "bcam_insert", bcam, key, response, options, "");
return rc;
}
int bcam_get_by_response(struct bcam *bcam, const uint8_t response[], const uint8_t response_mask[], uint32_t *pos,
uint8_t key[], ...)
{
NULL_CHECK(bcam);
NULL_CHECK(response);
NULL_CHECK(response_mask);
NULL_CHECK(pos);
NULL_CHECK(key);
cam_options_t *options = (cam_options_t *) alloca(cam_options_size());
if (a1aaaif_has_options(bcam)) {
va_list ap;
va_start(ap, key);
options = va_arg(ap, cam_options_t *);
va_end(ap);
NULL_CHECK(options);
} else {
cam_options_init(options);
}
int rc = a1aaacheck_type(bcam);
if (rc == CAM_OK)
{
aaaaaaaaaaaaa1aaat old_key;
aaaaaaaaaaaaaaaa1aaaaaaaaaaaaaaaabaaaaaaaaaaaaaaaaaaaaaaaaaaaa3aaat new_response;
memset(&old_key, 0, sizeof(aaaaaaaaaaaaa1aaat));
memset(&new_response, 0, sizeof(aaaaaaaaaaaaaaaa1aaaaaaaaaaaaaaaabaaaaaaaaaaaaaaaaaaaaaaaaaaaa3aaat));
const uint16_t response_width = a1aaaif_get_response_width(bcam);
cam_copy_bits((uint8_t *) &new_response.word[0], response, response_width);
aaaaaaaaaaaaaaaa1aaaaaaaaaaaaaaaabaaaaaaaaaaaaaaaaaaaaaaaaaaaa3aaat new_response_mask;
memset(&new_response_mask, 0, sizeof(aaaaaaaaaaaaaaaa1aaaaaaaaaaaaaaaabaaaaaaaaaaaaaaaaaaaaaaaaaaaa3aaat));
cam_copy_bits((uint8_t *) &new_response_mask.word[0], response_mask, response_width);
rc = a1aaaif_read_response_for_key(bcam, &new_response, &new_response_mask, pos, &old_key, options->narrow);
if (rc)
{
           bcam_print_entry(rc, "bcam_get_by_response", bcam, NULL, response, options, "");
return rc;
}
uint16_t key_width;
uint16_t dummy_response_width;
rc = a1aaaif_get_widths(bcam, &key_width, &dummy_response_width, options->narrow);
if (rc) {
           bcam_print_entry(rc, "bcam_get_by_response", bcam, NULL, response, options, "");
return rc;
}
uint8_t num_bytes = key_width / 8;
const uint16_t remaining_bits = key_width - num_bytes * 8;
if (remaining_bits > 0)
{
key[num_bytes] = aaaaaaaa1aaaaaaaaaaaaaaaabaaaaaaaaaaaaaaaaaaaaaa3aaa8(key[num_bytes], *((uint8_t *) &old_key + num_bytes), 0, remaining_bits);
}
memcpy(key, &old_key, num_bytes);
       bcam_print_entry(0, "bcam_get_by_response", bcam, key, response, options, "");
}
else
{
       bcam_print_entry(rc, "bcam_get_by_response", bcam, NULL, response, options, "");
}
return rc;
}
int bcam_get_by_key(struct bcam *bcam, const uint8_t key[], uint8_t response[], ...)
{
OPTIONS_SETUP;
if (rc == CAM_OK)
{
uint16_t key_width;
uint16_t response_width;
bool using_default_response = false;
rc = a1aaaif_get_widths(bcam, &key_width, &response_width, options->narrow);
if (rc) {
           bcam_print_entry(rc, "bcam_get_by_key", bcam, key, NULL, options, "");
return rc;
}
aaaaaaaaaaaaa1aaat new_key;
memset(&new_key, 0, sizeof(aaaaaaaaaaaaa1aaat));
cam_copy_bits((uint8_t *) &new_key.word[0], key, key_width);
aaaaaaaaaaaaaaaa1aaaaaaaaaaaaaaaabaaaaaaaaaaaaaaaaaaaaaaaaaaaa3aaat idx;
rc = a1aaaif_get_by_key(bcam, &new_key, &idx, key_width, response_width, options);
if (rc == CAM_ERROR_KEY_NOT_FOUND) {
rc = a1aaaif_get_default_response(bcam, (uint8_t *) &idx, response_width, options->narrow);
using_default_response = true;
}
if (rc) {
           bcam_print_entry(rc, "bcam_get_by_key", bcam, key, NULL, options, "");
return rc;
}
const uint8_t num_bytes = response_width / 8;
const uint16_t remaining_bits = response_width - num_bytes * 8;
if (remaining_bits > 0)
{
response[num_bytes] = aaaaaaaa1aaaaaaaaaaaaaaaabaaaaaaaaaaaaaaaaaaaaaa3aaa8(response[num_bytes], *((uint8_t *) &idx + num_bytes), 0, remaining_bits);
}
memcpy(response, &idx, num_bytes);
if (using_default_response)
rc = CAM_ERROR_KEY_NOT_FOUND;
       bcam_print_entry(0, "bcam_get_by_key", bcam, key, response, options,
               using_default_response ? "DEFAULT_MATCH" : "KEY_MATCH");
}
else
{
       bcam_print_entry(rc, "bcam_get_by_key", bcam, key, NULL, options, "");
}
return rc;
}
int bcam_delete(struct bcam *bcam, const uint8_t key[], ...)
{
NULL_CHECK(bcam);
NULL_CHECK(key);
cam_options_t *options = (cam_options_t *) alloca(cam_options_size());
if (a1aaaif_has_options(bcam)) {
va_list ap;
va_start(ap, key);
options = va_arg(ap, cam_options_t *);
va_end(ap);
NULL_CHECK(options);
} else {
cam_options_init(options);
}
int rc = a1aaacheck_type(bcam);
if (rc == CAM_OK)
{
aaaaaaaaaaaaa1aaat new_key;
memset(&new_key, 0, sizeof(aaaaaaaaaaaaa1aaat));
uint16_t key_width;
uint16_t dummy_response_width;
rc = a1aaaif_get_widths(bcam, &key_width, &dummy_response_width, options->narrow);
if (rc == CAM_OK) {
cam_copy_bits((uint8_t *) &new_key.word[0], key, key_width);
rc = a1aaaif_bcam_delete_key(bcam, &new_key, (uint32_t) key_width, options);
}
}
   bcam_print_entry(rc, "bcam_delete", bcam, key, NULL, options, "");
return rc;
}
int bcam_read_and_clear_ecc_counters(struct bcam *bcam, uint32_t *corrected_single_bit_errors, uint32_t *detected_double_bit_errors)
{
NULL_CHECK(bcam);
NULL_CHECK(corrected_single_bit_errors);
NULL_CHECK(detected_double_bit_errors);
int rc = a1aaacheck_type(bcam);
if (rc == CAM_OK)
{
rc = a1aaaif_read_and_clear_ecc_counters(bcam, corrected_single_bit_errors, detected_double_bit_errors);
}
   bcam_print_entry(rc, "bcam_read_and_clear_ecc_counters", bcam, NULL, NULL, NULL, "");
return rc;
}
int bcam_read_and_clear_ecc_addresses(struct bcam *bcam, uint32_t *failing_address_single_bit_error, uint32_t *failing_address_double_bit_error)
{
NULL_CHECK(bcam);
NULL_CHECK(failing_address_single_bit_error);
NULL_CHECK(failing_address_double_bit_error);
int rc = a1aaacheck_type(bcam);
if (rc == CAM_OK)
{
rc = a1aaaif_read_and_clear_ecc_addressess(bcam, failing_address_single_bit_error,
failing_address_double_bit_error);
}
   bcam_print_entry(rc, "bcam_read_and_clear_ecc_addresses", bcam, NULL, NULL, NULL, "");
return rc;
}
int bcam_destroy(struct bcam *bcam)
{
NULL_CHECK(bcam);
uint32_t rc;
rc = a1aaacheck_type(bcam);
   bcam_print_entry(rc, "bcam_destroy", bcam, NULL, NULL, NULL, "");
if (rc == CAM_OK)
{
rc = a1aaaif_a1aaaaaaaaaaaaaaaabaaaaaaaaaaaaaaaaaaaaaaaaa3aaa(bcam);
}
return rc;
}
static void bcam_print_entry(int error_code, char *function, const struct bcam *bcam, const uint8_t key[],
const uint8_t response[], const cam_options_t *options, char *match)
{
if (a1aaaif_get_debug_flags(bcam) & CAM_DEBUG_NO_ERROR_MSG)
return;
if (!error_code && !(a1aaaif_get_debug_flags(bcam) & CAM_DEBUG_ARGS))
return;
uint16_t key_width = a1aaaif_get_key_width(bcam);
uint16_t response_width = a1aaaif_get_response_width(bcam);
cam_malloc_func malloc_function = a1aaaaaaaaaaaaaaaabaaaaaaaaaaaa3aaaaaaaaaaaaaaaabaaaaaaaaaaaaaaaaaaaaaaaaaaaa3aaamalloc_function((a1aaat*) (bcam->client));
int rc;
if (options != NULL) {
rc = a1aaaif_get_widths(bcam, &key_width, &response_width, options->narrow);
assert(rc == 0);
}
char message[600];
char *key_str;
if (key != NULL)
{
key_str = byte_arr_to_str(key_width, key, malloc_function);
}
else
{
       key_str = "N/A";
}
char *response_str;
if (response != NULL)
{
response_str = byte_arr_to_str(response_width, response, malloc_function);
}
else
{
       response_str = "N/A";
}
   char *narrow_str = "                ";
if ((options != NULL) && (options->narrow)) {
       narrow_str = "Options = Narrow";
}
if (!error_code && (a1aaaif_get_debug_flags(bcam) & CAM_DEBUG_ARGS))
{
       sprintf(message, "%-20s  handle = %p  key = %s  response = %s %s %8s", function, (void *) bcam, key_str,
response_str, narrow_str, match);
a1aaaif_print_info(bcam, message);
}
if (error_code)
{
       sprintf(message, "%-20s  handle = %p  key = %s  response = %s %s   %s\n\n%10s%-20s  num_entries = %0d  (%0d used)",
function, (void *) bcam,
key_str,
response_str, narrow_str,
cam_error_string(error_code),
               " ",
               "bcam resources",
a1aaaif_get_num_entries(bcam),
a1aaaif_get_current_num_entries(bcam));
a1aaaif_print_error(bcam, message);
}
if (response != NULL)
{
cam_free_func free_function = a1aaaif_os_free(bcam);
free_function(response_str);
}
if (key != NULL)
{
cam_free_func free_function = a1aaaif_os_free(bcam);
free_function(key_str);
}
}
#ifndef _HCAM_DEVICE_H
#define _HCAM_DEVICE_H
int hcam_device_open(char *file_name);
int hcam_device_close();
void hcam_device_write(void *ctx, uint32_t address, uint32_t data);
void hcam_device_read(void *ctx, uint32_t address, uint32_t *data);
#endif
#ifndef aa1aaaH
#define aa1aaaH
typedef struct aa1aaat aa1aaat;
size_t aa1aaaaaaaaaaaaaabaaaaaaaaaa3aaa(void);
bool aa1aaaaaaaaaaaaaabaaaaaaaaaaa3aaa(aa1aaat *bm, a1aaat *client, uint16_t unit, uint8_t slot_number, cam_malloc_func malloc_function);
void aa1aaaaaaaaaaaaaabaaaaaaaaaaaa3aaa(aa1aaat *bm, cam_free_func free_function);
bool aa1aaaaaaaaaaaaaaabaaaaaaaaaaaa3aaaaaaaaaaaaaaaabaaaaaaaaaaaaaaaaaaaaaaaaaaaa3aaaaaaaaaaaaaaaabaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaa3aaa(const aa1aaat *bm, uint32_t bucket);
bool aa1aaaaaaaaaaaaaaabaaaaaaaaaaaa3aaaaaaaaaaaaaaaabaaaaaaaaaaaaaaaaaaaaaaaaaaaa3aaaaaaaaaaaaaaaabaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaa3aaaaaaaaaaaaaaaabaaaaaaaaaaaaaaaaaaaaaaaaaaaa4aaapointer(const aa1aaat *bm, uint32_t bucket);
bool aa1aaaaaaaaaaaaaaabaaaaaaaaaaaa3aaaaaaaaaaaaaaaabaaaaaaaaaaaaaaaaaaaaaaaaaaaa3aaaaaaaaaaaaaaaabaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaa3aaaaaaaaaaaaaaaabaaaaaaaaaaaaaaaaaaaaaaaaaaaa4aaapointer(const aa1aaat *bm, uint32_t bucket);
uint8_t aa1aaaaaaaaaaaaaaaabaaaaaaaaaaaa3aaaaaaaaaaaaaaaabaaaaaaaaaaaaaaaaaaaaaaaaaaaa3aaaaaaaaaaaaaaabaaaaaaaaaaaaaaaa4aaaber_of_keys(const aa1aaat *bm, uint32_t bucket);
uint32_t aa1aaaaaaaaaaaaaaaabaaaaaaaaaaaa3aaaaaaaaaaaaaaaabaaaaaaaaaaaaaaaaaaaaaaaaaaaa3aaaaaaaaaaaaaaaabaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaa3aaaaaaaaaaaaaaaabaaaaaaaaaaaaaaaaaaaaaaaaaaaa4aaapointer(const aa1aaat *bm, uint32_t bucket);
void aa1aaaaaaaaaaaaaaabaaaaaaaaaaaaaaaaaaa3aaaaaaaaaaaaaaaabaaaaaaaaaaaaaaaaaaaaaaaaaaaa3aaaaaaaaaaaaaaaabaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaa3aaaaaaaaaaaaaaaabaaaaaaaaaaaaaaaaaaaaaaaaaaaa4aaaaaaaaaaaaaaaabaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaa4aaa(aa1aaat *bm, uint32_t bucket, uint32_t aaaaaaaaaa1aaaaaaaaaaaaaaaabaaaaaaaaaaaaaaaaaaaaaaaaaaaa3aaaaaaaaaaaaaaabaaaaaaaaaaaaaaaa4aaaber);
void aa1aaaaaaaaaaaaaaabaaaaaaaaaaaaaaaaaaa3aaaaaaaaaaaaaaaabaaaaaaaaaaaaaaaaaaaaaaaaaaaa3aaanext_key(aa1aaat *bm, uint32_t bucket);
void aa1bbbbbbbbbbbbbbbbbb3aaaaaaaaaaaaaaaabaaaaaaaaaaaaaaaaaaaaaaaaaaaa4aaaaaaaaaaaaaaaabaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaa4aaaaaaaaaaaaaaaabaaaaaaaaaaaaaaaaaaaaaaaaaaaa5aaapointer(aa1aaat *bm, uint32_t bucket, uint8_t function);
void aa1aaaaaaaaaaaaaaaabaaaaaaaaaaaaaaaaaaaaaaaaaaaaaa3aaaaaaaaaaaaaaaabaaaaaaaaaaaaaaaaaaaaaaaaaaaa4aaaaaaaaaaaaaaaabaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaa4aaaaaaaaaaaaaaaabaaaaaaaaaaaaaaaaaaaaaaaaaaaa5aaapointer(aa1aaat *bm, uint32_t bucket, uint32_t new_aaaaaaaaaa1aaaaaaaaaaaaaaaabaaaaaaaaaaaaaaaaaaaaaaaaaaaa3aaaaaaaaaaaaaaabaaaaaaaaaaaaaaaa4aaaber);
uint8_t aa1aaaaaaaaaaaaaaaabaaaaaaaaaaaa3aaaaaaaaaaaaaaaabaaaaaaaaaaaaaaaaaaaaaaaaaaaa3aaaaaaaaaaaaaaaabaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaa3aaaaaaaaaaaaaaaabaaaaaaaaaaaaaaaaaaaaaaaaaaaa4aaapointer(const aa1aaat *bm, uint32_t bucket);
void aa1aaaaaaaaaaaaaaaabaaaaaaaaaaaaaaaaaaa3aaa(aa1aaat *bm);
void aa1aaaaaaaaaaaaaaaabaaaaaaaaaaaaaaaaaaa3aaaaaaaaaaaaaaaabaaaaaaaaaaaaaaaaaaaaaaaaaaaa3aaaaaaaaaaaaaaaabaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaa3aaa(aa1aaat *bm, uint32_t bucket);
void aa1bbbbbbbbbbbbbbbb3aaaaaaaaaaaaaaaabaaaaaaaaaaaaaaaaaaaaaaaaaaaa4aaaand_flush(aa1aaat *target_bm, aa1aaat *source_bm, uint32_t bucket);
void aa1bbbbbbbbbbbbbbbbbbb3aaaaaaaaaaaaaaaabaaaaaaaaaaaaaaaaaaaaaaaaaaaa4aaaall(const aa1aaat *bm);
#endif
#define INVALID 0
#define FUNCTION 1
#define POINTER 2
#define CLOG2(N) (32 - __builtin_clz((uint32_t) ((N) - 1)))
typedef struct {
uint8_t mode;
union {
uint32_t function_value;
uint32_t pointer;
uint32_t invalid;
} fp;
} bucket_control_t;
typedef struct {
uint8_t number_of_keys;
bucket_control_t bucket_control;
} bucket_t;
struct aa1aaat {
bucket_t *bucket;
uint16_t unit;
uint8_t slot_number;
a1aaat *client;
};
size_t aa1aaaaaaaaaaaaaabaaaaaaaaaa3aaa(void)
{
return sizeof(aa1aaat);
}
void flush_bucket(const aa1aaat *bm, uint32_t bucket)
{
assert(a1aaaaaaaaaaaaaaabaaaaaaaaaaaa3aaaaaaaaaaaaaaaabaaaaaaaaaaaaaaaaaaaaaaaaaaaa3aaaaaaaaaaaaaaaabaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaa3aaa(bm->client));
const uint32_t num_lists = a1aaaaaaaaaaaaaaaabaaaaaaaaaaaa3aaaaaaaaaaaaaaaabaaaaaaaaaaaaaaaaaaaaaaaaaaaa3aaaaaaaaaaaaaaabaaaaaaaaaaaaaaaa4aaaaaaaaaaaaaaaabaaaaaaaaaaaaaaaaaaaaaaaaaaaa4aaaaaaaaaaaaabaaaaaaaaaaaaaaaaa5aaas(bm->client);
const uint8_t num_slots = a1aaaaaaaaaaaaaaaabaaaaaaaaaaaa3aaaaaaaaaaaaaaaabaaaaaaaaaaaaaaaaaaaaaaaaaaaa3aaaaaaaaaaaaaaabaaaaaaaaaaaaaaaa4aaaaaaaaaaaaaaaabaaaaaaaaaaaaaaaaaaaaaaaaaaaa4bbbbbbbbbbbbbbbbbbbbbbbbbbbbbbbbbbbb4aaas(bm->client);
const uint32_t physical_lists = num_slots * num_lists;
const uint8_t log2_physical_lists = CLOG2(physical_lists);
const uint32_t num_buckets = aaaaaa1aaaaaaaaaabaaaaaaaaaaa3aaaaaaaaaaaaaaaabaaaaaaaaaaaaaaaaaaaaaaaaaaaa3aaaaaaaaaaaaaaaabaaaaaaaaaaaaaaaaaaaaaaaaaaaaa3aaaaaaaaaaaaaaaabaaaaaaaaaaaaaaaaaaaaaaaaaaaa4aaaaaaaaaaaaabaaaaaaaaaaaaaaaaa5aaaaaaaaaaaaaaaabaaaaaaaaaaaaaaaaaaaaaaaaaaaa5aaaRATIO * num_lists;
assert(bucket < num_buckets);
const uint32_t adjusted_bucket = num_buckets * bm->slot_number + bucket;
assert(adjusted_bucket < (physical_lists * aaaaaa1aaaaaaaaaabaaaaaaaaaaa3aaaaaaaaaaaaaaaabaaaaaaaaaaaaaaaaaaaaaaaaaaaa3aaaaaaaaaaaaaaaabaaaaaaaaaaaaaaaaaaaaaaaaaaaaa3aaaaaaaaaaaaaaaabaaaaaaaaaaaaaaaaaaaaaaaaaaaa4aaaaaaaaaaaaabaaaaaaaaaaaaaaaaa5aaaaaaaaaaaaaaaabaaaaaaaaaaaaaaaaaaaaaaaaaaaa5aaaRATIO));
const uint32_t base = aaaaaa1aaaaa1aaaaaaaaaaaaaaaabaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaa3aaa + bm->unit * aaaaaa1aaaaaaaaaaaabaaaaaaaaaaaaaaaaa3aaaaaaaaaaaaaaaabaaaaaaaaaaaaaaaaaaaaaaaaaaaa3aaaaaaaaaaaaaaaabaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaa3aaa;
const uint32_t address = base + (adjusted_bucket / 4) * aaaaaa1aaaaa1aaaWORD;
uint64_t data = 0;
for (uint8_t i = 0; i < 4; i++) {
uint32_t sub_bucket = (bucket / 4) * 4 + i;
uint8_t sub_word_pos = i * 16;
if (bm->bucket[sub_bucket].bucket_control.mode == POINTER) {
data = aaaaaaaa1aaaaaaaaaaaaaaaabaaaaaaaaaaaaaaaaaaaaaa3aaa64(data, bm->bucket[sub_bucket].bucket_control.fp.pointer,
sub_word_pos, log2_physical_lists);
} else if (bm->bucket[sub_bucket].bucket_control.mode == FUNCTION) {
data = aaaaaaaa1aaaaaaaaaaaaaaaabaaaaaaaaaaaaaaaaaaaaaa3aaa64(data, bm->bucket[sub_bucket].bucket_control.fp.function_value,
sub_word_pos, aaaaaa1aaaaaaaaaaaaaaaabaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaa3aaaaaaaaaaaaaaaabaaaaaaaaaaaaaaaaaaaaaaaaaaaa4aaaaaaaaaaaaaaaabaaaaaaaaaaaaaaaaaaaaaaaaaa5aaaaaaaaaaaaaaaabaaaaaaaaaaaaaaaaaaaaaaaaaaaa5aaaaaaaaaaaaaaaabaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaa5aaaS);
} else if (bm->bucket[sub_bucket].bucket_control.mode == INVALID) {
} else {
assert(false);
}
data = aaaaaaaa1aaaaaaaaaaaaaaaabaaaaaaaaaaaaaaaaaaaaaa3aaa64(data, bm->bucket[sub_bucket].bucket_control.mode,
sub_word_pos + log2_physical_lists, 2);
}
a1aaaaaaaaaaaaaaaabaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaa3aaaaaaaaaaaaaaaabaaaaaaaaaaaaaaaaaaaaaaaaaaaa4aaaaaaaaaaaaaaaabaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaa4aaa(bm->client, address, data);
}
void aa1aaaaaaaaaaaaaaaabaaaaaaaaaaaaaaaaaaa3aaa(aa1aaat *bm)
{
assert(a1aaaaaaaaaaaaaaabaaaaaaaaaaaa3aaaaaaaaaaaaaaaabaaaaaaaaaaaaaaaaaaaaaaaaaaaa3aaaaaaaaaaaaaaaabaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaa3aaa(bm->client));
const uint32_t end_bucket = a1aaaaaaaaaaaaaaaabaaaaaaaaaaaa3aaaaaaaaaaaaaaaabaaaaaaaaaaaaaaaaaaaaaaaaaaaa3aaaaaaaaaaaaaaabaaaaaaaaaaaaaaaa4aaaaaaaaaaaaaaaabaaaaaaaaaaaaaaaaaaaaaaaaaaaa4aaaaaaaaaaaaabaaaaaaaaaaaaaaaaa5aaas(bm->client) * aaaaaa1aaaaaaaaaabaaaaaaaaaaa3aaaaaaaaaaaaaaaabaaaaaaaaaaaaaaaaaaaaaaaaaaaa3aaaaaaaaaaaaaaaabaaaaaaaaaaaaaaaaaaaaaaaaaaaaa3aaaaaaaaaaaaaaaabaaaaaaaaaaaaaaaaaaaaaaaaaaaa4aaaaaaaaaaaaabaaaaaaaaaaaaaaaaa5aaaaaaaaaaaaaaaabaaaaaaaaaaaaaaaaaaaaaaaaaaaa5aaaRATIO;
for (uint32_t j = 0; j < end_bucket; j++) {
bm->bucket[j].bucket_control.mode = INVALID;
bm->bucket[j].bucket_control.fp.invalid = 0;
bm->bucket[j].number_of_keys = 0;
}
if (!(a1aaaaaaaaaaaaaaaabaaaaaaaaaaaa3aaaaaaaaaaaaaaaabaaaaaaaaaaaaaaaaaaaaaaaaaaaa3bbbbbbbbbbbbbbbbbbbbbbbbbbbbbbbbbbbbb3aaaaaaaaaaaaaaaabaaaaaaaaaaaaaaaaaaaaaaaaaaaa4aaaflags(bm->client) & CAM_DEBUG_SKIP_MEM_INIT)) {
for (uint16_t j = 0; j < end_bucket; j += 4) {
flush_bucket(bm, j);
}
}
}
bool aa1aaaaaaaaaaaaaabaaaaaaaaaaa3aaa(aa1aaat *bm, a1aaat *client, uint16_t unit, uint8_t slot_number, cam_malloc_func malloc_function)
{
assert(a1aaaaaaaaaaaaaaabaaaaaaaaaaaa3aaaaaaaaaaaaaaaabaaaaaaaaaaaaaaaaaaaaaaaaaaaa3aaaaaaaaaaaaaaaabaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaa3aaa(client));
assert(unit < aaaaaa1aaaaaaaaaaaaaaaabaaaaaaaaaaaaaaaaaaaaaaaaaa3aaaaaaaaaaaaaaaabaaaaaaaaaaaaaaaaaaaaaaaaaaaa3aaaaaaaaaaaaaaaabaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaa3aaaaaaaaaaaaaaaabaaaaaaaaaaaaaaaaaaaaaaaaaaaa4aaaaaaaaaaaabaaaaaaaaaaaaaaaaa5aaaS);
bm->bucket = malloc_function(aaaaaa1aaaaaaaaaabaaaaaaaaaaa3aaaaaaaaaaaaaaaabaaaaaaaaaaaaaaaaaaaaaaaaaaaa3aaaaaaaaaaaaaaaabaaaaaaaaaaaaaaaaaaaaaaaaaaaaa3aaaaaaaaaaaaaaaabaaaaaaaaaaaaaaaaaaaaaaaaaaaa4aaaaaaaaaaaaabaaaaaaaaaaaaaaaaa5aaaaaaaaaaaaaaaabaaaaaaaaaaaaaaaaaaaaaaaaaaaa5aaaRATIO * a1aaaaaaaaaaaaaaaabaaaaaaaaaaaa3aaaaaaaaaaaaaaaabaaaaaaaaaaaaaaaaaaaaaaaaaaaa3aaaaaaaaaaaaaaabaaaaaaaaaaaaaaaa4aaaaaaaaaaaaaaaabaaaaaaaaaaaaaaaaaaaaaaaaaaaa4aaaaaaaaaaaaabaaaaaaaaaaaaaaaaa5aaas(client) * sizeof(bucket_t));
if (bm->bucket == NULL) 
{
return false;
}
bm->client = client;
bm->unit = unit;
bm->slot_number = slot_number;
aa1aaaaaaaaaaaaaaaabaaaaaaaaaaaaaaaaaaa3aaa(bm);
return true;
}
void aa1aaaaaaaaaaaaaabaaaaaaaaaaaa3aaa(aa1aaat *bm, cam_free_func free_function)
{
if (bm == NULL) {
return;
}
if (bm->bucket != NULL) {
free_function(bm->bucket);
}
free_function(bm);
}
bool aa1aaaaaaaaaaaaaaabaaaaaaaaaaaa3aaaaaaaaaaaaaaaabaaaaaaaaaaaaaaaaaaaaaaaaaaaa3aaaaaaaaaaaaaaaabaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaa3aaa(const aa1aaat *bm, uint32_t bucket)
{
assert(a1aaaaaaaaaaaaaaabaaaaaaaaaaaa3aaaaaaaaaaaaaaaabaaaaaaaaaaaaaaaaaaaaaaaaaaaa3aaaaaaaaaaaaaaaabaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaa3aaa(bm->client));
assert(bucket < aaaaaa1aaaaaaaaaabaaaaaaaaaaa3aaaaaaaaaaaaaaaabaaaaaaaaaaaaaaaaaaaaaaaaaaaa3aaaaaaaaaaaaaaaabaaaaaaaaaaaaaaaaaaaaaaaaaaaaa3aaaaaaaaaaaaaaaabaaaaaaaaaaaaaaaaaaaaaaaaaaaa4aaaaaaaaaaaaabaaaaaaaaaaaaaaaaa5aaaaaaaaaaaaaaaabaaaaaaaaaaaaaaaaaaaaaaaaaaaa5aaaRATIO * a1aaaaaaaaaaaaaaaabaaaaaaaaaaaa3aaaaaaaaaaaaaaaabaaaaaaaaaaaaaaaaaaaaaaaaaaaa3aaaaaaaaaaaaaaabaaaaaaaaaaaaaaaa4aaaaaaaaaaaaaaaabaaaaaaaaaaaaaaaaaaaaaaaaaaaa4aaaaaaaaaaaaabaaaaaaaaaaaaaaaaa5aaas(bm->client));
return (bm->bucket[bucket].bucket_control.mode == INVALID);
}
bool aa1aaaaaaaaaaaaaaabaaaaaaaaaaaa3aaaaaaaaaaaaaaaabaaaaaaaaaaaaaaaaaaaaaaaaaaaa3aaaaaaaaaaaaaaaabaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaa3aaaaaaaaaaaaaaaabaaaaaaaaaaaaaaaaaaaaaaaaaaaa4aaapointer(const aa1aaat *bm, uint32_t bucket)
{
assert(a1aaaaaaaaaaaaaaabaaaaaaaaaaaa3aaaaaaaaaaaaaaaabaaaaaaaaaaaaaaaaaaaaaaaaaaaa3aaaaaaaaaaaaaaaabaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaa3aaa(bm->client));
assert(bucket < aaaaaa1aaaaaaaaaabaaaaaaaaaaa3aaaaaaaaaaaaaaaabaaaaaaaaaaaaaaaaaaaaaaaaaaaa3aaaaaaaaaaaaaaaabaaaaaaaaaaaaaaaaaaaaaaaaaaaaa3aaaaaaaaaaaaaaaabaaaaaaaaaaaaaaaaaaaaaaaaaaaa4aaaaaaaaaaaaabaaaaaaaaaaaaaaaaa5aaaaaaaaaaaaaaaabaaaaaaaaaaaaaaaaaaaaaaaaaaaa5aaaRATIO * a1aaaaaaaaaaaaaaaabaaaaaaaaaaaa3aaaaaaaaaaaaaaaabaaaaaaaaaaaaaaaaaaaaaaaaaaaa3aaaaaaaaaaaaaaabaaaaaaaaaaaaaaaa4aaaaaaaaaaaaaaaabaaaaaaaaaaaaaaaaaaaaaaaaaaaa4aaaaaaaaaaaaabaaaaaaaaaaaaaaaaa5aaas(bm->client));
return ((bm->bucket[bucket].bucket_control.mode == POINTER)); 
}
bool aa1aaaaaaaaaaaaaaabaaaaaaaaaaaa3aaaaaaaaaaaaaaaabaaaaaaaaaaaaaaaaaaaaaaaaaaaa3aaaaaaaaaaaaaaaabaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaa3aaaaaaaaaaaaaaaabaaaaaaaaaaaaaaaaaaaaaaaaaaaa4aaapointer(const aa1aaat *bm, uint32_t bucket)
{
assert(a1aaaaaaaaaaaaaaabaaaaaaaaaaaa3aaaaaaaaaaaaaaaabaaaaaaaaaaaaaaaaaaaaaaaaaaaa3aaaaaaaaaaaaaaaabaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaa3aaa(bm->client));
assert(bucket < aaaaaa1aaaaaaaaaabaaaaaaaaaaa3aaaaaaaaaaaaaaaabaaaaaaaaaaaaaaaaaaaaaaaaaaaa3aaaaaaaaaaaaaaaabaaaaaaaaaaaaaaaaaaaaaaaaaaaaa3aaaaaaaaaaaaaaaabaaaaaaaaaaaaaaaaaaaaaaaaaaaa4aaaaaaaaaaaaabaaaaaaaaaaaaaaaaa5aaaaaaaaaaaaaaaabaaaaaaaaaaaaaaaaaaaaaaaaaaaa5aaaRATIO * a1aaaaaaaaaaaaaaaabaaaaaaaaaaaa3aaaaaaaaaaaaaaaabaaaaaaaaaaaaaaaaaaaaaaaaaaaa3aaaaaaaaaaaaaaabaaaaaaaaaaaaaaaa4aaaaaaaaaaaaaaaabaaaaaaaaaaaaaaaaaaaaaaaaaaaa4aaaaaaaaaaaaabaaaaaaaaaaaaaaaaa5aaas(bm->client));
return (bm->bucket[bucket].bucket_control.mode == FUNCTION);
}
uint8_t aa1aaaaaaaaaaaaaaaabaaaaaaaaaaaa3aaaaaaaaaaaaaaaabaaaaaaaaaaaaaaaaaaaaaaaaaaaa3aaaaaaaaaaaaaaabaaaaaaaaaaaaaaaa4aaaber_of_keys(const aa1aaat *bm, uint32_t bucket)
{
assert(a1aaaaaaaaaaaaaaabaaaaaaaaaaaa3aaaaaaaaaaaaaaaabaaaaaaaaaaaaaaaaaaaaaaaaaaaa3aaaaaaaaaaaaaaaabaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaa3aaa(bm->client));
assert(bucket < aaaaaa1aaaaaaaaaabaaaaaaaaaaa3aaaaaaaaaaaaaaaabaaaaaaaaaaaaaaaaaaaaaaaaaaaa3aaaaaaaaaaaaaaaabaaaaaaaaaaaaaaaaaaaaaaaaaaaaa3aaaaaaaaaaaaaaaabaaaaaaaaaaaaaaaaaaaaaaaaaaaa4aaaaaaaaaaaaabaaaaaaaaaaaaaaaaa5aaaaaaaaaaaaaaaabaaaaaaaaaaaaaaaaaaaaaaaaaaaa5aaaRATIO * a1aaaaaaaaaaaaaaaabaaaaaaaaaaaa3aaaaaaaaaaaaaaaabaaaaaaaaaaaaaaaaaaaaaaaaaaaa3aaaaaaaaaaaaaaabaaaaaaaaaaaaaaaa4aaaaaaaaaaaaaaaabaaaaaaaaaaaaaaaaaaaaaaaaaaaa4aaaaaaaaaaaaabaaaaaaaaaaaaaaaaa5aaas(bm->client));
return bm->bucket[bucket].number_of_keys;
}
uint32_t aa1aaaaaaaaaaaaaaaabaaaaaaaaaaaa3aaaaaaaaaaaaaaaabaaaaaaaaaaaaaaaaaaaaaaaaaaaa3aaaaaaaaaaaaaaaabaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaa3aaaaaaaaaaaaaaaabaaaaaaaaaaaaaaaaaaaaaaaaaaaa4aaapointer(const aa1aaat *bm, uint32_t bucket)
{
assert(a1aaaaaaaaaaaaaaabaaaaaaaaaaaa3aaaaaaaaaaaaaaaabaaaaaaaaaaaaaaaaaaaaaaaaaaaa3aaaaaaaaaaaaaaaabaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaa3aaa(bm->client));
assert(bucket < aaaaaa1aaaaaaaaaabaaaaaaaaaaa3aaaaaaaaaaaaaaaabaaaaaaaaaaaaaaaaaaaaaaaaaaaa3aaaaaaaaaaaaaaaabaaaaaaaaaaaaaaaaaaaaaaaaaaaaa3aaaaaaaaaaaaaaaabaaaaaaaaaaaaaaaaaaaaaaaaaaaa4aaaaaaaaaaaaabaaaaaaaaaaaaaaaaa5aaaaaaaaaaaaaaaabaaaaaaaaaaaaaaaaaaaaaaaaaaaa5aaaRATIO * a1aaaaaaaaaaaaaaaabaaaaaaaaaaaa3aaaaaaaaaaaaaaaabaaaaaaaaaaaaaaaaaaaaaaaaaaaa3aaaaaaaaaaaaaaabaaaaaaaaaaaaaaaa4aaaaaaaaaaaaaaaabaaaaaaaaaaaaaaaaaaaaaaaaaaaa4aaaaaaaaaaaaabaaaaaaaaaaaaaaaaa5aaas(bm->client));
assert(true == aa1aaaaaaaaaaaaaaabaaaaaaaaaaaa3aaaaaaaaaaaaaaaabaaaaaaaaaaaaaaaaaaaaaaaaaaaa3aaaaaaaaaaaaaaaabaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaa3aaaaaaaaaaaaaaaabaaaaaaaaaaaaaaaaaaaaaaaaaaaa4aaapointer(bm, bucket));
return bm->bucket[bucket].bucket_control.fp.pointer;
}
uint8_t aa1aaaaaaaaaaaaaaaabaaaaaaaaaaaa3aaaaaaaaaaaaaaaabaaaaaaaaaaaaaaaaaaaaaaaaaaaa3aaaaaaaaaaaaaaaabaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaa3aaaaaaaaaaaaaaaabaaaaaaaaaaaaaaaaaaaaaaaaaaaa4aaapointer(const aa1aaat *bm, uint32_t bucket)
{
assert(a1aaaaaaaaaaaaaaabaaaaaaaaaaaa3aaaaaaaaaaaaaaaabaaaaaaaaaaaaaaaaaaaaaaaaaaaa3aaaaaaaaaaaaaaaabaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaa3aaa(bm->client));
assert(bucket < aaaaaa1aaaaaaaaaabaaaaaaaaaaa3aaaaaaaaaaaaaaaabaaaaaaaaaaaaaaaaaaaaaaaaaaaa3aaaaaaaaaaaaaaaabaaaaaaaaaaaaaaaaaaaaaaaaaaaaa3aaaaaaaaaaaaaaaabaaaaaaaaaaaaaaaaaaaaaaaaaaaa4aaaaaaaaaaaaabaaaaaaaaaaaaaaaaa5aaaaaaaaaaaaaaaabaaaaaaaaaaaaaaaaaaaaaaaaaaaa5aaaRATIO * a1aaaaaaaaaaaaaaaabaaaaaaaaaaaa3aaaaaaaaaaaaaaaabaaaaaaaaaaaaaaaaaaaaaaaaaaaa3aaaaaaaaaaaaaaabaaaaaaaaaaaaaaaa4aaaaaaaaaaaaaaaabaaaaaaaaaaaaaaaaaaaaaaaaaaaa4aaaaaaaaaaaaabaaaaaaaaaaaaaaaaa5aaas(bm->client));
assert(true == aa1aaaaaaaaaaaaaaabaaaaaaaaaaaa3aaaaaaaaaaaaaaaabaaaaaaaaaaaaaaaaaaaaaaaaaaaa3aaaaaaaaaaaaaaaabaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaa3aaaaaaaaaaaaaaaabaaaaaaaaaaaaaaaaaaaaaaaaaaaa4aaapointer(bm, bucket));
return bm->bucket[bucket].bucket_control.fp.function_value;
}
void aa1aaaaaaaaaaaaaaaabaaaaaaaaaaaaaaaaaaaaaaaaaaaaaa3aaaaaaaaaaaaaaaabaaaaaaaaaaaaaaaaaaaaaaaaaaaa4aaaaaaaaaaaaaaaabaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaa4aaaaaaaaaaaaaaaabaaaaaaaaaaaaaaaaaaaaaaaaaaaa5aaapointer(aa1aaat *bm, uint32_t bucket, uint32_t new_aaaaaaaaaa1aaaaaaaaaaaaaaaabaaaaaaaaaaaaaaaaaaaaaaaaaaaa3aaaaaaaaaaaaaaabaaaaaaaaaaaaaaaa4aaaber)
{
assert(a1aaaaaaaaaaaaaaabaaaaaaaaaaaa3aaaaaaaaaaaaaaaabaaaaaaaaaaaaaaaaaaaaaaaaaaaa3aaaaaaaaaaaaaaaabaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaa3aaa(bm->client));
assert(bucket < aaaaaa1aaaaaaaaaabaaaaaaaaaaa3aaaaaaaaaaaaaaaabaaaaaaaaaaaaaaaaaaaaaaaaaaaa3aaaaaaaaaaaaaaaabaaaaaaaaaaaaaaaaaaaaaaaaaaaaa3aaaaaaaaaaaaaaaabaaaaaaaaaaaaaaaaaaaaaaaaaaaa4aaaaaaaaaaaaabaaaaaaaaaaaaaaaaa5aaaaaaaaaaaaaaaabaaaaaaaaaaaaaaaaaaaaaaaaaaaa5aaaRATIO * a1aaaaaaaaaaaaaaaabaaaaaaaaaaaa3aaaaaaaaaaaaaaaabaaaaaaaaaaaaaaaaaaaaaaaaaaaa3aaaaaaaaaaaaaaabaaaaaaaaaaaaaaaa4aaaaaaaaaaaaaaaabaaaaaaaaaaaaaaaaaaaaaaaaaaaa4aaaaaaaaaaaaabaaaaaaaaaaaaaaaaa5aaas(bm->client));
assert(aa1aaaaaaaaaaaaaaabaaaaaaaaaaaa3aaaaaaaaaaaaaaaabaaaaaaaaaaaaaaaaaaaaaaaaaaaa3aaaaaaaaaaaaaaaabaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaa3aaaaaaaaaaaaaaaabaaaaaaaaaaaaaaaaaaaaaaaaaaaa4aaapointer(bm, bucket));
bm->bucket[bucket].bucket_control.mode = POINTER;
bm->bucket[bucket].bucket_control.fp.pointer = new_aaaaaaaaaa1aaaaaaaaaaaaaaaabaaaaaaaaaaaaaaaaaaaaaaaaaaaa3aaaaaaaaaaaaaaabaaaaaaaaaaaaaaaa4aaaber;
flush_bucket(bm, bucket);
}
void aa1aaaaaaaaaaaaaaabaaaaaaaaaaaaaaaaaaa3aaaaaaaaaaaaaaaabaaaaaaaaaaaaaaaaaaaaaaaaaaaa3aaaaaaaaaaaaaaaabaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaa3aaaaaaaaaaaaaaaabaaaaaaaaaaaaaaaaaaaaaaaaaaaa4aaaaaaaaaaaaaaaabaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaa4aaa(aa1aaat *bm, uint32_t bucket, uint32_t aaaaaaaaaa1aaaaaaaaaaaaaaaabaaaaaaaaaaaaaaaaaaaaaaaaaaaa3aaaaaaaaaaaaaaabaaaaaaaaaaaaaaaa4aaaber)
{
assert(a1aaaaaaaaaaaaaaabaaaaaaaaaaaa3aaaaaaaaaaaaaaaabaaaaaaaaaaaaaaaaaaaaaaaaaaaa3aaaaaaaaaaaaaaaabaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaa3aaa(bm->client));
assert(bucket < aaaaaa1aaaaaaaaaabaaaaaaaaaaa3aaaaaaaaaaaaaaaabaaaaaaaaaaaaaaaaaaaaaaaaaaaa3aaaaaaaaaaaaaaaabaaaaaaaaaaaaaaaaaaaaaaaaaaaaa3aaaaaaaaaaaaaaaabaaaaaaaaaaaaaaaaaaaaaaaaaaaa4aaaaaaaaaaaaabaaaaaaaaaaaaaaaaa5aaaaaaaaaaaaaaaabaaaaaaaaaaaaaaaaaaaaaaaaaaaa5aaaRATIO * a1aaaaaaaaaaaaaaaabaaaaaaaaaaaa3aaaaaaaaaaaaaaaabaaaaaaaaaaaaaaaaaaaaaaaaaaaa3aaaaaaaaaaaaaaabaaaaaaaaaaaaaaaa4aaaaaaaaaaaaaaaabaaaaaaaaaaaaaaaaaaaaaaaaaaaa4aaaaaaaaaaaaabaaaaaaaaaaaaaaaaa5aaas(bm->client));
assert(aa1aaaaaaaaaaaaaaabaaaaaaaaaaaa3aaaaaaaaaaaaaaaabaaaaaaaaaaaaaaaaaaaaaaaaaaaa3aaaaaaaaaaaaaaaabaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaa3aaa(bm, bucket) == true);
bm->bucket[bucket].bucket_control.mode = POINTER;
bm->bucket[bucket].bucket_control.fp.pointer = aaaaaaaaaa1aaaaaaaaaaaaaaaabaaaaaaaaaaaaaaaaaaaaaaaaaaaa3aaaaaaaaaaaaaaabaaaaaaaaaaaaaaaa4aaaber;
flush_bucket(bm, bucket);
bm->bucket[bucket].number_of_keys = 1;
}
void aa1aaaaaaaaaaaaaaabaaaaaaaaaaaaaaaaaaa3aaaaaaaaaaaaaaaabaaaaaaaaaaaaaaaaaaaaaaaaaaaa3aaanext_key(aa1aaat *bm, uint32_t bucket)
{
assert(a1aaaaaaaaaaaaaaabaaaaaaaaaaaa3aaaaaaaaaaaaaaaabaaaaaaaaaaaaaaaaaaaaaaaaaaaa3aaaaaaaaaaaaaaaabaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaa3aaa(bm->client));
assert(bucket < aaaaaa1aaaaaaaaaabaaaaaaaaaaa3aaaaaaaaaaaaaaaabaaaaaaaaaaaaaaaaaaaaaaaaaaaa3aaaaaaaaaaaaaaaabaaaaaaaaaaaaaaaaaaaaaaaaaaaaa3aaaaaaaaaaaaaaaabaaaaaaaaaaaaaaaaaaaaaaaaaaaa4aaaaaaaaaaaaabaaaaaaaaaaaaaaaaa5aaaaaaaaaaaaaaaabaaaaaaaaaaaaaaaaaaaaaaaaaaaa5aaaRATIO * a1aaaaaaaaaaaaaaaabaaaaaaaaaaaa3aaaaaaaaaaaaaaaabaaaaaaaaaaaaaaaaaaaaaaaaaaaa3aaaaaaaaaaaaaaabaaaaaaaaaaaaaaaa4aaaaaaaaaaaaaaaabaaaaaaaaaaaaaaaaaaaaaaaaaaaa4aaaaaaaaaaaaabaaaaaaaaaaaaaaaaa5aaas(bm->client));
assert(aa1aaaaaaaaaaaaaaabaaaaaaaaaaaa3aaaaaaaaaaaaaaaabaaaaaaaaaaaaaaaaaaaaaaaaaaaa3aaaaaaaaaaaaaaaabaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaa3aaa(bm, bucket) == false);
bm->bucket[bucket].number_of_keys++;
}
void aa1aaaaaaaaaaaaaaaabaaaaaaaaaaaaaaaaaaa3aaaaaaaaaaaaaaaabaaaaaaaaaaaaaaaaaaaaaaaaaaaa3aaaaaaaaaaaaaaaabaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaa3aaa(aa1aaat *bm, uint32_t bucket)
{
assert(a1aaaaaaaaaaaaaaabaaaaaaaaaaaa3aaaaaaaaaaaaaaaabaaaaaaaaaaaaaaaaaaaaaaaaaaaa3aaaaaaaaaaaaaaaabaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaa3aaa(bm->client));
assert(bucket < aaaaaa1aaaaaaaaaabaaaaaaaaaaa3aaaaaaaaaaaaaaaabaaaaaaaaaaaaaaaaaaaaaaaaaaaa3aaaaaaaaaaaaaaaabaaaaaaaaaaaaaaaaaaaaaaaaaaaaa3aaaaaaaaaaaaaaaabaaaaaaaaaaaaaaaaaaaaaaaaaaaa4aaaaaaaaaaaaabaaaaaaaaaaaaaaaaa5aaaaaaaaaaaaaaaabaaaaaaaaaaaaaaaaaaaaaaaaaaaa5aaaRATIO * a1aaaaaaaaaaaaaaaabaaaaaaaaaaaa3aaaaaaaaaaaaaaaabaaaaaaaaaaaaaaaaaaaaaaaaaaaa3aaaaaaaaaaaaaaabaaaaaaaaaaaaaaaa4aaaaaaaaaaaaaaaabaaaaaaaaaaaaaaaaaaaaaaaaaaaa4aaaaaaaaaaaaabaaaaaaaaaaaaaaaaa5aaas(bm->client));
assert(aa1aaaaaaaaaaaaaaabaaaaaaaaaaaa3aaaaaaaaaaaaaaaabaaaaaaaaaaaaaaaaaaaaaaaaaaaa3aaaaaaaaaaaaaaaabaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaa3aaa(bm, bucket) == false);
bm->bucket[bucket].number_of_keys--;
if (bm->bucket[bucket].number_of_keys == 0) {
bm->bucket[bucket].bucket_control.mode = INVALID;
bm->bucket[bucket].bucket_control.fp.invalid = 0;
}
}
void aa1bbbbbbbbbbbbbbbbbb3aaaaaaaaaaaaaaaabaaaaaaaaaaaaaaaaaaaaaaaaaaaa4aaaaaaaaaaaaaaaabaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaa4aaaaaaaaaaaaaaaabaaaaaaaaaaaaaaaaaaaaaaaaaaaa5aaapointer(aa1aaat *bm, uint32_t bucket, uint8_t function)
{
assert(a1aaaaaaaaaaaaaaabaaaaaaaaaaaa3aaaaaaaaaaaaaaaabaaaaaaaaaaaaaaaaaaaaaaaaaaaa3aaaaaaaaaaaaaaaabaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaa3aaa(bm->client));
assert(function < aaaaaa1aaaaaaaaaaaaaaaabaaaaaaaaaaaaaaaaaaaaaaaaaa3aaaaaaaaaaaaaaaabaaaaaaaaaaaaaaaaaaaaaaaaaaaa3aaaaaaaaaaaaaaaabaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaa3aaaS);
assert(bucket < aaaaaa1aaaaaaaaaabaaaaaaaaaaa3aaaaaaaaaaaaaaaabaaaaaaaaaaaaaaaaaaaaaaaaaaaa3aaaaaaaaaaaaaaaabaaaaaaaaaaaaaaaaaaaaaaaaaaaaa3aaaaaaaaaaaaaaaabaaaaaaaaaaaaaaaaaaaaaaaaaaaa4aaaaaaaaaaaaabaaaaaaaaaaaaaaaaa5aaaaaaaaaaaaaaaabaaaaaaaaaaaaaaaaaaaaaaaaaaaa5aaaRATIO * a1aaaaaaaaaaaaaaaabaaaaaaaaaaaa3aaaaaaaaaaaaaaaabaaaaaaaaaaaaaaaaaaaaaaaaaaaa3aaaaaaaaaaaaaaabaaaaaaaaaaaaaaaa4aaaaaaaaaaaaaaaabaaaaaaaaaaaaaaaaaaaaaaaaaaaa4aaaaaaaaaaaaabaaaaaaaaaaaaaaaaa5aaas(bm->client));
bm->bucket[bucket].bucket_control.fp.function_value = function;
bm->bucket[bucket].bucket_control.mode = FUNCTION;
flush_bucket(bm, bucket);
}
void aa1bbbbbbbbbbbbbbbb3aaaaaaaaaaaaaaaabaaaaaaaaaaaaaaaaaaaaaaaaaaaa4aaaand_flush(aa1aaat *target_bm, aa1aaat *source_bm, uint32_t bucket)
{
assert(a1aaaaaaaaaaaaaaabaaaaaaaaaaaa3aaaaaaaaaaaaaaaabaaaaaaaaaaaaaaaaaaaaaaaaaaaa3aaaaaaaaaaaaaaaabaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaa3aaa(source_bm->client));
target_bm->bucket[bucket] = source_bm->bucket[bucket];
flush_bucket(target_bm, bucket);
}
void aa1bbbbbbbbbbbbbbbbbbb3aaaaaaaaaaaaaaaabaaaaaaaaaaaaaaaaaaaaaaaaaaaa4aaaall(const aa1aaat *bm)
{
assert(a1aaaaaaaaaaaaaaabaaaaaaaaaaaa3aaaaaaaaaaaaaaaabaaaaaaaaaaaaaaaaaaaaaaaaaaaa3aaaaaaaaaaaaaaaabaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaa3aaa(bm->client));
const uint16_t end_bucket = a1aaaaaaaaaaaaaaaabaaaaaaaaaaaa3aaaaaaaaaaaaaaaabaaaaaaaaaaaaaaaaaaaaaaaaaaaa3aaaaaaaaaaaaaaabaaaaaaaaaaaaaaaa4aaaaaaaaaaaaaaaabaaaaaaaaaaaaaaaaaaaaaaaaaaaa4aaaaaaaaaaaaabaaaaaaaaaaaaaaaaa5aaas(bm->client) * aaaaaa1aaaaaaaaaabaaaaaaaaaaa3aaaaaaaaaaaaaaaabaaaaaaaaaaaaaaaaaaaaaaaaaaaa3aaaaaaaaaaaaaaaabaaaaaaaaaaaaaaaaaaaaaaaaaaaaa3aaaaaaaaaaaaaaaabaaaaaaaaaaaaaaaaaaaaaaaaaaaa4aaaaaaaaaaaaabaaaaaaaaaaaaaaaaa5aaaaaaaaaaaaaaaabaaaaaaaaaaaaaaaaaaaaaaaaaaaa5aaaRATIO;
for (uint16_t j = 0; j < end_bucket; j += 4) {
flush_bucket(bm, j);
}
}
static void dummy_wr_function(void *ctx, uint32_t address, uint32_t data)
{
}
static void dummy_rd_function(void *ctx, uint32_t address, uint32_t *data)
{
}
static void default_error_print_function(void *inst_ctx, char *message)
{
   fprintf(stderr, "** Error: %s\n", message);
}
static void default_info_print_function(void *inst_ctx, char *message)
{
   fprintf(stdout, "** Info:  %s\n", message);
}
int cam_arg_create(struct cam_arg_t **out_cam_arg)
{
struct cam_arg_t *cam_arg;
cam_arg = malloc(cam_arg_size());
if (cam_arg == NULL)
return CAM_ERROR_NOMEM;
cam_arg_init(cam_arg);
*out_cam_arg = cam_arg;
return 0;
}
void cam_arg_init(struct cam_arg_t* out_cam_arg)
{
memset(out_cam_arg, 0, cam_arg_size());
out_cam_arg->ram_freq = 600.0;
out_cam_arg->lookup_interface_freq = 15.0;
out_cam_arg->engine_lookup_rate = 15.0;
out_cam_arg->hw_read_function = &dummy_rd_function;
out_cam_arg->hw_write_function = &dummy_wr_function;
out_cam_arg->priority_width = -1;
out_cam_arg->mem_type = AUTO;
out_cam_arg->ram_size = 512 * 1024;
out_cam_arg->dram_read_size = 1024;
out_cam_arg->segment_ctx.segment = -1;
out_cam_arg->vc_seg_map.vcid = -1;
out_cam_arg->error_print_function = &default_error_print_function;
out_cam_arg->info_print_function = &default_info_print_function;
out_cam_arg->malloc_function = malloc;
out_cam_arg->calloc_function = calloc;
out_cam_arg->free_function = free;
}
size_t cam_arg_size(void)
{
return sizeof(cam_arg_t);
}
void cam_arg_destroy(struct cam_arg_t *cam_arg)
{
free(cam_arg);
}
int cam_arg_set_format(struct cam_arg_t *cam_arg, char *format)
{
if ((strlen(format) + 1) > sizeof(cam_arg->format))
return CAM_ERROR_FORMAT_SYNTAX;
strcpy(cam_arg->format, format);
return 0;
}
void cam_arg_set_inst_ctx(struct cam_arg_t *cam_arg, void *inst_ctx)
{
cam_arg->segment_ctx.ctx = inst_ctx;
}
void cam_arg_set_hw_write_function(struct cam_arg_t *cam_arg, void (*hw_write_function)(void*, uint32_t, uint32_t))
{
cam_arg->hw_write_function = hw_write_function;
}
void cam_arg_set_hw_read_function(struct cam_arg_t *cam_arg, void (*hw_read_function)(void*, uint32_t, uint32_t*))
{
cam_arg->hw_read_function = hw_read_function;
}
void cam_arg_set_hw_write_sequence_functions(cam_arg_t *cam_arg, void (*start_function)(void*),
void (*end_function)(void*))
{
cam_arg->hw_write_start_sequence_function = start_function;
cam_arg->hw_write_end_sequence_function = end_function;
}
void cam_arg_set_flow_control(struct cam_arg_t *cam_arg, bool flow_control)
{
cam_arg->flow_control = flow_control;
}
void cam_arg_set_hw_assist(struct cam_arg_t *cam_arg, bool hw_assist)
{
cam_arg->hw_assist = hw_assist;
}
void cam_arg_set_num_entries(struct cam_arg_t *cam_arg, uint32_t num_entries)
{
cam_arg->num_entries = num_entries;
}
void cam_arg_set_ram_freq(struct cam_arg_t *cam_arg, float freq)
{
cam_arg->ram_freq = freq;
}
void cam_arg_set_lookup_interface_freq(struct cam_arg_t *cam_arg, float freq)
{
cam_arg->lookup_interface_freq = freq;
}
void cam_arg_set_engine_lookup_rate(struct cam_arg_t *cam_arg, float lookup_rate)
{
cam_arg->engine_lookup_rate = lookup_rate;
}
void cam_arg_set_response_width(struct cam_arg_t *cam_arg, uint16_t response_width)
{
cam_arg->response_width = response_width;
}
void cam_arg_set_key_width(struct cam_arg_t *cam_arg, uint16_t key_width)
{
cam_arg->key_width = key_width;
}
void cam_arg_set_narrow_key_width(struct cam_arg_t *cam_arg, uint16_t narrow_key_width)
{
cam_arg->narrow_key_width = narrow_key_width;
}
void cam_arg_set_num_masks(struct cam_arg_t *cam_arg, uint8_t num_masks)
{
cam_arg->num_masks = num_masks;
}
void cam_arg_force_prio_width(struct cam_arg_t *cam_arg, uint8_t prio_width)
{
cam_arg->priority_width = prio_width;
}
void cam_arg_force_num_units(struct cam_arg_t *cam_arg, uint16_t num_units)
{
cam_arg->num_units = num_units;
}
void cam_arg_force_mem_type(struct cam_arg_t *cam_arg, bool uram)
{
if (uram)
cam_arg->mem_type = URAM;
else
cam_arg->mem_type = BRAM;
}
void cam_arg_force_hbm(struct cam_arg_t *cam_arg)
{
cam_arg->hbm = true;
}
void cam_arg_set_debug_flags(cam_arg_t *cam_arg, uint32_t debug_flags) {
cam_arg->debug_flags = debug_flags;
}
void cam_arg_set_optimization_flags(cam_arg_t *cam_arg, uint32_t optimization_flags)
{
cam_arg->optimization_flags = optimization_flags;
}
void cam_arg_set_error_print_function(struct cam_arg_t *cam_arg, void (*error_print_function)(void*, char*))
{
cam_arg->error_print_function = error_print_function;
}
void cam_arg_set_info_print_function(struct cam_arg_t *cam_arg, void (*info_print_function)(void*, char*))
{
cam_arg->info_print_function = info_print_function;
}
void cam_arg_set_malloc_function(struct cam_arg_t* cam_arg, void* (*malloc_function)(size_t size))
{
cam_arg->malloc_function = malloc_function;
}
void cam_arg_set_calloc_function(struct cam_arg_t* cam_arg, void* (*calloc_function)(size_t num, size_t size))
{
cam_arg->calloc_function = calloc_function;
}
void cam_arg_set_free_function(struct cam_arg_t* cam_arg, void (*free_function)(void* ptr))
{
cam_arg->free_function = free_function;
}
void cam_arg_set_ram_size(struct cam_arg_t *cam_arg, uint32_t size)
{
cam_arg->ram_size = size;
}
void cam_arg_set_default_response(struct cam_arg_t *cam_arg, const uint8_t *default_response)
{
memset(cam_arg->default_response, 0, sizeof(aaaaaaaaaaaaaaaa1aaaaaaaaaaaaaaaabaaaaaaaaaaaaaaaaaaaaaaaaaaaa3aaat));
cam_copy_bits(cam_arg->default_response, default_response, cam_arg->response_width);
}
void cam_arg_set_narrow_default_response(struct cam_arg_t *cam_arg, const uint8_t *narrow_default_response)
{
memset(cam_arg->narrow_default_response, 0, sizeof(aaaaaaaaaaaaaaaa1aaaaaaaaaaaaaaaabaaaaaaaaaaaaaaaaaaaaaaaaaaaa3aaat));
cam_copy_bits(cam_arg->narrow_default_response, narrow_default_response, cam_arg->response_width);
}
void cam_arg_set_max_hw_writes(struct cam_arg_t *cam_arg, uint16_t max_hw_writes)
{
cam_arg->max_hw_writes = max_hw_writes;
}
void camp_arg_set_seg(struct cam_arg_t *cam_arg, uint16_t segment)
{
assert(segment < CAM_MAX_VC_SEGMENTS); 
cam_arg->segment_ctx.segment = segment;
}
void camp_arg_set_vcid(struct cam_arg_t *cam_arg, uint8_t vcid)
{
cam_arg->vc_id = vcid;
}
void cam_arg_set_vcid(struct cam_arg_t* cam_arg, uint8_t vcid)
{
cam_arg->vc_seg_map.vcid = vcid;
}
void cam_arg_enable_options(struct cam_arg_t *cam_arg)
{
cam_arg->options = true;
}
void cam_arg_set_seg(struct cam_arg_t* cam_arg, uint16_t segment_id)
{
uint32_t byte = segment_id / 8;
uint32_t bit = segment_id % 8;
if (byte < CAM_MAX_VC_SEGMENTS_MEM)
{
cam_arg->vc_seg_map.bit_map[byte] |= cam_arg->vc_seg_map.bit_map[byte] | (1 << bit);
}
}
size_t cam_options_size(void)
{
return sizeof(cam_options_t);
}
void cam_options_init(cam_options_t *options)
{
memset(options, 0, cam_options_size());
}
int cam_options_create(struct cam_options_t** out_options)
{
struct cam_options_t* cam_options;
cam_options = malloc(cam_options_size());
if (cam_options == NULL)
return CAM_ERROR_NOMEM;
cam_options_init(cam_options);
*out_options = cam_options;
return 0;
}
void cam_options_destroy(struct cam_options_t *options)
{
free(options);
}
void cam_options_set_narrow_key(struct cam_options_t *options, bool narrow)
{
options->narrow = narrow;
}
void cam_options_set_precomputed_hash_value(struct cam_options_t* options, uint8_t hash_value[32])
{
options->precomp_hash = true;
memcpy(&options->hash_value, hash_value, CAM_HASH_VAL_SIZE_IN_BYTES);
}
void cam_options_clear_precomputed_hash_value(struct cam_options_t *options)
{
options->precomp_hash = false;
}
char *cam_error_string(int error_code)
{
   char *err_txt[CAM_ERROR_FATAL_BASE_END + 1] = { "UNDEFINED ERROR" };
char *error_text;
   err_txt[CAM_ERROR_FULL] = "CAM_ERROR_FULL";
   err_txt[CAM_ERROR_NO_OPEN] = "CAM_ERROR_NO_OPEN";
   err_txt[CAM_ERROR_INVALID_ARG] = "CAM_ERROR_INVALID_ARG";
   err_txt[CAM_ERROR_WRONG_KEY_WIDTH] = "CAM_ERROR_WRONG_KEY_WIDTH";
   err_txt[CAM_ERROR_TOO_MANY_INSTANCES] = "CAM_ERROR_TOO_MANY_INSTANCES";
   err_txt[CAM_ERROR_WRONG_PRIO_WIDTH] = "CAM_ERROR_WRONG_PRIO_SIZE";
   err_txt[CAM_ERROR_WRONG_MAX] = "CAM_ERROR_WRONG_MAX";
   err_txt[CAM_ERROR_DUPLICATE_FOUND] = "CAM_ERROR_DUPLICATE_FOUND";
   err_txt[CAM_ERROR_WRONG_PREFIX] = "CAM_ERROR_WRONG_PREFIX";
   err_txt[CAM_ERROR_WRONG_PREFIX_MASK] = "CAM_ERROR_WRONG_PREFIX_MASK";
   err_txt[CAM_ERROR_WRONG_RANGE] = "CAM_ERROR_WRONG_RANGE";
   err_txt[CAM_ERROR_WRONG_RANGE_MASK] = "CAM_ERROR_WRONG_RANGE_MASK";
   err_txt[CAM_ERROR_WRONG_BIT_FIELD_MASK] = "CAM_ERROR_WRONG_BIT_FIELD_MASK";
   err_txt[CAM_ERROR_WRONG_CONST_FIELD_MASK] = "CAM_ERROR_WRONG_CONST_FIELD_MASK";
   err_txt[CAM_ERROR_WRONG_UNUSED_FIELD_MASK] = "CAM_ERROR_WRONG_UNUSED_FIELD_MASK";
   err_txt[CAM_ERROR_INVALID_TERNARY_FIELD_LEN] = "CAM_ERROR_INVALID_TERNARY_FIELD_LEN";
   err_txt[CAM_ERROR_TOO_HIGH_FREQUENCY] = "CAM_ERROR_TOO_HIGH_FREQUENCY";
   err_txt[CAM_ERROR_KEY_NOT_FOUND] = "CAM_ERROR_KEY_NOT_FOUND";
   err_txt[CAM_ERROR_WRONG_MIN] = "CAM_ERROR_WRONG_MIN";
   err_txt[CAM_ERROR_WRONG_PRIO] = "CAM_ERROR_WRONG_PRIO";
   err_txt[CAM_ERROR_WRONG_LIST_LENGTH] = "CAM_ERROR_WRONG_LIST_LENGTH";
   err_txt[CAM_ERROR_WRONG_NUMBER_OF_SLOTS] = "CAM_ERROR_WRONG_NUMBER_OF_SLOTS";
   err_txt[CAM_ERROR_INVALID_MEM_TYPE] = "CAM_ERROR_INVALID_MEM_TYPE";
   err_txt[CAM_ERROR_WRONG_TERNARY_MASK] = "CAM_ERROR_WRONG_TERNARY_MASK";
   err_txt[CAM_ERROR_MASKED_KEY_BIT_IS_SET] = "CAM_ERROR_MASKED_KEY_BIT_IS_SET";
   err_txt[CAM_ERROR_INVALID_MODE] = "CAM_ERROR_INVALID_MODE";
   err_txt[CAM_ERROR_WRONG_RESPONSE_WIDTH] = "CAM_ERROR_WRONG_RESPONSE_SIZE";
   err_txt[CAM_ERROR_FORMAT_SYNTAX] = "CAM_ERROR_FORMAT_SYNTAX";
   err_txt[CAM_ERROR_TOO_MANY_FIELDS] = "CAM_ERROR_TOO_MANY_FIELDS";
   err_txt[CAM_ERROR_TOO_MANY_RANGES] = "CAM_ERROR_TOO_MANY_RANGES";
   err_txt[CAM_ERROR_INVALID_RANGE_LEN] = "CAM_ERROR_INVALID_RANGE_LEN";
   err_txt[CAM_ERROR_INVALID_RANGE_START] = "CAM_ERROR_INVALID_RANGE_START";
   err_txt[CAM_ERROR_INVALID_PREFIX_LEN] = "CAM_ERROR_INVALID_PREFIX_LEN";
   err_txt[CAM_ERROR_INVALID_PREFIX_START] = "CAM_ERROR_INVALID_PREFIX_START";
   err_txt[CAM_ERROR_INVALID_PREFIX_KEY] = "CAM_ERROR_INVALID_PREFIX_KEY";
   err_txt[CAM_ERROR_INVALID_BIT_FIELD_LEN] = "CAM_ERROR_INVALID_BIT_FIELD_LEN";
   err_txt[CAM_ERROR_INVALID_BIT_FIELD_START] = "CAM_ERROR_INVALID_BIT_FIELD_START";
   err_txt[CAM_ERROR_INVALID_CONST_FIELD_LEN] = "CAM_ERROR_INVALID_CONST_FIELD_LEN";
   err_txt[CAM_ERROR_INVALID_CONST_FIELD_START] = "CAM_ERROR_INVALID_CONST_FIELD_START";
   err_txt[CAM_ERROR_INVALID_UNUSED_FIELD_LEN] = "CAM_ERROR_INVALID_UNUSED_FIELD_LEN";
   err_txt[CAM_ERROR_INVALID_UNUSED_FIELD_START] = "CAM_ERROR_INVALID_UNUSED_FIELD_START";
   err_txt[CAM_ERROR_MAX_KEY_LEN_EXCEED] = "CAM_ERROR_MAX_KEY_LEN_EXCEED";
   err_txt[CAM_ERROR_INVALID_aaaaaaaaaaaaaa1aaaINDEX_WIDTH] = "CAM ERROR_INVALID_aaaaaaaaaaaaaa1aaaINDEX_WIDTH";
   err_txt[CAM_ERROR_TOO_MANY_UNITS] = "CAM ERROR_TOO_MANY_UNITS";
   err_txt[CAM_ERROR_NO_MASK] = "CAM_ERROR_NO_MASK";
   err_txt[CAM_ERROR_INVALID_MEMORY_WIDTH] = "CAM_ERROR_INVALID_MEMORY_WIDTH";
   err_txt[CAM_ERROR_NOMEM] = "CAM_ERROR_NOMEM";
   err_txt[CAM_ERROR_MALLOC_FAILED] = "CAM_ERROR_MALLOC_FAILED";
   err_txt[CAM_ERROR_UNSUPPORTED_COMMAND]    = "CAM_ERROR_UNSUPPORTED_COMMAND";
   err_txt[CAM_ERROR_ENVIRONMENT]            = "CAM_ERROR_ENVIRONMENT";
   err_txt[CAM_ERROR_UNSUPPORTED_CAM_TYPE]   = "CAM_ERROR_UNSUPPORTED_CAM_TYPE";
   err_txt[CAM_ERROR_NULL_POINTER]           = "CAM_ERROR_NULL_POINTER";
   err_txt[CAM_ERROR_TOO_MANY_PCS]           = "CAM_ERROR_TOO_MANY_PCS";
   err_txt[CAM_ERROR_CONFIGURATION]          = "CAM_ERROR_CONFIGURATION";
   err_txt[CAM_ERROR_ENVIRONMENT_FSMBUSY]    = "CAM_ERROR_ENVIRONMENT_FSMBUSY";
   err_txt[CAM_ERROR_ENVIRONMENT_POLLED_OUT] = "CAM_ERROR_ENVIRONMENT_POLLED_OUT";
   err_txt[CAM_ERROR_SEGMENT_COUNT_ZERO]     = "CAM_ERROR_SEGMENT_COUNT_ZERO";
   err_txt[CAM_ERROR_VC_UNSUPPORTED_COMMAND] = "CAM_ERROR_VC_UNSUPPORTED_COMMAND";
   err_txt[CAM_ERROR_WRONG_VIRTUAL_CAM_ID] = "CAM_ERROR_WRONG_VIRTUAL_CAM_ID";
   err_txt[CAM_ERROR_WRONG_SEGMENT_NUMBER] = "CAM_ERROR_WRONG_SEGMENT_NUMBER";
if (error_code > CAM_ERROR_FATAL_BASE_END) {
       error_text = "UNDEFINED ERROR";
} else {
error_text = err_txt[error_code];
}
return error_text;
}
void cam_print_error(int error_code)
{
char *error_text = cam_error_string(error_code);
if (error_code >= CAM_ERROR_FATAL_BASE_START) {
       fprintf(stderr, "Fatal Error: %s (%d)\n", error_text, error_code);
} else {
       fprintf(stderr, "Error: %s (%d)\n", error_text, error_code);
}
}
#ifndef COMP_BCAM_IP
#ifndef _aaaaa1aaaaaaaaaaaaaaaabaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaa3aaaaaaaaaaaaaaaabaaaaaaaaaaaaaaaaaaaaaaaaaaaa4aaaH_
#define _aaaaa1aaaaaaaaaaaaaaaabaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaa3aaaaaaaaaaaaaaaabaaaaaaaaaaaaaaaaaaaaaaaaaaaa4aaaH_
struct aaaaa1aaaaaaaaaaaaaaaabaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaa3aaaaaaaaaaaaaaaabaaaaaaaaaaaaaaaaaaaaaaaaaaaa4aaarelax_var_array {
uint8_t key[0];
};
struct aaaaa1aaaaaaaaaaaabaaaaaaaaaaa3aaa;
int aaaaa1aaaaaaaaaaaaaaaabaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaa3aaaaaaaaaaaaaaaabaaaaaaaaaaaaaaaaaaaaaaaaaaaa4bbbbbbbbbbbbbbbbbbbbbbbbbbbbbbbbbbbbbbb4aaaeate_exact(struct tcam *magg, struct aaaaa1aaaaaaaaaaaabaaaaaaaaaaa3aaa *me);
void aaaaa1aaaaaaaaaaaaaaaabaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaa3aaaaaaaaaaaaaaaabaaaaaaaaaaaaaaaaaaaaaaaaaaaa4aaaparse_format(struct tcam *magg, const char *format);
int aaaaa1aaaaaaaaaaaaaaaabaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaa3aaaaaaaaaaaaaaaabaaaaaaaaaaaaaaaaaaaaaaaaaaaa4aaaaaaaaaaaaaaaabaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaa4aaa(struct tcam *magg, aaaaaaaaaaaaa1aaat *exact_key,
int indent);
#endif
#endif
#ifndef _CAM_LATENCY_H_
#define _CAM_LATENCY_H_
uint16_t cam_latency(cam_instance_type_t inst_type,
uint16_t num_physical_units, uint8_t num_slots,
float lookup_interface_freq, float engine_lookup_rate, float ram_freq,
uint16_t key_width, uint16_t list_length, uint16_t num_lists,
uint8_t enable_ecc, bool flow_control, bool uram);
#endif
#define CAM_CONFIG_MAX_RANGE_WIDTH 16
#define CAM_CONFIG_MAX_TCAM_ENTRIES (32 * 1024)
#define CLOG2(N) (32 - __builtin_clz((uint32_t) ((N) - 1)))
#define BITS(N) (32 - __builtin_clz((uint32_t) (N)))
#define DIV_UP(N, S) (((N) + (S) - 1) / (S))
#define ROUND_UP(N, S) ((((N) + (S) - 1) / (S)) * (S))
uint16_t cam_config_max_mem_width(cam_instance_type_t instance_type, enum cam_mem_type_t mem_type, uint32_t mem_depth)
{
if (instance_type == HBMBCAM) {
return 1024;
} else {
uint8_t cascading = mem_depth / ((mem_type == BRAM) ? CAM_BRAM_DEPTH_MIN : CAM_URAM_DEPTH_MIN);
uint16_t max_rams = mem_type == BRAM ? CAM_MAX_BRAMS : CAM_MAX_URAMS;
if (instance_type == TCAM) {
max_rams -= cascading;
}
max_rams = max_rams / cascading;
return 64 * max_rams;
}
}
static int dimension(enum cam_mem_type_t mem_type, uint32_t mem_depth, cam_config_t *new_config)
{
if (mem_type == URAM) {
new_config->uram = true;
} else if (mem_type == BRAM) {
new_config->uram = false;
} else {
assert(false);
return CAM_ERROR_INVALID_MEM_TYPE;
}
new_config->num_slots = 1 <<
(31 - __builtin_clz((uint32_t) new_config->arg.ram_freq / new_config->arg.engine_lookup_rate));
if (new_config->num_slots > aaaaaa1aaaaaaaaaaaaaaaabaaaaaaaaaaaaaaaaaaaaaaaaaa3aaaaaaaaaaaaaaaabaaaaaaaaaaaaaaaaaaaaaaaaaaaa3bbbbbbbbbbbbbbbbbbbbbbbbbbbbbbbbbbbb3aaaS) {
new_config->num_slots = aaaaaa1aaaaaaaaaaaaaaaabaaaaaaaaaaaaaaaaaaaaaaaaaa3aaaaaaaaaaaaaaaabaaaaaaaaaaaaaaaaaaaaaaaaaaaa3bbbbbbbbbbbbbbbbbbbbbbbbbbbbbbbbbbbb3aaaS;
}
if (new_config->instance_type == COMPBCAM) {
if (new_config->num_slots > 4) {
new_config->num_slots = 4;
}
}
uint16_t units_storage;
uint16_t units_fields;
uint16_t units_base;
new_config->num_physical_units = 0;
if (new_config->instance_type == TCAM) {
new_config->list_length = ROUND_UP(2 * new_config->key_width + new_config->prio_width +
new_config->arg.response_width + 1, 64);
new_config->num_lists = mem_depth / new_config->num_slots;
new_config->num_entries_per_unit = aaaaaa1aaaaaaaaaaaaaaaabaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaa3aaaaaaaaaaaaaaaabaaaaaaaaaaaaaaaaaaaaaaaaaaaa4bbbbbbbbbbbbbbbbbbbbbbbbbbbbbbbbbb4aaaaaaaaaaaaaaaabaaaaaaaaaaaaaaaaaaaaaaaaaaaa5aaaRATIO * new_config->num_lists;
units_storage = DIV_UP(new_config->arg.num_entries, new_config->num_entries_per_unit);
units_fields = BITS(new_config->key_width);
units_base = 1;
} else if (new_config->instance_type == BCAM || new_config->instance_type == COMPBCAM) {
uint16_t list_length;
list_length = new_config->key_width + new_config->prio_width + new_config->arg.response_width + 1;
if (new_config->instance_type == COMPBCAM) {
list_length += CAM_AGING_BITS;
}
new_config->list_length = ROUND_UP(list_length, 64);
new_config->num_lists = mem_depth / new_config->num_slots;
new_config->num_entries_per_unit = new_config->num_lists;
units_storage = DIV_UP(new_config->arg.num_entries, new_config->num_entries_per_unit * aaaaaa1aaaBCAM_FILL_RATIO);
if (units_storage < 4)
units_storage = 4;
if (units_storage > 4 && new_config->num_slots > 1) {
new_config->num_physical_units = DIV_UP(units_storage, new_config->num_slots);
new_config->num_slots = DIV_UP(4, new_config->num_physical_units);
units_storage = new_config->num_physical_units * new_config->num_slots;
new_config->num_lists = mem_depth / new_config->num_slots;
new_config->num_entries_per_unit = new_config->num_lists;
}
units_fields = 0;
units_base = 0;
} else if (new_config->instance_type == STCAM) {
new_config->list_length = ROUND_UP(
new_config->key_width + new_config->prio_width + new_config->arg.response_width + 1, 64);
new_config->num_lists = mem_depth / new_config->num_slots;
new_config->num_entries_per_unit = MIN(new_config->num_lists, new_config->arg.num_entries);
const uint32_t units_per_level = new_config->arg.num_masks;
const uint32_t full_first_level_min_entries = units_per_level;
const uint32_t full_second_level_min_entries = units_per_level * aaaaaa1aaa1W_FILL_RATIO
* new_config->num_entries_per_unit
+ units_per_level;
const uint32_t full_third_level_min_entries = 2 * units_per_level * aaaaaa1aaa2W_CUCKOO_FILL_RATIO
* new_config->num_entries_per_unit
+ units_per_level;
const uint32_t full_fourth_level_min_entries = 3 * units_per_level * aaaaaa1aaa3W_CUCKOO_FILL_RATIO
* new_config->num_entries_per_unit
+ units_per_level;
if (new_config->arg.num_entries < full_first_level_min_entries) {
units_storage = new_config->arg.num_entries;
} else if (new_config->arg.num_entries < full_second_level_min_entries) {
uint32_t second_level_contribution = aaaaaa1aaa2W_CUCKOO_FILL_RATIO * 2 * new_config->num_entries_per_unit
- aaaaaa1aaa1W_FILL_RATIO * new_config->num_entries_per_unit;
const uint32_t num_second_level = DIV_UP(new_config->arg.num_entries - full_first_level_min_entries,
second_level_contribution);
const uint32_t num_first_level = units_per_level - num_second_level;
units_storage = num_first_level + 2 * num_second_level;
} else if (new_config->arg.num_entries < full_third_level_min_entries) {
uint32_t third_level_contribution = 3 * aaaaaa1aaa3W_CUCKOO_FILL_RATIO * new_config->num_entries_per_unit
- 2 * aaaaaa1aaa2W_CUCKOO_FILL_RATIO * new_config->num_entries_per_unit;
const uint16_t num_third_level = DIV_UP(new_config->arg.num_entries - full_second_level_min_entries,
third_level_contribution);
const uint16_t num_second_level = units_per_level - num_third_level;
units_storage = num_second_level * 2 + 3 * num_third_level;
} else if (new_config->arg.num_entries < full_fourth_level_min_entries) {
uint32_t fourth_level_contribution = 4 * aaaaaa1aaaBCAM_FILL_RATIO * new_config->num_entries_per_unit
- 3 * aaaaaa1aaa3W_CUCKOO_FILL_RATIO * new_config->num_entries_per_unit;
const uint16_t num_fourth_level = DIV_UP(new_config->arg.num_entries - full_third_level_min_entries,
fourth_level_contribution);
const uint16_t num_third_level = units_per_level - num_fourth_level;
units_storage = num_third_level * 3 + 4 * num_fourth_level;
} else {
units_storage = units_per_level
* DIV_UP(new_config->arg.num_entries / units_per_level,
(uint32_t ) (aaaaaa1aaaBCAM_FILL_RATIO * new_config->num_entries_per_unit));
const uint16_t skewed_storage = units_per_level
- 1+ DIV_UP(new_config->arg.num_entries - units_per_level - 1,
(uint32_t ) (aaaaaa1aaaBCAM_FILL_RATIO * new_config->num_entries_per_unit));
if (skewed_storage > units_storage)
units_storage = skewed_storage;
if (units_storage < (units_per_level * 4))
units_storage = 4 * units_per_level;
}
units_fields = 0;
units_base = 0;
} else {
assert(false);
return CAM_ERROR_INVALID_MODE;
}
new_config->num_units = units_base + units_storage + units_fields;
if (new_config->arg.num_units != 0)
new_config->num_units = new_config->arg.num_units;
new_config->num_units = ROUND_UP(new_config->num_units, new_config->num_slots);
if (new_config->num_physical_units == 0)
new_config->num_physical_units = new_config->num_units / new_config->num_slots;
new_config->latency = cam_latency(new_config->instance_type,
new_config->num_physical_units,
new_config->num_slots,
new_config->arg.lookup_interface_freq,
new_config->arg.engine_lookup_rate,
new_config->arg.ram_freq,
new_config->key_width,
new_config->list_length,
new_config->num_lists,
1,
new_config->arg.flow_control,
new_config->uram);
uint16_t max_mem_width = cam_config_max_mem_width(new_config->instance_type,
mem_type,
new_config->num_slots * new_config->num_lists);
if (new_config->list_length > max_mem_width) {
return CAM_ERROR_INVALID_MEMORY_WIDTH;
}
return 0;
}
static uint16_t get_num_rams(bool is_uram, bool is_tcam, uint16_t list_length, uint16_t mem_depth,
uint16_t num_physical_units)
{
uint16_t RAMS;
if (is_uram && (mem_depth == CAM_URAM_DEPTH_MIN)) {
if (is_tcam) {
RAMS = DIV_UP(list_length + 64, 128);
} else {
RAMS = DIV_UP(list_length, 128);
}
} else {
if (is_tcam) {
RAMS = DIV_UP(list_length + 64, 64);
} else {
RAMS = DIV_UP(list_length, 64);
}
}
uint8_t cascading = mem_depth / (is_uram ? CAM_URAM_DEPTH_MIN : CAM_BRAM_DEPTH_MIN);
if (is_uram && cascading > 1) {
cascading /= 2;
}
uint16_t P_UNITS = num_physical_units;
return P_UNITS * cascading * RAMS;
}
int cam_config_create(const cam_arg_t *cam_arg, cam_instance_type_t cam_instance_type, cam_config_t **cam_config)
{
struct cam_config_t *new_config = cam_arg->calloc_function(1, sizeof(cam_config_t));
if (new_config == NULL) {
return CAM_ERROR_MALLOC_FAILED;
}
new_config->version = (CAM_VERSION_MAJOR << 8) | CAM_VERSION_MINOR;
new_config->arg = *cam_arg;
new_config->instance_type = cam_instance_type;
assert(!((new_config->arg.segment_ctx.segment >= 0) && (new_config->arg.vc_seg_map.vcid != -1)));
if ((new_config->arg.segment_ctx.segment >= 0) || (new_config->arg.vc_seg_map.vcid != -1))
new_config->ctx = &(new_config->arg.segment_ctx);
else
new_config->ctx = new_config->arg.segment_ctx.ctx;
int rc;
char message[500];
char *str = strdup(cam_arg->format);
char *s = str;
char *saveptr = str;
if ((new_config->instance_type == STCAM) && (new_config->arg.num_masks == 0)) {
rc = CAM_ERROR_INVALID_ARG;
if ((cam_arg->debug_flags & CAM_DEBUG_NO_ERROR_MSG) == 0) {
           sprintf(message, "'%s' Number of masks '%d' is not allowed for STCAM",
cam_error_string(rc), new_config->arg.num_masks);
new_config->arg.error_print_function(new_config->ctx, message);
}
goto error;
}
if ((new_config->instance_type != STCAM) && (new_config->arg.num_masks != 0)) {
rc = CAM_ERROR_INVALID_ARG;
if ((cam_arg->debug_flags & CAM_DEBUG_NO_ERROR_MSG) == 0) {
           sprintf(message, "'%s' Number of masks '%d' is not allowed (must be '0')",
cam_error_string(rc), new_config->arg.num_masks);
new_config->arg.error_print_function(new_config->ctx, message);
}
goto error;
}
if ((cam_arg->num_entries > CAM_CONFIG_MAX_TCAM_ENTRIES) && cam_instance_type == TCAM) {
rc = CAM_ERROR_FULL;
if ((cam_arg->debug_flags & CAM_DEBUG_NO_ERROR_MSG) == 0) {
           sprintf(message, "'%s' Number of entries '%d' larger than the maxium supported %d for TCAM",
cam_error_string(rc), cam_arg->num_entries, CAM_CONFIG_MAX_TCAM_ENTRIES);
new_config->arg.error_print_function(new_config->ctx, message);
}
goto error;
}
if (!(cam_instance_type == HBMBCAM) && (cam_arg->narrow_key_width > 0)) {
rc = CAM_ERROR_INVALID_ARG;
if ((cam_arg->debug_flags & CAM_DEBUG_NO_ERROR_MSG) == 0) {
           sprintf(message, "'%s' Mixed mode only allowed for DRAM", cam_error_string(rc));
new_config->arg.error_print_function(new_config->ctx, message);
}
goto error;
}
if (((cam_instance_type != BCAM) && (cam_instance_type != HBMBCAM)) && cam_arg->options
) {
rc = CAM_ERROR_INVALID_ARG;
if ((cam_arg->debug_flags & CAM_DEBUG_NO_ERROR_MSG) == 0) {
           sprintf(message, "'%s' Options can only be enabled for HBM", cam_error_string(rc));
new_config->arg.error_print_function(new_config->ctx, message);
}
goto error;
}
if (new_config->instance_type == COMPBCAM && !cam_arg->flow_control) {
rc = CAM_ERROR_INVALID_ARG;
if ((cam_arg->debug_flags & CAM_DEBUG_NO_ERROR_MSG) == 0) {
           sprintf(message, "'%s' Flow control 'false/off' is not allowed for COMPBCAM (must be 'true/on')",
cam_error_string(rc));
new_config->arg.error_print_function(new_config->ctx, message);
}
goto error;
}
if (new_config->instance_type != TCAM) {
if (cam_arg->format[0] != 0) {
rc = CAM_ERROR_INVALID_ARG;
if ((cam_arg->debug_flags & CAM_DEBUG_NO_ERROR_MSG) == 0) {
               sprintf(message, "'%s' Format string can only be defined for TCAM",
cam_error_string(rc));
new_config->arg.error_print_function(new_config->ctx, message);
}
goto error;
}
new_config->key_width = cam_arg->key_width;
} else { 
if (cam_arg->key_width > 0) {
rc = CAM_ERROR_INVALID_ARG;
if ((cam_arg->debug_flags & CAM_DEBUG_NO_ERROR_MSG) == 0) {
               sprintf(message, "'%s' key width '%d' is not allowed for TCAM (must be '0')",
cam_error_string(rc), cam_arg->key_width);
new_config->arg.error_print_function(new_config->ctx, message);
}
goto error;
}
uint16_t start = 0;
uint16_t field_complexity = 0;
while (1) {
uint16_t cnt;
char type;
           char *field = strtok_r(str, ":", &saveptr);
if (field == NULL)
break;
str = NULL;
           rc = sscanf(field, "%hu%c", &cnt, &type);
if (rc != 2) {
rc = CAM_ERROR_FORMAT_SYNTAX;
goto error;
}
if (new_config->num_fields >= CAM_MAX_NUM_FIELDS) {
rc = CAM_ERROR_TOO_MANY_FIELDS;
goto error;
}
switch (type) {
case 'r':
if (new_config->num_ranges == CAM_CONFIG_MAX_RANGES) {
rc = CAM_ERROR_TOO_MANY_RANGES;
goto error;
}
if (cnt < 1 || cnt > CAM_CONFIG_MAX_RANGE_WIDTH) {
rc = CAM_ERROR_INVALID_RANGE_LEN;
goto error;
}
new_config->aaaaaaaaaaaaaaaaaa1aaa[new_config->num_fields].type = aaaaaaaaaaa1aaaaaaaaaaaaaaaabaaaaaaaaaaaaaaaaaaaaaaaaaaaa3aaaR16;
new_config->aaaaaaaaaaaaaaaaaa1aaa[new_config->num_fields].instance = new_config->num_ranges;
new_config->range_start_pos[new_config->num_ranges] = start;
new_config->range_width[new_config->num_ranges] = cnt;
new_config->num_ranges++;
field_complexity += 2;
break;
case 'p':
if (cnt == 0 || cnt > aaaaaaaaaaa1aaaaaaaaaaaaaaaabaaaaaaaaaaaaaaaaaaaaaaaaaaaa3aaaaaaaaaaaaaaaabaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaa3aaaaaaaaaaaaaaaabaaaaaaaaaaaaaaaaaaaaaaaaaaaa4aaaWIDTH_128) {
rc = CAM_ERROR_INVALID_PREFIX_LEN;
goto error;
}
new_config->aaaaaaaaaaaaaaaaaa1aaa[new_config->num_fields].type = aaaaaaaaaaa1aaaaaaaaaaaaaaaabaaaaaaaaaaaaaaaaaaaaaaaaaaaa3aaaP128;
field_complexity += cnt / 4;
break;
case 'b':
if (cnt == 0 || cnt > aaaaaaaaaaa1aaaaaaaaaaaaaaaabaaaaaaaaaaaaaaaaaaaaaaaaaaaa3aaaaaaaaaaaaaaaabaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaa3aaaaaaaaaaaaaaaabaaaaaaaaaaaaaaaaaaaaaaaaaaaa4aaaWIDTH_128) {
rc = CAM_ERROR_INVALID_BIT_FIELD_LEN;
goto error;
}
new_config->aaaaaaaaaaaaaaaaaa1aaa[new_config->num_fields].type = aaaaaaaaaaa1aaaaaaaaaaaaaaaabaaaaaaaaaaaaaaaaaaaaaaaaaaaa3aaaB128;
field_complexity += 1;
break;
case 't': {
if (cnt == 0 || cnt > aaaaaaaaaaa1aaaaaaaaaaaaaaaabaaaaaaaaaaaaaaaaaaaaaaaaaaaa3aaaaaaaaaaaaaaaabaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaa3aaaaaaaaaaaaaaaabaaaaaaaaaaaaaaaaaaaaaaaaaaaa4aaaWIDTH_128 / 2) {
rc = CAM_ERROR_INVALID_TERNARY_FIELD_LEN;
goto error;
}
uint8_t field = new_config->num_fields;
new_config->aaaaaaaaaaaaaaaaaa1aaa[field].type = aaaaaaaaaaa1aaaaaaaaaaaaaaaabaaaaaaaaaaaaaaaaaaaaaaaaaaaa3aaaT64;
field_complexity += cnt / 4;
break;
}
case 'c':
if (cnt == 0 || cnt > aaaaaaaaaaa1aaaaaaaaaaaaaaaabaaaaaaaaaaaaaaaaaaaaaaaaaaaa3aaaaaaaaaaaaaaaabaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaa3aaaaaaaaaaaaaaaabaaaaaaaaaaaaaaaaaaaaaaaaaaaa4aaaWIDTH_128) {
rc = CAM_ERROR_INVALID_CONST_FIELD_LEN;
goto error;
}
new_config->aaaaaaaaaaaaaaaaaa1aaa[new_config->num_fields].type = aaaaaaaaaaa1aaaaaaaaaaaaaaaabaaaaaaaaaaaaaaaaaaaaaaaaaaaa3aaaC128;
break;
case 'u':
if (cnt == 0 || cnt > aaaaaaaaaaa1aaaaaaaaaaaaaaaabaaaaaaaaaaaaaaaaaaaaaaaaaaaa3aaaaaaaaaaaaaaaabaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaa3aaaaaaaaaaaaaaaabaaaaaaaaaaaaaaaaaaaaaaaaaaaa4aaaWIDTH_128) {
rc = CAM_ERROR_INVALID_UNUSED_FIELD_LEN;
goto error;
}
new_config->aaaaaaaaaaaaaaaaaa1aaa[new_config->num_fields].type = aaaaaaaaaaa1aaaaaaaaaaaaaaaabaaaaaaaaaaaaaaaaaaaaaaaaaaaa3aaaU128;
break;
default:
rc = CAM_ERROR_FORMAT_SYNTAX;
goto error;
}
new_config->aaaaaaaaaaaaaaaaaa1aaa[new_config->num_fields].len = cnt;
new_config->aaaaaaaaaaaaaaaaaa1aaa[new_config->num_fields].start_pos = start;
new_config->num_fields++;
new_config->key_width += cnt;
start += cnt;
}
} 
if ((new_config->key_width < CAM_MIN_KEY_WIDTH) || (new_config->key_width > CAM_MAX_KEY_WIDTH)) {
rc = CAM_ERROR_MAX_KEY_LEN_EXCEED;
if ((cam_arg->debug_flags & CAM_DEBUG_NO_ERROR_MSG) == 0) {
           sprintf(message, "'%s' Key width '%d' out of supported range %d-%d",
cam_error_string(rc), new_config->key_width, CAM_MIN_KEY_WIDTH, CAM_MAX_KEY_WIDTH);
new_config->arg.error_print_function(new_config->ctx, message);
}
goto error;
}
if (cam_arg->num_entries == 0) {
rc = CAM_ERROR_INVALID_ARG;
if ((cam_arg->debug_flags & CAM_DEBUG_NO_ERROR_MSG) == 0) {
           sprintf(message, "'%s' CAM can not have 0 entries", cam_error_string(rc));
new_config->arg.error_print_function(new_config->ctx, message);
}
goto error;
}
uint8_t test_prio_width = 0;
if ((new_config->instance_type == TCAM) || (new_config->instance_type == STCAM)) {
if (new_config->arg.priority_width >= 0) {
if (new_config->arg.priority_width <= CAM_MAX_PRIO_WIDTH) {
test_prio_width = new_config->arg.priority_width;
} else {
rc = CAM_ERROR_WRONG_PRIO_WIDTH;
if ((cam_arg->debug_flags & CAM_DEBUG_NO_ERROR_MSG) == 0) {
                   sprintf(message, "'%s' Priority width '%d' is out of supported range %d-%d",
cam_error_string(rc), new_config->arg.priority_width, 0, CAM_MAX_PRIO_WIDTH);
new_config->arg.error_print_function(new_config->ctx, message);
}
goto error;
}
} else {
if (new_config->instance_type == TCAM)
test_prio_width = CLOG2(new_config->arg.num_entries);
else
test_prio_width = CLOG2(new_config->arg.num_masks);
}
} else {
if (new_config->arg.priority_width > 0) {
rc = CAM_ERROR_WRONG_PRIO_WIDTH;
if ((cam_arg->debug_flags & CAM_DEBUG_NO_ERROR_MSG) == 0) {
               sprintf(message, "'%s' Priority width '%d' is not supported for BCAM (must be '0')",
cam_error_string(rc), new_config->arg.priority_width);
new_config->arg.error_print_function(new_config->ctx, message);
}
goto error;
}
}
if ((new_config->arg.response_width > CAM_MAX_RESPONSE_WIDTH) ||
(new_config->arg.response_width < CAM_MIN_RESPONSE_WIDTH)) {
rc = CAM_ERROR_WRONG_RESPONSE_WIDTH;
if ((cam_arg->debug_flags & CAM_DEBUG_NO_ERROR_MSG) == 0) {
           sprintf(message, "'%s' Response width '%d' out of supported range %d-%d",
cam_error_string(rc),
new_config->arg.response_width,
CAM_MIN_RESPONSE_WIDTH, CAM_MAX_RESPONSE_WIDTH);
new_config->arg.error_print_function(new_config->ctx, message);
}
goto error;
}
new_config->prio_width = test_prio_width;
enum cam_mem_type_t mem_type = new_config->arg.mem_type;
if (((new_config->arg.optimization_flags != 0) && (new_config->instance_type == HBMBCAM))
|| ((new_config->arg.optimization_flags & (CAM_OPTIMIZE_RAM | CAM_OPTIMIZE_LOGIC))
== (CAM_OPTIMIZE_RAM | CAM_OPTIMIZE_LOGIC))) {
rc = CAM_ERROR_INVALID_ARG;
if ((cam_arg->debug_flags & CAM_DEBUG_NO_ERROR_MSG) == 0) {
           sprintf(message, "Logic and RAM can not be reduced at the same time or optimization not supported for HBM");
new_config->arg.error_print_function(new_config->ctx, message);
}
goto error;
}
if (new_config->instance_type == HBMBCAM) {
new_config->num_slots = 1;
new_config->replication = (uint32_t) ((new_config->arg.engine_lookup_rate + 18.74) / 18.75);
if (new_config->replication == 0)
new_config->replication = 1;
else if (new_config->replication == 3)
new_config->replication = 4;
else if (new_config->replication > 4) {
new_config->replication = ROUND_UP(new_config->replication, 4);
}
uint8_t control_width = 1;
if (cam_arg->narrow_key_width > 0) {
control_width = 2;
}
const uint16_t entry_size = new_config->arg.response_width + new_config->key_width + control_width;
if (entry_size > aaaaaa1aaaHBMBCAM_MAX_LIST_SIZE) {
new_config->list_length = entry_size;
rc = CAM_ERROR_INVALID_MEMORY_WIDTH;
goto error;
}
uint8_t log2 = CLOG2(entry_size);
if (cam_arg->narrow_key_width > 0) {
const uint16_t narrow_entry_size = new_config->arg.response_width + new_config->arg.narrow_key_width
+ control_width;
uint8_t narrow_entry_log2 = CLOG2(narrow_entry_size);
if (log2 <= 8) {
rc = CAM_ERROR_INVALID_ARG;
if ((cam_arg->debug_flags & CAM_DEBUG_NO_ERROR_MSG) == 0) {
                   sprintf(message, "'%s' Mixed mode not supported for this key width",
cam_error_string(rc));
new_config->arg.error_print_function(new_config->ctx, message);
}
goto error;
}
if (cam_arg->narrow_key_width >= cam_arg->key_width) {
rc = CAM_ERROR_INVALID_ARG;
if ((cam_arg->debug_flags & CAM_DEBUG_NO_ERROR_MSG) == 0) {
                   sprintf(message, "'%s' Narrow key width is not narrower than key width", cam_error_string(rc));
new_config->arg.error_print_function(new_config->ctx, message);
}
goto error;
}
if (narrow_entry_log2 >= log2) {
rc = CAM_ERROR_INVALID_ARG;
if ((cam_arg->debug_flags & CAM_DEBUG_NO_ERROR_MSG) == 0) {
                   sprintf(message, "'%s' Mixed mode not supported, narrow entry size and entry size are equal",
cam_error_string(rc));
new_config->arg.error_print_function(new_config->ctx, message);
}
goto error;
}
if ((new_config->arg.narrow_key_width < CAM_MIN_KEY_WIDTH) ||
(new_config->arg.narrow_key_width > CAM_MAX_KEY_WIDTH)) {
rc = CAM_ERROR_MAX_KEY_LEN_EXCEED;
if ((cam_arg->debug_flags & CAM_DEBUG_NO_ERROR_MSG) == 0) {
                   sprintf(message, "'%s' Narrow key width '%d' out of supported range %d-%d", cam_error_string(rc),
new_config->arg.narrow_key_width, CAM_MIN_KEY_WIDTH, CAM_MAX_KEY_WIDTH);
new_config->arg.error_print_function(new_config->ctx, message);
}
goto error;
}
}
if (log2 < 8)
log2 = 8;
new_config->num_lists_per_read = new_config->arg.dram_read_size / (1 << log2);
if ((__builtin_popcount(new_config->arg.ram_size) != 1) || (new_config->arg.ram_size == 0)) {
rc = CAM_ERROR_INVALID_MEM_TYPE;
if ((cam_arg->debug_flags & CAM_DEBUG_NO_ERROR_MSG) == 0) {
               sprintf(message, "'%s' DRAM size '%d' is not a power of 2", cam_error_string(rc),
new_config->arg.ram_size);
new_config->arg.error_print_function(new_config->ctx, message);
}
goto error;
}
new_config->num_lists = new_config->arg.ram_size * new_config->num_lists_per_read;
new_config->num_entries_per_unit = new_config->num_lists;
if (new_config->num_entries_per_unit > aaaaaa1aaaaaaaaaaaaaaaabaaaaaaaaaaaaaaaaaaaaaaaaaa3aaaaaaaaaaaaaaaabaaaaaaaaaaaaaaaaaaaaaaaaaaaa3aaaaaaaaaaaaaaaabaaaaaaaaaaaaaaaaaaaaa4aaaaaaaaaaaaaaaabaaaaaaaaaaaaaaaaaaaaaaaaaaaa4aaaPER_UNIT) {
rc = CAM_ERROR_INVALID_MEM_TYPE;
if ((cam_arg->debug_flags & CAM_DEBUG_NO_ERROR_MSG) == 0) {
               sprintf(message, "'%s' DRAM size '%d' is too large", cam_error_string(rc), new_config->arg.ram_size);
new_config->arg.error_print_function(new_config->ctx, message);
}
goto error;
}
assert(new_config->num_lists_per_read > 0);
new_config->list_length = new_config->arg.dram_read_size / new_config->num_lists_per_read;
new_config->num_pcs = DIV_UP(new_config->arg.num_entries * new_config->replication,
4 * new_config->num_entries_per_unit * aaaaaa1aaaHBMBCAM_FILL_RATIO);
uint16_t units_storage = (new_config->num_pcs * 4) / new_config->replication;
if (units_storage < 4)
{
units_storage = 4;
new_config->num_pcs = (new_config->replication * units_storage + 3) / 4;
}
new_config->num_units = units_storage;
if (new_config->num_units > aaaaaa1aaaaaaaaaaaaaaaabaaaaaaaaaaaaaaaaaaaaaaaaaa3aaaaaaaaaaaaaaaabaaaaaaaaaaaaaaaaaaaaaaaaaaaa3aaaHaa1aaaaaaaaaaaabaaaaaaaaaaaaaaaaa3aaaS) {
rc = CAM_ERROR_TOO_MANY_UNITS;
if ((cam_arg->debug_flags & CAM_DEBUG_NO_ERROR_MSG) == 0) {
sprintf(message,
                       "'%s' The required number of logical memory units '%d' is larger than the maximum supported %d",
cam_error_string(rc), new_config->num_units, aaaaaa1aaaaaaaaaaaaaaaabaaaaaaaaaaaaaaaaaaaaaaaaaa3aaaaaaaaaaaaaaaabaaaaaaaaaaaaaaaaaaaaaaaaaaaa3aaaHaa1aaaaaaaaaaaabaaaaaaaaaaaaaaaaa3aaaS);
new_config->arg.error_print_function(new_config->ctx, message);
}
goto error;
}
if (new_config->num_pcs > aaaaaa1aaaaaaaaaaaaaaaabaaaaaaaaaaaaaaaaaaaaaaaaaa3aaaaaaaaaaaaaaaabaaaaaaaaaaaaaaaaaaaaaaaaaaaa3aaaPCS) {
rc = CAM_ERROR_TOO_MANY_PCS;
if ((cam_arg->debug_flags & CAM_DEBUG_NO_ERROR_MSG) == 0) {
sprintf(message,
                       "'%s' The required number of pseudo-channels (PCs) '%d' is larger than the maximum supported %d",
cam_error_string(rc), new_config->num_units / new_config->num_slots, aaaaaa1aaaaaaaaaaaaaaaabaaaaaaaaaaaaaaaaaaaaaaaaaa3aaaaaaaaaaaaaaaabaaaaaaaaaaaaaaaaaaaaaaaaaaaa3aaaPCS);
new_config->arg.error_print_function(new_config->ctx, message);
}
goto error;
}
}
else {
if (new_config->arg.engine_lookup_rate > CAM_MAX_FREQ) {
rc = CAM_ERROR_TOO_HIGH_FREQUENCY;
if ((cam_arg->debug_flags & CAM_DEBUG_NO_ERROR_MSG) == 0) {
               sprintf(message, "'%s' Lookup rate '%g Msps' exceeds the maximum supported (%d Msps)",
cam_error_string(rc), new_config->arg.engine_lookup_rate, CAM_MAX_FREQ);
new_config->arg.error_print_function(new_config->ctx, message);
}
goto error;
}
if (new_config->arg.engine_lookup_rate > new_config->arg.lookup_interface_freq) {
rc = CAM_ERROR_TOO_HIGH_FREQUENCY;
if ((cam_arg->debug_flags & CAM_DEBUG_NO_ERROR_MSG) == 0) {
               sprintf(message, "'%s' Lookup rate '%g Msps' exceeds the lookup interface frequency (%g MHz)",
cam_error_string(rc), new_config->arg.engine_lookup_rate,
new_config->arg.lookup_interface_freq);
new_config->arg.error_print_function(new_config->ctx, message);
}
goto error;
}
if (new_config->arg.lookup_interface_freq > CAM_MAX_FREQ) {
rc = CAM_ERROR_TOO_HIGH_FREQUENCY;
if ((cam_arg->debug_flags & CAM_DEBUG_NO_ERROR_MSG) == 0) {
               sprintf(message, "'%s' Lookup interface frequency '%g MHz' exceeds the maximum supported (%d MHz)",
cam_error_string(rc), new_config->arg.lookup_interface_freq, CAM_MAX_FREQ);
new_config->arg.error_print_function(new_config->ctx, message);
}
goto error;
}
if (new_config->arg.lookup_interface_freq > new_config->arg.ram_freq) {
rc = CAM_ERROR_TOO_HIGH_FREQUENCY;
if ((cam_arg->debug_flags & CAM_DEBUG_NO_ERROR_MSG) == 0) {
               sprintf(message, "'%s' Lookup interface frequency '%g MHz' exceeds the RAM frequency (%g MHz)",
cam_error_string(rc), new_config->arg.lookup_interface_freq, new_config->arg.ram_freq);
new_config->arg.error_print_function(new_config->ctx, message);
}
goto error;
}
if (new_config->arg.ram_freq > CAM_MAX_FREQ) {
rc = CAM_ERROR_TOO_HIGH_FREQUENCY;
if ((cam_arg->debug_flags & CAM_DEBUG_NO_ERROR_MSG) == 0) {
               sprintf(message, "'%s' RAM clock frequency '%g MHz' exceeds the maximum supported (%d MHz)",
cam_error_string(rc), new_config->arg.ram_freq, CAM_MAX_FREQ);
new_config->arg.error_print_function(new_config->ctx, message);
}
goto error;
}
bool auto_mem_type = mem_type == AUTO;
bool auto_mem_depth = new_config->arg.ram_size == 512 * 1024;
if (!auto_mem_type && !auto_mem_depth) {
rc = dimension(mem_type, new_config->arg.ram_size, new_config);
if (rc) {
goto error;
}
}
uint16_t num_physical_units_bram = UINT16_MAX;
uint16_t num_physical_units_uram = UINT16_MAX;
uint32_t mem_depth_bram = 0;
uint32_t mem_depth_uram = 0;
uint16_t num_rams_bram = UINT16_MAX;
uint16_t num_rams_uram = UINT16_MAX;
uint32_t mem_depth = 0;
const bool optimize_ram = ((new_config->arg.optimization_flags & CAM_OPTIMIZE_RAM) != 0);
const bool optimize_logic = ((new_config->arg.optimization_flags & CAM_OPTIMIZE_LOGIC) != 0);
assert(!(optimize_ram && optimize_logic));
if (auto_mem_type || (mem_type == BRAM && auto_mem_depth)) {
mem_type = BRAM;
for (uint32_t mem_depth = CAM_BRAM_DEPTH_MIN; mem_depth <= CAM_BRAM_DEPTH_MAX; mem_depth *= 2) {
rc = dimension(mem_type, mem_depth, new_config);
if (!rc) {
const uint16_t num_rams = get_num_rams(false, new_config->instance_type == TCAM,
new_config->list_length, mem_depth, new_config->num_physical_units);
const float delta_rams = num_rams - num_rams_bram;
const float delta_physical_units = new_config->num_physical_units - num_physical_units_bram;
const float ram_improvement = -(delta_rams / num_rams_bram);
const float physical_units_improvement = -(delta_physical_units / num_physical_units_bram);
const float tot_improvement = ram_improvement + 3 * physical_units_improvement;
bool update_values = false;
if ((new_config->num_physical_units < num_physical_units_bram) && optimize_logic) {
update_values = true;
} else if ((num_rams < num_rams_bram) && optimize_ram) {
update_values = true;
} else if (tot_improvement > 0) {
update_values = true;
}
if (update_values) {
num_physical_units_bram = new_config->num_physical_units;
mem_depth_bram = mem_depth;
num_rams_bram = num_rams;
}
}
}
}
if (auto_mem_type || (mem_type == URAM && auto_mem_depth)) {
mem_type = URAM;
for (uint32_t mem_depth = CAM_URAM_DEPTH_MIN; mem_depth <= CAM_URAM_DEPTH_MAX; mem_depth *= 2) {
if (new_config->instance_type == COMPBCAM && mem_depth == CAM_URAM_DEPTH_MIN) {
continue;
}
rc = dimension(mem_type, mem_depth, new_config);
if (!rc) {
const uint16_t num_rams = get_num_rams(false, new_config->instance_type == TCAM,
new_config->list_length, mem_depth, new_config->num_physical_units);
const float delta_rams = num_rams - num_rams_uram;
const float delta_physical_units = new_config->num_physical_units - num_physical_units_uram;
const float ram_improvement = -(delta_rams / num_rams_uram);
const float physical_units_improvement = -(delta_physical_units / num_physical_units_uram);
const float tot_improvement = ram_improvement + 3 * physical_units_improvement;
bool update_values = false;
if ((new_config->num_physical_units < num_physical_units_uram) && optimize_logic) {
update_values = true;
} else if ((num_rams < num_rams_uram) && optimize_ram) {
update_values = true;
} else if (tot_improvement > 0) {
update_values = true;
}
if (update_values) {
num_physical_units_uram = new_config->num_physical_units;
mem_depth_uram = mem_depth;
num_rams_uram = num_rams;
}
}
}
}
if (auto_mem_type || auto_mem_depth) {
if (num_physical_units_bram == UINT16_MAX && num_physical_units_uram == UINT16_MAX) {
rc = CAM_ERROR_TOO_MANY_UNITS;
goto error;
}
mem_type = URAM;
mem_depth = mem_depth_uram;
const float ram_size_bram = num_rams_bram * CAM_BRAM_DEPTH_WIDTH64;
const float ram_size_uram = num_rams_uram * CAM_URAM_DEPTH_WIDTH64;
const float delta_ram_size = ram_size_bram - ram_size_uram;
const float delta_physical_units = num_physical_units_bram - num_physical_units_uram;
const float ram_improvement = -(delta_ram_size / ram_size_uram);
const float physical_units_improvement = -(delta_physical_units / num_physical_units_uram);
const float tot_improvement = ram_improvement + 3 * physical_units_improvement;
if ((num_physical_units_bram <= num_physical_units_uram) && optimize_logic) {
mem_type = BRAM;
mem_depth = mem_depth_bram;
}
else if ((ram_size_bram <= ram_size_uram) && optimize_ram) {
mem_type = BRAM;
mem_depth = mem_depth_bram;
}
else if (tot_improvement > 0) {
mem_type = BRAM;
mem_depth = mem_depth_bram;
}
rc = dimension(mem_type, mem_depth, new_config);
if (rc) {
goto error;
}
}
if (new_config->num_units > aaaaaa1aaaaaaaaaaaaaaaabaaaaaaaaaaaaaaaaaaaaaaaaaa3aaaaaaaaaaaaaaaabaaaaaaaaaaaaaaaaaaaaaaaaaaaa3bbbbbbbbbbbbbbbbbbbbbbbbbbbbbbbbbbb3aaaaaaaaaaaaaaaabaaaaaaaaaaaaaaaaaaaaaaaaaaaa4aaaaaaaaaaaabaaaaaaaaaaaaaaaaa5aaaS) {
rc = CAM_ERROR_TOO_MANY_UNITS;
if ((cam_arg->debug_flags & CAM_DEBUG_NO_ERROR_MSG) == 0) {
               sprintf(message, "'%s' The required number of logical memory units '%d' is larger than the maximum supported %d",
cam_error_string(rc), new_config->num_units, aaaaaa1aaaaaaaaaaaaaaaabaaaaaaaaaaaaaaaaaaaaaaaaaa3aaaaaaaaaaaaaaaabaaaaaaaaaaaaaaaaaaaaaaaaaaaa3bbbbbbbbbbbbbbbbbbbbbbbbbbbbbbbbbbb3aaaaaaaaaaaaaaaabaaaaaaaaaaaaaaaaaaaaaaaaaaaa4aaaaaaaaaaaabaaaaaaaaaaaaaaaaa5aaaS);
new_config->arg.error_print_function(new_config->ctx, message);
}
goto error;
}
if ((new_config->num_physical_units) > aaaaaa1aaaaaaaaaaaaaaaabaaaaaaaaaaaaaaaaaaaaaaaaaa3aaaaaaaaaaaaaaaabaaaaaaaaaaaaaaaaaaaaaaaaaaaa3aaaaaaaaaaaaaaaabaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaa3aaaaaaaaaaaaaaaabaaaaaaaaaaaaaaaaaaaaaaaaaaaa4aaaaaaaaaaaabaaaaaaaaaaaaaaaaa5aaaS) {
rc = CAM_ERROR_TOO_MANY_UNITS;
if ((cam_arg->debug_flags & CAM_DEBUG_NO_ERROR_MSG) == 0) {
               sprintf(message, "'%s' The required number of physical memory units '%d' is larger than the maximum supported %d",
cam_error_string(rc), new_config->num_units / new_config->num_slots, aaaaaa1aaaaaaaaaaaaaaaabaaaaaaaaaaaaaaaaaaaaaaaaaa3aaaaaaaaaaaaaaaabaaaaaaaaaaaaaaaaaaaaaaaaaaaa3aaaaaaaaaaaaaaaabaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaa3aaaaaaaaaaaaaaaabaaaaaaaaaaaaaaaaaaaaaaaaaaaa4aaaaaaaaaaaabaaaaaaaaaaaaaaaaa5aaaS);
new_config->arg.error_print_function(new_config->ctx, message);
}
goto error;
}
} 
if (new_config->arg.hw_write_function == NULL) {
rc = CAM_ERROR_NULL_POINTER;
if ((cam_arg->debug_flags & CAM_DEBUG_NO_ERROR_MSG) == 0) {
           sprintf(message, "'%s' The hardware write function is undefined.", cam_error_string(rc));
new_config->arg.error_print_function(new_config->ctx, message);
}
goto error;
}
if (new_config->arg.hw_read_function == NULL) {
rc = CAM_ERROR_NULL_POINTER;
if ((cam_arg->debug_flags & CAM_DEBUG_NO_ERROR_MSG) == 0) {
           sprintf(message, "'%s' The hardware read function is undefined.", cam_error_string(rc));
new_config->arg.error_print_function(new_config->ctx, message);
}
goto error;
}
if ((cam_instance_type != HBMBCAM)
&& ((new_config->arg.hw_write_start_sequence_function != NULL)
|| (new_config->arg.hw_write_end_sequence_function != NULL))) {
rc = CAM_ERROR_INVALID_ARG;
if ((cam_arg->debug_flags & CAM_DEBUG_NO_ERROR_MSG) == 0) {
sprintf(message,
                   "'%s' hw_write_start_sequence_function or hw_write_end_sequence_function are defined but are only supported for hbm.",
cam_error_string(rc));
new_config->arg.error_print_function(new_config->ctx, message);
}
goto error;
}
if ((cam_instance_type == HBMBCAM) && (new_config->arg.mem_type != AUTO)) {
rc = CAM_ERROR_INVALID_ARG;
if ((cam_arg->debug_flags & CAM_DEBUG_NO_ERROR_MSG) == 0) {
           sprintf(message, "'%s' cam_arg_force_mem_type not supported for hbm", cam_error_string(rc));
new_config->arg.error_print_function(new_config->ctx, message);
}
goto error;
}
if ((cam_instance_type == BCAM) || (cam_instance_type == HBMBCAM)) {
if (new_config->arg.vc_seg_map.vcid >= 0) {
if (new_config->arg.vc_seg_map.vcid >= CAM_MAX_VCS) {
rc = CAM_ERROR_WRONG_VIRTUAL_CAM_ID;
if ((cam_arg->debug_flags & CAM_DEBUG_NO_ERROR_MSG) == 0) {
                   sprintf(message, "'%s' The virtual cam id is too large.", cam_error_string(rc));
new_config->arg.error_print_function(new_config->ctx, message);
}
goto error;
}
uint8_t val = 0;
for (uint32_t x = 0; x < CAM_MAX_VC_SEGMENTS_MEM; x++) {
val |= new_config->arg.vc_seg_map.bit_map[x] & 0xff;
}
if (val == 0) {
rc = CAM_ERROR_SEGMENT_COUNT_ZERO;
if ((cam_arg->debug_flags & CAM_DEBUG_NO_ERROR_MSG) == 0) {
                   sprintf(message, "'%s' No segments are specified for the virtual cam.", cam_error_string(rc));
new_config->arg.error_print_function(new_config->ctx, message);
}
goto error;
}
}
if (new_config->arg.segment_ctx.segment >= 0) {
new_config->segment = new_config->arg.segment_ctx.segment;
}
}
*cam_config = new_config;
if (new_config->arg.debug_flags & CAM_DEBUG_CONFIG) {
cam_config_print(new_config);
}
cam_arg->free_function(s);
return 0;
error:
if (rc == CAM_ERROR_INVALID_MEMORY_WIDTH) {
uint16_t max_mem_width = cam_config_max_mem_width(new_config->instance_type,
mem_type,
new_config->num_slots * new_config->num_lists);
if (new_config->instance_type == HBMBCAM) {
sprintf(message,
                   "'%s' The memory width '%d' required to store key, response and valid is larger than the maximum supported width %d",
cam_error_string(rc), new_config->list_length, max_mem_width);
} else if (new_config->instance_type == TCAM) {
           sprintf(message, "'%s' The memory width '%d' required to store key, mask, priority, response and valid is larger than the maximum supported %s width %d",
                   cam_error_string(rc), new_config->list_length, new_config->uram ? "URAM" : "BRAM", max_mem_width);
} else if (new_config->instance_type == STCAM) {
sprintf(message,
                   "'%s' The memory width '%d' required to store key, priority, response and valid is larger than the maximum supported %s width %d",
                   cam_error_string(rc), new_config->list_length, new_config->uram ? "URAM" : "BRAM", max_mem_width);
} else if (new_config->instance_type == BCAM) {
           sprintf(message, "'%s' The memory width '%d' required to store key, response and valid is larger than the maximum supported %s width %d",
                   cam_error_string(rc), new_config->list_length, new_config->uram ? "URAM" : "BRAM", max_mem_width);
} else {
           sprintf(message, "'%s' The memory width '%d' required to store key, response, aging and valid is larger than the maximum supported %s width %d",
                   cam_error_string(rc), new_config->list_length, new_config->uram ? "URAM" : "BRAM", max_mem_width);
}
if ((cam_arg->debug_flags & CAM_DEBUG_NO_ERROR_MSG) == 0) {
new_config->arg.error_print_function(new_config->ctx, message);
}
}
cam_arg->free_function(new_config);
cam_arg->free_function(s);
return rc;
}
void cam_config_destroy(cam_config_t *cam_config)
{
cam_free_func free_function = cam_config->arg.free_function;
free_function(cam_config);
}
uint16_t cam_config_get_key_width(const cam_config_t *cam_config)
{
return cam_config->key_width;
}
uint8_t cam_config_get_num_pcs(const cam_config_t *cam_config)
{
return cam_config->num_pcs;
}
uint8_t cam_config_get_prio_width(const cam_config_t *cam_config)
{
return cam_config->prio_width;
}
uint16_t cam_config_get_response_width(const cam_config_t *cam_config)
{
return cam_config->arg.response_width;
}
uint16_t cam_config_get_narrow_key_width(const cam_config_t *cam_config)
{
return cam_config->arg.narrow_key_width;
}
uint16_t cam_config_get_num_units(const cam_config_t * cam_config)
{
return cam_config->num_units;
}
uint8_t cam_config_get_num_slots(const cam_config_t * cam_config)
{
return cam_config->num_slots;
}
uint16_t cam_config_get_num_physical_units(const cam_config_t * cam_config)
{
return cam_config->num_physical_units;
}
uint16_t cam_config_get_list_length(const cam_config_t * cam_config)
{
return cam_config->list_length;
}
uint8_t cam_config_get_num_ranges(const cam_config_t * cam_config)
{
return cam_config->num_ranges;
}
uint32_t cam_config_get_num_lists(const cam_config_t * cam_config)
{
return cam_config->num_lists;
}
uint8_t cam_config_get_num_fields(const cam_config_t * cam_config)
{
return cam_config->num_fields;
}
uint8_t cam_config_get_latency(const cam_config_t *cam_config)
{
return cam_config->latency;
}
static uint16_t cam_config_get_num_rams(const cam_config_t *cam_config)
{
const bool IS_TCAM = cam_config->instance_type == TCAM;
const uint32_t mem_depth = cam_config->num_slots * cam_config->num_lists;
return get_num_rams(cam_config->uram, IS_TCAM, cam_config->list_length, mem_depth, cam_config->num_physical_units);
}
uint16_t cam_config_get_num_brams(const cam_config_t *cam_config)
{
if (cam_config->uram) {
return 0;
} else {
return cam_config_get_num_rams(cam_config);
}
}
uint16_t cam_config_get_num_urams(const cam_config_t *cam_config)
{
if (!cam_config->uram) {
return 0;
} else {
return cam_config_get_num_rams(cam_config);
}
}
uint32_t cam_config_get_num_entries(const cam_config_t *cam_config)
{
return cam_config->arg.num_entries;
}
uint16_t cam_config_get_num_entries_per_unit(const cam_config_t *cam_config)
{
return cam_config->num_entries_per_unit;
}
uint8_t cam_config_get_num_masks(const cam_config_t *cam_config)
{
return cam_config->arg.num_masks;
}
int cam_config_get_aaaaaaaaaaaaaaaaaa1aaa(const cam_config_t *cam_config, uint8_t field_number, aaaaaaaaaaa1aaaaaaaaaaaaaaaabaaaaaaaaaaaaaaaaaaaaaaaaaaaa3aaadesc *desc)
{
if (field_number >= cam_config->num_fields)
return CAM_ERROR_TOO_MANY_FIELDS;;
*desc = cam_config->aaaaaaaaaaaaaaaaaa1aaa[field_number];
return 0;
}
int cam_config_get_range_start_pos(const cam_config_t *cam_config, uint8_t range_number,
uint16_t *start_pos)
{
if (range_number >= cam_config->num_ranges)
return CAM_ERROR_TOO_MANY_RANGES;;
*start_pos = cam_config->range_start_pos[range_number];
return 0;
}
int cam_config_get_range_width(const cam_config_t *cam_config, uint8_t range_number, uint8_t *width)
{
if (range_number >= cam_config->num_ranges)
return CAM_ERROR_TOO_MANY_RANGES;;
*width = cam_config->range_width[range_number];
return 0;
}
bool cam_config_is_uram_instance(const cam_config_t *cam_config)
{
return cam_config->uram;
}
bool cam_config_is_mixed_mode(const cam_config_t *cam_config)
{
return (cam_config->arg.narrow_key_width > 0);
}
bool cam_config_is_tcam_instance(const cam_config_t *cam_config)
{
return (cam_config->instance_type == TCAM);
}
bool cam_config_is_bcam_instance(const cam_config_t *cam_config)
{
return (cam_config->instance_type == BCAM);
}
bool cam_config_is_hbmbcam_instance(const cam_config_t *cam_config)
{
return (cam_config->instance_type == HBMBCAM);
}
uint8_t cam_config_get_replication(const cam_config_t *cam_config)
{
return cam_config->replication;
}
uint32_t cam_config_get_ram_size(const cam_config_t *cam_config)
{
return cam_config->arg.ram_size;
}
uint16_t cam_config_get_segment(const cam_config_t *cam_config)
{
return cam_config->segment;
}
uint32_t cam_config_get_num_lists_per_read(const cam_config_t * const cam_config)
{
return cam_config->num_lists_per_read;
}
bool cam_config_is_single_clock(const cam_config_t *cam_config)
{
return (cam_config->arg.ram_freq == cam_config->arg.lookup_interface_freq);
}
bool cam_config_has_flow_control(const cam_config_t *cam_config)
{
return cam_config->arg.flow_control;
}
void cam_config_get_default_response(const cam_config_t *cam_config, uint8_t *default_response)
{
memcpy(default_response, cam_config->arg.default_response, sizeof(aaaaaaaaaaaaaaaa1aaaaaaaaaaaaaaaabaaaaaaaaaaaaaaaaaaaaaaaaaaaa3aaat));
}
void cam_config_get_narrow_default_response(const cam_config_t *cam_config, uint8_t *narrow_default_response)
{
memcpy(narrow_default_response, cam_config->arg.narrow_default_response, sizeof(aaaaaaaaaaaaaaaa1aaaaaaaaaaaaaaaabaaaaaaaaaaaaaaaaaaaaaaaaaaaa3aaat));
}
uint8_t cam_config_get_field_width(const cam_config_t *cam_config, uint8_t field_num) {
const char *format = cam_config->arg.format;
int i = 0;
if (field_num > 0) {
int cnt = 0;
for (i = 0; i < strlen(format); i++) {
if (format[i] == ':') {
cnt++;
if (cnt == field_num) {
i++;
break;
}
}
}
}
uint8_t val = strtoul(&format[i], NULL, 10);
return val;
}
uint16_t cam_config_get_field_pos(const cam_config_t *cam_config, uint8_t field_num) {
uint16_t pos = 0;
for (int field = 0; field < field_num; field++) {
pos += cam_config_get_field_width(cam_config, field);
}
return pos;
}
char* cam_config_get_header(const cam_config_t *cam_config)
{
static char message[100];
   sprintf(message, "  Depth x (Key  %s+ Response %s+ Valid + Unused = Width)",
           cam_config->instance_type == TCAM ? "+ Mask " : "",
           cam_config->instance_type == TCAM || cam_config->instance_type == STCAM ? "+ Priority " :
           cam_config->instance_type == COMPBCAM ? "+ Aging " : "");
return &message[0];
}
char* cam_config_get_values(const cam_config_t *cam_config)
{
static char message[100];
int unused = cam_config->list_length - cam_config_get_key_width(cam_config) -
cam_config_get_response_width(cam_config) - 1;
if (cam_config->instance_type == TCAM) {
unused -= cam_config_get_key_width(cam_config);
}
if (cam_config->instance_type == TCAM || cam_config->instance_type == STCAM) {
unused -= cam_config_get_prio_width(cam_config);
}
if (cam_config->instance_type == COMPBCAM) {
unused -= CAM_AGING_BITS;
}
char mask[10];
if (cam_config->instance_type == TCAM) {
       sprintf(mask, " + %3d ", cam_config_get_key_width(cam_config));
} else {
mask[0] = '\0';
}
char prio[13];
if (cam_config->instance_type == TCAM || cam_config->instance_type == STCAM) {
       sprintf(prio, "+   %2d     ", cam_config_get_prio_width(cam_config));
} else if (cam_config->instance_type == COMPBCAM) {
       sprintf(prio, "+  %d    ", CAM_AGING_BITS);
} else {
prio[0] = '\0';
}
   sprintf(message, "%7d x (%4d%s +   %4d   %s+   1   +  %3d   = %4d )",
cam_config->arg.num_entries,
cam_config_get_key_width(cam_config),
&mask[0],
cam_config_get_response_width(cam_config),
&prio[0],
unused,
cam_config->list_length);
return &message[0];
}
char* cam_config_get_lookup_clock_info(const cam_config_t *cam_config)
{
static char message[100];
int li_limit = cam_config->arg.lookup_interface_freq / cam_config->arg.engine_lookup_rate;
int ram_limit = cam_config_get_num_slots(cam_config) /
(cam_config->arg.ram_freq / cam_config->arg.lookup_interface_freq);
int rate_limit = li_limit > ram_limit ? li_limit : ram_limit;
   sprintf(message, " %.8g MHz (1 lookup every", cam_config->arg.lookup_interface_freq);
if (rate_limit == 1) {
       sprintf(&message[strlen(message)], " cycle)");
} else {
       sprintf(&message[strlen(message)], " %d cycles)", rate_limit);
}
   sprintf(&message[strlen(message)], " flow control %s",
           cam_config->arg.flow_control ? "enabled" : "disabled");
return &message[0];
}
char* cam_config_get_ram_clock_info(const cam_config_t *cam_config)
{
float lookup_bw = cam_config->arg.engine_lookup_rate * cam_config->num_slots;
static char message[150];
   sprintf(message, " %.8g MHz (Lookups %d x %.8g Msps = %.8g MHz + Management %.8g MHz)",
cam_config->arg.ram_freq,
cam_config->num_slots,
cam_config->arg.engine_lookup_rate,
lookup_bw,
cam_config->arg.ram_freq - lookup_bw);
return &message[0];
}
char* cam_config_get_tdm_info(const cam_config_t *cam_config)
{
float lookup_bw = cam_config->arg.engine_lookup_rate * cam_config->num_slots;
uint8_t num_slots = 1 <<
(31 - __builtin_clz((uint32_t) cam_config->arg.ram_freq / cam_config->arg.engine_lookup_rate));
if (num_slots > aaaaaa1aaaaaaaaaaaaaaaabaaaaaaaaaaaaaaaaaaaaaaaaaa3aaaaaaaaaaaaaaaabaaaaaaaaaaaaaaaaaaaaaaaaaaaa3bbbbbbbbbbbbbbbbbbbbbbbbbbbbbbbbbbbb3aaaS) {
num_slots = aaaaaa1aaaaaaaaaaaaaaaabaaaaaaaaaaaaaaaaaaaaaaaaaa3aaaaaaaaaaaaaaaabaaaaaaaaaaaaaaaaaaaaaaaaaaaa3bbbbbbbbbbbbbbbbbbbbbbbbbbbbbbbbbbbb3aaaS;
}
static char message[150];
   sprintf(message, " %d", cam_config->num_slots);
if (cam_config->num_slots == aaaaaa1aaaaaaaaaaaaaaaabaaaaaaaaaaaaaaaaaaaaaaaaaa3aaaaaaaaaaaaaaaabaaaaaaaaaaaaaaaaaaaaaaaaaaaa3bbbbbbbbbbbbbbbbbbbbbbbbbbbbbbbbbbbb3aaaS &&
(cam_config->arg.ram_freq - lookup_bw) > 0) {
       sprintf(&message[strlen(message)], " (capped at maximum value '%d')",
aaaaaa1aaaaaaaaaaaaaaaabaaaaaaaaaaaaaaaaaaaaaaaaaa3aaaaaaaaaaaaaaaabaaaaaaaaaaaaaaaaaaaaaaaaaaaa3bbbbbbbbbbbbbbbbbbbbbbbbbbbbbbbbbbbb3aaaS);
} else if ((cam_config->instance_type == BCAM || cam_config->instance_type == COMPBCAM) &&
num_slots > cam_config->num_slots) {
       sprintf(&message[strlen(message)], " (capped at '%d' because no more hash lookups needed)",
cam_config->num_slots);
}
return &message[0];
}
char* cam_config_get_ram_utilization_info(const cam_config_t *cam_config)
{
static char message[150];
int used = cam_config_get_key_width(cam_config) + cam_config_get_response_width(cam_config) + 1;
if (cam_config->instance_type == TCAM) {
used += cam_config_get_key_width(cam_config);
}
if (cam_config->instance_type == TCAM || cam_config->instance_type == STCAM) {
used += cam_config_get_prio_width(cam_config);
}
if (cam_config->instance_type == COMPBCAM) {
used += CAM_AGING_BITS;
}
int depth_util = 100 * cam_config->arg.num_entries / (cam_config_get_num_units(cam_config) * cam_config->num_lists);
int width_util = 100 * used / cam_config->list_length;
int total_util = 100 * cam_config->arg.num_entries * used
/ (cam_config_get_num_units(cam_config) * cam_config->num_lists * cam_config->list_length);
   sprintf(message, " Depth %d%% (%d / %d) x Width %d%% (%d / %d) = Total %d%%", depth_util,
cam_config->arg.num_entries, cam_config_get_num_units(cam_config) * cam_config->num_lists, width_util, used,
cam_config->list_length, total_util);
return &message[0];
}
char* cam_config_get_memory_units_info(const cam_config_t *cam_config)
{
static char message[150];
   sprintf(message, " %d logical / %d physical",
cam_config_get_num_units(cam_config),
cam_config_get_num_physical_units(cam_config));
return &message[0];
}
static char* get_generation_info(const cam_config_t *cam_config)
{
static char message[150];
   char *mem_type_str = "";
char *optimize_str;
if (cam_config->arg.mem_type == AUTO)
       mem_type_str = "AUTO RAM type";
else if (cam_config->arg.mem_type == URAM)
       mem_type_str = "forced URAM";
else if (cam_config->arg.mem_type == BRAM)
       mem_type_str = "forced BRAM";
else
assert(false);
if ((cam_config->arg.optimization_flags & CAM_OPTIMIZE_RAM) == CAM_OPTIMIZE_RAM)
       optimize_str = "RAM";
else if ((cam_config->arg.optimization_flags & CAM_OPTIMIZE_LOGIC) == CAM_OPTIMIZE_LOGIC)
       optimize_str = "LOGIC";
else
       optimize_str = "AUTO";
   sprintf(message, " Generated using %s and %s optimization", mem_type_str, optimize_str);
return &message[0];
}
void cam_config_print(const cam_config_t *cam_config)
{
char message[500];
char sub_str[2048];
char *message_pos;
int width;
   const char *padding = "------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------";
int col[3] = { 15, 54, 22 };
if (cam_config->instance_type == TCAM) {
col[1] += 7;
}
if (cam_config->instance_type == TCAM || cam_config->instance_type == STCAM) {
col[1] += 11;
}
if (cam_config->instance_type == COMPBCAM) {
col[1] += 8;
}
   sprintf(message, " ");
cam_config->arg.info_print_function(cam_config->ctx, message);
cam_config->arg.info_print_function(cam_config->ctx, message);
   sprintf(message, "Version %d.%d", cam_config->version >> 8, cam_config->version & 0xff);
cam_config->arg.info_print_function(cam_config->ctx, message);
   sprintf(message, "+%-.*s+%-.*s+%-.*s+", col[0], padding, col[1], padding, col[2], padding);
cam_config->arg.info_print_function(cam_config->ctx, message);
   sprintf(message, "|%-*s| %s |%-*s|",
           col[0], " Instance Type",
cam_config_get_header(cam_config),
           col[2], " Primitives");
cam_config->arg.info_print_function(cam_config->ctx, message);
   sprintf(message, "+%-.*s+%-.*s+%-.*s+", col[0], padding, col[1], padding, col[2], padding);
cam_config->arg.info_print_function(cam_config->ctx, message);
   sprintf(sub_str, " %d-Mask STCAM", cam_config->arg.num_masks);
   sprintf(message, "|%-*s| %s | %13s x %4d |",
col[0],
           cam_config->instance_type == TCAM ? " TCAM" : cam_config->instance_type == STCAM ? sub_str : " BCAM",
cam_config_get_values(cam_config),
           !cam_config->uram && cam_config->instance_type != HBMBCAM ? "RAMB36E2" : cam_config->uram && cam_config->instance_type != HBMBCAM ? "URAM288_BASE" : "HBM512K",
cam_config->instance_type != HBMBCAM ? cam_config_get_num_rams(cam_config) : cam_config_get_num_pcs(cam_config));
cam_config->arg.info_print_function(cam_config->ctx, message);
if (cam_config->instance_type == STCAM || cam_config->instance_type == TCAM) {
       sprintf(message, "|%-*s|%-*s| %12s x %5d |",
               col[0], " ",
               col[1], " ",
               "RAM32D",
cam_config_get_num_physical_units(cam_config) * cam_config_get_key_width(cam_config));
cam_config->arg.info_print_function(cam_config->ctx, message);
}
   sprintf(message, "+%-.*s+%-.*s+%-.*s+", col[0], padding, col[1], padding, col[2], padding);
cam_config->arg.info_print_function(cam_config->ctx, message);
   sprintf(message, " ");
cam_config->arg.info_print_function(cam_config->ctx, message);
if (cam_config->instance_type == TCAM) {
width = 17 + cam_config_get_num_fields(cam_config) * 9;
       sprintf(message, "+%-.*s+", width, padding);
cam_config->arg.info_print_function(cam_config->ctx, message);
       sprintf(sub_str, " Key format %s (%d bits)",
cam_config->arg.format,
cam_config_get_key_width(cam_config));
       sprintf(message, "|%-*s|", width, sub_str);
cam_config->arg.info_print_function(cam_config->ctx, message);
message_pos = &sub_str[0];
       sprintf(message_pos, "+-----------------");
message_pos += strlen(message_pos);
for (int f = cam_config_get_num_fields(cam_config) - 1; f >= 0; f--) {
           sprintf(message_pos, "+--------");
message_pos += strlen(message_pos);
}
       sprintf(message_pos, "+");
cam_config->arg.info_print_function(cam_config->ctx, sub_str);
aaaaaaaaaaa1aaaaaaaaaaaaaaaabaaaaaaaaaaaaaaaaaaaaaaaaaaaa3aaadesc aaaaaaaaaaaaaaaaaa1aaa;
message_pos = &message[0];
       sprintf(message_pos, "| Key field       ");
message_pos += strlen(message_pos);
for (int f = cam_config_get_num_fields(cam_config) - 1; f >= 0; f--) {
cam_config_get_aaaaaaaaaaaaaaaaaa1aaa(cam_config, f, &aaaaaaaaaaaaaaaaaa1aaa);
           sprintf(message_pos, "|  %3d%c  ", aaaaaaaaaaaaaaaaaa1aaa.len,
aaaaaaaaaaaaaaaaaa1aaa.type == aaaaaaaaaaa1aaaaaaaaaaaaaaaabaaaaaaaaaaaaaaaaaaaaaaaaaaaa3aaaR16 ? 'r' :
aaaaaaaaaaaaaaaaaa1aaa.type == aaaaaaaaaaa1aaaaaaaaaaaaaaaabaaaaaaaaaaaaaaaaaaaaaaaaaaaa3aaaP128 ? 'p' :
aaaaaaaaaaaaaaaaaa1aaa.type == aaaaaaaaaaa1aaaaaaaaaaaaaaaabaaaaaaaaaaaaaaaaaaaaaaaaaaaa3aaaB128 ? 'b' :
aaaaaaaaaaaaaaaaaa1aaa.type == aaaaaaaaaaa1aaaaaaaaaaaaaaaabaaaaaaaaaaaaaaaaaaaaaaaaaaaa3aaaT64 ? 't' :
aaaaaaaaaaaaaaaaaa1aaa.type == aaaaaaaaaaa1aaaaaaaaaaaaaaaabaaaaaaaaaaaaaaaaaaaaaaaaaaaa3aaaC128 ? 'c' : 'u');
message_pos += strlen(message_pos);
}
       sprintf(message_pos, "|");
cam_config->arg.info_print_function(cam_config->ctx, message);
cam_config->arg.info_print_function(cam_config->ctx, sub_str);
message_pos = &message[0];
       sprintf(message_pos, "| Key bit pos     ");
message_pos += strlen(message_pos);
for (int f = cam_config_get_num_fields(cam_config) - 1; f >= 0; f--) {
cam_config_get_aaaaaaaaaaaaaaaaaa1aaa(cam_config, f, &aaaaaaaaaaaaaaaaaa1aaa);
           sprintf(message_pos, "|%3d  %3d",
aaaaaaaaaaaaaaaaaa1aaa.start_pos + aaaaaaaaaaaaaaaaaa1aaa.len - 1,
aaaaaaaaaaaaaaaaaa1aaa.start_pos);
message_pos += strlen(message_pos);
}
       sprintf(message_pos, "|");
cam_config->arg.info_print_function(cam_config->ctx, message);
cam_config->arg.info_print_function(cam_config->ctx, sub_str);
       sprintf(message, " ");
cam_config->arg.info_print_function(cam_config->ctx, message);
}
col[0] = 28;
col[1] = 75;
   sprintf(message, "+%-.*s+%-.*s+", col[0], padding, col[1], padding);
cam_config->arg.info_print_function(cam_config->ctx, message);
   sprintf(sub_str, " %.8g Msps", cam_config->arg.engine_lookup_rate);
   sprintf(message, "|%-*s|%-*s|", col[0], " Lookup rate", col[1], sub_str);
cam_config->arg.info_print_function(cam_config->ctx, message);
   sprintf(message, "+%-.*s+%-.*s+", col[0], padding, col[1], padding);
cam_config->arg.info_print_function(cam_config->ctx, message);
if (cam_config->instance_type != HBMBCAM) {
       sprintf(message, "|%-*s|%-*s|", col[0], " Lookup interface frequency", col[1],
cam_config_get_lookup_clock_info(cam_config));
cam_config->arg.info_print_function(cam_config->ctx, message);
       sprintf(message, "+%-.*s+%-.*s+", col[0], padding, col[1], padding);
cam_config->arg.info_print_function(cam_config->ctx, message);
       sprintf(message, "|%-*s|%-*s|", col[0], " TDM Factor", col[1],
cam_config_get_tdm_info(cam_config));
cam_config->arg.info_print_function(cam_config->ctx, message);
       sprintf(message, "+%-.*s+%-.*s+", col[0], padding, col[1], padding);
cam_config->arg.info_print_function(cam_config->ctx, message);
       sprintf(message, "|%-*s|%-*s|", col[0], " RAM clock frequency", col[1],
cam_config_get_ram_clock_info(cam_config));
cam_config->arg.info_print_function(cam_config->ctx, message);
       sprintf(message, "+%-.*s+%-.*s+", col[0], padding, col[1], padding);
cam_config->arg.info_print_function(cam_config->ctx, message);
       sprintf(sub_str, " %d logical / %d physical",
cam_config_get_num_units(cam_config),
cam_config_get_num_physical_units(cam_config));
       sprintf(message, "|%-*s|%-*s|", col[0], " Memory units", col[1], sub_str);
cam_config->arg.info_print_function(cam_config->ctx, message);
       sprintf(message, "+%-.*s+%-.*s+", col[0], padding, col[1], padding);
cam_config->arg.info_print_function(cam_config->ctx, message);
       sprintf(message, "|%-*s|%-*s|", col[0], " RAM utilization", col[1],
cam_config_get_ram_utilization_info(cam_config));
cam_config->arg.info_print_function(cam_config->ctx, message);
       sprintf(message, "+%-.*s+%-.*s+", col[0], padding, col[1], padding);
cam_config->arg.info_print_function(cam_config->ctx, message);
       sprintf(message, "|%-*s|%-*s|", col[0], " Optimization settings", col[1],
get_generation_info(cam_config));
cam_config->arg.info_print_function(cam_config->ctx, message);
       sprintf(message, "+%-.*s+%-.*s+", col[0], padding, col[1], padding);
cam_config->arg.info_print_function(cam_config->ctx, message);
}
}
int cam_latency_mirror(int UNITS)
{
bool MIRROR_X = UNITS <= 2 ? false : true;
return MIRROR_X ? 2 : 1;
}
int cam_latency_unit_ram_height(cam_instance_type_t MODE, bool URAM, int aaaa1aaaDATA,
int aaaa1bbbbbbbbbbbbbbbbbbbbbbbbbbbbbbbb3aaaR, int CASCADE_HEIGHT)
{
int M_W64 = MODE == TCAM ? (aaaa1aaaDATA + 64 + 63) / 64 : (aaaa1aaaDATA + 63) / 64;
int M_W128 = MODE == TCAM ? (aaaa1aaaDATA + 64 + 127) / 128 : (aaaa1aaaDATA + 127) / 128;
int UNIT_RAMS = (URAM && aaaa1bbbbbbbbbbbbbbbbbbbbbbbbbbbbbbbb3aaaR == 2048 ? M_W128 : M_W64) * CASCADE_HEIGHT;
int UNIT_RAM_HEIGHT = !URAM && UNIT_RAMS > 6 ? (UNIT_RAMS + 1) / 2 : UNIT_RAMS;
return UNIT_RAM_HEIGHT > 16 ? 16 : UNIT_RAM_HEIGHT;
}
int cam_latency_tiles(cam_instance_type_t MODE, int UNITS, bool URAM,
int aaaa1aaaDATA, int aaaa1bbbbbbbbbbbbbbbbbbbbbbbbbbbbbbbb3aaaR, int CASCADE_HEIGHT)
{
int TOT_HEIGHT = UNITS * cam_latency_unit_ram_height(MODE, URAM, aaaa1aaaDATA,
aaaa1bbbbbbbbbbbbbbbbbbbbbbbbbbbbbbbb3aaaR, CASCADE_HEIGHT);
return URAM ? (TOT_HEIGHT + 15) / 16 : (TOT_HEIGHT + 11) / 12;
}
int cam_latency_cols(cam_instance_type_t MODE, int UNITS, bool URAM,
int aaaa1aaaDATA, int aaaa1bbbbbbbbbbbbbbbbbbbbbbbbbbbbbbbb3aaaR, int CASCADE_HEIGHT)
{
int T = cam_latency_tiles(MODE, UNITS, URAM, aaaa1aaaDATA, aaaa1bbbbbbbbbbbbbbbbbbbbbbbbbbbbbbbb3aaaR, CASCADE_HEIGHT);
int C = T >= 16 ? 4 : T >= 9 ? 3 : T >= 4 ? 2 : 1;
int M = cam_latency_mirror(UNITS);
int COL_ROWS = UNITS <= 2 ? UNITS : (((UNITS + C - 1) / C) + M - 1) / M;
int COL_LIMIT = URAM ? 80 : 120;
if (M * COL_ROWS *
cam_latency_unit_ram_height(MODE, URAM, aaaa1aaaDATA,
aaaa1bbbbbbbbbbbbbbbbbbbbbbbbbbbbbbbb3aaaR, CASCADE_HEIGHT) > COL_LIMIT) {
C++;
}
return C;
}
int cam_prio_latency(cam_instance_type_t MODE, int UNITS, bool URAM,
int aaaa1aaaDATA, int aaaa1bbbbbbbbbbbbbbbbbbbbbbbbbbbbbbbb3aaaR, int CASCADE_HEIGHT)
{
int T = cam_latency_tiles(MODE, UNITS, URAM, aaaa1aaaDATA, aaaa1bbbbbbbbbbbbbbbbbbbbbbbbbbbbbbbb3aaaR, CASCADE_HEIGHT);
int C = cam_latency_cols(MODE, UNITS, URAM, aaaa1aaaDATA, aaaa1bbbbbbbbbbbbbbbbbbbbbbbbbbbbbbbb3aaaR, CASCADE_HEIGHT);
return ((T + C - 1) / C) / 4;
}
int cam_rows(cam_instance_type_t MODE, int UNITS, bool URAM,
int aaaa1aaaDATA, int aaaa1bbbbbbbbbbbbbbbbbbbbbbbbbbbbbbbb3aaaR, int CASCADE_HEIGHT)
{
int C = cam_latency_cols(MODE, UNITS, URAM, aaaa1aaaDATA, aaaa1bbbbbbbbbbbbbbbbbbbbbbbbbbbbbbbb3aaaR, CASCADE_HEIGHT);
int M = cam_latency_mirror(UNITS);
return UNITS <= 2 ? UNITS : (((UNITS + C - 1) / C) + M - 1) / M;
}
int cam_latency_hash(cam_instance_type_t MODE, int TDM_FACTOR, int KEY_WIDTH,
int MEM_WIDTH, int CASCADE_HEIGHT, int HI_FREQ)
{
int aaaaaaaaaaaa1aaaDIV = (MODE == TCAM || MODE == STCAM) && TDM_FACTOR != 1 ? 2 : 1;
int MEM_FANOUT = CASCADE_HEIGHT * MEM_WIDTH;
return KEY_WIDTH <= 160/aaaaaaaaaaaa1aaaDIV && MEM_FANOUT <= 256/aaaaaaaaaaaa1aaaDIV ? 0 + HI_FREQ :
KEY_WIDTH <= 320/aaaaaaaaaaaa1aaaDIV && MEM_FANOUT <= 512/aaaaaaaaaaaa1aaaDIV ? 0 + 2*HI_FREQ :
KEY_WIDTH <= 640/aaaaaaaaaaaa1aaaDIV && MEM_FANOUT <= 1024/aaaaaaaaaaaa1aaaDIV ? 1 + HI_FREQ :
KEY_WIDTH <= 1280/aaaaaaaaaaaa1aaaDIV && MEM_FANOUT <= 2048/aaaaaaaaaaaa1aaaDIV ? 2 + HI_FREQ : 3;
}
int cam_latency_ram(bool URAM, int ECC_EN, int HI_FREQ)
{
return 1 + ECC_EN + (URAM && HI_FREQ);
}
int cam_latency_array(cam_instance_type_t MODE, int UNITS, int TDM_FACTOR, int KEY_WIDTH, bool URAM,
int aaaa1aaaDATA, int aaaa1bbbbbbbbbbbbbbbbbbbbbbbbbbbbbbbb3aaaR, int CASCADE_HEIGHT, int ECC_EN, int HI_FREQ)
{
int R = cam_rows(MODE, UNITS, URAM, aaaa1aaaDATA, aaaa1bbbbbbbbbbbbbbbbbbbbbbbbbbbbbbbb3aaaR, CASCADE_HEIGHT);
int KEY_LATENCY = UNITS > 1 ? (R + 1) / 2 - 1 : 0;
int H_LATENCY = cam_latency_hash(MODE, TDM_FACTOR, KEY_WIDTH,
aaaa1aaaDATA, CASCADE_HEIGHT, HI_FREQ);
int R_LATENCY = cam_latency_ram(URAM, ECC_EN, HI_FREQ);
int C_LATENCY = MODE == COMPBCAM ? 2 : 2;
int HASH_MODULE_LATENCY = MODE == TCAM ? 7 + HI_FREQ + H_LATENCY + 2*R_LATENCY + C_LATENCY :
MODE == STCAM ? 4 + H_LATENCY + R_LATENCY + C_LATENCY :
3 + H_LATENCY + R_LATENCY + C_LATENCY;
int PRIO_COL_LATENCY = cam_latency_cols(MODE, UNITS, URAM, aaaa1aaaDATA, aaaa1bbbbbbbbbbbbbbbbbbbbbbbbbbbbbbbb3aaaR, CASCADE_HEIGHT);
int MIRROR_LATENCY = cam_latency_mirror(UNITS) == 2 ? 1 : 0;
int RETURN_LATENCY = cam_latency_cols(MODE, UNITS, URAM, aaaa1aaaDATA, aaaa1bbbbbbbbbbbbbbbbbbbbbbbbbbbbbbbb3aaaR, CASCADE_HEIGHT) - 1;
int DOUBLE_INSTANCE = R >= 2 ? 2 : UNITS >= 2 ? 0 : -1;
return KEY_LATENCY + HASH_MODULE_LATENCY + DOUBLE_INSTANCE + PRIO_COL_LATENCY +
cam_prio_latency(MODE, UNITS, URAM, aaaa1aaaDATA, aaaa1bbbbbbbbbbbbbbbbbbbbbbbbbbbbbbbb3aaaR, CASCADE_HEIGHT) + MIRROR_LATENCY + RETURN_LATENCY;
}
int cam_latency_core(cam_instance_type_t inst_type, uint16_t num_physical_units,
uint8_t TDM_FACTOR, uint16_t key_width, bool uram,
uint16_t list_length, uint16_t num_lists,
uint8_t enable_ecc, float ram_freq)
{
int aaaa1bbbbbbbbbbbbbbbbbbbbbbbbbbbbbbbb3aaaR = num_lists * TDM_FACTOR;
int aaaa1aaaDATA = list_length;
int HI_FREQ = ram_freq > 330 ? 1 : 0;
int CASCADE_HEIGHT = aaaa1bbbbbbbbbbbbbbbbbbbbbbbbbbbbbbbb3aaaR / (uram ? 2 * CAM_URAM_DEPTH_MIN : CAM_BRAM_DEPTH_MIN);
if (CASCADE_HEIGHT == 0) {
CASCADE_HEIGHT = 1;
}
int latency = cam_latency_array(inst_type, num_physical_units, TDM_FACTOR, key_width, uram,
aaaa1aaaDATA, aaaa1bbbbbbbbbbbbbbbbbbbbbbbbbbbbbbbb3aaaR, CASCADE_HEIGHT, enable_ecc, HI_FREQ);
return TDM_FACTOR == 1 ? latency + 1 : 1 + latency + 1 + TDM_FACTOR;
}
uint16_t cam_latency(cam_instance_type_t inst_type,
uint16_t num_physical_units, uint8_t num_slots,
float lookup_interface_freq, float engine_lookup_rate, float ram_freq,
uint16_t key_width, uint16_t list_length, uint16_t num_lists,
uint8_t enable_ecc, bool flow_control, bool uram)
{
if (inst_type == HBMBCAM) {
return 250;
}
int CUCKOO_REG_LATENCY = inst_type == COMPBCAM ? (num_slots == 1 ? 1 : 2) : 1;
int CORE_LATENCY = CUCKOO_REG_LATENCY + cam_latency_core(inst_type, num_physical_units, num_slots,
key_width, uram, list_length, num_lists,
enable_ecc, ram_freq);
int CYCLE_STEAL;
if (inst_type == COMPBCAM) {
CYCLE_STEAL = num_slots - 1;
} else {
CYCLE_STEAL = 0;
}
bool SINGLE_CLOCK_MODE = ram_freq == lookup_interface_freq ? true : false;
int CLOCK_RATIO = ram_freq / lookup_interface_freq;
int FLOW_CONTROL;
FLOW_CONTROL = SINGLE_CLOCK_MODE && flow_control ? 4 : 0;
if (SINGLE_CLOCK_MODE) {
return FLOW_CONTROL + 1 + CORE_LATENCY + CYCLE_STEAL + 1;
} else {
return 2 + (1 + CORE_LATENCY + CYCLE_STEAL + 1 + CLOCK_RATIO - 1) / CLOCK_RATIO + 1 + 2 + 1;
}
}
#include <inttypes.h>
#ifndef HASH_H
#define HASH_H
typedef struct hash_t hash_t;
size_t hash_size(void);
void aaaaaaa1aaa(hash_t *hash, const aaaaaaaaaaaaa1aaat *key, const aaa1aaat *phm);
uint32_t hash_calculate_bucket(hash_t *hash);
uint32_t hash_calculate_list(hash_t *hash, uint8_t function);
void camlib_hashmsr_init(hash_t *hash, aaaaaaaaaaaaa1aaat *key, uint16_t seed, uint16_t key_width, uint32_t num_lists, uint8_t num_slots);
#endif
typedef enum {
UNUSED = 0, OPEN = 1, CLOSED = 2, RECOVER = 3
} unit_mode_t;
typedef struct {
unit_mode_t unit_mode;
aaa1aaat *phm;
} unit_t;
typedef struct {
aaa1aaat *phm;
uint32_t list;
uint32_t murmur_bucket;
aaaaaaaaaaaaa1aaat key;
aaaaaaaaaaaaaaaa1aaaaaaaaaaaaaaaabaaaaaaaaaaaaaaaaaaaaaaaaaaaa3aaat aaaaaaaaaaaaaa1aaaaaaaaaaaaaaaabaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaa3aaa;
uint8_t narrow;
uint8_t narrow_element;
} overwrite_entry_t;
#define MAX_OVERWRITES 512
struct a1aaat {
cam_config_t *conf;
unit_t unit[aaaaaa1aaaaaaaaaaaaaaaabaaaaaaaaaaaaaaaaaaaaaaaaaa3aaaaaaaaaaaaaaaabaaaaaaaaaaaaaaaaaaaaaaaaaaaa3bbbbbbbbbbbbbbbbbbbbbbbbbbbbbbbbbbb3aaaaaaaaaaaaaaaabaaaaaaaaaaaaaaaaaaaaaaaaaaaa4aaaaaaaaaaaabaaaaaaaaaaaaaaaaa5aaaS];
aaaa1aaat *test_km; 
uint32_t prev_hi_addr;
uint32_t prev_hi_data;
htable_t *htable; 
aaaaaaaaaaaaaaaa1aaaaaaaaaaaaaaaabaaaaaaaaaaaaaaaaaaaaaaaaaaaa3aaat default_response;
bool default_response_valid;
aaaaaaaaaaaaaaaa1aaaaaaaaaaaaaaaabaaaaaaaaaaaaaaaaaaaaaaaaaaaa3aaat narrow_default_response; 
bool narrow_default_response_valid; 
overwrite_entry_t overwrites[MAX_OVERWRITES]; 
uint16_t num_overwrites; 
bool zero_unused; 
uint32_t num_entries; 
uint32_t narrow_num_entries; 
uint64_t num_inserts; 
uint64_t num_updates; 
uint64_t num_deletes; 
uint32_t failed_inserts; 
uint32_t failed_updates; 
uint32_t failed_deletes; 
uint64_t num_collisions; 
uint16_t max_collisions; 
};
static void verify_config(a1aaat *client);
static int init(a1aaat *client)
{
assert(client != NULL);
client->num_entries = 0;
client->narrow_num_entries = 0;
client->num_overwrites = 0;
client->zero_unused = false;
const uint16_t num_units = cam_config_get_num_units(client->conf);
const uint16_t num_slots = cam_config_get_num_slots(client->conf);
cam_free_func free_function = a1aaaaaaaaaaaaaaaabaaaaaaaaaaaa3aaaaaaaaaaaaaaaabaaaaaaaaaaaaaaaaaaaaaaaaaaaa3aaaaaaaaaaaaaabaaaaaaaaaaaa4aaaaaaaaaaaaaaaabaaaaaaaaaaaaaaaaaaaaaaaaaaaa4aaaaaaaaaaaaaaaabaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaa4aaa(client);
client->test_km = NULL;
if ((client->conf->instance_type == TCAM)) {
client->test_km = (aaaa1aaat *) client->conf->arg.malloc_function(aaaa1aaaaaaaaaaaaaabaaaaaaaaaa3aaa());
if (client->test_km == NULL) {
return CAM_ERROR_MALLOC_FAILED;
}
if (!aaaa1aaaaaaaaaaaaaabaaaaaaaaaaa3aaa(client->test_km, client, 0, 0, false)) {
aaaa1aaaaaaaaaaaaaabaaaaaaaaaaaa3aaa(client->test_km, free_function);
return CAM_ERROR_MALLOC_FAILED;
}
}
for (uint16_t i = 0; i < num_units; i++) {
client->unit[i].phm = client->conf->arg.malloc_function(aaa1aaaaaaaaaaaaaabaaaaaaaaaa3aaa());
if (client->unit[i].phm == NULL) {
for (uint16_t j = 0; j < i; j++) {
aaa1aaaaaaaaaaaaaabaaaaaaaaaaaa3aaa(client->unit[j].phm, free_function);
}
aaaa1aaaaaaaaaaaaaabaaaaaaaaaaaa3aaa(client->test_km, free_function);
return CAM_ERROR_MALLOC_FAILED;
}
}
assert(num_units <= aaaaaa1aaaaaaaaaaaaaaaabaaaaaaaaaaaaaaaaaaaaaaaaaa3aaaaaaaaaaaaaaaabaaaaaaaaaaaaaaaaaaaaaaaaaaaa3bbbbbbbbbbbbbbbbbbbbbbbbbbbbbbbbbbb3aaaaaaaaaaaaaaaabaaaaaaaaaaaaaaaaaaaaaaaaaaaa4aaaaaaaaaaaabaaaaaaaaaaaaaaaaa5aaaS);
for (uint16_t i = 0; i < num_units; i++) {
const uint16_t physical_unit = i / num_slots;
const uint8_t slot_number = i - physical_unit * num_slots;
if (false
== aaa1aaaaaaaaaaaaaabaaaaaaaaaaa3aaa(client->unit[i].phm, client, physical_unit, slot_number)) {
for (uint16_t j = 0; j < i; j++) {
aaa1aaaaaaaaaaaaaabaaaaaaaaaaaa3aaa(client->unit[j].phm, free_function);
}
aaaa1aaaaaaaaaaaaaabaaaaaaaaaaaa3aaa(client->test_km, free_function);
return CAM_ERROR_MALLOC_FAILED;
}
client->unit[i].unit_mode = UNUSED;
}
if ((client->conf->instance_type == TCAM)) {
client->unit[0].unit_mode = RECOVER;
}
client->num_inserts = 0;
client->num_updates = 0;
client->num_deletes = 0;
client->failed_inserts = 0;
client->failed_updates = 0;
client->failed_deletes = 0;
client->num_collisions = 0;
client->max_collisions = 0;
return 0;
}
void a1aaahaa1aaaaaaaaaaaaaaaabaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaa3aaaaaaaaaaaaaaaabaaaaaaaaaaaaaaaaaaaaaaaaaaaa4aaaread(const a1aaat *client, uint32_t address, uint32_t *data32)
{
client->conf->arg.hw_read_function(client->conf->ctx, address, data32);
}
#define aaaaaa1aaaHaa1aaaPARAM_KW_REG 0x184
#define aaaaaa1aaaHaa1aaaPARAM_RW_REG 0x188
#define aaaaaa1aaaHaa1aaaPARAM_NUM_PCS_REG 0x190
static void verify_haa1aaaconfig(const a1aaat *client)
{
uint32_t data = 0;
bool err;
char sub_str[500];
char message[500];
a1aaahaa1aaaaaaaaaaaaaaaabaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaa3aaaaaaaaaaaaaaaabaaaaaaaaaaaaaaaaaaaaaaaaaaaa4aaaread(client, aaaaaa1aaaHaa1aaaPARAM_KW_REG, &data);
err = client->conf->key_width != data;
if (err || (a1aaaaaaaaaaaaaaaabaaaaaaaaaaaa3aaaaaaaaaaaaaaaabaaaaaaaaaaaaaaaaaaaaaaaaaaaa3bbbbbbbbbbbbbbbbbbbbbbbbbbbbbbbbbbbbb3aaaaaaaaaaaaaaaabaaaaaaaaaaaaaaaaaaaaaaaaaaaa4aaaflags(client) & CAM_DEBUG_VERBOSE_VERIFY)) {
       sprintf(sub_str, "CAM_DEBUG_CONFIG  key width = %0d (expected %0d)", data, client->conf->key_width);
       sprintf(message, "%-70s%s", sub_str, err ? "FAIL" : "OK");
if (err) {
a1aaaaaaaaaaaaaaaabaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaa3aaaaaaaaaaaaaaaabaaaaaaaaaaaaaaaaaaaaaaaaaaaa4aaaerror(client, message);
} else {
a1aaaaaaaaaaaaaaaabaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaa3aaaaaaaaaaaaaaaabaaaaaaaaaaaaaaaaaaaaaaaaaaaa4aaainfo(client, message);
}
}
a1aaahaa1aaaaaaaaaaaaaaaabaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaa3aaaaaaaaaaaaaaaabaaaaaaaaaaaaaaaaaaaaaaaaaaaa4aaaread(client, aaaaaa1aaaHaa1aaaPARAM_RW_REG, &data);
err = client->conf->arg.response_width != data;
if (err || (a1aaaaaaaaaaaaaaaabaaaaaaaaaaaa3aaaaaaaaaaaaaaaabaaaaaaaaaaaaaaaaaaaaaaaaaaaa3bbbbbbbbbbbbbbbbbbbbbbbbbbbbbbbbbbbbb3aaaaaaaaaaaaaaaabaaaaaaaaaaaaaaaaaaaaaaaaaaaa4aaaflags(client) & CAM_DEBUG_VERBOSE_VERIFY)) {
       sprintf(sub_str, "CAM_DEBUG_CONFIG  response width = %0d (expected %0d)", data,
client->conf->arg.response_width);
       sprintf(message, "%-70s%s", sub_str, err ? "FAIL" : "OK");
if (err) {
a1aaaaaaaaaaaaaaaabaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaa3aaaaaaaaaaaaaaaabaaaaaaaaaaaaaaaaaaaaaaaaaaaa4aaaerror(client, message);
} else {
a1aaaaaaaaaaaaaaaabaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaa3aaaaaaaaaaaaaaaabaaaaaaaaaaaaaaaaaaaaaaaaaaaa4aaainfo(client, message);
}
}
a1aaahaa1aaaaaaaaaaaaaaaabaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaa3aaaaaaaaaaaaaaaabaaaaaaaaaaaaaaaaaaaaaaaaaaaa4aaaread(client, aaaaaa1aaaHaa1aaaPARAM_NUM_PCS_REG, &data);
const uint8_t num_pcs = a1aaaaaaaaaaaaaaaabaaaaaaaaaaaa3aaaaaaaaaaaaaaaabaaaaaaaaaaaaaaaaaaaaaaaaaaaa3aaaaaaaaaaaaaaabaaaaaaaaaaaaaaaa4aaaaaaaaaaaaaaaabaaaaaaaaaaaaaaaaaaaaaaaaaaaa4aaapcs(client);
err = num_pcs != data;
if (err || (a1aaaaaaaaaaaaaaaabaaaaaaaaaaaa3aaaaaaaaaaaaaaaabaaaaaaaaaaaaaaaaaaaaaaaaaaaa3bbbbbbbbbbbbbbbbbbbbbbbbbbbbbbbbbbbbb3aaaaaaaaaaaaaaaabaaaaaaaaaaaaaaaaaaaaaaaaaaaa4aaaflags(client) & CAM_DEBUG_VERBOSE_VERIFY)) {
       sprintf(sub_str, "CAM_DEBUG_CONFIG  number of PCs = %0d (expected %0d)", data, num_pcs);
       sprintf(message, "%-70s%s", sub_str, err ? "FAIL" : "OK");
if (err) {
a1aaaaaaaaaaaaaaaabaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaa3aaaaaaaaaaaaaaaabaaaaaaaaaaaaaaaaaaaaaaaaaaaa4aaaerror(client, message);
} else {
a1aaaaaaaaaaaaaaaabaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaa3aaaaaaaaaaaaaaaabaaaaaaaaaaaaaaaaaaaaaaaaaaaa4aaainfo(client, message);
}
}
}
int a1bbbbbbbbbbbbbbbbbbbbbbbbbbbbbbbbbbbbbbb3aaaeate(const cam_arg_t *cam_conf_arg, cam_instance_type_t cam_instance_type, a1aaat **client)
{
srand(123);
a1aaat *new_client = cam_conf_arg->malloc_function(sizeof(a1aaat));
if (new_client == NULL) {
return CAM_ERROR_MALLOC_FAILED;
}
cam_config_t *cam_conf;
int rc = cam_config_create(cam_conf_arg, cam_instance_type, &cam_conf);
if (rc) {
cam_conf_arg->free_function(new_client);
return rc;
}
new_client->conf = cam_conf;
if ((new_client->conf->instance_type != HBMBCAM)) {
new_client->prev_hi_addr = 0;
new_client->prev_hi_data = 0;
new_client->conf->arg.hw_write_function(new_client->conf->ctx, aaaaaa1aaaHA_BASE, 0);
new_client->conf->arg.hw_write_function(new_client->conf->ctx, aaaaaa1aaaHD_BASE, 0);
} else { 
}
if (cam_conf->arg.debug_flags & CAM_DEBUG_VERIFY_CONFIG) {
if (cam_instance_type == HBMBCAM) {
verify_haa1aaaconfig(new_client);
} else {
verify_config(new_client);
}
}
if (!a1aaaaaaaaaaaaaaabaaaaaaaaaaaa3aaaaaaaaaaaaaaaabaaaaaaaaaaaaaaaaaaaaaaaaaaaa3aaaaaaaaaaaaaaaabaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaa3aaa(new_client)) {
new_client->htable = cam_conf_arg->malloc_function(htable_size());
if (new_client->htable == NULL) {
cam_conf_arg->free_function(new_client->conf);
cam_conf_arg->free_function(new_client);
return CAM_ERROR_MALLOC_FAILED;
}
const uint32_t num_entries = cam_config_get_num_entries(cam_conf);
if (!htable_init(new_client->htable, num_entries, cam_conf_arg->calloc_function)) {
htable_free(new_client->htable, cam_conf_arg->free_function);
cam_conf_arg->free_function(new_client->conf);
cam_conf_arg->free_function(new_client);
return CAM_ERROR_MALLOC_FAILED;
}
} else {
new_client->htable = NULL;
}
rc = init(new_client);
if (rc) {
htable_free(new_client->htable, cam_conf_arg->free_function);
cam_conf_arg->free_function(new_client->conf);
cam_conf_arg->free_function(new_client);
return rc;
}
uint32_t cnt1, cnt2;
if ((cam_conf_arg->segment_ctx.segment == -1) && (cam_instance_type != HBMBCAM))
a1aaaread_and_clear_ecc_counters(new_client, &cnt1, &cnt2);
*client = new_client;
return 0;
}
bool a1aaaaaaaaaaaaaaabaaaaaaaaaaaa3aaaaaaaaaaaaaaaabaaaaaaaaaaaaaaaaaaaaaaaaaaaa3aaawide_instance(const a1aaat *client)
{
if (cam_config_get_key_width(client->conf) > 160) {
return true;
}
return false;
}
void a1aaaaaaaaaaaaaaaabaaaaaaaaaaaa3aaaaaaaaaaaaaaaabaaaaaaaaaaaaaaaaaaaaaaaaaaaa3aaadefault_response(const a1aaat *client, uint8_t *default_response, bool narrow)
{
if (narrow) {
assert(a1aaaaaaaaaaaaaaabaaaaaaaaaaaa3aaaaaaaaaaaaaaaabaaaaaaaaaaaaaaaaaaaaaaaaaaaa3aaamixed_mode(client));
cam_config_get_narrow_default_response(client->conf, default_response);
} else
cam_config_get_default_response(client->conf, default_response);
}
bool a1aaaaaaaaaaaaaaabaaaaaaaaaaaa3aaaaaaaaaaaaaaaabaaaaaaaaaaaaaaaaaaaaaaaaaaaa3aaamixed_mode(const a1aaat *client)
{
assert(client != NULL);
return cam_config_is_mixed_mode(client->conf);
}
bool a1aaaaaaaaaaaaaaabaaaaaaaaaaaa3aaaaaaaaaaaaaaaabaaaaaaaaaaaaaaaaaaaaaaaaaaaa3aaaaaaaaaaaaaaaabaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaa3aaa(const a1aaat *client)
{
assert(client != NULL);
return cam_config_is_tcam_instance(client->conf);
}
bool a1aaaaaaaaaaaaaaabaaaaaaaaaaaa3aaaaaaaaaaaaaaaabaaaaaaaaaaaaaaaaaaaaaaaaaaaa3aaabcam(const a1aaat *client)
{
assert(client != NULL);
return cam_config_is_bcam_instance(client->conf);
}
bool a1aaaaaaaaaaaaaaabaaaaaaaaaaaa3aaaaaaaaaaaaaaaabaaaaaaaaaaaaaaaaaaaaaaaaaaaa3aaahbmbcam(const a1aaat *client)
{
assert(client != NULL);
return cam_config_is_hbmbcam_instance(client->conf);
}
uint8_t a1aaaaaaaaaaaaaaaabaaaaaaaaaaaa3aaaaaaaaaaaaaaaabaaaaaaaaaaaaaaaaaaaaaaaaaaaa3aaaaaaaaaaaaaaabaaaaaaaaaaaaaaaa4aaaaaaaaaaaaaaaabaaaaaaaaaaaaaaaaaaaaaaaaaaaa4aaapcs(const a1aaat *client)
{
assert(client != NULL);
assert((client->conf->instance_type == HBMBCAM));
return cam_config_get_num_pcs(client->conf);
}
uint8_t a1aaaaaaaaaaaaaaaabaaaaaaaaaaaa3aaaaaaaaaaaaaaaabaaaaaaaaaaaaaaaaaaaaaaaaaaaa3aaareplication(const a1aaat *client)
{
assert(client != NULL);
assert((client->conf->instance_type == HBMBCAM));
return cam_config_get_replication(client->conf);
}
uint16_t a1aaaaaaaaaaaaaaaabaaaaaaaaaaaa3aaaaaaaaaaaaaaaabaaaaaaaaaaaaaaaaaaaaaaaaaaaa3aaaaaaaaaaaaaaabaaaaaaaaaaaaaaaa4aaaaaaaaaaaaaaaabaaaaaaaaaaaaaaaaaaaaaaaaaaaa4aaaaaaaaaaaaaaaabaaaaaaaaaaaaaaaaaaaaa5aaaaaaaaaaaaaaaabaaaaaaaaaaaaaaaaaaaaaaaaaaaa5aaaper_unit(const a1aaat *client)
{
assert(client != NULL);
return cam_config_get_num_entries_per_unit(client->conf);
}
uint32_t a1aaaaaaaaaaaaaaaabaaaaaaaaaaaa3aaaaaaaaaaaaaaaabaaaaaaaaaaaaaaaaaaaaaaaaaaaa3aaaaaaaaaaaaaaabaaaaaaaaaaaaaaaa4aaaaaaaaaaaaaaaabaaaaaaaaaaaaaaaaaaaaaaaaaaaa4aaaaaaaaaaaaaaaabaaaaaaaaaaaaaaaaaaaaa5aaa(const a1aaat *client)
{
assert(client != NULL);
return cam_config_get_num_entries(client->conf);
}
uint8_t a1aaaaaaaaaaaaaaaabaaaaaaaaaaaa3aaaaaaaaaaaaaaaabaaaaaaaaaaaaaaaaaaaaaaaaaaaa3aaaaaaaaaaaaaaabaaaaaaaaaaaaaaaa4aaaaaaaaaaaaaaaabaaaaaaaaaaaaaaaaaaaaaaaaaaaa4aaaaaaaaaaaaaaaabaaaaaaaaaaaaaaaaaaaaaaa5aaas(const a1aaat *client)
{
assert(client != NULL);
return cam_config_get_num_masks(client->conf);
}
uint8_t a1aaaaaaaaaaaaaaaabaaaaaaaaaaaa3aaaaaaaaaaaaaaaabaaaaaaaaaaaaaaaaaaaaaaaaaaaa3aaaaaaaaaaaaaaabaaaaaaaaaaaaaaaa4aaaaaaaaaaaaaaaabaaaaaaaaaaaaaaaaaaaaaaaaaaaa4aaaaaaaaaaaaaaabaaaaaaaaaaaaaaaaaa5aaas(const a1aaat *client)
{
assert(client != NULL);
return cam_config_get_num_fields(client->conf);
}
uint8_t a1aaaaaaaaaaaaaaaabaaaaaaaaaaaa3aaaaaaaaaaaaaaaabaaaaaaaaaaaaaaaaaaaaaaaaaaaa3aaaaaaaaaaaaaaabaaaaaaaaaaaaaaaa4aaaaaaaaaaaaaaaabaaaaaaaaaaaaaaaaaaaaaaaaaaaa4bbbbbbbbbbbbbbbbbbbbbbbbbbbbbbbbbbbb4aaas(const a1aaat *client)
{
assert(client != NULL);
return cam_config_get_num_slots(client->conf);
}
uint16_t a1aaaaaaaaaaaaaaaabaaaaaaaaaaaa3aaaaaaaaaaaaaaaabaaaaaaaaaaaaaaaaaaaaaaaaaaaa3aaaaaaaaaaaaabaaaaaaaaaaaaaaaaa4aaaaaaaaaaaaaaaabaaaaaaaaaaaaaaaaaaaaaaaaaaaa4aaalength(const a1aaat *client)
{
assert(client != NULL);
return cam_config_get_list_length(client->conf);
}
uint16_t a1aaaaaaaaaaaaaaaabaaaaaaaaaaaa3aaaaaaaaaaaaaaaabaaaaaaaaaaaaaaaaaaaaaaaaaaaa3aaaaaaaaaaaaaaabaaaaaaaaaaaaaaaa4aaaaaaaaaaaaaaaabaaaaaaaaaaaaaaaaaaaaaaaaaaaa4aaaaaaaaaaaabaaaaaaaaaaaaaaaaa5aaas(const a1aaat *client)
{
assert(client != NULL);
return cam_config_get_num_units(client->conf);
}
bool a1aaahas_options(const a1aaat *client)
{
return client->conf->arg.options;
}
int a1aaaaaaaaaaaaaaaabaaaaaaaaaaaa3aaaaaaaaaaaaaaaabaaaaaaaaaaaaaaaaaaaaaaaaaaaa3aaaaaaaaaaaaaaaaaaaaa1aaa(const a1aaat *client, uint8_t field_number, aaaaaaaaaaa1aaaaaaaaaaaaaaaabaaaaaaaaaaaaaaaaaaaaaaaaaaaa3aaadesc *desc)
{
assert(client != NULL);
return cam_config_get_aaaaaaaaaaaaaaaaaa1aaa(client->conf, field_number, desc);
}
aaa1aaat *a1aaaaaaaaaaaaaaaabaaaaaaaaaaaa3aaaaaaaaaaaaaaaabaaaaaaaaaaaaaaaaaaaaaaaaaaaa3aaarecover_phm(const a1aaat *client)
{
if ((client->conf->instance_type == TCAM))
return client->unit[0].phm;
else
return NULL;
}
aaaa1aaat *a1aaaaaaaaaaaaaaaabaaaaaaaaaaaa3aaaaaaaaaaaaaaaabaaaaaaaaaaaaaaaaaaaaaaaaaaaa3aaatest_km(const a1aaat *client)
{
return client->test_km;
}
htable_t *a1aaaaaaaaaaaaaaaabaaaaaaaaaaaa3aaaaaaaaaaaaaaaabaaaaaaaaaaaaaaaaaaaaaaaaaaaa3aaahtable(const a1aaat *client)
{
return client->htable;
}
static inline aaa1aaat *get_phm(const a1aaat *client, uint16_t unit)
{
assert(client != NULL);
assert(unit < a1aaaaaaaaaaaaaaaabaaaaaaaaaaaa3aaaaaaaaaaaaaaaabaaaaaaaaaaaaaaaaaaaaaaaaaaaa3aaaaaaaaaaaaaaabaaaaaaaaaaaaaaaa4aaaaaaaaaaaaaaaabaaaaaaaaaaaaaaaaaaaaaaaaaaaa4aaaaaaaaaaaabaaaaaaaaaaaaaaaaa5aaas(client));
return client->unit[unit].phm;
}
static uint16_t get_number_of_unused_units(const a1aaat *client)
{
assert(client != NULL);
const uint16_t number_of_units = a1aaaaaaaaaaaaaaaabaaaaaaaaaaaa3aaaaaaaaaaaaaaaabaaaaaaaaaaaaaaaaaaaaaaaaaaaa3aaaaaaaaaaaaaaabaaaaaaaaaaaaaaaa4aaaaaaaaaaaaaaaabaaaaaaaaaaaaaaaaaaaaaaaaaaaa4aaaaaaaaaaaabaaaaaaaaaaaaaaaaa5aaas(client);
uint16_t count = 0;
for (uint16_t i = 0; i < number_of_units; i++) {
if (client->unit[i].unit_mode == UNUSED) {
count++;
}
}
return count;
}
void a1aaaaaaaaaaaaaaaabaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaa3aaa(const a1aaat *client)
{
int entries = 0;
const uint8_t num_slots = a1aaaaaaaaaaaaaaaabaaaaaaaaaaaa3aaaaaaaaaaaaaaaabaaaaaaaaaaaaaaaaaaaaaaaaaaaa3aaaaaaaaaaaaaaabaaaaaaaaaaaaaaaa4aaaaaaaaaaaaaaaabaaaaaaaaaaaaaaaaaaaaaaaaaaaa4bbbbbbbbbbbbbbbbbbbbbbbbbbbbbbbbbbbb4aaas(client);
const uint32_t max_lists = a1aaaaaaaaaaaaaaaabaaaaaaaaaaaa3aaaaaaaaaaaaaaaabaaaaaaaaaaaaaaaaaaaaaaaaaaaa3aaaaaaaaaaaaaaabaaaaaaaaaaaaaaaa4aaaaaaaaaaaaaaaabaaaaaaaaaaaaaaaaaaaaaaaaaaaa4aaaaaaaaaaaaabaaaaaaaaaaaaaaaaa5aaas(client);
   printf("\nLUnit\tMode\tMask\t\t\t\t\t\t\t\t\t\t\tSize\tKeys\tRValid\tMaskId\tSeed\tPUnit\tSlot");
const uint16_t num_units = a1aaaaaaaaaaaaaaaabaaaaaaaaaaaa3aaaaaaaaaaaaaaaabaaaaaaaaaaaaaaaaaaaaaaaaaaaa3aaaaaaaaaaaaaaabaaaaaaaaaaaaaaaa4aaaaaaaaaaaaaaaabaaaaaaaaaaaaaaaaaaaaaaaaaaaa4aaaaaaaaaaaabaaaaaaaaaaaaaaaaa5aaas(client);
for (uint16_t unit = 0; unit < num_units; unit++) {
const aaa1aaat *phm = client->unit[unit].phm;
const uint8_t slot_number = aaa1aaaaaaaaaaaaaaaabaaaaaaaaaaaa3aaaaaaaaaaaaaaaabaaaaaaaaaaaaaaaaaaaaaaaaaaaa3bbbbbbbbbbbbbbbbbbbbbbbbbbbbbbbbbbbb3aaaaaaaaaaaaaaaabaaaaaaaaaaaaaaaaaaaaaaaaaaaa4aaaaaaaaaaaaaaabaaaaaaaaaaaaaaaa5aaaber(phm);
const uint16_t physical_unit = aaa1aaaaaaaaaaaaaaaabaaaaaaaaaaaa3aaaaaaaaaaaaaaaabaaaaaaaaaaaaaaaaaaaaaaaaaaaa3aaaaaaaaaaaabaaaaaaaaaaaaaaaaa4aaa(phm);
       printf("\n%d\t", unit);
if (client->unit[unit].unit_mode == UNUSED) {
           printf("UNUSED\t\t");
           printf("\t\t\t\t\t\t\t\t\t\t\t\t\t\t\t%d\t%d", physical_unit, slot_number);
} else if (client->unit[unit].unit_mode == RECOVER) {
           printf("REHASH\t\t");
           printf("\t\t\t\t\t\t\t\t\t\t\t\t\t\t\t%d\t%d", physical_unit, slot_number);
} else if (client->unit[unit].unit_mode == CLOSED) {
           printf("CLOSED\t");
} else if (client->unit[unit].unit_mode == OPEN) {
           printf("OPEN\t");
}
if (aaa1aaaaaaaaaaaaaaabaaaaaaaaaaaa3aaaaaaaaaaaaaaaabaaaaaaaaaaaaaaaaaaaaaaaaaaaa3aaaaaaaaaaaaaaaabaaaaaaaaaaaaaaaaaaaaaaa4aaaaaaaaaaaaaaaabaaaaaaaaaaaaaaaaaaaaaaaaaaaa4aaaaaaaaaaaabaaaaaaaaaaa5aaaaaaaaaaaaaaaabaaaaaaaaaaaaaaaaaaaaaaaaaaaa5aaavalid(phm)) {
aaaaaaaaaaaaa1aaat mask;
memset(&mask, 0, sizeof(aaaaaaaaaaaaa1aaat));
uint8_t range_valid, mask_id;
aaa1aaaread_mask(phm, &mask, &range_valid, &mask_id);
const uint16_t seed = aaa1aaaaaaaaaaaaaaaabaaaaaaaaaaaa3aaaaaaaaaaaaaaaabaaaaaaaaaaaaaaaaaaaaaaaaaaaa3aaaseed(phm);
for (int8_t j = 9; j >= 0; j--) {
               printf("%08x", mask.word[j]);
}
           printf("\t%d\t%d", max_lists, aaa1aaaaaaaaaaaaaaaabaaaaaaaaaaaa3aaaaaaaaaaaaaaaabaaaaaaaaaaaaaaaaaaaaaaaaaaaa3aaaaaaaaaaaaaaabaaaaaaaaaaaaaaaa4aaaber_of_keys(phm));
entries += aaa1aaaaaaaaaaaaaaaabaaaaaaaaaaaa3aaaaaaaaaaaaaaaabaaaaaaaaaaaaaaaaaaaaaaaaaaaa3aaaaaaaaaaaaaaabaaaaaaaaaaaaaaaa4aaaber_of_keys(phm);
           printf("\t%d\t%d\t%d\t%d\t%d", range_valid, mask_id, seed, physical_unit, slot_number);
}
}
   printf("\nNumber of physical units = %d, Number of slots = %d\n",
(num_units - 1) / num_slots + 1, num_slots);
   printf("\nNumber of logical units = %d", num_units);
   printf("\nNumber of entries = %d, number of unused units = %d\n", entries, get_number_of_unused_units(client));
}
static bool is_closed(const a1aaat *client, uint16_t unit)
{
assert(client != NULL);
assert(unit < a1aaaaaaaaaaaaaaaabaaaaaaaaaaaa3aaaaaaaaaaaaaaaabaaaaaaaaaaaaaaaaaaaaaaaaaaaa3aaaaaaaaaaaaaaabaaaaaaaaaaaaaaaa4aaaaaaaaaaaaaaaabaaaaaaaaaaaaaaaaaaaaaaaaaaaa4aaaaaaaaaaaabaaaaaaaaaaaaaaaaa5aaas(client));
if (client->unit[unit].unit_mode == CLOSED) {
return true;
}
return false;
}
static bool is_open(const a1aaat *client, uint16_t unit)
{
assert(client != NULL);
assert(unit < a1aaaaaaaaaaaaaaaabaaaaaaaaaaaa3aaaaaaaaaaaaaaaabaaaaaaaaaaaaaaaaaaaaaaaaaaaa3aaaaaaaaaaaaaaabaaaaaaaaaaaaaaaa4aaaaaaaaaaaaaaaabaaaaaaaaaaaaaaaaaaaaaaaaaaaa4aaaaaaaaaaaabaaaaaaaaaaaaaaaaa5aaas(client));
if (client->unit[unit].unit_mode == OPEN) {
return true;
}
return false;
}
static bool find_closed(const a1aaat *client, uint16_t *start_value)
{
assert(client != NULL);
const uint16_t number_of_units = a1aaaaaaaaaaaaaaaabaaaaaaaaaaaa3aaaaaaaaaaaaaaaabaaaaaaaaaaaaaaaaaaaaaaaaaaaa3aaaaaaaaaaaaaaabaaaaaaaaaaaaaaaa4aaaaaaaaaaaaaaaabaaaaaaaaaaaaaaaaaaaaaaaaaaaa4aaaaaaaaaaaabaaaaaaaaaaaaaaaaa5aaas(client);
for (uint16_t i = *start_value; i < number_of_units; i++) {
if (client->unit[i].unit_mode == CLOSED) {
*start_value = i;
return true;
}
}
return false;
}
static bool find_closed_with_equal_mask(const a1aaat *client, uint16_t *start_value,
const aaaaaaaaaaaaa1aaat *mask,
uint8_t range_valid, uint8_t mask_id)
{
uint16_t closed_unit = *start_value;
while (find_closed(client, &closed_unit)) {
const aaa1aaat *phm = client->unit[closed_unit].phm;
assert(aaa1aaaaaaaaaaaaaaabaaaaaaaaaaaa3aaaaaaaaaaaaaaaabaaaaaaaaaaaaaaaaaaaaaaaaaaaa3aaaaaaaaaaaaaaaabaaaaaaaaaaaaaaaaaaaaaaa4aaaaaaaaaaaaaaaabaaaaaaaaaaaaaaaaaaaaaaaaaaaa4aaaaaaaaaaaabaaaaaaaaaaa5aaaaaaaaaaaaaaaabaaaaaaaaaaaaaaaaaaaaaaaaaaaa5aaavalid(phm));
if (aaa1aaaaaaaaaaaaaaabaaaaaaaaaaaa3aaaaaaaaaaaaaaaabaaaaaaaaaaaaaaaaaaaaaaaaaaaa3aaaaaaaaaaaaaaaabaaaaaaaaaaaaaaaaaaaaaaa4aaaaaaaaaaaaaaaabaaaaaaaaaaaaaaaaaaaaaaaaaaaa4aaaequal(phm, mask, range_valid, mask_id)) {
*start_value = closed_unit;
return true;
}
closed_unit++;
}
return false;
}
static void set_open(a1aaat *client, uint16_t unit)
{
assert(client != NULL);
assert(unit < a1aaaaaaaaaaaaaaaabaaaaaaaaaaaa3aaaaaaaaaaaaaaaabaaaaaaaaaaaaaaaaaaaaaaaaaaaa3aaaaaaaaaaaaaaabaaaaaaaaaaaaaaaa4aaaaaaaaaaaaaaaabaaaaaaaaaaaaaaaaaaaaaaaaaaaa4aaaaaaaaaaaabaaaaaaaaaaaaaaaaa5aaas(client));
client->unit[unit].unit_mode = OPEN;
}
static bool find_unused(const a1aaat *client, uint16_t *start_value)
{
assert(client != NULL);
const uint16_t number_of_units = a1aaaaaaaaaaaaaaaabaaaaaaaaaaaa3aaaaaaaaaaaaaaaabaaaaaaaaaaaaaaaaaaaaaaaaaaaa3aaaaaaaaaaaaaaabaaaaaaaaaaaaaaaa4aaaaaaaaaaaaaaaabaaaaaaaaaaaaaaaaaaaaaaaaaaaa4aaaaaaaaaaaabaaaaaaaaaaaaaaaaa5aaas(client);
for (uint16_t i = *start_value; i < number_of_units; i++) {
if (client->unit[i].unit_mode == UNUSED) {
*start_value = i;
return true;
}
}
return false;
}
static void set_unused(a1aaat *client, uint16_t unit)
{
assert(client != NULL);
assert(unit < a1aaaaaaaaaaaaaaaabaaaaaaaaaaaa3aaaaaaaaaaaaaaaabaaaaaaaaaaaaaaaaaaaaaaaaaaaa3aaaaaaaaaaaaaaabaaaaaaaaaaaaaaaa4aaaaaaaaaaaaaaaabaaaaaaaaaaaaaaaaaaaaaaaaaaaa4aaaaaaaaaaaabaaaaaaaaaaaaaaaaa5aaas(client));
client->unit[unit].unit_mode = UNUSED;
client->zero_unused = false;
}
static void set_closed(a1aaat *client, uint16_t unit)
{
assert(client != NULL);
assert(unit < a1aaaaaaaaaaaaaaaabaaaaaaaaaaaa3aaaaaaaaaaaaaaaabaaaaaaaaaaaaaaaaaaaaaaaaaaaa3aaaaaaaaaaaaaaabaaaaaaaaaaaaaaaa4aaaaaaaaaaaaaaaabaaaaaaaaaaaaaaaaaaaaaaaaaaaa4aaaaaaaaaaaabaaaaaaaaaaaaaaaaa5aaas(client));
client->unit[unit].unit_mode = CLOSED;
}
static bool find_open(const a1aaat *client, uint16_t *start_value)
{
assert(client != NULL);
const uint16_t number_of_units = a1aaaaaaaaaaaaaaaabaaaaaaaaaaaa3aaaaaaaaaaaaaaaabaaaaaaaaaaaaaaaaaaaaaaaaaaaa3aaaaaaaaaaaaaaabaaaaaaaaaaaaaaaa4aaaaaaaaaaaaaaaabaaaaaaaaaaaaaaaaaaaaaaaaaaaa4aaaaaaaaaaaabaaaaaaaaaaaaaaaaa5aaas(client);
for (uint16_t i = *start_value; i < number_of_units; i++) {
if ((client->unit[i].unit_mode == OPEN)) {
*start_value = i;
return true;
}
}
return false;
}
static bool find_open_dec(const a1aaat *client, uint16_t *start_value)
{
assert(client != NULL);
assert(*start_value < a1aaaaaaaaaaaaaaaabaaaaaaaaaaaa3aaaaaaaaaaaaaaaabaaaaaaaaaaaaaaaaaaaaaaaaaaaa3aaaaaaaaaaaaaaabaaaaaaaaaaaaaaaa4aaaaaaaaaaaaaaaabaaaaaaaaaaaaaaaaaaaaaaaaaaaa4aaaaaaaaaaaabaaaaaaaaaaaaaaaaa5aaas(client));
for (int32_t i = *start_value; i >= 0; i--) {
if ((client->unit[i].unit_mode == OPEN)) {
*start_value = i;
return true;
}
}
return false;
}
static bool find_open_or_closed(const a1aaat *client, uint16_t *start_value)
{
assert(client != NULL);
const uint16_t number_of_units = a1aaaaaaaaaaaaaaaabaaaaaaaaaaaa3aaaaaaaaaaaaaaaabaaaaaaaaaaaaaaaaaaaaaaaaaaaa3aaaaaaaaaaaaaaabaaaaaaaaaaaaaaaa4aaaaaaaaaaaaaaaabaaaaaaaaaaaaaaaaaaaaaaaaaaaa4aaaaaaaaaaaabaaaaaaaaaaaaaaaaa5aaas(client);
for (uint16_t i = *start_value; i < number_of_units; i++) {
if ((client->unit[i].unit_mode == OPEN) || (client->unit[i].unit_mode == CLOSED)) {
*start_value = i;
return true;
}
}
return false;
}
static bool find_open_with_equal_mask(const a1aaat *client, uint16_t *start_value,
const aaaaaaaaaaaaa1aaat *mask,
uint8_t range_valid, uint8_t mask_id)
{
while (find_open(client, start_value)) {
assert((*start_value) < a1aaaaaaaaaaaaaaaabaaaaaaaaaaaa3aaaaaaaaaaaaaaaabaaaaaaaaaaaaaaaaaaaaaaaaaaaa3aaaaaaaaaaaaaaabaaaaaaaaaaaaaaaa4aaaaaaaaaaaaaaaabaaaaaaaaaaaaaaaaaaaaaaaaaaaa4aaaaaaaaaaaabaaaaaaaaaaaaaaaaa5aaas(client));
const aaa1aaat *phm = client->unit[*start_value].phm;
assert(aaa1aaaaaaaaaaaaaaabaaaaaaaaaaaa3aaaaaaaaaaaaaaaabaaaaaaaaaaaaaaaaaaaaaaaaaaaa3aaaaaaaaaaaaaaaabaaaaaaaaaaaaaaaaaaaaaaa4aaaaaaaaaaaaaaaabaaaaaaaaaaaaaaaaaaaaaaaaaaaa4aaaaaaaaaaaabaaaaaaaaaaa5aaaaaaaaaaaaaaaabaaaaaaaaaaaaaaaaaaaaaaaaaaaa5aaavalid(phm));
if (aaa1aaaaaaaaaaaaaaabaaaaaaaaaaaa3aaaaaaaaaaaaaaaabaaaaaaaaaaaaaaaaaaaaaaaaaaaa3aaaaaaaaaaaaaaaabaaaaaaaaaaaaaaaaaaaaaaa4aaaaaaaaaaaaaaaabaaaaaaaaaaaaaaaaaaaaaaaaaaaa4aaaequal(phm, mask, range_valid, mask_id)) {
return true;
}
(*start_value)++;
}
return false;
}
static bool find_open_with_equal_mask_dec(const a1aaat *client, uint16_t *start_value, const aaaaaaaaaaaaa1aaat *mask,
uint8_t range_valid, uint8_t mask_id)
{
assert(*start_value < a1aaaaaaaaaaaaaaaabaaaaaaaaaaaa3aaaaaaaaaaaaaaaabaaaaaaaaaaaaaaaaaaaaaaaaaaaa3aaaaaaaaaaaaaaabaaaaaaaaaaaaaaaa4aaaaaaaaaaaaaaaabaaaaaaaaaaaaaaaaaaaaaaaaaaaa4aaaaaaaaaaaabaaaaaaaaaaaaaaaaa5aaas(client));
while (find_open_dec(client, start_value)) {
assert((*start_value) < a1aaaaaaaaaaaaaaaabaaaaaaaaaaaa3aaaaaaaaaaaaaaaabaaaaaaaaaaaaaaaaaaaaaaaaaaaa3aaaaaaaaaaaaaaabaaaaaaaaaaaaaaaa4aaaaaaaaaaaaaaaabaaaaaaaaaaaaaaaaaaaaaaaaaaaa4aaaaaaaaaaaabaaaaaaaaaaaaaaaaa5aaas(client));
const aaa1aaat *phm = client->unit[*start_value].phm;
assert(aaa1aaaaaaaaaaaaaaabaaaaaaaaaaaa3aaaaaaaaaaaaaaaabaaaaaaaaaaaaaaaaaaaaaaaaaaaa3aaaaaaaaaaaaaaaabaaaaaaaaaaaaaaaaaaaaaaa4aaaaaaaaaaaaaaaabaaaaaaaaaaaaaaaaaaaaaaaaaaaa4aaaaaaaaaaaabaaaaaaaaaaa5aaaaaaaaaaaaaaaabaaaaaaaaaaaaaaaaaaaaaaaaaaaa5aaavalid(phm));
if (aaa1aaaaaaaaaaaaaaabaaaaaaaaaaaa3aaaaaaaaaaaaaaaabaaaaaaaaaaaaaaaaaaaaaaaaaaaa3aaaaaaaaaaaaaaaabaaaaaaaaaaaaaaaaaaaaaaa4aaaaaaaaaaaaaaaabaaaaaaaaaaaaaaaaaaaaaaaaaaaa4aaaequal(phm, mask, range_valid, mask_id)) {
return true;
}
if (*start_value == 0)
return false;
(*start_value)--;
}
return false;
}
uint8_t a1aaaaaaaaaaaaaaaabaaaaaaaaaaaa3aaaaaaaaaaaaaaaabaaaaaaaaaaaaaaaaaaaaaaaaaaaa3aaaaaaaaaaaaaaabaaaaaaaaaaaaaaaa4aaaaaaaaaaaaaaaabaaaaaaaaaaaaaaaaaaaaaaaaaaaa4aaaaaaaaaaaaaaaabaaaaaaaaaaaaaaaaaaaa5aaas(const a1aaat *client)
{
return cam_config_get_num_ranges(client->conf);
}
void a1aaaaaaaaaaaaaaaabaaaaaaaaaaaaaaaaaaaaaaaaa3aaa(a1aaat *client)
{
if (client == NULL) {
return;
}
cam_free_func free_function = a1aaaaaaaaaaaaaaaabaaaaaaaaaaaa3aaaaaaaaaaaaaaaabaaaaaaaaaaaaaaaaaaaaaaaaaaaa3aaaaaaaaaaaaaabaaaaaaaaaaaa4aaaaaaaaaaaaaaaabaaaaaaaaaaaaaaaaaaaaaaaaaaaa4aaaaaaaaaaaaaaaabaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaa4aaa(client);
if ((a1aaaaaaaaaaaaaaaabaaaaaaaaaaaa3aaaaaaaaaaaaaaaabaaaaaaaaaaaaaaaaaaaaaaaaaaaa3bbbbbbbbbbbbbbbbbbbbbbbbbbbbbbbbbbbbb3aaaaaaaaaaaaaaaabaaaaaaaaaaaaaaaaaaaaaaaaaaaa4aaaflags(client) & CAM_DEBUG_STATS) && (client->conf->instance_type != TCAM)) {
char message[100];
       sprintf(message, "inserts = %" PRIu64 " (%0d fail)   collisions = %" PRIu64 "/%0d (total/max)",
client->num_inserts, client->failed_inserts,
client->num_collisions, client->max_collisions);
a1aaaaaaaaaaaaaaaabaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaa3aaaaaaaaaaaaaaaabaaaaaaaaaaaaaaaaaaaaaaaaaaaa4aaainfo(client, message);
       sprintf(message, "updates = %" PRIu64 " (%0d fail)",
client->num_updates, client->failed_updates);
a1aaaaaaaaaaaaaaaabaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaa3aaaaaaaaaaaaaaaabaaaaaaaaaaaaaaaaaaaaaaaaaaaa4aaainfo(client, message);
       sprintf(message, "deletes = %" PRIu64 " (%0d fail)",
client->num_deletes, client->failed_deletes);
a1aaaaaaaaaaaaaaaabaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaa3aaaaaaaaaaaaaaaabaaaaaaaaaaaaaaaaaaaaaaaaaaaa4aaainfo(client, message);
}
const uint16_t num_units = cam_config_get_num_units(client->conf);
for (uint16_t i = 0; i < num_units; i++) {
aaa1aaaaaaaaaaaaaabaaaaaaaaaaaa3aaa(client->unit[i].phm, free_function);
}
if (!a1aaaaaaaaaaaaaaabaaaaaaaaaaaa3aaaaaaaaaaaaaaaabaaaaaaaaaaaaaaaaaaaaaaaaaaaa3aaaaaaaaaaaaaaaabaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaa3aaa(client)) {
htable_free(client->htable, free_function);
}
if (client->test_km != NULL) {
aaaa1aaaaaaaaaaaaaabaaaaaaaaaaaa3aaa(client->test_km, free_function);
}
if (client->conf != NULL) {
cam_config_destroy(client->conf);
}
free_function(client);
}
static void write_mask(a1aaat *client, const aaaaaaaaaaaaa1aaat *mask, uint16_t unit,
uint8_t range_valid, uint8_t mask_id)
{
assert(client != NULL);
aaa1aaat *phm = get_phm(client, unit);
const uint32_t wrap = unit - (unit / 256) * 256;
aaa1aaaaaaaaaaaaaaaabaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaa3aaaaaaaaaaaaaaaabaaaaaaaaaaaaaaaaaaaaaaaaaaaa4aaaaaaaaaaaaaaaabaaaaaaaaaaaaaaaaaaaaaaa5aaaaaaaaaaaaaaaabaaaaaaaaaaaaaaaaaaaaaaaaaaaa5aaaaaaaaaaaabaaaaaaaaaaa6aaa(phm, mask, (wrap << 8) + wrap, range_valid, mask_id);
}
uint16_t a1aaaaaaaaaaaaaaaabaaaaaaaaaaaa3aaaaaaaaaaaaaaaabaaaaaaaaaaaaaaaaaaaaaaaaaaaa3aaanarrow_key_width(const a1aaat *client)
{
return cam_config_get_narrow_key_width(client->conf);
}
uint16_t a1aaaaaaaaaaaaaaaabaaaaaaaaaaaa3aaaaaaaaaaaaaaaabaaaaaaaaaaaaaaaaaaaaaaaaaaaa3aaaaaaaaaaaaaaaabaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaa3aaaaaaaaaaaaaaaabaaaaaaaaaaaaaaaaaaaaaaaaaaaa4aaawidth(const a1aaat *client)
{
return cam_config_get_key_width(client->conf);
}
uint8_t a1aaaaaaaaaaaaaaaabaaaaaaaaaaaa3aaaaaaaaaaaaaaaabaaaaaaaaaaaaaaaaaaaaaaaaaaaa3aaaaaaaaaaaaaaabaaaaaaaaaaaaaaaaa4aaaaaaaaaaaaaaaabaaaaaaaaaaaaaaaaaaaaaaaaaaaa4aaawidth(const a1aaat *client)
{
return cam_config_get_prio_width(client->conf);
}
uint16_t a1aaaaaaaaaaaaaaaabaaaaaaaaaaaa3aaaaaaaaaaaaaaaabaaaaaaaaaaaaaaaaaaaaaaaaaaaa3aaaaaaaaaaaaaaaabaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaa3aaaaaaaaaaaaaaaabaaaaaaaaaaaaaaaaaaaaaaaaaaaa4aaawidth(const a1aaat *client)
{
return cam_config_get_response_width(client->conf);
}
int a1aaaaaaaaaaaaaaaabaaaaaaaaaaaa3aaaaaaaaaaaaaaaabaaaaaaaaaaaaaaaaaaaaaaaaaaaa3aaaaaaaaaaaaaaaabaaaaaaaaaaaaaaaaaaaa4aaaaaaaaaaaaaaaabaaaaaaaaaaaaaaaaaaaaaaaaaaaa4aaastart_pos(const a1aaat *client, uint8_t range_number, uint16_t *start_pos)
{
return cam_config_get_range_start_pos(client->conf, range_number, start_pos);
}
int a1aaaaaaaaaaaaaaaabaaaaaaaaaaaa3aaaaaaaaaaaaaaaabaaaaaaaaaaaaaaaaaaaaaaaaaaaa3aaaaaaaaaaaaaaaabaaaaaaaaaaaaaaaaaaaa4aaaaaaaaaaaaaaaabaaaaaaaaaaaaaaaaaaaaaaaaaaaa4aaawidth(const a1aaat *client, uint8_t range_number, uint8_t *width)
{
return cam_config_get_range_width(client->conf, range_number, width);
}
uint32_t a1aaaaaaaaaaaaaaaabaaaaaaaaaaaa3aaaaaaaaaaaaaaaabaaaaaaaaaaaaaaaaaaaaaaaaaaaa3aaaaaaaaaaaaaaabaaaaaaaaaaaaaaaa4aaaaaaaaaaaaaaaabaaaaaaaaaaaaaaaaaaaaaaaaaaaa4aaaaaaaaaaaaabaaaaaaaaaaaaaaaaa5aaas(const a1aaat *client)
{
return cam_config_get_num_lists(client->conf);
}
uint32_t a1aaaaaaaaaaaaaaaabaaaaaaaaaaaa3aaaaaaaaaaaaaaaabaaaaaaaaaaaaaaaaaaaaaaaaaaaa3aaaram_size(const a1aaat *client)
{
return cam_config_get_ram_size(client->conf);
}
uint16_t a1aaaaaaaaaaaaaaaabaaaaaaaaaaaa3aaaaaaaaaaaaaaaabaaaaaaaaaaaaaaaaaaaaaaaaaaaa3aaasegment(const a1aaat *client)
{
return cam_config_get_segment(client->conf);
}
uint32_t a1aaaaaaaaaaaaaaaabaaaaaaaaaaaa3aaaaaaaaaaaaaaaabaaaaaaaaaaaaaaaaaaaaaaaaaaaa3aaaaaaaaaaaaaaabaaaaaaaaaaaaaaaa4aaaaaaaaaaaaaaaabaaaaaaaaaaaaaaaaaaaaaaaaaaaa4aaaaaaaaaaaaabaaaaaaaaaaaaaaaaa5aaas_per_read(const a1aaat * const client)
{
return cam_config_get_num_lists_per_read(client->conf);
}
static int add_key_to_open(a1aaat *client, const aaaaaaaaaaaaa1aaat *key, const aaaaaaaaaaaaa1aaat *ternary_mask,
const aaaaaaaaaaaaaaaa1aaaaaaaaaaaaaaaabaaaaaaaaaaaaaaaaaaaaaaaaaaaa3aaat *response,
const aaaaaaaaaaaaa1aaat *mask, uint16_t *unit, uint8_t range_valid,
uint8_t mask_id)
{
assert(client != NULL);
uint16_t start_value = 0;
if (!find_open_with_equal_mask(client, &start_value, mask, range_valid, mask_id)) {
return CAM_ERROR_NO_OPEN;
}
aaa1aaat *phm = get_phm(client, start_value);
*unit = start_value;
bool success = aaa1aaaaaaaaaaaaaaabaaaaaaaaaaaaaaaaaaa3aaa(phm, key, ternary_mask, response, false, 0);
if (success) {
return 0;
}
return CAM_ERROR_FULL;
}
static int check_masked_key_bits(const aaaaaaaaaaaaa1aaat *mask, const aaaaaaaaaaaaa1aaat *key, uint16_t key_size)
{
const uint16_t number_of_words = key_size / 32;
for (uint8_t i = 0; i < number_of_words; i++) {
if ((mask->word[i] & key->word[i]) != key->word[i]) {
return CAM_ERROR_MASKED_KEY_BIT_IS_SET;
}
}
const uint8_t remaining_bits = key_size - number_of_words * 32;
if (remaining_bits > 0) {
const uint32_t remaining_key_bits = aaaaaaaa1aaaaaaaaaaaaaaaabaaaaaaaaaaaa3aaa(key->word[number_of_words], 0, remaining_bits);
const uint32_t remaining_mask_bits = aaaaaaaa1aaaaaaaaaaaaaaaabaaaaaaaaaaaa3aaa(mask->word[number_of_words], 0, remaining_bits);
if ((remaining_mask_bits & remaining_key_bits) != remaining_key_bits) {
return CAM_ERROR_MASKED_KEY_BIT_IS_SET;
}
}
return 0;
}
static bool db_execute(a1aaat *client, const aaaaaaaaaaaaa1aaat *key, const aaaaaaaaaaaaa1aaat *ternary_mask, const aaaaaaaaaaaaa1aaat *mask,
uint8_t range_valid, uint8_t mask_id, aaa1bbbbbbbbbbbbbbbbbbbbbbbbbbbb3aaaaaaaaaaaaaaaabaaaaaaaaaaaaaaaaaaaaaaaaaaaa4aaat execute, bool match_prio, aaaaaaaaaaaaaaaa1aaaaaaaaaaaaaaaabaaaaaaaaaaaaaaaaaaaaaaaaaaaa3aaat *prio,
uint16_t *unit,
bool *unresolvable_collision)
{
assert(client != NULL);
uint16_t open_unit = 0;
if (!find_open_with_equal_mask(client, &open_unit, mask, range_valid, mask_id)) {
*unresolvable_collision = false;
return false;
}
aaa1aaat *phm = get_phm(client, open_unit);
bool unresolvable_coll;
const bool status = aaa1bbbbbbbbbbbbbbbbbbbbbbbbbbbb3aaa(phm, key, ternary_mask, execute, &unresolvable_coll, match_prio, prio);
if (status == true) {
*unit = open_unit;
return true;
}
if (unresolvable_coll) {
*unresolvable_collision = true;
return false;
}
uint16_t closed_unit = 0;
while (find_closed_with_equal_mask(client, &closed_unit, mask, range_valid, mask_id)) {
aaa1aaat *phm = get_phm(client, closed_unit);
const bool status = aaa1bbbbbbbbbbbbbbbbbbbbbbbbbbbb3aaa(phm, key, ternary_mask, execute, &unresolvable_coll, match_prio, prio);
if (status == true) {
*unit = closed_unit;
return true;
}
if (unresolvable_coll) {
*unresolvable_collision = true;
return false;
}
closed_unit++;
}
*unresolvable_collision = false;
return false;
}
static uint8_t cache_hit(const a1aaat *client, const aaaaaaaaaaaaa1aaat *key, const aaaaaaaaaaaaa1aaat *mask, bool *unit_valid,
uint16_t *unit, const cam_options_t *options, uint32_t *murmur_bucket)
{
if (options->precomp_hash) {
*murmur_bucket = options->hash_value;
} else {
uint16_t kw = client->conf->arg.key_width;
if (options->narrow)
kw = client->conf->arg.narrow_key_width;
const uint16_t num_bytes = (kw + 7) / 8;
murmur3((const void *) key, num_bytes, 3, murmur_bucket);
}
uint8_t counter;
uint16_t value;
bool value_unknown;
htable_read(client->htable, *murmur_bucket, &counter, &value, &value_unknown);
if (counter == 0)
return 0;
if (value_unknown)
*unit_valid = false;
else {
*unit_valid = true;
*unit = value;
}
return counter;
}
static bool db_cuckoo_execute(a1aaat *client, const aaaaaaaaaaaaa1aaat *key, const aaaaaaaaaaaaa1aaat *mask, aaa1bbbbbbbbbbbbbbbbbbbbbbbbbbbb3aaaaaaaaaaaaaaaabaaaaaaaaaaaaaaaaaaaaaaaaaaaa4aaat execute,
bool match_response, aaaaaaaaaaaaaaaa1aaaaaaaaaaaaaaaabaaaaaaaaaaaaaaaaaaaaaaaaaaaa3aaat *response, uint8_t hit_counter, bool unit_valid, uint16_t *unit,
uint32_t murmur_bucket, bool narrow)
{
assert(client != NULL);
uint16_t open_unit = 0;
if (unit_valid)
open_unit = *unit;
const uint16_t num_units = a1aaaaaaaaaaaaaaaabaaaaaaaaaaaa3aaaaaaaaaaaaaaaabaaaaaaaaaaaaaaaaaaaaaaaaaaaa3aaaaaaaaaaaaaaabaaaaaaaaaaaaaaaa4aaaaaaaaaaaaaaaabaaaaaaaaaaaaaaaaaaaaaaaaaaaa4aaaaaaaaaaaabaaaaaaaaaaaaaaaaa5aaas(client);
uint16_t loop = num_units;
const bool is_hbmbcam_or_bcam = (client->conf->instance_type == HBMBCAM) || (client->conf->instance_type == BCAM);
while (loop) {
if (client->unit[open_unit].unit_mode == OPEN) {
aaa1aaat *phm = client->unit[open_unit].phm;
assert(aaa1aaaaaaaaaaaaaaabaaaaaaaaaaaa3aaaaaaaaaaaaaaaabaaaaaaaaaaaaaaaaaaaaaaaaaaaa3aaaaaaaaaaaaaaaabaaaaaaaaaaaaaaaaaaaaaaa4aaaaaaaaaaaaaaaabaaaaaaaaaaaaaaaaaaaaaaaaaaaa4aaaaaaaaaaaabaaaaaaaaaaa5aaaaaaaaaaaaaaaabaaaaaaaaaaaaaaaaaaaaaaaaaaaa5aaavalid(phm));
bool mask_equal = true;
if (!(is_hbmbcam_or_bcam)) {
assert(mask!=NULL);
mask_equal = aaa1aaaaaaaaaaaaaaabaaaaaaaaaaaa3aaaaaaaaaaaaaaaabaaaaaaaaaaaaaaaaaaaaaaaaaaaa3aaaaaaaaaaaaaaaabaaaaaaaaaaaaaaaaaaaaaaa4aaaaaaaaaaaaaaaabaaaaaaaaaaaaaaaaaaaaaaaaaaaa4aaaequal(phm, mask, 0, 0);
}
if (mask_equal) {
const bool status = aaa1bbbbbbbbbbbbbbbbbbbbbbbbbbbbbbbbbbbbbb3aaaaaaaaaaaaaaaabaaaaaaaaaaaaaaaaaaaaaaaaaaaa4bbbbbbbbbbbbbbbbbbbbbbbbbbbb4aaa(phm, key, execute, match_response, response, murmur_bucket,
narrow);
if (status == true) {
*unit = open_unit;
return true;
}
if (hit_counter == 1 && unit_valid)
return false;
}
}
if (open_unit == (num_units - 1))
open_unit = 0;
else
open_unit++;
loop--;
}
return false;
}
static void move_from_open(a1aaat *client, uint16_t target, uint16_t source)
{
if (target == source) {
assert(is_open(client, source));
assert(is_open(client, target));
return;
}
assert(is_closed(client, target));
assert(is_open(client, source));
aaa1aaat *target_phm = get_phm(client, target);
aaa1aaat *source_phm = get_phm(client, source);
const bool success = aaa1bbbbbbbbbbbbbbbbbbbbbbbb3aaaaaaaaaaaaaaaabaaaaaaaaaaaaaaaaaaaaaaaaaaaa4aaaone_element(target_phm, source_phm);
assert((success && (client->conf->instance_type == TCAM)) || (!(client->conf->instance_type == TCAM)));
}
int a1aaaaaaaaaaaaaaaabaaaaaaaaaaaaaaaaaaa3aaaaaaaaaaaaaaaabaaaaaaaaaaaaaaaaaaaaaaaaaaaa3aaaaaaaaaaaaaaaabaaaaaaaaaaaaaaaaaaaa4aaaaaaaaaaaaaaaabaaaaaaaaaaaaaaaaaaaaaaaaaaaa4aaaaaaaaaaaaaaaabaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaa4aaa(a1aaat *client, const aaaaaaaaaaaaa1aaat *key, const aaaaaaaaaaaaa1aaat *ternary_mask, const aaaaaaaaaaaaa1aaat *msk,
uint8_t range_valid, uint8_t mask_id)
{
int status = aaa1aaacheck_ternary_mask(client, key, ternary_mask, msk, range_valid);
if (status != 0) {
return status;
}
aaaaaaaaaaaaaaaa1aaaaaaaaaaaaaaaabaaaaaaaaaaaaaaaaaaaaaaaaaaaa3aaat del_prio;
uint16_t unit;
bool collision_found;
bool success = db_execute(client, key, ternary_mask, msk, range_valid, mask_id, aaa1aaaaaaaaaaaaaaaabaaaaaaaaaaaaaaaaaaa3aaa, false, &del_prio, &unit,
&collision_found);
if (!success) {
return CAM_ERROR_KEY_NOT_FOUND;
}
uint16_t open_unit = 0;
if (!find_open_with_equal_mask(client, &open_unit, msk, range_valid, mask_id)) {
assert(false);
}
move_from_open(client, unit, open_unit);
aaa1aaat *open_phm = get_phm(client, open_unit);
uint16_t number_of_keys = aaa1aaaaaaaaaaaaaaaabaaaaaaaaaaaa3aaaaaaaaaaaaaaaabaaaaaaaaaaaaaaaaaaaaaaaaaaaa3aaaaaaaaaaaaaaabaaaaaaaaaaaaaaaa4aaaber_of_keys(open_phm);
if (number_of_keys == 0) {
uint16_t closed_unit = 0;
if (find_closed_with_equal_mask(client, &closed_unit, msk, range_valid, mask_id)) {
set_open(client, closed_unit);
}
aaa1bbbbbbbbbbbbbbbbb3aaaaaaaaaaaaaaaabaaaaaaaaaaaaaaaaaaaaaaaaaaaa4aaaaaaaaaaaaaaaabaaaaaaaaaaaaaaaaaaaaaaa5aaaaaaaaaaaaaaaabaaaaaaaaaaaaaaaaaaaaaaaaaaaa5aaaaaaaaaaaabaaaaaaaaaaa6aaa(open_phm);
set_unused(client, open_unit);
}
return 0;
}
int a1aaaaaaaaaaaaaaaabaaaaaaaaaaaaaaaaaaa3aaaaaaaaaaaaaaaabaaaaaaaaaaaaaaaaaaaaaaaaaaaa3aaaaaaaaaaaaaaaabaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaa3aaa(a1aaat *client, const aaaaaaaaaaaaa1aaat *key, const aaaaaaaaaaaaa1aaat *mask, const cam_options_t *options)
{
client->num_deletes++;
if (a1aaaaaaaaaaaaaaaabaaaaaaaaaaaa3aaaaaaaaaaaaaaaabaaaaaaaaaaaaaaaaaaaaaaaaaaaa3aaaaaaaaaaaaaaabaaaaaaaaaaaaaaaa4aaaaaaaaaaaaaaaabaaaaaaaaaaaaaaaaaaaaaaaaaaaa4aaaaaaaaaaaaaaaabaaaaaaaaaaaaaaaaaaaa5aaas(client)) {
client->failed_deletes++;
return CAM_ERROR_WRONG_RANGE;
}
if (mask != NULL) {
const uint16_t key_width = cam_config_get_key_width(client->conf);
int status = check_masked_key_bits(mask, key, key_width);
if (status != 0) {
client->failed_deletes++;
return status;
}
}
aaaaaaaaaaaaaaaa1aaaaaaaaaaaaaaaabaaaaaaaaaaaaaaaaaaaaaaaaaaaa3aaat del_prio;
uint16_t unit;
uint32_t murmur_bucket;
bool unit_valid;
const uint8_t hit_counter = cache_hit(client, key, mask, &unit_valid, &unit, options, &murmur_bucket);
if (hit_counter == 0) {
client->failed_deletes++;
return CAM_ERROR_KEY_NOT_FOUND;
}
bool success = db_cuckoo_execute(client, key, mask, aaa1aaaaaaaaaaaaaaaabaaaaaaaaaaaaaaaaaaa3aaa, false, &del_prio, hit_counter, unit_valid,
&unit,
murmur_bucket, options->narrow);
if (!success) {
client->failed_deletes++;
return CAM_ERROR_KEY_NOT_FOUND;
}
aaa1aaat *phm = get_phm(client, unit);
uint32_t number_of_keys = aaa1aaaaaaaaaaaaaaaabaaaaaaaaaaaa3aaaaaaaaaaaaaaaabaaaaaaaaaaaaaaaaaaaaaaaaaaaa3aaaaaaaaaaaaaaabaaaaaaaaaaaaaaaa4aaaber_of_keys(phm);
if (number_of_keys == 0) {
aaa1bbbbbbbbbbbbbbbbb3aaaaaaaaaaaaaaaabaaaaaaaaaaaaaaaaaaaaaaaaaaaa4aaaaaaaaaaaaaaaabaaaaaaaaaaaaaaaaaaaaaaa5aaaaaaaaaaaaaaaabaaaaaaaaaaaaaaaaaaaaaaaaaaaa5aaaaaaaaaaaabaaaaaaaaaaa6aaa(phm);
set_unused(client, unit);
}
htable_dec(client->htable, murmur_bucket, unit);
client->num_entries--;
if (options->narrow) {
assert(client->narrow_num_entries > 0);
client->narrow_num_entries--;
}
return 0;
}
int a1aaaread_prio_for_range_key(const a1aaat *client, const aaaaaaaaaaaaaaaa1aaaaaaaaaaaaaaaabaaaaaaaaaaaaaaaaaaaaaaaaaaaa3aaat *prio, const aaaaaaaaaaaaaaaa1aaaaaaaaaaaaaaaabaaaaaaaaaaaaaaaaaaaaaaaaaaaa3aaat *prio_mask,
uint32_t *start_value,
aaaaaaaaaaaaa1aaat *key, aaaaaaaaaaaaa1aaat *ternary_mask, aaaaaaaaaaaaa1aaat *mask, uint8_t *range_valid,
uint8_t *mask_id)
{
assert(aaaaaa1aaaaaaaaaaaaaaaabaaaaaaaaaaaaaaaaaaaaaaaaaa3aaaaaaaaaaaaaaaabaaaaaaaaaaaaaaaaaaaaaaaaaaaa3bbbbbbbbbbbbbbbbbbbbbbbbbbbbbbbbbbb3aaaaaaaaaaaaaaaabaaaaaaaaaaaaaaaaaaaaaaaaaaaa4aaaaaaaaaaaabaaaaaaaaaaaaaaaaa5aaaS <= 256);
uint32_t key_pos = (*start_value) & 0x00ffffff;
uint16_t unit = ((*start_value) & 0xff000000) >> 24;
while (find_open_or_closed(client, &unit)) {
aaa1aaat *phm = get_phm(client, unit);
uint8_t narrow = 0;
uint8_t narrow_element = 0;
if (aaa1aaafind_response(phm, prio, prio_mask, &key_pos, key, ternary_mask, &narrow, &narrow_element, false)) {
key_pos++;
*start_value = (unit << 24) + key_pos;
aaa1aaaread_mask(phm, mask, range_valid, mask_id);
return 0;
}
unit++;
key_pos = 0;
}
return CAM_ERROR_KEY_NOT_FOUND;
}
int a1aaaread_response_for_key(const a1aaat *client, aaaaaaaaaaaaaaaa1aaaaaaaaaaaaaaaabaaaaaaaaaaaaaaaaaaaaaaaaaaaa3aaat *response, aaaaaaaaaaaaaaaa1aaaaaaaaaaaaaaaabaaaaaaaaaaaaaaaaaaaaaaaaaaaa3aaat *response_mask,
uint32_t *start_value,
aaaaaaaaaaaaa1aaat *key, aaaaaaaaaaaaa1aaat *mask, bool narrow_key)
{
assert(aaaaaa1aaaaaaaaaaaaaaaabaaaaaaaaaaaaaaaaaaaaaaaaaa3aaaaaaaaaaaaaaaabaaaaaaaaaaaaaaaaaaaaaaaaaaaa3bbbbbbbbbbbbbbbbbbbbbbbbbbbbbbbbbbb3aaaaaaaaaaaaaaaabaaaaaaaaaaaaaaaaaaaaaaaaaaaa4aaaaaaaaaaaabaaaaaaaaaaaaaaaaa5aaaS <= 256);
aaaaaaaaaaaaa1aaat ternary_mask;
uint32_t key_pos = (*start_value) & 0x00ffffff;
uint16_t unit = ((*start_value) & 0xff000000) >> 24;
uint8_t narrow = 0;
uint8_t narrow_element = 0;
if (a1aaaaaaaaaaaaaaabaaaaaaaaaaaa3aaaaaaaaaaaaaaaabaaaaaaaaaaaaaaaaaaaaaaaaaaaa3aaamixed_mode(client)) {
if (unit & 0x80) {
if (!narrow_key)
return CAM_ERROR_INVALID_ARG;
narrow_element = 1;
}
unit = unit & 0x7f;
}
if (narrow_key)
narrow = 1;
while (find_open_or_closed(client, &unit)) {
aaa1aaat *phm = get_phm(client, unit);
if (aaa1aaafind_response(phm, response, response_mask, &key_pos, key, &ternary_mask, &narrow, &narrow_element,
narrow_key)) {
if (narrow && (narrow_element == 0)) {
narrow_element = 1;
} else {
key_pos++;
}
*start_value = (0x00ffffff & key_pos);
uint32_t temp = unit << 24;
if (a1aaaaaaaaaaaaaaabaaaaaaaaaaaa3aaaaaaaaaaaaaaaabaaaaaaaaaaaaaaaaaaaaaaaaaaaa3aaamixed_mode(client))
{
if (narrow && (narrow_element == 1)) {
temp = temp | 0x80000000;
}
}
*start_value = *start_value | temp;
uint8_t range_valid = 0;
uint8_t mask_id = 0;
aaa1aaaread_mask(phm, mask, &range_valid, &mask_id);
return 0;
}
unit++;
key_pos = 0;
narrow = 0;
narrow_element = 0;
}
return CAM_ERROR_KEY_NOT_FOUND;
}
static int add_key(a1aaat *client, const aaaaaaaaaaaaa1aaat *key, const aaaaaaaaaaaaa1aaat *ternary_mask,
const aaaaaaaaaaaaaaaa1aaaaaaaaaaaaaaaabaaaaaaaaaaaaaaaaaaaaaaaaaaaa3aaat *key_prio,
const aaaaaaaaaaaaa1aaat *mask, uint8_t range_valid, uint8_t mask_id);
int a1bbbbbbbbbbbbbbbbbbbb3aaaaaaaaaaaaaaaabaaaaaaaaaaaaaaaaaaaaaaaaaaaa4aaaaaaaaaaaaaaaabaaaaaaaaaaaaaaaaaaaa5aaaaaaaaaaaaaaaabaaaaaaaaaaaaaaaaaaaaaaaaaaaa5aaaaaaaaaaaaaaaabaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaa5aaa(a1aaat *client, const aaaaaaaaaaaaa1aaat *key, const aaaaaaaaaaaaa1aaat *ternary_mask,
const aaaaaaaaaaaaaaaa1aaaaaaaaaaaaaaaabaaaaaaaaaaaaaaaaaaaaaaaaaaaa3aaat *key_prio,
const aaaaaaaaaaaaa1aaat *msk, uint8_t range_valid, uint8_t mask_id)
{
int status = aaa1aaacheck_ternary_mask(client, key, ternary_mask, msk, range_valid);
if (status != 0) {
return status;
}
uint16_t open_unit = 0;
if (!find_open_with_equal_mask(client, &open_unit, msk,
range_valid, mask_id)) {
status = add_key(client, key, ternary_mask, key_prio, msk,
range_valid, mask_id);
return status;
}
aaaaaaaaaaaaaaaa1aaaaaaaaaaaaaaaabaaaaaaaaaaaaaaaaaaaaaaaaaaaa3aaat comp_prio = *key_prio;
uint16_t read_unit;
bool collisions_found;
const bool found_in_db = db_execute(client, key, ternary_mask, msk, range_valid, mask_id, aaa1bbbbbbbbbbbbbbbbbbbb3aaa, false,
&comp_prio, &read_unit, &collisions_found);
if (found_in_db) {
return 0;
}
if (collisions_found) {
return CAM_ERROR_DUPLICATE_FOUND;
}
status = add_key(client, key, ternary_mask, key_prio, msk,
range_valid, mask_id);
return status;
}
int a1aaaread_range_key(const a1aaat *client, const aaaaaaaaaaaaa1aaat *key, const aaaaaaaaaaaaa1aaat *ternary_mask,
aaaaaaaaaaaaaaaa1aaaaaaaaaaaaaaaabaaaaaaaaaaaaaaaaaaaaaaaaaaaa3aaat *key_prio, const aaaaaaaaaaaaa1aaat *msk, uint8_t range_valid,
uint8_t mask_id)
{
int status = aaa1aaacheck_ternary_mask(client, key, ternary_mask, msk, range_valid);
if (status != 0) {
return status;
}
uint16_t read_unit;
bool collisions_found;
const bool found_in_db = db_execute((a1aaat *) client, key, ternary_mask, msk, range_valid,
mask_id, aaa1aaaREAD,
false, key_prio, &read_unit, &collisions_found);
if (!found_in_db) {
return CAM_ERROR_KEY_NOT_FOUND;
}
return 0;
}
static bool probe_and_insert(a1aaat *client, uint16_t start_unit, uint16_t except_unit, const aaaaaaaaaaaaa1aaat *key,
const aaaaaaaaaaaaaaaa1aaaaaaaaaaaaaaaabaaaaaaaaaaaaaaaaaaaaaaaaaaaa3aaat *response, uint32_t murmur_bucket, bool narrow_key)
{
uint16_t unit = start_unit;
const uint16_t num_units = a1aaaaaaaaaaaaaaaabaaaaaaaaaaaa3aaaaaaaaaaaaaaaabaaaaaaaaaaaaaaaaaaaaaaaaaaaa3aaaaaaaaaaaaaaabaaaaaaaaaaaaaaaa4aaaaaaaaaaaaaaaabaaaaaaaaaaaaaaaaaaaaaaaaaaaa4aaaaaaaaaaaabaaaaaaaaaaaaaaaaa5aaas(client);
uint16_t loop = num_units;
while (loop) {
if (unit != except_unit) {
aaa1aaat *phm = get_phm(client, unit);
bool success = aaa1aaaif_invalid_insert(phm, key, response, murmur_bucket, narrow_key);
if (success) {
htable_write(client->htable, murmur_bucket, unit);
return true;
}
}
if (unit == (num_units - 1))
unit = 0;
else
unit++;
loop--;
}
return false;
}
static bool split_dual_narrow(a1aaat *client, uint16_t unit, uint32_t murmur_bucket)
{
aaaaaaaaaaaaaaa1aaat *read_entry = (aaaaaaaaaaaaaaa1aaat *) alloca(aaaaaaaaaaaaaaa1aaaaaaaaaaaaaabaaaaaaaaaa3aaa());
assert(a1aaaaaaaaaaaaaaabaaaaaaaaaaaa3aaaaaaaaaaaaaaaabaaaaaaaaaaaaaaaaaaaaaaaaaaaa3aaahbmbcam(client));
aaa1aaat *phm = get_phm(client, unit);
uint32_t aaaaaaaaaa1aaaaaaaaaaaaaaaabaaaaaaaaaaaaaaaaaaaaaaaaaaaa3aaaaaaaaaaaaaaabaaaaaaaaaaaaaaaa4aaaber = aaa1aaaaaaaaaaaaaaaabaaaaaaaaaaaa3aaaaaaaaaaaaaaaabaaaaaaaaaaaaaaaaaaaaaaaaaaaa3aaaaaaaaaaaaabaaaaaaaaaaaaaaaaa4aaaaaaaaaaaaaaaabaaaaaaaaaaaaaaaaaaaaaaaaaaaa4aaafrom_murmur(phm, murmur_bucket);
const uint8_t num_lists_per_read = a1aaaaaaaaaaaaaaaabaaaaaaaaaaaa3aaaaaaaaaaaaaaaabaaaaaaaaaaaaaaaaaaaaaaaaaaaa3aaaaaaaaaaaaaaabaaaaaaaaaaaaaaaa4aaaaaaaaaaaaaaaabaaaaaaaaaaaaaaaaaaaaaaaaaaaa4aaaaaaaaaaaaabaaaaaaaaaaaaaaaaa5aaas_per_read(client);
for (uint8_t list = 0; list < num_lists_per_read; list++) {
if (a1aaaaaaaaaaaaaaabaaaaaaaaaaaa3aaaaaaaaaaaaaaaabaaaaaaaaaaaaaaaaaaaaaaaaaaaa3aaaoverwritten(client, phm, aaaaaaaaaa1aaaaaaaaaaaaaaaabaaaaaaaaaaaaaaaaaaaaaaaaaaaa3aaaaaaaaaaaaaaabaaaaaaaaaaaaaaaa4aaaber + list))
continue;
for (uint8_t narrow_element = 0; narrow_element < 2; narrow_element++) {
bool success = aaa1aaaread_element(phm, aaaaaaaaaa1aaaaaaaaaaaaaaaabaaaaaaaaaaaaaaaaaaaaaaaaaaaa3aaaaaaaaaaaaaaabaaaaaaaaaaaaaaaa4aaaber + list, read_entry, false, true, narrow_element);
assert(success); 
aaaaaaaaaaaaa1aaat insert_key;
aaaaaaaaaaaaaaaa1aaaaaaaaaaaaaaaabaaaaaaaaaaaaaaaaaaaaaaaaaaaa3aaat insert_response;
const aaaaaaaaaaaaa1aaat *stored_key = aaaaaaaaaaaaaaa1aaaaaaaaaaaaaaaabaaaaaaaaaaaa3aaaaaaaaaaaaaaaabaaaaaaaaaaaaaaaaaaaaaaaaaaaa3aaaaaaaaaaaa1aaa(read_entry, 0);
memcpy(&insert_key, stored_key, sizeof(aaaaaaaaaaaaa1aaat));
const aaaaaaaaaaaaaaaa1aaaaaaaaaaaaaaaabaaaaaaaaaaaaaaaaaaaaaaaaaaaa3aaat *prio_ptr = aaaaaaaaaaaaaaa1aaaaaaaaaaaaaaaabaaaaaaaaaaaa3aaaaaaaaaaaaaaaabaaaaaaaaaaaaaaaaaaaaaaaaaaaa3aaaaaaaaaaaaaaabaaaaaaaaaaaaaaaaa4aaa(read_entry, 0);
memcpy(&insert_response, prio_ptr, sizeof(aaaaaaaaaaaaaaaa1aaaaaaaaaaaaaaaabaaaaaaaaaaaaaaaaaaaaaaaaaaaa3aaat));
const uint16_t narrow_key_width_num_bytes = (client->conf->arg.narrow_key_width + 7) / 8;
uint32_t insert_murmur_bucket;
murmur3((const void *) &insert_key, narrow_key_width_num_bytes, 3, &insert_murmur_bucket);
success = probe_and_insert(client, 0, unit, &insert_key, &insert_response, insert_murmur_bucket, true);
if (success) {
success = aaa1aaaaaaaaaaaaaaaabaaaaaaaaaaaaaaaaaaa3aaaaaaaaaaaaaaaabaaaaaaaaaaaaaaaaaaaaaaaaaaaa3aaaelement(phm, aaaaaaaaaa1aaaaaaaaaaaaaaaabaaaaaaaaaaaaaaaaaaaaaaaaaaaa3aaaaaaaaaaaaaaabaaaaaaaaaaaaaaaa4aaaber + list, true, narrow_element);
assert(success);
return true;
}
}
}
return false;
}
static void delete_overwrites(a1aaat *client, aaa1aaat *phm, uint32_t list, uint16_t last_pos, uint8_t narrow,
uint8_t narrow_element)
{
assert(last_pos < client->num_overwrites);
assert(phm != NULL);
for (int i = last_pos; i >= 0; i--) {
if (client->overwrites[i].phm == phm && client->overwrites[i].list == list
&& client->overwrites[i].narrow == narrow && client->overwrites[i].narrow_element == narrow_element) {
client->overwrites[i].phm = NULL;
}
}
}
bool a1aaaaaaaaaaaaaaabaaaaaaaaaaaa3aaaaaaaaaaaaaaaabaaaaaaaaaaaaaaaaaaaaaaaaaaaa3aaaoverwritten(const a1aaat *client, const aaa1aaat *phm, uint32_t list)
{
for (int i = (client->num_overwrites - 1); i >= 0; i--) {
if (client->overwrites[i].phm == phm && client->overwrites[i].list == list)
return true;
}
return false;
}
void a1bbbbbbbbbbbbbbbbbbbbbbbbbbbbbbbb3aaaaaaaaaaaaaaaabaaaaaaaaaaaaaaaaaaaaaaaaaaaa4aaaoverwrite(a1aaat *client, aaa1aaat *phm, uint32_t list, aaaaaaaaaaaaaaa1aaat *pointer_list, uint8_t narrow,
uint8_t narrow_element)
{
assert((!narrow && narrow_element == 0) || narrow);
assert(client->num_overwrites < MAX_OVERWRITES);
const aaaaaaaaaaaaa1aaat *key = aaaaaaaaaaaaaaa1aaaaaaaaaaaaaaaabaaaaaaaaaaaa3aaaaaaaaaaaaaaaabaaaaaaaaaaaaaaaaaaaaaaaaaaaa3aaaaaaaaaaaa1aaa(pointer_list, 0);
const aaaaaaaaaaaaaaaa1aaaaaaaaaaaaaaaabaaaaaaaaaaaaaaaaaaaaaaaaaaaa3aaat *aaaaaaaaaaaaaa1aaaaaaaaaaaaaaaabaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaa3aaa = aaaaaaaaaaaaaaa1aaaaaaaaaaaaaaaabaaaaaaaaaaaa3aaaaaaaaaaaaaaaabaaaaaaaaaaaaaaaaaaaaaaaaaaaa3aaaaaaaaaaaaaaabaaaaaaaaaaaaaaaaa4aaa(pointer_list, 0);
client->overwrites[client->num_overwrites].murmur_bucket = aaaaaaaaaaaaaaa1aaaaaaaaaaaaaaaabaaaaaaaaaaaa3aaaaaaaaaaaaaaaabaaaaaaaaaaaaaaaaaaaaaaaaaaaa3aaaaaaaaaabaaaaaaaaaaa4aaa(pointer_list);
client->overwrites[client->num_overwrites].key = *key;
client->overwrites[client->num_overwrites].aaaaaaaaaaaaaa1aaaaaaaaaaaaaaaabaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaa3aaa = *aaaaaaaaaaaaaa1aaaaaaaaaaaaaaaabaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaa3aaa;
client->overwrites[client->num_overwrites].list = list;
client->overwrites[client->num_overwrites].phm = phm;
client->overwrites[client->num_overwrites].narrow = narrow;
client->overwrites[client->num_overwrites].narrow_element = narrow_element;
client->num_overwrites++;
}
static inline void flush_and_empty_overwrites(a1aaat *client)
{
if (client->num_overwrites == 0)
return;
aaaaaaaaaaaaaaa1aaat *pointer_list = (aaaaaaaaaaaaaaa1aaat *) alloca(aaaaaaaaaaaaaaa1aaaaaaaaaaaaaabaaaaaaaaaa3aaa());
for (int i = (client->num_overwrites - 1); i >= 0; i--) {
if (client->overwrites[i].phm != NULL) {
aaaaaaaaaaaaaaa1aaaaaaaaaaaaaabaaaaaaaaaaa3aaa(pointer_list, client->overwrites[i].murmur_bucket, true, false);
aaaaaaaaaaaaaaa1bbbbbbbbbbbbbbbbbbbbbbbbbbbbbbbb3aaa(pointer_list, &client->overwrites[i].aaaaaaaaaaaaaa1aaaaaaaaaaaaaaaabaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaa3aaa, &client->overwrites[i].key, NULL,
client->overwrites[i].narrow);
aaaa1aaat *km = aaa1aaaaaaaaaaaaaaaabaaaaaaaaaaaa3aaaaaaaaaaaaaaaabaaaaaaaaaaaaaaaaaaaaaaaaaaaa3aaakm(client->overwrites[i].phm);
if (!(client->conf->instance_type == HBMBCAM)) {
aaaa1aaaaaaaaaaaaaaaabaaaaaaaaaaaaaaaaaaa3aaaaaaaaaaaaaaaabaaaaaaaaaaaaaaaaaaaaaaaaaaaa3aaaelement(km, client->overwrites[i].list,
client->overwrites[i].narrow,
client->overwrites[i].narrow_element);
}
aaaa1aaaaaaaaaaaaaaaabaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaa3aaa(km, client->overwrites[i].list, pointer_list, client->overwrites[i].narrow,
client->overwrites[i].narrow_element);
const uint16_t phys_unit = aaa1aaaaaaaaaaaaaaaabaaaaaaaaaaaa3aaaaaaaaaaaaaaaabaaaaaaaaaaaaaaaaaaaaaaaaaaaa3aaaaaaaaaaaabaaaaaaaaaaaaaaaaa4aaa(client->overwrites[i].phm);
const uint16_t num_slots = cam_config_get_num_slots(client->conf);
const uint8_t slot = aaa1aaaaaaaaaaaaaaaabaaaaaaaaaaaa3aaaaaaaaaaaaaaaabaaaaaaaaaaaaaaaaaaaaaaaaaaaa3bbbbbbbbbbbbbbbbbbbbbbbbbbbbbbbbbbbb3aaaaaaaaaaaaaaaabaaaaaaaaaaaaaaaaaaaaaaaaaaaa4aaaaaaaaaaaaaaabaaaaaaaaaaaaaaaa5aaaber(client->overwrites[i].phm);
htable_write(client->htable, client->overwrites[i].murmur_bucket, phys_unit * num_slots + slot);
if (i > 0)
delete_overwrites(client, client->overwrites[i].phm, client->overwrites[i].list, i - 1,
client->overwrites[i].narrow, client->overwrites[i].narrow_element);
}
}
client->num_overwrites = 0;
}
static uint16_t compute_num_hw_write_operations(const a1aaat *client, uint16_t split_dual_narrows)
{
if (a1aaaaaaaaaaaaaaabaaaaaaaaaaaa3aaaaaaaaaaaaaaaabaaaaaaaaaaaaaaaaaaaaaaaaaaaa3aaahbmbcam(client)) {
return client->num_overwrites * 33 + split_dual_narrows * 2 * 33; 
} else {
assert(split_dual_narrows == 0);
return (1 + (cam_config_get_list_length(client->conf) + 63) / 64 + 2) * client->num_overwrites; 
}
}
static int insert_single_mask_key(a1aaat *client, const aaaaaaaaaaaaa1aaat *key, const aaaaaaaaaaaaaaaa1aaaaaaaaaaaaaaaabaaaaaaaaaaaaaaaaaaaaaaaaaaaa3aaat *response,
bool narrow, uint32_t murmur_bucket)
{
bool success;
client->num_overwrites = 0;
if (!client->zero_unused) {
uint16_t new_unit = 0;
if (find_unused(client, &new_unit)) {
write_mask(client, NULL, new_unit, 0, 0);
aaa1aaat *phm = get_phm(client, new_unit);
success = aaa1aaaif_invalid_insert(phm, key, response, murmur_bucket, narrow);
assert(success);
set_open(client, new_unit);
htable_write(client->htable, murmur_bucket, new_unit);
return 0;
} else {
client->zero_unused = true;
}
}
const uint16_t key_width_num_bytes = (client->conf->arg.key_width + 7) / 8;
const uint16_t narrow_key_width_num_bytes = (client->conf->arg.narrow_key_width + 7) / 8;
aaaaaaaaaaaaaaa1aaat *evicted_entry = (aaaaaaaaaaaaaaa1aaat *) alloca(aaaaaaaaaaaaaaa1aaaaaaaaaaaaaabaaaaaaaaaa3aaa());
const uint16_t num_units = a1aaaaaaaaaaaaaaaabaaaaaaaaaaaa3aaaaaaaaaaaaaaaabaaaaaaaaaaaaaaaaaaaaaaaaaaaa3aaaaaaaaaaaaaaabaaaaaaaaaaaaaaaa4aaaaaaaaaaaaaaaabaaaaaaaaaaaaaaaaaaaaaaaaaaaa4aaaaaaaaaaaabaaaaaaaaaaaaaaaaa5aaas(client);
assert(num_units > 0);
bool insert_narrow_key = narrow;
aaaaaaaaaaaaa1aaat insert_key = *key;
aaaaaaaaaaaaaaaa1aaaaaaaaaaaaaaaabaaaaaaaaaaaaaaaaaaaaaaaaaaaa3aaat insert_response = *response;
uint32_t insert_murmur_bucket = murmur_bucket;
uint16_t collision_count = 0;
uint16_t split_dual_narrows = 0;
uint32_t random = rand();
uint16_t start_unit = random - random / num_units * num_units;
assert(start_unit < num_units);
uint16_t except_unit = num_units;
uint16_t unit = start_unit;
const uint16_t max_hw_writes = client->conf->arg.max_hw_writes;
while (1) {
success = probe_and_insert(client, start_unit, except_unit, &insert_key, &insert_response,
insert_murmur_bucket,
insert_narrow_key);
if (success) {
flush_and_empty_overwrites(client);
return 0;
}
if (client->num_overwrites >= MAX_OVERWRITES) { 
return CAM_ERROR_FULL;
}
if (max_hw_writes > 0) { 
if (max_hw_writes <= compute_num_hw_write_operations(client, split_dual_narrows)) {
return CAM_ERROR_FULL;
}
}
client->num_collisions++; 
collision_count++;
if (collision_count > client->max_collisions) {
client->max_collisions = collision_count;
}
success = false;
for (uint8_t i = 0; i < num_units; i++) {
if (unit != except_unit) {
aaa1aaat *phm = get_phm(client, unit);
success = aaa1bbbbbbbbbbbbbbbbbbbbbbbbbbbbbbbbbbbbbb3aaaaaaaaaaaaaaaabaaaaaaaaaaaaaaaaaaaaaaaaaaaa4aaaaaaaaaaaaaaabaaaaaaaaaaaaaaaaaaa5aaa(phm, &insert_key, &insert_response, insert_murmur_bucket, evicted_entry,
insert_narrow_key);
if (!success) {
}
else {
break;
}
}
if (unit == (num_units - 1))
unit = 0;
else
unit++;
}
if (!success) {
if (!a1aaaaaaaaaaaaaaabaaaaaaaaaaaa3aaaaaaaaaaaaaaaabaaaaaaaaaaaaaaaaaaaaaaaaaaaa3aaamixed_mode(client)) { 
return CAM_ERROR_FULL;
}
if (insert_narrow_key) {
return CAM_ERROR_FULL;
}
if (client->num_overwrites >= MAX_OVERWRITES) { 
return CAM_ERROR_FULL;
}
if (max_hw_writes > 0) { 
if (max_hw_writes <= compute_num_hw_write_operations(client, split_dual_narrows)) {
return CAM_ERROR_FULL;
}
}
for (uint8_t i = 0; i < num_units; i++) {
if (unit != except_unit) {
success = split_dual_narrow(client, unit, insert_murmur_bucket);
if (success) { 
aaa1aaat *phm = get_phm(client, unit);
success = aaa1bbbbbbbbbbbbbbbbbbbbbbbbbbbbbbbbbbbbbb3aaaaaaaaaaaaaaaabaaaaaaaaaaaaaaaaaaaaaaaaaaaa4aaaaaaaaaaaaaaabaaaaaaaaaaaaaaaaaaa5aaa(phm, &insert_key, &insert_response, insert_murmur_bucket,
evicted_entry, insert_narrow_key);
assert(success);
split_dual_narrows++;
break;
}
} 
if (unit == (num_units - 1))
unit = 0;
else
unit++;
} 
if (!success) { 
return CAM_ERROR_FULL;
}
} 
except_unit = unit;
assert(success);
if (success) {
const aaaaaaaaaaaaa1aaat *stored_key = aaaaaaaaaaaaaaa1aaaaaaaaaaaaaaaabaaaaaaaaaaaa3aaaaaaaaaaaaaaaabaaaaaaaaaaaaaaaaaaaaaaaaaaaa3aaaaaaaaaaaa1aaa(evicted_entry, 0);
memcpy(&insert_key, stored_key, sizeof(aaaaaaaaaaaaa1aaat));
const aaaaaaaaaaaaaaaa1aaaaaaaaaaaaaaaabaaaaaaaaaaaaaaaaaaaaaaaaaaaa3aaat *prio_ptr = aaaaaaaaaaaaaaa1aaaaaaaaaaaaaaaabaaaaaaaaaaaa3aaaaaaaaaaaaaaaabaaaaaaaaaaaaaaaaaaaaaaaaaaaa3aaaaaaaaaaaaaaabaaaaaaaaaaaaaaaaa4aaa(evicted_entry, 0);
memcpy(&insert_response, prio_ptr, sizeof(aaaaaaaaaaaaaaaa1aaaaaaaaaaaaaaaabaaaaaaaaaaaaaaaaaaaaaaaaaaaa3aaat));
insert_narrow_key = aaaaaaaaaaaaaaa1aaaaaaaaaaaaaaabaaaaaaaaaaaa3aaaaaaaaaaaaaaaabaaaaaaaaaaaaaaaaaaaaaaaaaaaa3aaanarrow_key(evicted_entry, 0);
uint16_t num_bytes;
if (insert_narrow_key)
num_bytes = narrow_key_width_num_bytes;
else
num_bytes = key_width_num_bytes;
murmur3((const void *) &insert_key, num_bytes, 3, &insert_murmur_bucket);
}
if (unit == (num_units - 1))
unit = 0;
else
unit++;
} 
}
static int insert_multi_mask_key(a1aaat *client, const aaaaaaaaaaaaa1aaat *key, const aaaaaaaaaaaaaaaa1aaaaaaaaaaaaaaaabaaaaaaaaaaaaaaaaaaaaaaaaaaaa3aaat *response,
const aaaaaaaaaaaaa1aaat *mask, bool narrow, uint32_t murmur_bucket)
{
bool success;
const uint16_t key_width_num_bytes = (client->conf->arg.key_width + 7) / 8;
const uint16_t narrow_key_width_num_bytes = (client->conf->arg.narrow_key_width + 7) / 8;
aaaaaaaaaaaaaaa1aaat *evicted_entry = (aaaaaaaaaaaaaaa1aaat *) alloca(aaaaaaaaaaaaaaa1aaaaaaaaaaaaaabaaaaaaaaaa3aaa());
const uint16_t num_units = a1aaaaaaaaaaaaaaaabaaaaaaaaaaaa3aaaaaaaaaaaaaaaabaaaaaaaaaaaaaaaaaaaaaaaaaaaa3aaaaaaaaaaaaaaabaaaaaaaaaaaaaaaa4aaaaaaaaaaaaaaaabaaaaaaaaaaaaaaaaaaaaaaaaaaaa4aaaaaaaaaaaabaaaaaaaaaaaaaaaaa5aaas(client);
bool insert_narrow_key = narrow;
aaaaaaaaaaaaa1aaat insert_key = *key;
aaaaaaaaaaaaaaaa1aaaaaaaaaaaaaaaabaaaaaaaaaaaaaaaaaaaaaaaaaaaa3aaat insert_response = *response;
uint32_t insert_murmur_bucket = murmur_bucket;
uint16_t recycle_count = 0;
uint16_t max_recycles = 1;
uint16_t collision_count = 0;
while (recycle_count < max_recycles) {
uint16_t start_value = num_units - 1;
uint16_t num_open = 0;
while (find_open_with_equal_mask_dec(client, &start_value, mask, 0, 0)) { 
aaa1aaat *phm = get_phm(client, start_value);
bool success = aaa1aaaif_invalid_insert(phm, &insert_key, &insert_response, insert_murmur_bucket,
insert_narrow_key);
if (success) {
htable_write(client->htable, insert_murmur_bucket, start_value);
flush_and_empty_overwrites(client);
return 0;
}
client->num_collisions++;
collision_count++;
if (collision_count > client->max_collisions) {
client->max_collisions = collision_count;
}
success = aaa1bbbbbbbbbbbbbbbbbbbbbbbbbbbbbbbbbbbbbb3aaaaaaaaaaaaaaaabaaaaaaaaaaaaaaaaaaaaaaaaaaaa4aaaaaaaaaaaaaaabaaaaaaaaaaaaaaaaaaa5aaa(phm, &insert_key, &insert_response, insert_murmur_bucket, evicted_entry,
insert_narrow_key);
if (success) {
insert_narrow_key = aaaaaaaaaaaaaaa1aaaaaaaaaaaaaaabaaaaaaaaaaaa3aaaaaaaaaaaaaaaabaaaaaaaaaaaaaaaaaaaaaaaaaaaa3aaanarrow_key(evicted_entry, 0);
const aaaaaaaaaaaaa1aaat *stored_key = aaaaaaaaaaaaaaa1aaaaaaaaaaaaaaaabaaaaaaaaaaaa3aaaaaaaaaaaaaaaabaaaaaaaaaaaaaaaaaaaaaaaaaaaa3aaaaaaaaaaaa1aaa(evicted_entry, 0);
memcpy(&insert_key, stored_key, sizeof(aaaaaaaaaaaaa1aaat));
const aaaaaaaaaaaaaaaa1aaaaaaaaaaaaaaaabaaaaaaaaaaaaaaaaaaaaaaaaaaaa3aaat *prio_ptr = aaaaaaaaaaaaaaa1aaaaaaaaaaaaaaaabaaaaaaaaaaaa3aaaaaaaaaaaaaaaabaaaaaaaaaaaaaaaaaaaaaaaaaaaa3aaaaaaaaaaaaaaabaaaaaaaaaaaaaaaaa4aaa(evicted_entry, 0);
memcpy(&insert_response, prio_ptr, sizeof(aaaaaaaaaaaaaaaa1aaaaaaaaaaaaaaaabaaaaaaaaaaaaaaaaaaaaaaaaaaaa3aaat));
uint16_t num_bytes;
if (insert_narrow_key)
num_bytes = narrow_key_width_num_bytes;
else
num_bytes = key_width_num_bytes;
murmur3((const void *) &insert_key, num_bytes, 3, &insert_murmur_bucket);
}
num_open++;
if (start_value > 0)
start_value--;
else
break;
}
if (num_open < 2)
break;
else if (num_open == 2)
max_recycles = 24; 
else if (num_open == 3)
max_recycles = 128;
else if (num_open == 4)
max_recycles = 64;
else
max_recycles = 128 / num_open + 1;
recycle_count++;
}
uint16_t new_unit = 0;
if (!find_unused(client, &new_unit)) {
return CAM_ERROR_FULL;
}
write_mask(client, mask, new_unit, 0, 0);
aaa1aaat *phm = client->unit[new_unit].phm;
success = aaa1aaaif_invalid_insert(phm, &insert_key, &insert_response, insert_murmur_bucket, insert_narrow_key);
assert(success);
set_open(client, new_unit);
htable_write(client->htable, insert_murmur_bucket, new_unit);
flush_and_empty_overwrites(client);
return 0;
}
static bool is_duplicate(a1aaat *client, const aaaaaaaaaaaaa1aaat *key, const aaaaaaaaaaaaa1aaat *mask, const cam_options_t *options,
uint32_t *murmur_bucket)
{
uint16_t unit;
bool unit_valid;
aaaaaaaaaaaaaaaa1aaaaaaaaaaaaaaaabaaaaaaaaaaaaaaaaaaaaaaaaaaaa3aaat response;
const uint8_t hit_counter = cache_hit(client, key, mask, &unit_valid, &unit, options, murmur_bucket);
if (hit_counter > 0) {
const bool found = db_cuckoo_execute(client, key, mask, aaa1aaaREAD,
false, &response, hit_counter, unit_valid, &unit, *murmur_bucket, options->narrow);
if (found)
return true;
}
return false;
}
int a1aaaaaaaaaaaaaaaabaaaaaaaaaaaa3aaaaaaaaaaaaaaaabaaaaaaaaaaaaaaaaaaaaaaaaaaaa3aaawidths(const a1aaat *client, uint16_t *key_width, uint16_t *response_width,
bool narrow_key)
{
*key_width = a1aaaaaaaaaaaaaaaabaaaaaaaaaaaa3aaaaaaaaaaaaaaaabaaaaaaaaaaaaaaaaaaaaaaaaaaaa3aaaaaaaaaaaaaaaabaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaa3aaaaaaaaaaaaaaaabaaaaaaaaaaaaaaaaaaaaaaaaaaaa4aaawidth(client);
*response_width = a1aaaaaaaaaaaaaaaabaaaaaaaaaaaa3aaaaaaaaaaaaaaaabaaaaaaaaaaaaaaaaaaaaaaaaaaaa3aaaaaaaaaaaaaaaabaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaa3aaaaaaaaaaaaaaaabaaaaaaaaaaaaaaaaaaaaaaaaaaaa4aaawidth(client);
if (a1aaaaaaaaaaaaaaabaaaaaaaaaaaa3aaaaaaaaaaaaaaaabaaaaaaaaaaaaaaaaaaaaaaaaaaaa3aaamixed_mode(client)) {
if (narrow_key) {
*key_width = a1aaaaaaaaaaaaaaaabaaaaaaaaaaaa3aaaaaaaaaaaaaaaabaaaaaaaaaaaaaaaaaaaaaaaaaaaa3aaanarrow_key_width(client);
}
}
else if (narrow_key) {
return CAM_ERROR_WRONG_KEY_WIDTH;
}
return 0;
}
int a1aaaaaaaaaaaaaaabaaaaaaaaaaaaaaaaaaa3aaaaaaaaaaaaaaaabaaaaaaaaaaaaaaaaaaaaaaaaaaaa3aaaaaaaaaaaaaaaabaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaa3aaa(a1aaat *client, const aaaaaaaaaaaaa1aaat *key, const aaaaaaaaaaaaaaaa1aaaaaaaaaaaaaaaabaaaaaaaaaaaaaaaaaaaaaaaaaaaa3aaat *response, const aaaaaaaaaaaaa1aaat *mask,
const cam_options_t *options)
{
client->num_inserts++;
assert(((client->narrow_num_entries > 0) && a1aaaaaaaaaaaaaaabaaaaaaaaaaaa3aaaaaaaaaaaaaaaabaaaaaaaaaaaaaaaaaaaaaaaaaaaa3aaamixed_mode(client)) || (client->narrow_num_entries == 0));
const uint32_t wide_entries = client->num_entries - client->narrow_num_entries;
if ((wide_entries + (client->narrow_num_entries + 1) / 2) >= client->conf->arg.num_entries) {
client->failed_inserts++;
return CAM_ERROR_FULL;
}
if (mask != NULL) {
const uint16_t key_width = cam_config_get_key_width(client->conf);
int status = check_masked_key_bits(mask, key, key_width);
if (status != 0) {
client->failed_inserts++;
return status;
}
}
uint32_t murmur_bucket;
const bool duplicate = is_duplicate(client, key, mask, options, &murmur_bucket);
if (duplicate) {
client->failed_inserts++;
return CAM_ERROR_DUPLICATE_FOUND;
}
htable_inc(client->htable, murmur_bucket);
if (mask == NULL)
{
int rc = insert_single_mask_key(client, key, response, options->narrow, murmur_bucket);
if (rc == 0) {
client->num_entries++;
if (options->narrow)
client->narrow_num_entries++;
}
else
client->failed_inserts++;
return rc;
}
int rc = insert_multi_mask_key(client, key, response, mask, options->narrow, murmur_bucket);
if (rc == 0) {
client->num_entries++;
if (options->narrow)
client->narrow_num_entries++;
}
else
client->failed_inserts++;
return rc;
}
int a1bbbbbbbbbbbbbbbbbbbb3aaaaaaaaaaaaaaaabaaaaaaaaaaaaaaaaaaaaaaaaaaaa4aaaaaaaaaaaaaaaabaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaa4aaa(a1aaat *client, const aaaaaaaaaaaaa1aaat *key, const aaaaaaaaaaaaaaaa1aaaaaaaaaaaaaaaabaaaaaaaaaaaaaaaaaaaaaaaaaaaa3aaat *response, const aaaaaaaaaaaaa1aaat *mask,
const cam_options_t *options)
{
client->num_updates++;
if (mask != NULL) {
const uint16_t key_width = cam_config_get_key_width(client->conf);
int status = check_masked_key_bits(mask, key, key_width);
if (status != 0) {
client->failed_updates++;
return status;
}
}
uint16_t read_unit;
aaaaaaaaaaaaaaaa1aaaaaaaaaaaaaaaabaaaaaaaaaaaaaaaaaaaaaaaaaaaa3aaat comp_prio = *response;
uint32_t murmur_bucket;
bool read_unit_valid;
const uint8_t hit_counter = cache_hit(client, key, mask, &read_unit_valid, &read_unit, options, &murmur_bucket);
if (hit_counter == 0) {
client->failed_updates++;
return CAM_ERROR_KEY_NOT_FOUND;
}
const bool found_in_db = db_cuckoo_execute(client, key, mask, aaa1bbbbbbbbbbbbbbbbbbbb3aaa,
false, &comp_prio, hit_counter, read_unit_valid, &read_unit, murmur_bucket, options->narrow);
if (found_in_db) {
return 0;
}
client->failed_updates++;
return CAM_ERROR_KEY_NOT_FOUND;
}
int a1aaaread_key(const a1aaat *client, const aaaaaaaaaaaaa1aaat *key, aaaaaaaaaaaaaaaa1aaaaaaaaaaaaaaaabaaaaaaaaaaaaaaaaaaaaaaaaaaaa3aaat *response, const aaaaaaaaaaaaa1aaat *mask,
const cam_options_t *options)
{
if (mask != NULL) {
const uint16_t key_width = cam_config_get_key_width(client->conf);
int status = check_masked_key_bits(mask, key, key_width);
if (status != 0)
return status;
}
uint16_t read_unit;
uint32_t murmur_bucket;
bool read_unit_valid;
const uint8_t hit_counter = cache_hit(client, key, mask, &read_unit_valid, &read_unit, options, &murmur_bucket);
if (hit_counter == 0)
return CAM_ERROR_KEY_NOT_FOUND;
const bool found_in_db = db_cuckoo_execute((a1aaat *) client, key, mask, aaa1aaaREAD,
false, response, hit_counter, read_unit_valid, &read_unit, murmur_bucket, options->narrow);
if (found_in_db) {
return 0;
}
return CAM_ERROR_KEY_NOT_FOUND;
}
static int add_key(a1aaat *client, const aaaaaaaaaaaaa1aaat *key, const aaaaaaaaaaaaa1aaat *ternary_mask,
const aaaaaaaaaaaaaaaa1aaaaaaaaaaaaaaaabaaaaaaaaaaaaaaaaaaaaaaaaaaaa3aaat *key_prio,
const aaaaaaaaaaaaa1aaat *mask, uint8_t range_valid, uint8_t mask_id)
{
uint16_t unit;
const int status = add_key_to_open(client, key, ternary_mask, key_prio, mask,
&unit, range_valid,
mask_id);
if (status == 0) {
return 0;
}
else if (status == CAM_ERROR_FULL) {
uint16_t unit = 0;
bool success = find_open_with_equal_mask(client, &unit,
mask, range_valid, mask_id);
assert(success);
uint16_t new_unit = 0;
if (!find_unused(client, &new_unit)) {
return CAM_ERROR_FULL;
}
write_mask(client, mask, new_unit, range_valid, mask_id);
set_closed(client, unit);
set_open(client, new_unit);
const int new_status = add_key_to_open(client, key, ternary_mask, key_prio, mask,
&new_unit,
range_valid, mask_id);
assert(new_status == 0);
return 0;
}
else if (status == CAM_ERROR_NO_OPEN) {
uint16_t start_value = 0;
if (find_unused(client, &start_value)) {
set_open(client, start_value);
write_mask(client, mask, start_value, range_valid, mask_id);
const int new_status = add_key_to_open(client, key, ternary_mask, key_prio, mask, &unit,
range_valid, mask_id);
assert(new_status == 0);
assert(unit == start_value);
return 0;
}
else {
return CAM_ERROR_FULL;
}
}
assert(false);
return status;
}
uint32_t a1aaaaaaaaaaaaaaaabaaaaaaaaaaaa3aaaaaaaaaaaaaaaabaaaaaaaaaaaaaaaaaaaaaaaaaaaa3aaacurrent_num_entries(const a1aaat *client)
{
uint32_t number_of_entries = 0;
uint16_t start_value = 0;
while (find_open_or_closed(client, &start_value)) {
const aaa1aaat *phm = get_phm(client, start_value);
const uint32_t number_of_keys = aaa1aaaaaaaaaaaaaaaabaaaaaaaaaaaa3aaaaaaaaaaaaaaaabaaaaaaaaaaaaaaaaaaaaaaaaaaaa3aaaaaaaaaaaaaaabaaaaaaaaaaaaaaaa4aaaber_of_keys(phm);
number_of_entries = number_of_entries + number_of_keys;
start_value++;
}
if (!a1aaaaaaaaaaaaaaabaaaaaaaaaaaa3aaaaaaaaaaaaaaaabaaaaaaaaaaaaaaaaaaaaaaaaaaaa3aaaaaaaaaaaaaaaabaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaa3aaa(client))
assert(client->num_entries == number_of_entries);
return number_of_entries;
}
void a1aaatable_print(const a1aaat *client)
{
uint32_t number_of_entries = 0;
uint16_t start_value = 0;
while (find_open_or_closed(client, &start_value)) {
const aaa1aaat *phm = get_phm(client, start_value);
const uint16_t number_of_keys = aaa1aaaaaaaaaaaaaaaabaaaaaaaaaaaa3aaaaaaaaaaaaaaaabaaaaaaaaaaaaaaaaaaaaaaaaaaaa3aaaaaaaaaaaaaaabaaaaaaaaaaaaaaaa4aaaber_of_keys(phm);
number_of_entries = number_of_entries + number_of_keys;
aaa1aaaaaaaaaaaaaaaabaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaa3aaa(phm);
start_value++;
}
printf(
           "\nNumber_of_entries = %d", number_of_entries);
}
int a1bbbbbbbbbbbbbbbbbbbbbb3aaaokup(a1aaat *client, const aaaaaaaaaaaaa1aaat *key, aaaaaaaaaaaaaaaa1aaaaaaaaaaaaaaaabaaaaaaaaaaaaaaaaaaaaaaaaaaaa3aaat *out_prio_resp, bool narrow_key)
{
aaaaaaaaaaaaaaaa1aaaaaaaaaaaaaaaabaaaaaaaaaaaaaaaaaaaaaaaaaaaa3aaat lowest_prio;
memset(&lowest_prio, 0xff, sizeof(aaaaaaaaaaaaaaaa1aaaaaaaaaaaaaaaabaaaaaaaaaaaaaaaaaaaaaaaaaaaa3aaat));
uint16_t unit = 0;
const uint8_t prio_width = a1aaaaaaaaaaaaaaaabaaaaaaaaaaaa3aaaaaaaaaaaaaaaabaaaaaaaaaaaaaaaaaaaaaaaaaaaa3aaaaaaaaaaaaaaabaaaaaaaaaaaaaaaaa4aaaaaaaaaaaaaaaabaaaaaaaaaaaaaaaaaaaaaaaaaaaa4aaawidth(client);
const uint16_t response_width = a1aaaaaaaaaaaaaaaabaaaaaaaaaaaa3aaaaaaaaaaaaaaaabaaaaaaaaaaaaaaaaaaaaaaaaaaaa3aaaaaaaaaaaaaaaabaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaa3aaaaaaaaaaaaaaaabaaaaaaaaaaaaaaaaaaaaaaaaaaaa4aaawidth(client);
bool found = false;
while (find_open_or_closed(client, &unit)) {
aaa1aaat *phm = get_phm(client, unit);
aaaaaaaaaaaaaaaa1aaaaaaaaaaaaaaaabaaaaaaaaaaaaaaaaaaaaaaaaaaaa3aaat prio_resp;
memset(&prio_resp, 0, sizeof(aaaaaaaaaaaaaaaa1aaaaaaaaaaaaaaaabaaaaaaaaaaaaaaaaaaaaaaaaaaaa3aaat));
bool success = false;
if ((client->conf->instance_type == STCAM))
success = aaa1bbbbbbbbbbbbbbbbbbbbbbbbbbbbbbbbbbbbbb3aaaaaaaaaaaaaaaabaaaaaaaaaaaaaaaaaaaaaaaaaaaa4bbbbbbbbbbbbbbbbbbbbbb4aaaokup(phm, key, &prio_resp, narrow_key);
else if ((client->conf->instance_type == TCAM))
success = aaa1bbbbbbbbbbbbbbbbbbbbbb3aaaokup(phm, key, &prio_resp);
else
assert(false);
if (success) {
found = true;
if (prio_width > 0) {
uint32_t prio_resp_prio;
uint32_t lowest_prio_prio;
cam_read_field((uint32_t *) &prio_resp, response_width, response_width + prio_width - 1,
&prio_resp_prio);
cam_read_field((uint32_t *) &lowest_prio, response_width, response_width + prio_width - 1,
&lowest_prio_prio);
if (prio_resp_prio <= lowest_prio_prio) {
lowest_prio = prio_resp;
}
} else {
*out_prio_resp = prio_resp;
return 0;
}
}
unit++;
}
if (found) {
*out_prio_resp = lowest_prio;
return 0;
}
return CAM_ERROR_KEY_NOT_FOUND;
}
#define aaaaaa1aaaHaa1aaaDATA_WRITE_START_REG 0x00
#define aaaaaa1aaaHaa1aaaDATA_READ_START_REG 0xa0
#define aaaaaa1aaaHaa1bbbbbbbbbbbbbbbbbbbbbbbbbbbbbbbb3aaaRESS_REG 0x80
#define aaaaaa1aaaHaa1aaaCMD_REG 0x84
#define aaaaaa1aaaHaa1aaaSLVERR_ADDRESS_REG 0x8c
#define aaaaaa1aaaHaa1aaaNARROW_DEF_RESP_ENABLE_REG 0x8c
#define aaaaaa1aaaHaa1aaaNARROW_DEF_RESP_DATA_START_REG 0x200
void a1aaahaa1aaaaaaaaaaaaaaaabaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaa3aaaaaaaaaaaaaaaabaaaaaaaaaaaaaaaaaaaaaaaaaaaa4aaaaaaaaaaaaaaaabaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaa4aaaaaaaaaaaaaaaabaaaaaaaaaaaaaaaaaaaaaaaaaaaa5aaaread(a1aaat *client, uint32_t address, uint32_t data[])
{
client->conf->arg.hw_write_function(client->conf->ctx, aaaaaa1aaaHaa1bbbbbbbbbbbbbbbbbbbbbbbbbbbbbbbb3aaaRESS_REG,
address);
client->conf->arg.hw_write_function(client->conf->ctx, aaaaaa1aaaHaa1aaaCMD_REG, 0);
for (uint8_t slice = 0; slice < 4; slice++) {
for (uint16_t j = 0; j < 8; j++) {
client->conf->arg.hw_read_function(client->conf->ctx,
aaaaaa1aaaHaa1aaaDATA_READ_START_REG + j * 4, &data[slice * 8 + j]);
}
}
}
void a1aaahaa1aaaaaaaaaaaaaaaabaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaa3aaaaaaaaaaaaaaaabaaaaaaaaaaaaaaaaaaaaaaaaaaaa4aaaaaaaaaaaaaaaabaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaa4aaaaaaaaaaaaaaaabaaaaaaaaaaaaaaaaaaaaaaaaaaaa5aaaaaaaaaaaaaaaabaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaa5aaa(a1aaat *client, uint32_t address, uint32_t data[], uint8_t write_mask,
operation_t operation,
bool bit511or255)
{
const uint8_t num_lists_per_read = a1aaaaaaaaaaaaaaaabaaaaaaaaaaaa3aaaaaaaaaaaaaaaabaaaaaaaaaaaaaaaaaaaaaaaaaaaa3aaaaaaaaaaaaaaabaaaaaaaaaaaaaaaa4aaaaaaaaaaaaaaaabaaaaaaaaaaaaaaaaaaaaaaaaaaaa4aaaaaaaaaaaaabaaaaaaaaaaaaaaaaa5aaas_per_read(client);
if (client->conf->arg.hw_write_start_sequence_function != NULL)
client->conf->arg.hw_write_start_sequence_function(client->conf->ctx);
client->conf->arg.hw_write_function(client->conf->ctx, aaaaaa1aaaHaa1bbbbbbbbbbbbbbbbbbbbbbbbbbbbbbbb3aaaRESS_REG,
address);
uint8_t slice_shift = write_mask;
for (uint8_t slice = 0; slice < 4; slice++) {
if ((slice_shift & 1) == 0) {
slice_shift = slice_shift >> 1;
continue;
}
slice_shift = slice_shift >> 1;
assert(num_lists_per_read == 1 || num_lists_per_read == 2 || num_lists_per_read == 4);
uint8_t capped_slice = slice;
if (num_lists_per_read == 2) {
if (slice > 1)
capped_slice = slice - 2;
} else if (num_lists_per_read == 4) {
capped_slice = 0;
}
for (uint16_t i = 0; i < 8; i++) {
const uint32_t idx = slice * 8 + i;
const uint32_t reg = capped_slice * 8 + i;
assert(((reg * 4) < 0x40) || (num_lists_per_read == 1));
client->conf->arg.hw_write_function(client->conf->ctx,
aaaaaa1aaaHaa1aaaDATA_WRITE_START_REG + reg * 4, data[idx]);
}
}
uint32_t cmd = (write_mask << 4) | 1;
if (operation == UPDATE) {
assert(!bit511or255);
cmd = cmd | 4;
cmd = cmd | (client->conf->arg.vc_id << 8); 
} else if (operation == DELETE) {
cmd = cmd | 2; 
if (bit511or255) {
if ((write_mask == 0xf) || (write_mask == 0x3) || (write_mask == 0xc)) {
cmd = cmd | 8; 
} else {
assert(false);
}
}
cmd = cmd | (client->conf->arg.vc_id << 8); 
} else {
assert(!bit511or255);
assert(operation == OTHER);
}
client->conf->arg.hw_write_function(client->conf->ctx, aaaaaa1aaaHaa1aaaCMD_REG, cmd);
if (a1aaaaaaaaaaaaaaaabaaaaaaaaaaaa3aaaaaaaaaaaaaaaabaaaaaaaaaaaaaaaaaaaaaaaaaaaa3bbbbbbbbbbbbbbbbbbbbbbbbbbbbbbbbbbbbb3aaaaaaaaaaaaaaaabaaaaaaaaaaaaaaaaaaaaaaaaaaaa4aaaflags(client) & CAM_DEBUG_VERIFY_WR) {
char message[256];
uint32_t read_data[32];
a1aaahaa1aaaaaaaaaaaaaaaabaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaa3aaaaaaaaaaaaaaaabaaaaaaaaaaaaaaaaaaaaaaaaaaaa4aaaaaaaaaaaaaaaabaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaa4aaaaaaaaaaaaaaaabaaaaaaaaaaaaaaaaaaaaaaaaaaaa5aaaread(client, address, &read_data[0]);
uint8_t slice_shift = write_mask;
for (uint8_t slice = 0; slice < 4; slice++) {
if ((slice_shift & 1) == 0) {
slice_shift = slice_shift >> 1;
continue;
}
slice_shift = slice_shift >> 1;
for (uint16_t j = 0; j < 8; j++) {
const uint32_t idx = slice * 8 + j;
if (read_data[idx] != data[idx]) {
sprintf(message,
                           "CAM_DEBUG_VERIFY_WR  address = 0x%08" PRIx32 "  cmd = 0x%08" PRIx32 "  data 0x%02" PRIx8 " = 0x%08" PRIx32 " expected data = 0x%08" PRIx32 "     FAIL",
address, cmd, idx, read_data[idx], data[idx]);
a1aaaaaaaaaaaaaaaabaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaa3aaaaaaaaaaaaaaaabaaaaaaaaaaaaaaaaaaaaaaaaaaaa4aaaerror(client, message);
} else if (a1aaaaaaaaaaaaaaaabaaaaaaaaaaaa3aaaaaaaaaaaaaaaabaaaaaaaaaaaaaaaaaaaaaaaaaaaa3bbbbbbbbbbbbbbbbbbbbbbbbbbbbbbbbbbbbb3aaaaaaaaaaaaaaaabaaaaaaaaaaaaaaaaaaaaaaaaaaaa4aaaflags(client) & CAM_DEBUG_VERBOSE_VERIFY) {
sprintf(message,
                           "CAM_DEBUG_VERIFY_WR  address = 0x%08" PRIx32 "  cmd = 0x%08" PRIx32 "  data 0x%02" PRIx8 " = 0x%08" PRIx32 " expected data = 0x%08" PRIx32 "     OK",
address, cmd, idx, read_data[idx], data[idx]);
a1aaaaaaaaaaaaaaaabaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaa3aaaaaaaaaaaaaaaabaaaaaaaaaaaaaaaaaaaaaaaaaaaa4aaainfo(client, message);
}
}
}
}
if (client->conf->arg.hw_write_end_sequence_function != NULL)
client->conf->arg.hw_write_end_sequence_function(client->conf->ctx);
}
void a1aaaaaaaaaaaaaaaabaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaa3aaaaaaaaaaaaaaaabaaaaaaaaaaaaaaaaaaaaaaaaaaaa4aaaaaaaaaaaaaaaabaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaa4aaa(a1aaat *client, uint32_t address, uint64_t data)
{
uint32_t hi_addr = address & aaaaaa1bbbbbbbbbbbbbbbbbbbbb3aaaaaaaaaaaaaaaabaaaaaaaaaaaaaaaaaaaaaaaaaaaa4bbbbbbbbbbbbbbbbbbbbbbbbbbbbbbbb4aaaR_MASK;
if (hi_addr != client->prev_hi_addr) {
client->prev_hi_addr = hi_addr;
client->conf->arg.hw_write_function(client->conf->ctx, aaaaaa1aaaHA_BASE, address >> aaaaaa1bbbbbbbbbbbbbbbbbbbbb3aaaaaaaaaaaaaaaabaaaaaaaaaaaaaaaaaaaaaaaaaaaa4bbbbbbbbbbbbbbbbbbbbbbbbbbbbbbbb4aaaR_OFFSET);
}
uint32_t hi_data = data >> 32;
if (hi_data != client->prev_hi_data) {
client->prev_hi_data = hi_data;
client->conf->arg.hw_write_function(client->conf->ctx, aaaaaa1aaaHD_BASE, hi_data);
}
uint32_t lo_addr = address & aaaaaa1bbbbbbbbbbbbbbbbbbbbbb3aaaaaaaaaaaaaaaabaaaaaaaaaaaaaaaaaaaaaaaaaaaa4bbbbbbbbbbbbbbbbbbbbbbbbbbbbbbbb4aaaR_MASK;
client->conf->arg.hw_write_function(client->conf->ctx, lo_addr, (uint32_t) data);
if (a1aaaaaaaaaaaaaaaabaaaaaaaaaaaa3aaaaaaaaaaaaaaaabaaaaaaaaaaaaaaaaaaaaaaaaaaaa3bbbbbbbbbbbbbbbbbbbbbbbbbbbbbbbbbbbbb3aaaaaaaaaaaaaaaabaaaaaaaaaaaaaaaaaaaaaaaaaaaa4aaaflags(client) & CAM_DEBUG_VERIFY_WR) {
char message[500];
uint64_t read_data;
a1aaaaaaaaaaaaaaaabaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaa3aaaaaaaaaaaaaaaabaaaaaaaaaaaaaaaaaaaaaaaaaaaa4aaaread(client, address, &read_data);
if (read_data != data) {
           sprintf(message, "CAM_DEBUG_VERIFY_WR  address = 0x%08" PRIx32 "  data = 0x%016" PRIx64 " expected data = 0x%016" PRIx64 "     FAIL",
address, read_data, data);
a1aaaaaaaaaaaaaaaabaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaa3aaaaaaaaaaaaaaaabaaaaaaaaaaaaaaaaaaaaaaaaaaaa4aaaerror(client, message);
} else if (a1aaaaaaaaaaaaaaaabaaaaaaaaaaaa3aaaaaaaaaaaaaaaabaaaaaaaaaaaaaaaaaaaaaaaaaaaa3bbbbbbbbbbbbbbbbbbbbbbbbbbbbbbbbbbbbb3aaaaaaaaaaaaaaaabaaaaaaaaaaaaaaaaaaaaaaaaaaaa4aaaflags(client) & CAM_DEBUG_VERBOSE_VERIFY) {
           sprintf(message, "CAM_DEBUG_VERIFY_WR  address = 0x%08" PRIx32 "  data = 0x%016" PRIx64 " expected data = 0x%016" PRIx64 "     OK",
address, read_data, data);
a1aaaaaaaaaaaaaaaabaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaa3aaaaaaaaaaaaaaaabaaaaaaaaaaaaaaaaaaaaaaaaaaaa4aaainfo(client, message);
}
}
}
void a1aaaaaaaaaaaaaaaabaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaa3aaaaaaaaaaaaaaaabaaaaaaaaaaaaaaaaaaaaaaaaaaaa4aaaread(a1aaat *client, uint32_t address, uint64_t *data)
{
uint32_t lo_addr = address & aaaaaa1bbbbbbbbbbbbbbbbbbbbbb3aaaaaaaaaaaaaaaabaaaaaaaaaaaaaaaaaaaaaaaaaaaa4bbbbbbbbbbbbbbbbbbbbbbbbbbbbbbbb4aaaR_MASK;
uint32_t hi_addr = address & aaaaaa1bbbbbbbbbbbbbbbbbbbbb3aaaaaaaaaaaaaaaabaaaaaaaaaaaaaaaaaaaaaaaaaaaa4bbbbbbbbbbbbbbbbbbbbbbbbbbbbbbbb4aaaR_MASK;
if (hi_addr != client->prev_hi_addr) {
client->prev_hi_addr = hi_addr;
client->conf->arg.hw_write_function(client->conf->ctx, aaaaaa1aaaHA_BASE, address >> aaaaaa1bbbbbbbbbbbbbbbbbbbbb3aaaaaaaaaaaaaaaabaaaaaaaaaaaaaaaaaaaaaaaaaaaa4bbbbbbbbbbbbbbbbbbbbbbbbbbbbbbbb4aaaR_OFFSET);
}
uint32_t *data32 = (uint32_t *) data;
client->conf->arg.hw_read_function(client->conf->ctx, lo_addr, data32);
lo_addr = (address + 4) & aaaaaa1bbbbbbbbbbbbbbbbbbbbbb3aaaaaaaaaaaaaaaabaaaaaaaaaaaaaaaaaaaaaaaaaaaa4bbbbbbbbbbbbbbbbbbbbbbbbbbbbbbbb4aaaR_MASK;
hi_addr = (address + 4) & aaaaaa1bbbbbbbbbbbbbbbbbbbbb3aaaaaaaaaaaaaaaabaaaaaaaaaaaaaaaaaaaaaaaaaaaa4bbbbbbbbbbbbbbbbbbbbbbbbbbbbbbbb4aaaR_MASK;
if (hi_addr != client->prev_hi_addr) {
client->prev_hi_addr = hi_addr;
client->conf->arg.hw_write_function(client->conf->ctx, aaaaaa1aaaHA_BASE, address >> aaaaaa1bbbbbbbbbbbbbbbbbbbbb3aaaaaaaaaaaaaaaabaaaaaaaaaaaaaaaaaaaaaaaaaaaa4bbbbbbbbbbbbbbbbbbbbbbbbbbbbbbbb4aaaR_OFFSET);
}
data32++;
client->conf->arg.hw_read_function(client->conf->ctx, lo_addr, data32);
}
int a1aaaread_and_clear_ecc_counters(a1aaat *client, uint32_t *corrected_single_bit_errors,
uint32_t *detected_double_bit_errors)
{
if (a1aaaaaaaaaaaaaaabaaaaaaaaaaaa3aaaaaaaaaaaaaaaabaaaaaaaaaaaaaaaaaaaaaaaaaaaa3aaahbmbcam(client))
return CAM_ERROR_UNSUPPORTED_COMMAND;
uint64_t data = 0;
a1aaaaaaaaaaaaaaaabaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaa3aaaaaaaaaaaaaaaabaaaaaaaaaaaaaaaaaaaaaaaaaaaa4aaaread(client, aaaaaa1aaaECC_CNT_BASE, &data);
*corrected_single_bit_errors = data & 0xffffffff;
*detected_double_bit_errors = (data >> 32) & 0xffffffff;
return 0;
}
int a1aaaread_and_clear_ecc_addresses(a1aaat *client,
uint32_t *failing_address_single_bit_error,
uint32_t *failing_address_double_bit_error)
{
if (a1aaaaaaaaaaaaaaabaaaaaaaaaaaa3aaaaaaaaaaaaaaaabaaaaaaaaaaaaaaaaaaaaaaaaaaaa3aaahbmbcam(client))
return CAM_ERROR_UNSUPPORTED_COMMAND;
uint64_t data = 0;
const uint16_t num_units = a1aaaaaaaaaaaaaaaabaaaaaaaaaaaa3aaaaaaaaaaaaaaaabaaaaaaaaaaaaaaaaaaaaaaaaaaaa3aaaaaaaaaaaaaaabaaaaaaaaaaaaaaaa4aaaaaaaaaaaaaaaabaaaaaaaaaaaaaaaaaaaaaaaaaaaa4aaaaaaaaaaaabaaaaaaaaaaaaaaaaa5aaas(client);
for (uint16_t unit = 0; unit < num_units; unit++) {
const aaa1aaat *phm = client->unit[unit].phm;
data = aaa1aaaread_and_clear_ecc_addresses(phm);
if (data != UINT64_MAX)
break;
}
*failing_address_single_bit_error = data & 0xffffffff;
*failing_address_double_bit_error = (data >> 32) & 0xffffffff;
return 0;
}
void a1bbbbbbbbbbbbbbbbbb3aaaaaaaaaaaaaaaabaaaaaaaaaaaaaaaaaaaaaaaaaaaa4bbbbbbbbbbbbbbbbbbbbbbbbbbbbbbbbbbbbb4aaaaaaaaaaaaaaaabaaaaaaaaaaaaaaaaaaaaaaaaaaaa5aaaflags(const a1aaat *client, uint32_t debug_flags)
{
client->conf->arg.debug_flags = debug_flags;
}
uint32_t a1aaaaaaaaaaaaaaaabaaaaaaaaaaaa3aaaaaaaaaaaaaaaabaaaaaaaaaaaaaaaaaaaaaaaaaaaa3bbbbbbbbbbbbbbbbbbbbbbbbbbbbbbbbbbbbb3aaaaaaaaaaaaaaaabaaaaaaaaaaaaaaaaaaaaaaaaaaaa4aaaflags(const a1aaat *client)
{
return client->conf->arg.debug_flags;
}
void a1aaaaaaaaaaaaaaaabaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaa3aaaaaaaaaaaaaaaabaaaaaaaaaaaaaaaaaaaaaaaaaaaa4aaaerror(const a1aaat *client, char *message) {
client->conf->arg.error_print_function(client->conf->ctx, message);
}
void a1aaaaaaaaaaaaaaaabaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaa3aaaaaaaaaaaaaaaabaaaaaaaaaaaaaaaaaaaaaaaaaaaa4aaainfo(const a1aaat *client, char *message) {
client->conf->arg.info_print_function(client->conf->ctx, message);
}
static void verify_config(a1aaat *client)
{
char sub_str[500];
char message[500];
cam_config_t hw_conf;
cam_config_t *sw_conf = client->conf;
uint64_t data = 0;
a1aaaaaaaaaaaaaaaabaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaa3aaaaaaaaaaaaaaaabaaaaaaaaaaaaaaaaaaaaaaaaaaaa4aaaread(client, aaaaaa1bbbbbbbbbbbbbbbbbbbbbbbbbbbbbbbbbbbbbbb3aaaaaaaaaaaaaaaabaaaaaaaaaaaaaaaaaaaaaaaaaaaa4aaaaaaaaaaaaaaaabaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaa4aaa, &data);
hw_conf.key_width = data & 0xffffffff;
hw_conf.prio_width = (data >> 32) & 0xffffffff;
a1aaaaaaaaaaaaaaaabaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaa3aaaaaaaaaaaaaaaabaaaaaaaaaaaaaaaaaaaaaaaaaaaa4aaaread(client, aaaaaa1bbbbbbbbbbbbbbbbbbbbbbbbbbbbbbbbbbbbbbb3aaaaaaaaaaaaaaaabaaaaaaaaaaaaaaaaaaaaaaaaaaaa4aaaaaaaaaaaaaaaabaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaa4aaa + 2 * aaaaaa1bbbbbbbbbbbbbbbbbbbbbbbbbbbbbbbbbbbbbbb3aaaaaaaaaaaaaaaabaaaaaaaaaaaaaaaaaaaaaaaaaaaa4aaaWORD , &data);
hw_conf.arg.response_width = data & 0xffffffff;
hw_conf.num_units = (data >> 32) & 0xffffffff;
a1aaaaaaaaaaaaaaaabaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaa3aaaaaaaaaaaaaaaabaaaaaaaaaaaaaaaaaaaaaaaaaaaa4aaaread(client, aaaaaa1bbbbbbbbbbbbbbbbbbbbbbbbbbbbbbbbbbbbbbb3aaaaaaaaaaaaaaaabaaaaaaaaaaaaaaaaaaaaaaaaaaaa4aaaaaaaaaaaaaaaabaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaa4aaa + 4 * aaaaaa1bbbbbbbbbbbbbbbbbbbbbbbbbbbbbbbbbbbbbbb3aaaaaaaaaaaaaaaabaaaaaaaaaaaaaaaaaaaaaaaaaaaa4aaaWORD , &data);
hw_conf.num_slots = data & 0xffffffff;
hw_conf.num_units *= hw_conf.num_slots;
hw_conf.list_length = (data >> 32) & 0xffffffff;
a1aaaaaaaaaaaaaaaabaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaa3aaaaaaaaaaaaaaaabaaaaaaaaaaaaaaaaaaaaaaaaaaaa4aaaread(client, aaaaaa1bbbbbbbbbbbbbbbbbbbbbbbbbbbbbbbbbbbbbbb3aaaaaaaaaaaaaaaabaaaaaaaaaaaaaaaaaaaaaaaaaaaa4aaaaaaaaaaaaaaaabaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaa4aaa + 6 * aaaaaa1bbbbbbbbbbbbbbbbbbbbbbbbbbbbbbbbbbbbbbb3aaaaaaaaaaaaaaaabaaaaaaaaaaaaaaaaaaaaaaaaaaaa4aaaWORD , &data);
if (hw_conf.num_slots != 0) {
hw_conf.num_lists = (data & 0xffffffff) / hw_conf.num_slots;
} else {
hw_conf.num_lists = 0;
}
hw_conf.instance_type = (data >> 32) & 0xffffffff;
a1aaaaaaaaaaaaaaaabaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaa3aaaaaaaaaaaaaaaabaaaaaaaaaaaaaaaaaaaaaaaaaaaa4aaaread(client, aaaaaa1bbbbbbbbbbbbbbbbbbbbbbbbbbbbbbbbbbbbbbb3aaaaaaaaaaaaaaaabaaaaaaaaaaaaaaaaaaaaaaaaaaaa4aaaaaaaaaaaaaaaabaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaa4aaa + 32 * aaaaaa1bbbbbbbbbbbbbbbbbbbbbbbbbbbbbbbbbbbbbbb3aaaaaaaaaaaaaaaabaaaaaaaaaaaaaaaaaaaaaaaaaaaa4aaaWORD , &data);
hw_conf.version = data;
bool err;
err = sw_conf->version != hw_conf.version;
if (err || (a1aaaaaaaaaaaaaaaabaaaaaaaaaaaa3aaaaaaaaaaaaaaaabaaaaaaaaaaaaaaaaaaaaaaaaaaaa3bbbbbbbbbbbbbbbbbbbbbbbbbbbbbbbbbbbbb3aaaaaaaaaaaaaaaabaaaaaaaaaaaaaaaaaaaaaaaaaaaa4aaaflags(client) & CAM_DEBUG_VERBOSE_VERIFY)) {
       sprintf(sub_str, "CAM_DEBUG_CONFIG  version = %0d.%0d (expected %0d.%0d)",
hw_conf.version >> 8, hw_conf.version & 0xff,
sw_conf->version >> 8, sw_conf->version & 0xff);
       sprintf(message, "%-70s%s", sub_str, err ? "FAIL" : "OK");
if (err) {
a1aaaaaaaaaaaaaaaabaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaa3aaaaaaaaaaaaaaaabaaaaaaaaaaaaaaaaaaaaaaaaaaaa4aaaerror(client, message);
} else {
a1aaaaaaaaaaaaaaaabaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaa3aaaaaaaaaaaaaaaabaaaaaaaaaaaaaaaaaaaaaaaaaaaa4aaainfo(client, message);
}
}
err = sw_conf->key_width != hw_conf.key_width;
if (err || (a1aaaaaaaaaaaaaaaabaaaaaaaaaaaa3aaaaaaaaaaaaaaaabaaaaaaaaaaaaaaaaaaaaaaaaaaaa3bbbbbbbbbbbbbbbbbbbbbbbbbbbbbbbbbbbbb3aaaaaaaaaaaaaaaabaaaaaaaaaaaaaaaaaaaaaaaaaaaa4aaaflags(client) & CAM_DEBUG_VERBOSE_VERIFY)) {
       sprintf(sub_str, "CAM_DEBUG_CONFIG  key width = %0d (expected %0d)",
hw_conf.key_width, sw_conf->key_width);
       sprintf(message, "%-70s%s", sub_str, err ? "FAIL" : "OK");
if (err) {
a1aaaaaaaaaaaaaaaabaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaa3aaaaaaaaaaaaaaaabaaaaaaaaaaaaaaaaaaaaaaaaaaaa4aaaerror(client, message);
} else {
a1aaaaaaaaaaaaaaaabaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaa3aaaaaaaaaaaaaaaabaaaaaaaaaaaaaaaaaaaaaaaaaaaa4aaainfo(client, message);
}
}
err = sw_conf->prio_width != hw_conf.prio_width;
if (err || (a1aaaaaaaaaaaaaaaabaaaaaaaaaaaa3aaaaaaaaaaaaaaaabaaaaaaaaaaaaaaaaaaaaaaaaaaaa3bbbbbbbbbbbbbbbbbbbbbbbbbbbbbbbbbbbbb3aaaaaaaaaaaaaaaabaaaaaaaaaaaaaaaaaaaaaaaaaaaa4aaaflags(client) & CAM_DEBUG_VERBOSE_VERIFY)) {
       sprintf(sub_str, "CAM_DEBUG_CONFIG  prio width = %0d (expected %0d)",
hw_conf.prio_width, sw_conf->prio_width);
       sprintf(message, "%-70s%s", sub_str, err ? "FAIL" : "OK");
if (err) {
a1aaaaaaaaaaaaaaaabaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaa3aaaaaaaaaaaaaaaabaaaaaaaaaaaaaaaaaaaaaaaaaaaa4aaaerror(client, message);
} else {
a1aaaaaaaaaaaaaaaabaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaa3aaaaaaaaaaaaaaaabaaaaaaaaaaaaaaaaaaaaaaaaaaaa4aaainfo(client, message);
}
}
err = sw_conf->arg.response_width != hw_conf.arg.response_width;
if (err || (a1aaaaaaaaaaaaaaaabaaaaaaaaaaaa3aaaaaaaaaaaaaaaabaaaaaaaaaaaaaaaaaaaaaaaaaaaa3bbbbbbbbbbbbbbbbbbbbbbbbbbbbbbbbbbbbb3aaaaaaaaaaaaaaaabaaaaaaaaaaaaaaaaaaaaaaaaaaaa4aaaflags(client) & CAM_DEBUG_VERBOSE_VERIFY)) {
       sprintf(sub_str, "CAM_DEBUG_CONFIG  response width = %0d (expected %0d)",
hw_conf.arg.response_width, sw_conf->arg.response_width);
       sprintf(message, "%-70s%s", sub_str, err ? "FAIL" : "OK");
if (err) {
a1aaaaaaaaaaaaaaaabaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaa3aaaaaaaaaaaaaaaabaaaaaaaaaaaaaaaaaaaaaaaaaaaa4aaaerror(client, message);
} else {
a1aaaaaaaaaaaaaaaabaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaa3aaaaaaaaaaaaaaaabaaaaaaaaaaaaaaaaaaaaaaaaaaaa4aaainfo(client, message);
}
}
err = sw_conf->num_units != hw_conf.num_units;
if (err || (a1aaaaaaaaaaaaaaaabaaaaaaaaaaaa3aaaaaaaaaaaaaaaabaaaaaaaaaaaaaaaaaaaaaaaaaaaa3bbbbbbbbbbbbbbbbbbbbbbbbbbbbbbbbbbbbb3aaaaaaaaaaaaaaaabaaaaaaaaaaaaaaaaaaaaaaaaaaaa4aaaflags(client) & CAM_DEBUG_VERBOSE_VERIFY)) {
       sprintf(sub_str, "CAM_DEBUG_CONFIG  number of logical units = %0d (expected %0d)",
hw_conf.num_units, sw_conf->num_units);
       sprintf(message, "%-70s%s", sub_str, err ? "FAIL" : "OK");
if (err) {
a1aaaaaaaaaaaaaaaabaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaa3aaaaaaaaaaaaaaaabaaaaaaaaaaaaaaaaaaaaaaaaaaaa4aaaerror(client, message);
} else {
a1aaaaaaaaaaaaaaaabaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaa3aaaaaaaaaaaaaaaabaaaaaaaaaaaaaaaaaaaaaaaaaaaa4aaainfo(client, message);
}
}
err = sw_conf->num_slots != hw_conf.num_slots;
if (err || (a1aaaaaaaaaaaaaaaabaaaaaaaaaaaa3aaaaaaaaaaaaaaaabaaaaaaaaaaaaaaaaaaaaaaaaaaaa3bbbbbbbbbbbbbbbbbbbbbbbbbbbbbbbbbbbbb3aaaaaaaaaaaaaaaabaaaaaaaaaaaaaaaaaaaaaaaaaaaa4aaaflags(client) & CAM_DEBUG_VERBOSE_VERIFY)) {
       sprintf(sub_str, "CAM_DEBUG_CONFIG  number of time slots = %0d (expected %0d)",
hw_conf.num_slots, sw_conf->num_slots);
       sprintf(message, "%-70s%s", sub_str, err ? "FAIL" : "OK");
if (err) {
a1aaaaaaaaaaaaaaaabaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaa3aaaaaaaaaaaaaaaabaaaaaaaaaaaaaaaaaaaaaaaaaaaa4aaaerror(client, message);
} else {
a1aaaaaaaaaaaaaaaabaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaa3aaaaaaaaaaaaaaaabaaaaaaaaaaaaaaaaaaaaaaaaaaaa4aaainfo(client, message);
}
}
err = sw_conf->num_lists != hw_conf.num_lists;
if (err || (a1aaaaaaaaaaaaaaaabaaaaaaaaaaaa3aaaaaaaaaaaaaaaabaaaaaaaaaaaaaaaaaaaaaaaaaaaa3bbbbbbbbbbbbbbbbbbbbbbbbbbbbbbbbbbbbb3aaaaaaaaaaaaaaaabaaaaaaaaaaaaaaaaaaaaaaaaaaaa4aaaflags(client) & CAM_DEBUG_VERBOSE_VERIFY)) {
       sprintf(sub_str, "CAM_DEBUG_CONFIG  RAM addresses (logical) = %0d (expected %0d)",
hw_conf.num_lists, sw_conf->num_lists);
       sprintf(message, "%-70s%s", sub_str, err ? "FAIL" : "OK");
if (err) {
a1aaaaaaaaaaaaaaaabaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaa3aaaaaaaaaaaaaaaabaaaaaaaaaaaaaaaaaaaaaaaaaaaa4aaaerror(client, message);
} else {
a1aaaaaaaaaaaaaaaabaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaa3aaaaaaaaaaaaaaaabaaaaaaaaaaaaaaaaaaaaaaaaaaaa4aaainfo(client, message);
}
}
err = sw_conf->list_length != hw_conf.list_length;
if (err || (a1aaaaaaaaaaaaaaaabaaaaaaaaaaaa3aaaaaaaaaaaaaaaabaaaaaaaaaaaaaaaaaaaaaaaaaaaa3bbbbbbbbbbbbbbbbbbbbbbbbbbbbbbbbbbbbb3aaaaaaaaaaaaaaaabaaaaaaaaaaaaaaaaaaaaaaaaaaaa4aaaflags(client) & CAM_DEBUG_VERBOSE_VERIFY)) {
       sprintf(sub_str, "CAM_DEBUG_CONFIG  RAM data width = %0d (expected %0d)",
hw_conf.list_length, sw_conf->list_length);
       sprintf(message, "%-70s%s", sub_str, err ? "FAIL" : "OK");
if (err) {
a1aaaaaaaaaaaaaaaabaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaa3aaaaaaaaaaaaaaaabaaaaaaaaaaaaaaaaaaaaaaaaaaaa4aaaerror(client, message);
} else {
a1aaaaaaaaaaaaaaaabaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaa3aaaaaaaaaaaaaaaabaaaaaaaaaaaaaaaaaaaaaaaaaaaa4aaainfo(client, message);
}
}
const uint32_t addr = aaaaaa1bbbbbbbbbbbbbbbbbbbbbbbbbbbbbbbbbbbbbbb3aaaaaaaaaaaaaaaabaaaaaaaaaaaaaaaaaaaaaaaaaaaa4aaaaaaaaaaaaaaaabaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaa4aaa + 33 * aaaaaa1bbbbbbbbbbbbbbbbbbbbbbbbbbbbbbbbbbbbbbb3aaaaaaaaaaaaaaaabaaaaaaaaaaaaaaaaaaaaaaaaaaaa4aaaWORD;
const uint64_t test_data = 0xabcd0123;
uint64_t read_data = 0;
a1aaaaaaaaaaaaaaaabaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaa3aaaaaaaaaaaaaaaabaaaaaaaaaaaaaaaaaaaaaaaaaaaa4aaaaaaaaaaaaaaaabaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaa4aaa(client, addr, test_data);
a1aaaaaaaaaaaaaaaabaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaa3aaaaaaaaaaaaaaaabaaaaaaaaaaaaaaaaaaaaaaaaaaaa4aaaread(client, addr, &read_data);
err = read_data != test_data;
if (err || (a1aaaaaaaaaaaaaaaabaaaaaaaaaaaa3aaaaaaaaaaaaaaaabaaaaaaaaaaaaaaaaaaaaaaaaaaaa3bbbbbbbbbbbbbbbbbbbbbbbbbbbbbbbbbbbbb3aaaaaaaaaaaaaaaabaaaaaaaaaaaaaaaaaaaaaaaaaaaa4aaaflags(client) & CAM_DEBUG_VERBOSE_VERIFY)) {
       sprintf(sub_str, "CAM_DEBUG_CONFIG  Scratch read-back = 0x%016" PRIx64 "  (expected 0x%016" PRIx64 ")",
read_data, test_data);
       sprintf(message, "%-70s%s", sub_str, err ? "FAIL" : "OK");
if (err) {
a1aaaaaaaaaaaaaaaabaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaa3aaaaaaaaaaaaaaaabaaaaaaaaaaaaaaaaaaaaaaaaaaaa4aaaerror(client, message);
} else {
a1aaaaaaaaaaaaaaaabaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaa3aaaaaaaaaaaaaaaabaaaaaaaaaaaaaaaaaaaaaaaaaaaa4aaainfo(client, message);
}
}
}
void a1bbbbbbbbbbbbbbbbbbb3aaa(const a1aaat *client)
{
assert(client != NULL);
char message[500];
if (a1aaaaaaaaaaaaaaaabaaaaaaaaaaaa3aaaaaaaaaaaaaaaabaaaaaaaaaaaaaaaaaaaaaaaaaaaa3bbbbbbbbbbbbbbbbbbbbbbbbbbbbbbbbbbbbb3aaaaaaaaaaaaaaaabaaaaaaaaaaaaaaaaaaaaaaaaaaaa4aaaflags(client) & CAM_DEBUG_ARGS) {
       sprintf(message, "CAM_DEBUG_ARGS  memory rewrite");
a1aaaaaaaaaaaaaaaabaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaa3aaaaaaaaaaaaaaaabaaaaaaaaaaaaaaaaaaaaaaaaaaaa4aaainfo(client, message);
}
const uint16_t num_units = cam_config_get_num_units(client->conf);
for (uint16_t i = 0; i < num_units; i++) {
aaa1bbbbbbbbbbbbbbbbbbb3aaa(client->unit[i].phm, client);
}
}
cam_free_func a1aaaaaaaaaaaaaaaabaaaaaaaaaaaa3aaaaaaaaaaaaaaaabaaaaaaaaaaaaaaaaaaaaaaaaaaaa3aaaaaaaaaaaaaabaaaaaaaaaaaa4aaaaaaaaaaaaaaaabaaaaaaaaaaaaaaaaaaaaaaaaaaaa4aaaaaaaaaaaaaaaabaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaa4aaa(const a1aaat* client)
{
return(client->conf->arg.free_function);
}
cam_malloc_func a1aaaaaaaaaaaaaaaabaaaaaaaaaaaa3aaaaaaaaaaaaaaaabaaaaaaaaaaaaaaaaaaaaaaaaaaaa3aaamalloc_function(const a1aaat* client)
{
return(client->conf->arg.malloc_function);
}
cam_calloc_func a1aaaaaaaaaaaaaaaabaaaaaaaaaaaa3aaaaaaaaaaaaaaaabaaaaaaaaaaaaaaaaaaaaaaaaaaaa3aaacalloc_function(const a1aaat* client)
{
return(client->conf->arg.calloc_function);
}
int a1aaaaaaaaaaaaaaaabaaaaaaaaaaaa3aaaaaaaaaaaaaaaabaaaaaaaaaaaaaaaaaaaaaaaaaaaa3aaacurrent_num_units(const a1aaat *client)
{
int units = 0;
const uint16_t num_units = a1aaaaaaaaaaaaaaaabaaaaaaaaaaaa3aaaaaaaaaaaaaaaabaaaaaaaaaaaaaaaaaaaaaaaaaaaa3aaaaaaaaaaaaaaabaaaaaaaaaaaaaaaa4aaaaaaaaaaaaaaaabaaaaaaaaaaaaaaaaaaaaaaaaaaaa4aaaaaaaaaaaabaaaaaaaaaaaaaaaaa5aaas(client);
for (uint16_t unit = 0; unit < num_units; unit++) {
const aaa1aaat *phm = client->unit[unit].phm;
if (aaa1aaaaaaaaaaaaaaabaaaaaaaaaaaa3aaaaaaaaaaaaaaaabaaaaaaaaaaaaaaaaaaaaaaaaaaaa3aaaaaaaaaaaaaaaabaaaaaaaaaaaaaaaaaaaaaaa4aaaaaaaaaaaaaaaabaaaaaaaaaaaaaaaaaaaaaaaaaaaa4aaaaaaaaaaaabaaaaaaaaaaa5aaaaaaaaaaaaaaaabaaaaaaaaaaaaaaaaaaaaaaaaaaaa5aaavalid(phm)) {
units++;
}
}
return units;
}
void a1bbbbbbbbbbbbbbbbbbbbbbbbbbbbbbbbbbbbbb3aaaaaaaaaaaaaaaabaaaaaaaaaaaaaaaaaaaaaaaaaaaa4aaaaaaaaaaaaaaaabaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaa4aaa(const a1aaat *client)
{
const uint16_t num_units = a1aaaaaaaaaaaaaaaabaaaaaaaaaaaa3aaaaaaaaaaaaaaaabaaaaaaaaaaaaaaaaaaaaaaaaaaaa3aaaaaaaaaaaaaaabaaaaaaaaaaaaaaaa4aaaaaaaaaaaaaaaabaaaaaaaaaaaaaaaaaaaaaaaaaaaa4aaaaaaaaaaaabaaaaaaaaaaaaaaaaa5aaas(client);
for (uint16_t unit = 0; unit < num_units; unit++) {
const aaa1aaat *phm = client->unit[unit].phm;
aaa1bbbbbbbbbbbbbbbbbbbbbbbbbbbbbbbbbbbbbb3aaaaaaaaaaaaaaaabaaaaaaaaaaaaaaaaaaaaaaaaaaaa4aaaaaaaaaaaaaaaabaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaa4aaa(phm);
}
}
#ifndef COMP_BCAM_IP
#endif
uint32_t a1aaaif_get_current_num_entries(const struct bcam *bcam)
{
#ifdef COMP_BCAM_IP
return comp_bcam_a1aaaaaaaaaaaaaaaabaaaaaaaaaaaa3aaaaaaaaaaaaaaaabaaaaaaaaaaaaaaaaaaaaaaaaaaaa3aaacurrent_num_entries((const comp_cam_a1aaat*) (bcam->client));
#else
if (bcam->type == COMPBCAM)
{
return comp_bcam_a1aaaaaaaaaaaaaaaabaaaaaaaaaaaa3aaaaaaaaaaaaaaaabaaaaaaaaaaaaaaaaaaaaaaaaaaaa3aaacurrent_num_entries((const comp_cam_a1aaat*) (bcam->client));
}
else 
{
return a1aaaaaaaaaaaaaaaabaaaaaaaaaaaa3aaaaaaaaaaaaaaaabaaaaaaaaaaaaaaaaaaaaaaaaaaaa3aaacurrent_num_entries((const a1aaat*) (bcam->client));
}
#endif
}
uint32_t a1aaaif_get_num_lists(const struct bcam *bcam)
{
#ifdef COMP_BCAM_IP
return comp_bcam_a1aaaaaaaaaaaaaaaabaaaaaaaaaaaa3aaaaaaaaaaaaaaaabaaaaaaaaaaaaaaaaaaaaaaaaaaaa3aaaaaaaaaaaaaaabaaaaaaaaaaaaaaaa4aaaaaaaaaaaaaaaabaaaaaaaaaaaaaaaaaaaaaaaaaaaa4aaaaaaaaaaaaabaaaaaaaaaaaaaaaaa5aaas((const comp_cam_a1aaat*) (bcam->client));
#else
if (bcam->type == COMPBCAM)
{
return comp_bcam_a1aaaaaaaaaaaaaaaabaaaaaaaaaaaa3aaaaaaaaaaaaaaaabaaaaaaaaaaaaaaaaaaaaaaaaaaaa3aaaaaaaaaaaaaaabaaaaaaaaaaaaaaaa4aaaaaaaaaaaaaaaabaaaaaaaaaaaaaaaaaaaaaaaaaaaa4aaaaaaaaaaaaabaaaaaaaaaaaaaaaaa5aaas((const comp_cam_a1aaat*) (bcam->client));
}
else 
{
return a1aaaaaaaaaaaaaaaabaaaaaaaaaaaa3aaaaaaaaaaaaaaaabaaaaaaaaaaaaaaaaaaaaaaaaaaaa3aaaaaaaaaaaaaaabaaaaaaaaaaaaaaaa4aaaaaaaaaaaaaaaabaaaaaaaaaaaaaaaaaaaaaaaaaaaa4aaaaaaaaaaaaabaaaaaaaaaaaaaaaaa5aaas((const a1aaat*) (bcam->client));
}
#endif
}
uint32_t a1aaaif_get_num_units(const struct bcam *bcam)
{
#ifdef COMP_BCAM_IP
return comp_bcam_a1aaaaaaaaaaaaaaaabaaaaaaaaaaaa3aaaaaaaaaaaaaaaabaaaaaaaaaaaaaaaaaaaaaaaaaaaa3aaaaaaaaaaaaaaabaaaaaaaaaaaaaaaa4aaaaaaaaaaaaaaaabaaaaaaaaaaaaaaaaaaaaaaaaaaaa4aaaaaaaaaaaabaaaaaaaaaaaaaaaaa5aaas((const comp_cam_a1aaat*) (bcam->client));
#else
if (bcam->type == COMPBCAM)
{
return comp_bcam_a1aaaaaaaaaaaaaaaabaaaaaaaaaaaa3aaaaaaaaaaaaaaaabaaaaaaaaaaaaaaaaaaaaaaaaaaaa3aaaaaaaaaaaaaaabaaaaaaaaaaaaaaaa4aaaaaaaaaaaaaaaabaaaaaaaaaaaaaaaaaaaaaaaaaaaa4aaaaaaaaaaaabaaaaaaaaaaaaaaaaa5aaas((const comp_cam_a1aaat*) (bcam->client));
}
else 
{
return a1aaaaaaaaaaaaaaaabaaaaaaaaaaaa3aaaaaaaaaaaaaaaabaaaaaaaaaaaaaaaaaaaaaaaaaaaa3aaaaaaaaaaaaaaabaaaaaaaaaaaaaaaa4aaaaaaaaaaaaaaaabaaaaaaaaaaaaaaaaaaaaaaaaaaaa4aaaaaaaaaaaabaaaaaaaaaaaaaaaaa5aaas((const a1aaat*) (bcam->client));
}
#endif
}
int a1aaaif_get_widths(const struct bcam *bcam, uint16_t *key_width, uint16_t *response_width, bool narrow_key)
{
#ifdef COMP_BCAM_IP
comp_bcam_a1aaaaaaaaaaaaaaaabaaaaaaaaaaaa3aaaaaaaaaaaaaaaabaaaaaaaaaaaaaaaaaaaaaaaaaaaa3aaawidths((const comp_cam_a1aaat*) (bcam->client), key_width, response_width);
return 0;
#else
if (bcam->type == COMPBCAM)
{
comp_bcam_a1aaaaaaaaaaaaaaaabaaaaaaaaaaaa3aaaaaaaaaaaaaaaabaaaaaaaaaaaaaaaaaaaaaaaaaaaa3aaawidths((const comp_cam_a1aaat*) (bcam->client), key_width, response_width);
return 0;
}
else 
{
return a1aaaaaaaaaaaaaaaabaaaaaaaaaaaa3aaaaaaaaaaaaaaaabaaaaaaaaaaaaaaaaaaaaaaaaaaaa3aaawidths((const a1aaat*) (bcam->client), key_width, response_width, narrow_key);
}
#endif
}
bool a1aaaif_has_options(const struct bcam *bcam)
{
#ifdef COMP_BCAM_IP
return false;
#else
if (bcam->type == COMPBCAM) {
return false;
} else 
{
return a1aaahas_options((const a1aaat*) (bcam->client));
}
#endif
}
uint16_t a1aaaif_get_key_width(const struct bcam *bcam)
{
#ifdef COMP_BCAM_IP
return comp_bcam_a1aaaaaaaaaaaaaaaabaaaaaaaaaaaa3aaaaaaaaaaaaaaaabaaaaaaaaaaaaaaaaaaaaaaaaaaaa3aaaaaaaaaaaaaaaabaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaa3aaaaaaaaaaaaaaaabaaaaaaaaaaaaaaaaaaaaaaaaaaaa4aaawidth((const comp_cam_a1aaat*) (bcam->client));
#else
if (bcam->type == COMPBCAM) {
return comp_bcam_a1aaaaaaaaaaaaaaaabaaaaaaaaaaaa3aaaaaaaaaaaaaaaabaaaaaaaaaaaaaaaaaaaaaaaaaaaa3aaaaaaaaaaaaaaaabaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaa3aaaaaaaaaaaaaaaabaaaaaaaaaaaaaaaaaaaaaaaaaaaa4aaawidth((const comp_cam_a1aaat*) (bcam->client));
} else 
{
return a1aaaaaaaaaaaaaaaabaaaaaaaaaaaa3aaaaaaaaaaaaaaaabaaaaaaaaaaaaaaaaaaaaaaaaaaaa3aaaaaaaaaaaaaaaabaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaa3aaaaaaaaaaaaaaaabaaaaaaaaaaaaaaaaaaaaaaaaaaaa4aaawidth((const a1aaat*) (bcam->client));
}
#endif
}
uint16_t a1aaaif_get_response_width(const struct bcam *bcam)
{
#ifdef COMP_BCAM_IP
return comp_bcam_a1aaaaaaaaaaaaaaaabaaaaaaaaaaaa3aaaaaaaaaaaaaaaabaaaaaaaaaaaaaaaaaaaaaaaaaaaa3aaaaaaaaaaaaaaaabaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaa3aaaaaaaaaaaaaaaabaaaaaaaaaaaaaaaaaaaaaaaaaaaa4aaawidth((const comp_cam_a1aaat*) (bcam->client));
#else
if (bcam->type == COMPBCAM)
{
return comp_bcam_a1aaaaaaaaaaaaaaaabaaaaaaaaaaaa3aaaaaaaaaaaaaaaabaaaaaaaaaaaaaaaaaaaaaaaaaaaa3aaaaaaaaaaaaaaaabaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaa3aaaaaaaaaaaaaaaabaaaaaaaaaaaaaaaaaaaaaaaaaaaa4aaawidth((const comp_cam_a1aaat*) (bcam->client));
}
else 
{
return a1aaaaaaaaaaaaaaaabaaaaaaaaaaaa3aaaaaaaaaaaaaaaabaaaaaaaaaaaaaaaaaaaaaaaaaaaa3aaaaaaaaaaaaaaaabaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaa3aaaaaaaaaaaaaaaabaaaaaaaaaaaaaaaaaaaaaaaaaaaa4aaawidth((const a1aaat*) (bcam->client));
}
#endif
}
void a1aaaif_set_debug_flags(struct bcam *bcam, uint32_t debug_flags)
{
#ifdef COMP_BCAM_IP
comp_bcam_a1bbbbbbbbbbbbbbbbbb3aaaaaaaaaaaaaaaabaaaaaaaaaaaaaaaaaaaaaaaaaaaa4bbbbbbbbbbbbbbbbbbbbbbbbbbbbbbbbbbbbb4aaaaaaaaaaaaaaaabaaaaaaaaaaaaaaaaaaaaaaaaaaaa5aaaflags((const comp_cam_a1aaat*) (bcam->client), debug_flags);
#else
if (bcam->type == COMPBCAM)
{
comp_bcam_a1bbbbbbbbbbbbbbbbbb3aaaaaaaaaaaaaaaabaaaaaaaaaaaaaaaaaaaaaaaaaaaa4bbbbbbbbbbbbbbbbbbbbbbbbbbbbbbbbbbbbb4aaaaaaaaaaaaaaaabaaaaaaaaaaaaaaaaaaaaaaaaaaaa5aaaflags((const comp_cam_a1aaat*) (bcam->client), debug_flags);
}
else 
{
a1bbbbbbbbbbbbbbbbbb3aaaaaaaaaaaaaaaabaaaaaaaaaaaaaaaaaaaaaaaaaaaa4bbbbbbbbbbbbbbbbbbbbbbbbbbbbbbbbbbbbb4aaaaaaaaaaaaaaaabaaaaaaaaaaaaaaaaaaaaaaaaaaaa5aaaflags((const a1aaat*) (bcam->client), debug_flags);
}
#endif
}
uint32_t a1aaaif_get_debug_flags(const struct bcam *bcam)
{
#ifdef COMP_BCAM_IP
return (uint32_t) (comp_bcam_a1aaaaaaaaaaaaaaaabaaaaaaaaaaaa3aaaaaaaaaaaaaaaabaaaaaaaaaaaaaaaaaaaaaaaaaaaa3bbbbbbbbbbbbbbbbbbbbbbbbbbbbbbbbbbbbb3aaaaaaaaaaaaaaaabaaaaaaaaaaaaaaaaaaaaaaaaaaaa4aaaflags((const comp_cam_a1aaat*) (bcam->client)));
#else
if (bcam->type == COMPBCAM)
{
return (uint32_t) (comp_bcam_a1aaaaaaaaaaaaaaaabaaaaaaaaaaaa3aaaaaaaaaaaaaaaabaaaaaaaaaaaaaaaaaaaaaaaaaaaa3bbbbbbbbbbbbbbbbbbbbbbbbbbbbbbbbbbbbb3aaaaaaaaaaaaaaaabaaaaaaaaaaaaaaaaaaaaaaaaaaaa4aaaflags((const comp_cam_a1aaat*) (bcam->client)));
}
else 
{
return a1aaaaaaaaaaaaaaaabaaaaaaaaaaaa3aaaaaaaaaaaaaaaabaaaaaaaaaaaaaaaaaaaaaaaaaaaa3bbbbbbbbbbbbbbbbbbbbbbbbbbbbbbbbbbbbb3aaaaaaaaaaaaaaaabaaaaaaaaaaaaaaaaaaaaaaaaaaaa4aaaflags((const a1aaat*) (bcam->client));
}
#endif
}
void a1aaaif_print_error(const struct bcam *bcam, char *message)
{
#ifdef COMP_BCAM_IP
comp_bcam_a1aaaaaaaaaaaaaaaabaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaa3aaaaaaaaaaaaaaaabaaaaaaaaaaaaaaaaaaaaaaaaaaaa4aaaerror((const comp_cam_a1aaat*) (bcam->client), message);
#else
if (bcam->type == COMPBCAM)
{
comp_bcam_a1aaaaaaaaaaaaaaaabaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaa3aaaaaaaaaaaaaaaabaaaaaaaaaaaaaaaaaaaaaaaaaaaa4aaaerror((const comp_cam_a1aaat*)(bcam->client), message);
}
else 
{
a1aaaaaaaaaaaaaaaabaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaa3aaaaaaaaaaaaaaaabaaaaaaaaaaaaaaaaaaaaaaaaaaaa4aaaerror((const a1aaat*)(bcam->client), message);
}
#endif
}
void a1aaaif_print_info(const struct bcam *bcam, char *message)
{
#ifdef COMP_BCAM_IP
comp_bcam_a1aaaaaaaaaaaaaaaabaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaa3aaaaaaaaaaaaaaaabaaaaaaaaaaaaaaaaaaaaaaaaaaaa4aaainfo((const comp_cam_a1aaat*) (bcam->client), message);
#else
if (bcam->type == COMPBCAM)
{
comp_bcam_a1aaaaaaaaaaaaaaaabaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaa3aaaaaaaaaaaaaaaabaaaaaaaaaaaaaaaaaaaaaaaaaaaa4aaainfo((const comp_cam_a1aaat*) (bcam->client), message);
}
else 
{
a1aaaaaaaaaaaaaaaabaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaa3aaaaaaaaaaaaaaaabaaaaaaaaaaaaaaaaaaaaaaaaaaaa4aaainfo((const a1aaat*) (bcam->client), message);
}
#endif
}
uint32_t a1aaaif_get_num_entries(const struct bcam *bcam)
{
#ifdef COMP_BCAM_IP
return comp_bcam_a1aaaaaaaaaaaaaaaabaaaaaaaaaaaa3aaaaaaaaaaaaaaaabaaaaaaaaaaaaaaaaaaaaaaaaaaaa3aaaaaaaaaaaaaaabaaaaaaaaaaaaaaaa4aaaaaaaaaaaaaaaabaaaaaaaaaaaaaaaaaaaaaaaaaaaa4aaaaaaaaaaaaaaaabaaaaaaaaaaaaaaaaaaaaa5aaa((const comp_cam_a1aaat*) (bcam->client));
#else
if (bcam->type == COMPBCAM)
{
return comp_bcam_a1aaaaaaaaaaaaaaaabaaaaaaaaaaaa3aaaaaaaaaaaaaaaabaaaaaaaaaaaaaaaaaaaaaaaaaaaa3aaaaaaaaaaaaaaabaaaaaaaaaaaaaaaa4aaaaaaaaaaaaaaaabaaaaaaaaaaaaaaaaaaaaaaaaaaaa4aaaaaaaaaaaaaaaabaaaaaaaaaaaaaaaaaaaaa5aaa((const comp_cam_a1aaat*)(bcam->client));
}
else 
{
return a1aaaaaaaaaaaaaaaabaaaaaaaaaaaa3aaaaaaaaaaaaaaaabaaaaaaaaaaaaaaaaaaaaaaaaaaaa3aaaaaaaaaaaaaaabaaaaaaaaaaaaaaaa4aaaaaaaaaaaaaaaabaaaaaaaaaaaaaaaaaaaaaaaaaaaa4aaaaaaaaaaaaaaaabaaaaaaaaaaaaaaaaaaaaa5aaa((const a1aaat*)(bcam->client));
}
#endif
}
int a1aaaif_update_key(const struct bcam *bcam, const aaaaaaaaaaaaa1aaat *key, const aaaaaaaaaaaaaaaa1aaaaaaaaaaaaaaaabaaaaaaaaaaaaaaaaaaaaaaaaaaaa3aaat *response,
uint32_t key_width, uint32_t response_width, const cam_options_t *options)
{
#ifdef COMP_BCAM_IP
return(comp_bcam_a1bbbbbbbbbbbbbbbbbbbb3aaaaaaaaaaaaaaaabaaaaaaaaaaaaaaaaaaaaaaaaaaaa4aaaaaaaaaaaaaaaabaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaa4aaa((comp_cam_a1aaat *) (bcam->client), key, response, key_width, response_width));
#else
if (bcam->type == COMPBCAM)
{
return(comp_bcam_a1bbbbbbbbbbbbbbbbbbbb3aaaaaaaaaaaaaaaabaaaaaaaaaaaaaaaaaaaaaaaaaaaa4aaaaaaaaaaaaaaaabaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaa4aaa((comp_cam_a1aaat *) (bcam->client), key, response, key_width, response_width));
}
else 
{
return (a1bbbbbbbbbbbbbbbbbbbb3aaaaaaaaaaaaaaaabaaaaaaaaaaaaaaaaaaaaaaaaaaaa4aaaaaaaaaaaaaaaabaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaa4aaa((a1aaat *) (bcam->client), key, response, NULL, options));
}
#endif
}
int a1aaaif_insert_key(const struct bcam *bcam, aaaaaaaaaaaaa1aaat *key, const aaaaaaaaaaaaaaaa1aaaaaaaaaaaaaaaabaaaaaaaaaaaaaaaaaaaaaaaaaaaa3aaat *response, uint32_t key_width,
uint32_t response_width, const cam_options_t *options)
{
#ifdef COMP_BCAM_IP
return(comp_bcam_a1aaaaaaaaaaaaaaabaaaaaaaaaaaaaaaaaaa3aaaaaaaaaaaaaaaabaaaaaaaaaaaaaaaaaaaaaaaaaaaa3aaaaaaaaaaaaaaaabaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaa3aaa((comp_cam_a1aaat *)(bcam->client), key, response, key_width, response_width));
#else
if (bcam->type == COMPBCAM)
{
return(comp_bcam_a1aaaaaaaaaaaaaaabaaaaaaaaaaaaaaaaaaa3aaaaaaaaaaaaaaaabaaaaaaaaaaaaaaaaaaaaaaaaaaaa3aaaaaaaaaaaaaaaabaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaa3aaa((comp_cam_a1aaat *)(bcam->client), key, response, key_width, response_width));
}
else 
{
return (a1aaaaaaaaaaaaaaabaaaaaaaaaaaaaaaaaaa3aaaaaaaaaaaaaaaabaaaaaaaaaaaaaaaaaaaaaaaaaaaa3aaaaaaaaaaaaaaaabaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaa3aaa((a1aaat *) (bcam->client), key, response, NULL, options));
}
#endif
}
int a1aaaif_read_response_for_key(const struct bcam *bcam, aaaaaaaaaaaaaaaa1aaaaaaaaaaaaaaaabaaaaaaaaaaaaaaaaaaaaaaaaaaaa3aaat *response, aaaaaaaaaaaaaaaa1aaaaaaaaaaaaaaaabaaaaaaaaaaaaaaaaaaaaaaaaaaaa3aaat *response_mask,
uint32_t *pos, aaaaaaaaaaaaa1aaat *key, bool narrow_key)
{
#ifdef COMP_BCAM_IP
return(CAM_ERROR_UNSUPPORTED_COMMAND);
#else
if (bcam->type == COMPBCAM)
{
return(CAM_ERROR_UNSUPPORTED_COMMAND);
}
else 
{
aaaaaaaaaaaaa1aaat mask;
return (a1aaaread_response_for_key((a1aaat *) (bcam->client), response, response_mask, pos, key, &mask,
narrow_key));
}
#endif
}
int a1aaaif_get_by_key(const struct bcam *bcam, aaaaaaaaaaaaa1aaat *key, aaaaaaaaaaaaaaaa1aaaaaaaaaaaaaaaabaaaaaaaaaaaaaaaaaaaaaaaaaaaa3aaat *idx, uint32_t key_width,
uint32_t response_width, const cam_options_t *options)
{
#ifdef COMP_BCAM_IP
return(comp_bcam_a1aaaaaaaaaaaaaaaabaaaaaaaaaaaa3aaaaaaaaaaaaaaaabaaaaaaaaaaaaaaaaaaaaaaaaaaaa3aaaby_key((comp_cam_a1aaat *) (bcam->client), key, idx, key_width, response_width));
#else
if (bcam->type == COMPBCAM)
{
return(comp_bcam_a1aaaaaaaaaaaaaaaabaaaaaaaaaaaa3aaaaaaaaaaaaaaaabaaaaaaaaaaaaaaaaaaaaaaaaaaaa3aaaby_key((comp_cam_a1aaat *) (bcam->client), key, idx, key_width, response_width));
}
else 
{
return (a1aaaread_key((a1aaat *) (bcam->client), key, idx, NULL, options));
}
#endif
}
int a1aaaif_bcam_delete_key(const struct bcam *bcam, const aaaaaaaaaaaaa1aaat *key, uint32_t key_width,
const cam_options_t *options)
{
#ifdef COMP_BCAM_IP
return(comp_bcam_a1aaaaaaaaaaaaaaaabaaaaaaaaaaaaaaaaaaa3aaaaaaaaaaaaaaaabaaaaaaaaaaaaaaaaaaaaaaaaaaaa3aaaaaaaaaaaaaaaabaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaa3aaa((comp_cam_a1aaat *) (bcam->client), key, (uint32_t) key_width));
#else
if (bcam->type == COMPBCAM)
{
return(comp_bcam_a1aaaaaaaaaaaaaaaabaaaaaaaaaaaaaaaaaaa3aaaaaaaaaaaaaaaabaaaaaaaaaaaaaaaaaaaaaaaaaaaa3aaaaaaaaaaaaaaaabaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaa3aaa((comp_cam_a1aaat *) (bcam->client), key, (uint32_t) key_width));
}
else 
{
return (a1aaaaaaaaaaaaaaaabaaaaaaaaaaaaaaaaaaa3aaaaaaaaaaaaaaaabaaaaaaaaaaaaaaaaaaaaaaaaaaaa3aaaaaaaaaaaaaaaabaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaa3aaa((a1aaat *) (bcam->client), key, NULL, options));
}
#endif
}
int a1aaaif_read_and_clear_ecc_counters(const struct bcam *bcam, uint32_t *corrected_single_bit_errors, uint32_t *detected_double_bit_errors)
{
#ifdef COMP_BCAM_IP
return CAM_ERROR_UNSUPPORTED_COMMAND;
#else
if (bcam->type == COMPBCAM)
{
return CAM_ERROR_UNSUPPORTED_COMMAND;
}
else 
{
return a1aaaread_and_clear_ecc_counters((a1aaat *) (bcam->client), corrected_single_bit_errors, detected_double_bit_errors);
}
#endif
}
int a1aaaif_read_and_clear_ecc_addressess(const struct bcam *bcam, uint32_t *failing_address_single_bit_error, uint32_t *failing_address_double_bit_error)
{
#ifdef COMP_BCAM_IP
return CAM_ERROR_UNSUPPORTED_COMMAND;
#else
if (bcam->type == COMPBCAM)
{
return CAM_ERROR_UNSUPPORTED_COMMAND;
}
else 
{
return a1aaaread_and_clear_ecc_addresses((a1aaat *) (bcam->client), failing_address_single_bit_error, failing_address_double_bit_error);
}
#endif
}
int a1aaaif_get_default_response(const struct bcam *bcam, uint8_t response[], uint16_t response_width,
bool narrow_key)
{
#ifdef COMP_BCAM_IP
return CAM_ERROR_UNSUPPORTED_COMMAND;
#else
if (bcam->type == COMPBCAM)
{
return CAM_ERROR_UNSUPPORTED_COMMAND;
}
else 
{
a1aaaaaaaaaaaaaaaabaaaaaaaaaaaa3aaaaaaaaaaaaaaaabaaaaaaaaaaaaaaaaaaaaaaaaaaaa3aaadefault_response((a1aaat *) (bcam->client), response, narrow_key);
return 0;
}
#endif
}
int a1aaaif_a1aaaaaaaaaaaaaaaabaaaaaaaaaaaaaaaaaaaaaaaaa3aaa(struct bcam *bcam)
{
#ifdef COMP_BCAM_IP
return comp_bcam_a1aaaaaaaaaaaaaaaabaaaaaaaaaaaaaaaaaaaaaaaaa3aaa((comp_cam_a1aaat *) (bcam->client));
#else
if (bcam->type == COMPBCAM)
{
return comp_bcam_a1aaaaaaaaaaaaaaaabaaaaaaaaaaaaaaaaaaaaaaaaa3aaa((comp_cam_a1aaat *) (bcam->client));
}
else 
{
cam_free_func free_function = a1aaaaaaaaaaaaaaaabaaaaaaaaaaaa3aaaaaaaaaaaaaaaabaaaaaaaaaaaaaaaaaaaaaaaaaaaa3aaaaaaaaaaaaaabaaaaaaaaaaaa4aaaaaaaaaaaaaaaabaaaaaaaaaaaaaaaaaaaaaaaaaaaa4aaaaaaaaaaaaaaaabaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaa4aaa((a1aaat*) (bcam->client));
a1aaaaaaaaaaaaaaaabaaaaaaaaaaaaaaaaaaaaaaaaa3aaa((a1aaat *) (bcam->client));
free_function(bcam);
}
#endif
return 0;
}
int a1aaaif_a1aaarewrite(const struct bcam *bcam)
{
#ifdef COMP_BCAM_IP
#else
if (bcam->type == COMPBCAM)
{
}
else 
{
a1bbbbbbbbbbbbbbbbbbb3aaa((a1aaat *) (bcam->client));
}
#endif
return 0;
}
void a1aaaif_populate_bcam(struct bcam **bcam, cam_instance_type_t type, void *client, cam_malloc_func malloc_function)
{
struct bcam *new_bcam = malloc_function(sizeof(struct bcam));
new_bcam->type = type;
new_bcam->client = (struct bcam_client*)client;
*bcam = new_bcam;
}
void a1aaaif_get_client(const struct bcam *bcam, void **client)
{
*client = bcam->client;
}
uint32_t a1aaacheck_type(const struct bcam *bcam)
{
#ifdef COMP_BCAM_IP
if (bcam->type == COMPBCAM)
{
return CAM_OK;
}
else
{
return CAM_ERROR_UNSUPPORTED_CAM_TYPE;
}
#else
if ((bcam->type == COMPBCAM) || (bcam->type == HBMBCAM) || (bcam->type == BCAM))
{
return CAM_OK;
}
else
{
return CAM_ERROR_UNSUPPORTED_CAM_TYPE;
}
#endif
}
cam_free_func a1aaaif_os_free(const struct bcam *bcam)
{ 
#ifdef COMP_BCAM_IP
return(a1aaaaaaaaaaaaaaaabaaaaaaaaaaaa3aaaaaaaaaaaaaaaabaaaaaaaaaaaaaaaaaaaaaaaaaaaa3aaaaaaaaaaaaaabaaaaaaaaaaaa4aaaaaaaaaaaaaaaabaaaaaaaaaaaaaaaaaaaaaaaaaaaa4aaaaaaaaaaaaaaaabaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaa4aaa((a1aaat*) (bcam->client)));
#else
if (bcam->type == COMPBCAM)
{
return(comp_bcam_a1aaaaaaaaaaaaaaaabaaaaaaaaaaaa3aaaaaaaaaaaaaaaabaaaaaaaaaaaaaaaaaaaaaaaaaaaa3aaaaaaaaaaaaaabaaaaaaaaaaaa4aaaaaaaaaaaaaaaabaaaaaaaaaaaaaaaaaaaaaaaaaaaa4aaaaaaaaaaaaaaaabaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaa4aaa((comp_cam_a1aaat*)(bcam->client)));
}
else 
{
return(a1aaaaaaaaaaaaaaaabaaaaaaaaaaaa3aaaaaaaaaaaaaaaabaaaaaaaaaaaaaaaaaaaaaaaaaaaa3aaaaaaaaaaaaaabaaaaaaaaaaaa4aaaaaaaaaaaaaaaabaaaaaaaaaaaaaaaaaaaaaaaaaaaa4aaaaaaaaaaaaaaaabaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaa4aaa((a1aaat*)(bcam->client)));
}
#endif
}
cam_malloc_func a1aaaif_os_malloc(const struct bcam* bcam)
{ 
#ifdef COMP_BCAM_IP
return(a1aaaaaaaaaaaaaaaabaaaaaaaaaaaa3aaaaaaaaaaaaaaaabaaaaaaaaaaaaaaaaaaaaaaaaaaaa3aaamalloc_function((a1aaat*) (bcam->client)));
#else
if (bcam->type == COMPBCAM)
{
return(comp_bcam_a1aaaaaaaaaaaaaaaabaaaaaaaaaaaa3aaaaaaaaaaaaaaaabaaaaaaaaaaaaaaaaaaaaaaaaaaaa3aaamalloc_function((comp_cam_a1aaat*) (bcam->client)));
}
else 
{
return(a1aaaaaaaaaaaaaaaabaaaaaaaaaaaa3aaaaaaaaaaaaaaaabaaaaaaaaaaaaaaaaaaaaaaaaaaaa3aaamalloc_function((a1aaat*) (bcam->client)));
}
#endif
}
cam_calloc_func a1aaaif_os_calloc(const struct bcam* bcam)
{ 
#ifdef COMP_BCAM_IP
return(a1aaaaaaaaaaaaaaaabaaaaaaaaaaaa3aaaaaaaaaaaaaaaabaaaaaaaaaaaaaaaaaaaaaaaaaaaa3aaacalloc_function((a1aaat*) (bcam->client)));
#else
if (bcam->type == COMPBCAM)
{
return(comp_bcam_a1aaaaaaaaaaaaaaaabaaaaaaaaaaaa3aaaaaaaaaaaaaaaabaaaaaaaaaaaaaaaaaaaaaaaaaaaa3aaacalloc_function((comp_cam_a1aaat*) (bcam->client)));
}
else 
{
return(a1aaaaaaaaaaaaaaaabaaaaaaaaaaaa3aaaaaaaaaaaaaaaabaaaaaaaaaaaaaaaaaaaaaaaaaaaa3aaacalloc_function((a1aaat*) (bcam->client)));
}
#endif
}
#ifndef COMP_BCAM_REG_ACCESS_PROJECT_H_
#define COMP_BCAM_REG_ACCESS_PROJECT_H_
#ifdef __cplusplus
extern "C"
{
#endif
#ifndef COMP_BCAM_BITFIELD_ACCESS_H_
#define COMP_BCAM_BITFIELD_ACCESS_H_
#ifdef __cplusplus
extern "C"
{
#endif
XLNX_ERROR_CODE XLNX_COMP_BCAM_GetCompBcamBaseVersionMajor(XLNX_COMP_BCAM_CONTEXT_TYPE* ContextPtr, uint32_t* MajorPtr);
XLNX_ERROR_CODE XLNX_COMP_BCAM_GetCompBcamBaseVersionMinor(XLNX_COMP_BCAM_CONTEXT_TYPE* ContextPtr, uint32_t* MinorPtr);
XLNX_ERROR_CODE XLNX_COMP_BCAM_GetCompBcamBaseVersionReg(XLNX_COMP_BCAM_CONTEXT_TYPE* ContextPtr, uint32_t* ValuePtr);
XLNX_ERROR_CODE XLNX_COMP_BCAM_SetCompBcamBaseScratchScratch(XLNX_COMP_BCAM_CONTEXT_TYPE* ContextPtr, uint32_t Scratch);
void XLNX_COMP_BCAM_BuildCompBcamBaseScratchScratch(uint32_t* MaskPtr, uint32_t* ValPtr, uint32_t Scratch);
XLNX_ERROR_CODE XLNX_COMP_BCAM_GetCompBcamBaseScratchScratch(XLNX_COMP_BCAM_CONTEXT_TYPE* ContextPtr, uint32_t* ScratchPtr);
XLNX_ERROR_CODE XLNX_COMP_BCAM_SetCompBcamBaseScratchReg(XLNX_COMP_BCAM_CONTEXT_TYPE* ContextPtr, uint32_t Mask, uint32_t Value);
XLNX_ERROR_CODE XLNX_COMP_BCAM_GetCompBcamBaseScratchReg(XLNX_COMP_BCAM_CONTEXT_TYPE* ContextPtr, uint32_t* ValuePtr);
XLNX_ERROR_CODE XLNX_COMP_BCAM_SetCompBcamBaseAgeThresholdAgeThreshold(XLNX_COMP_BCAM_CONTEXT_TYPE* ContextPtr, uint32_t AgeThreshold);
void XLNX_COMP_BCAM_BuildCompBcamBaseAgeThresholdAgeThreshold(uint32_t* MaskPtr, uint32_t* ValPtr, uint32_t AgeThreshold);
XLNX_ERROR_CODE XLNX_COMP_BCAM_GetCompBcamBaseAgeThresholdAgeThreshold(XLNX_COMP_BCAM_CONTEXT_TYPE* ContextPtr, uint32_t* AgeThresholdPtr);
XLNX_ERROR_CODE XLNX_COMP_BCAM_SetCompBcamBaseAgeThresholdReg(XLNX_COMP_BCAM_CONTEXT_TYPE* ContextPtr, uint32_t Mask, uint32_t Value);
XLNX_ERROR_CODE XLNX_COMP_BCAM_GetCompBcamBaseAgeThresholdReg(XLNX_COMP_BCAM_CONTEXT_TYPE* ContextPtr, uint32_t* ValuePtr);
XLNX_ERROR_CODE XLNX_COMP_BCAM_SetCompBcamBaseNumberPassesNumberPasses(XLNX_COMP_BCAM_CONTEXT_TYPE* ContextPtr, uint32_t NumberPasses);
void XLNX_COMP_BCAM_BuildCompBcamBaseNumberPassesNumberPasses(uint32_t* MaskPtr, uint32_t* ValPtr, uint32_t NumberPasses);
XLNX_ERROR_CODE XLNX_COMP_BCAM_GetCompBcamBaseNumberPassesNumberPasses(XLNX_COMP_BCAM_CONTEXT_TYPE* ContextPtr, uint32_t* NumberPassesPtr);
XLNX_ERROR_CODE XLNX_COMP_BCAM_SetCompBcamBaseNumberPassesReg(XLNX_COMP_BCAM_CONTEXT_TYPE* ContextPtr, uint32_t Mask, uint32_t Value);
XLNX_ERROR_CODE XLNX_COMP_BCAM_GetCompBcamBaseNumberPassesReg(XLNX_COMP_BCAM_CONTEXT_TYPE* ContextPtr, uint32_t* ValuePtr);
XLNX_ERROR_CODE XLNX_COMP_BCAM_GetCompBcamBaseInsertCountInsertCount(XLNX_COMP_BCAM_CONTEXT_TYPE* ContextPtr, uint32_t* InsertCountPtr);
XLNX_ERROR_CODE XLNX_COMP_BCAM_GetCompBcamBaseInsertCountTimerCount(XLNX_COMP_BCAM_CONTEXT_TYPE* ContextPtr, uint32_t* TimerCountPtr);
XLNX_ERROR_CODE XLNX_COMP_BCAM_GetCompBcamBaseInsertCountReg(XLNX_COMP_BCAM_CONTEXT_TYPE* ContextPtr, uint32_t* ValuePtr);
XLNX_ERROR_CODE XLNX_COMP_BCAM_GetCompBcamBaseUpdateCountUpdateCount(XLNX_COMP_BCAM_CONTEXT_TYPE* ContextPtr, uint32_t* UpdateCountPtr);
XLNX_ERROR_CODE XLNX_COMP_BCAM_GetCompBcamBaseUpdateCountTimerCount(XLNX_COMP_BCAM_CONTEXT_TYPE* ContextPtr, uint32_t* TimerCountPtr);
XLNX_ERROR_CODE XLNX_COMP_BCAM_GetCompBcamBaseUpdateCountReg(XLNX_COMP_BCAM_CONTEXT_TYPE* ContextPtr, uint32_t* ValuePtr);
XLNX_ERROR_CODE XLNX_COMP_BCAM_GetCompBcamBaseDeleteCountDeleteCount(XLNX_COMP_BCAM_CONTEXT_TYPE* ContextPtr, uint32_t* DeleteCountPtr);
XLNX_ERROR_CODE XLNX_COMP_BCAM_GetCompBcamBaseDeleteCountTimerCount(XLNX_COMP_BCAM_CONTEXT_TYPE* ContextPtr, uint32_t* TimerCountPtr);
XLNX_ERROR_CODE XLNX_COMP_BCAM_GetCompBcamBaseDeleteCountReg(XLNX_COMP_BCAM_CONTEXT_TYPE* ContextPtr, uint32_t* ValuePtr);
XLNX_ERROR_CODE XLNX_COMP_BCAM_GetCompBcamBaseGetbykeyCountGetbykeyCount(XLNX_COMP_BCAM_CONTEXT_TYPE* ContextPtr, uint32_t* GetbykeyCountPtr);
XLNX_ERROR_CODE XLNX_COMP_BCAM_GetCompBcamBaseGetbykeyCountTimerCount(XLNX_COMP_BCAM_CONTEXT_TYPE* ContextPtr, uint32_t* TimerCountPtr);
XLNX_ERROR_CODE XLNX_COMP_BCAM_GetCompBcamBaseGetbykeyCountReg(XLNX_COMP_BCAM_CONTEXT_TYPE* ContextPtr, uint32_t* ValuePtr);
XLNX_ERROR_CODE XLNX_COMP_BCAM_GetCompBcamBaseLookupCountLookupCount(XLNX_COMP_BCAM_CONTEXT_TYPE* ContextPtr, uint32_t* LookupCountPtr);
XLNX_ERROR_CODE XLNX_COMP_BCAM_GetCompBcamBaseLookupCountTimerCount(XLNX_COMP_BCAM_CONTEXT_TYPE* ContextPtr, uint32_t* TimerCountPtr);
XLNX_ERROR_CODE XLNX_COMP_BCAM_GetCompBcamBaseLookupCountReg(XLNX_COMP_BCAM_CONTEXT_TYPE* ContextPtr, uint32_t* ValuePtr);
XLNX_ERROR_CODE XLNX_COMP_BCAM_GetCompBcamBaseHitCountHitCount(XLNX_COMP_BCAM_CONTEXT_TYPE* ContextPtr, uint32_t* HitCountPtr);
XLNX_ERROR_CODE XLNX_COMP_BCAM_GetCompBcamBaseHitCountTimerCount(XLNX_COMP_BCAM_CONTEXT_TYPE* ContextPtr, uint32_t* TimerCountPtr);
XLNX_ERROR_CODE XLNX_COMP_BCAM_GetCompBcamBaseHitCountReg(XLNX_COMP_BCAM_CONTEXT_TYPE* ContextPtr, uint32_t* ValuePtr);
XLNX_ERROR_CODE XLNX_COMP_BCAM_GetCompBcamBaseSbiterrCountSbiterrCount(XLNX_COMP_BCAM_CONTEXT_TYPE* ContextPtr, uint32_t* SbiterrCountPtr);
XLNX_ERROR_CODE XLNX_COMP_BCAM_GetCompBcamBaseSbiterrCountReg(XLNX_COMP_BCAM_CONTEXT_TYPE* ContextPtr, uint32_t* ValuePtr);
XLNX_ERROR_CODE XLNX_COMP_BCAM_GetCompBcamBaseDbiterrCountDbiterrCount(XLNX_COMP_BCAM_CONTEXT_TYPE* ContextPtr, uint32_t* DbiterrCountPtr);
XLNX_ERROR_CODE XLNX_COMP_BCAM_GetCompBcamBaseDbiterrCountReg(XLNX_COMP_BCAM_CONTEXT_TYPE* ContextPtr, uint32_t* ValuePtr);
XLNX_ERROR_CODE XLNX_COMP_BCAM_GetCompBcamBaseExtEventCountExtEventCount(XLNX_COMP_BCAM_CONTEXT_TYPE* ContextPtr, uint32_t* ExtEventCountPtr);
XLNX_ERROR_CODE XLNX_COMP_BCAM_GetCompBcamBaseExtEventCountTimerCount(XLNX_COMP_BCAM_CONTEXT_TYPE* ContextPtr, uint32_t* TimerCountPtr);
XLNX_ERROR_CODE XLNX_COMP_BCAM_GetCompBcamBaseExtEventCountReg(XLNX_COMP_BCAM_CONTEXT_TYPE* ContextPtr, uint32_t* ValuePtr);
XLNX_ERROR_CODE XLNX_COMP_BCAM_GetCompBcamBaseLiReqWsCountLiReqWsCount(XLNX_COMP_BCAM_CONTEXT_TYPE* ContextPtr, uint32_t* LiReqWsCountPtr);
XLNX_ERROR_CODE XLNX_COMP_BCAM_GetCompBcamBaseLiReqWsCountTimerCount(XLNX_COMP_BCAM_CONTEXT_TYPE* ContextPtr, uint32_t* TimerCountPtr);
XLNX_ERROR_CODE XLNX_COMP_BCAM_GetCompBcamBaseLiReqWsCountReg(XLNX_COMP_BCAM_CONTEXT_TYPE* ContextPtr, uint32_t* ValuePtr);
XLNX_ERROR_CODE XLNX_COMP_BCAM_GetCompBcamBaseTotalNumPassesLoTotalNumPassesLo(XLNX_COMP_BCAM_CONTEXT_TYPE* ContextPtr,
uint32_t* TotalNumPassesLoPtr);
XLNX_ERROR_CODE XLNX_COMP_BCAM_GetCompBcamBaseTotalNumPassesLoReg(XLNX_COMP_BCAM_CONTEXT_TYPE* ContextPtr, uint32_t* ValuePtr);
XLNX_ERROR_CODE XLNX_COMP_BCAM_GetCompBcamBaseTotalNumPassesHiTotalNumPassesHi(XLNX_COMP_BCAM_CONTEXT_TYPE* ContextPtr,
uint32_t* TotalNumPassesHiPtr);
XLNX_ERROR_CODE XLNX_COMP_BCAM_GetCompBcamBaseTotalNumPassesHiReg(XLNX_COMP_BCAM_CONTEXT_TYPE* ContextPtr, uint32_t* ValuePtr);
XLNX_ERROR_CODE XLNX_COMP_BCAM_GetCompBcamBaseLastDetNumPassesLastDetNumPasses(XLNX_COMP_BCAM_CONTEXT_TYPE* ContextPtr,
uint32_t* LastDetNumPassesPtr);
XLNX_ERROR_CODE XLNX_COMP_BCAM_GetCompBcamBaseLastDetNumPassesReg(XLNX_COMP_BCAM_CONTEXT_TYPE* ContextPtr, uint32_t* ValuePtr);
XLNX_ERROR_CODE XLNX_COMP_BCAM_GetCompBcamBaseMaxDetNumPassesMaxDetNumPasses(XLNX_COMP_BCAM_CONTEXT_TYPE* ContextPtr, uint32_t* MaxDetNumPassesPtr);
XLNX_ERROR_CODE XLNX_COMP_BCAM_GetCompBcamBaseMaxDetNumPassesReg(XLNX_COMP_BCAM_CONTEXT_TYPE* ContextPtr, uint32_t* ValuePtr);
XLNX_ERROR_CODE XLNX_COMP_BCAM_SetCompBcamBaseFreezeCountersFreezeCounters(XLNX_COMP_BCAM_CONTEXT_TYPE* ContextPtr, uint32_t FreezeCounters);
void XLNX_COMP_BCAM_BuildCompBcamBaseFreezeCountersFreezeCounters(uint32_t* MaskPtr, uint32_t* ValPtr, uint32_t FreezeCounters);
XLNX_ERROR_CODE XLNX_COMP_BCAM_GetCompBcamBaseFreezeCountersFreezeCounters(XLNX_COMP_BCAM_CONTEXT_TYPE* ContextPtr, uint32_t* FreezeCountersPtr);
XLNX_ERROR_CODE XLNX_COMP_BCAM_SetCompBcamBaseFreezeCountersReg(XLNX_COMP_BCAM_CONTEXT_TYPE* ContextPtr, uint32_t Mask, uint32_t Value);
XLNX_ERROR_CODE XLNX_COMP_BCAM_SetCompBcamBaseFreezeCountersOperationReg(const XLNX_COMP_BCAM_CONTEXT_TYPE* ContextPtr, uint32_t Value);
XLNX_ERROR_CODE XLNX_COMP_BCAM_GetCompBcamBaseFreezeCountersReg(XLNX_COMP_BCAM_CONTEXT_TYPE* ContextPtr, uint32_t* ValuePtr);
XLNX_ERROR_CODE XLNX_COMP_BCAM_SetCompBcamBaseIndirectAddrIndirectAddr(const XLNX_COMP_BCAM_CONTEXT_TYPE* ContextPtr, uint32_t IndirectAddr);
void XLNX_COMP_BCAM_BuildCompBcamBaseIndirectAddrIndirectAddr(uint32_t* MaskPtr, uint32_t* ValPtr, uint32_t IndirectAddr);
XLNX_ERROR_CODE XLNX_COMP_BCAM_GetCompBcamBaseIndirectAddrIndirectAddr(XLNX_COMP_BCAM_CONTEXT_TYPE* ContextPtr, uint32_t* IndirectAddrPtr);
XLNX_ERROR_CODE XLNX_COMP_BCAM_SetCompBcamBaseIndirectAddrReg(const XLNX_COMP_BCAM_CONTEXT_TYPE* ContextPtr, uint32_t Value);
XLNX_ERROR_CODE XLNX_COMP_BCAM_GetCompBcamBaseIndirectAddrReg(XLNX_COMP_BCAM_CONTEXT_TYPE* ContextPtr, uint32_t* ValuePtr);
XLNX_ERROR_CODE XLNX_COMP_BCAM_GetCompBcamBaseIndirectRdData00IndirectRdData00(const XLNX_COMP_BCAM_CONTEXT_TYPE* ContextPtr,
uint32_t* IndirectRdData00Ptr);
XLNX_ERROR_CODE XLNX_COMP_BCAM_GetCompBcamBaseIndirectRdData00Reg(const XLNX_COMP_BCAM_CONTEXT_TYPE* ContextPtr, uint32_t* ValuePtr);
XLNX_ERROR_CODE XLNX_COMP_BCAM_SetCompBcamBaseIndirectWrData00IndirectWrData00(XLNX_COMP_BCAM_CONTEXT_TYPE* ContextPtr, uint32_t IndirectWrData00);
void XLNX_COMP_BCAM_BuildCompBcamBaseIndirectWrData00IndirectWrData00(uint32_t* MaskPtr, uint32_t* ValPtr, uint32_t IndirectWrData00);
XLNX_ERROR_CODE XLNX_COMP_BCAM_GetCompBcamBaseIndirectWrData00IndirectWrData00(XLNX_COMP_BCAM_CONTEXT_TYPE* ContextPtr,
uint32_t* IndirectWrData00Ptr);
XLNX_ERROR_CODE XLNX_COMP_BCAM_SetCompBcamBaseIndirectWrData00Reg(XLNX_COMP_BCAM_CONTEXT_TYPE* ContextPtr, uint32_t Mask, uint32_t Value);
XLNX_ERROR_CODE XLNX_COMP_BCAM_GetCompBcamBaseIndirectWrData00Reg(XLNX_COMP_BCAM_CONTEXT_TYPE* ContextPtr, uint32_t* ValuePtr);
XLNX_ERROR_CODE XLNX_COMP_BCAM_SetCompBcamBaseIndirectWrData01IndirectWrData01(XLNX_COMP_BCAM_CONTEXT_TYPE* ContextPtr, uint32_t IndirectWrData01);
void XLNX_COMP_BCAM_BuildCompBcamBaseIndirectWrData01IndirectWrData01(uint32_t* MaskPtr, uint32_t* ValPtr, uint32_t IndirectWrData01);
XLNX_ERROR_CODE XLNX_COMP_BCAM_GetCompBcamBaseIndirectWrData01IndirectWrData01(XLNX_COMP_BCAM_CONTEXT_TYPE* ContextPtr,
uint32_t* IndirectWrData01Ptr);
XLNX_ERROR_CODE XLNX_COMP_BCAM_SetCompBcamBaseIndirectWrData01Reg(XLNX_COMP_BCAM_CONTEXT_TYPE* ContextPtr, uint32_t Mask, uint32_t Value);
XLNX_ERROR_CODE XLNX_COMP_BCAM_GetCompBcamBaseIndirectWrData01Reg(XLNX_COMP_BCAM_CONTEXT_TYPE* ContextPtr, uint32_t* ValuePtr);
XLNX_ERROR_CODE XLNX_COMP_BCAM_GetCompBcamBaseStatusStatus(XLNX_COMP_BCAM_CONTEXT_TYPE* ContextPtr, uint32_t* StatusPtr);
XLNX_ERROR_CODE XLNX_COMP_BCAM_GetCompBcamBaseStatusReg(XLNX_COMP_BCAM_CONTEXT_TYPE* ContextPtr, uint32_t* ValuePtr);
XLNX_ERROR_CODE XLNX_COMP_BCAM_SetCompBcamBaseOperationOperation(XLNX_COMP_BCAM_CONTEXT_TYPE* ContextPtr, uint32_t Operation);
void XLNX_COMP_BCAM_BuildCompBcamBaseOperationOperation(uint32_t* MaskPtr, uint32_t* ValPtr, uint32_t Operation);
XLNX_ERROR_CODE XLNX_COMP_BCAM_SetCompBcamBaseOperationReg(const XLNX_COMP_BCAM_CONTEXT_TYPE* ContextPtr, uint32_t Value);
XLNX_ERROR_CODE XLNX_COMP_BCAM_SetCompBcamBaseSampleRateSampleRate(XLNX_COMP_BCAM_CONTEXT_TYPE* ContextPtr, uint32_t SampleRate);
void XLNX_COMP_BCAM_BuildCompBcamBaseSampleRateSampleRate(uint32_t* MaskPtr, uint32_t* ValPtr, uint32_t SampleRate);
XLNX_ERROR_CODE XLNX_COMP_BCAM_GetCompBcamBaseSampleRateSampleRate(XLNX_COMP_BCAM_CONTEXT_TYPE* ContextPtr, uint32_t* SampleRatePtr);
XLNX_ERROR_CODE XLNX_COMP_BCAM_SetCompBcamBaseSampleRateReg(XLNX_COMP_BCAM_CONTEXT_TYPE* ContextPtr, uint32_t Mask, uint32_t Value);
XLNX_ERROR_CODE XLNX_COMP_BCAM_GetCompBcamBaseSampleRateReg(XLNX_COMP_BCAM_CONTEXT_TYPE* ContextPtr, uint32_t* ValuePtr);
XLNX_ERROR_CODE XLNX_COMP_BCAM_SetCompBcamBaseCamClearCamClear(XLNX_COMP_BCAM_CONTEXT_TYPE* ContextPtr, uint32_t CamClear);
void XLNX_COMP_BCAM_BuildCompBcamBaseCamClearCamClear(uint32_t* MaskPtr, uint32_t* ValPtr, uint32_t CamClear);
XLNX_ERROR_CODE XLNX_COMP_BCAM_GetCompBcamBaseCamClearCamClear(XLNX_COMP_BCAM_CONTEXT_TYPE* ContextPtr, uint32_t* CamClearPtr);
XLNX_ERROR_CODE XLNX_COMP_BCAM_SetCompBcamBaseCamClearReg(XLNX_COMP_BCAM_CONTEXT_TYPE* ContextPtr, uint32_t Mask, uint32_t Value);
XLNX_ERROR_CODE XLNX_COMP_BCAM_GetCompBcamBaseCamClearReg(XLNX_COMP_BCAM_CONTEXT_TYPE* ContextPtr, uint32_t* ValuePtr);
XLNX_ERROR_CODE XLNX_COMP_BCAM_SetCompBcamBaseKeyData00KeyData00(XLNX_COMP_BCAM_CONTEXT_TYPE* ContextPtr, uint32_t KeyData00);
void XLNX_COMP_BCAM_BuildCompBcamBaseKeyData00KeyData00(uint32_t* MaskPtr, uint32_t* ValPtr, uint32_t KeyData00);
XLNX_ERROR_CODE XLNX_COMP_BCAM_GetCompBcamBaseKeyData00KeyData00(XLNX_COMP_BCAM_CONTEXT_TYPE* ContextPtr, uint32_t* KeyData00Ptr);
XLNX_ERROR_CODE XLNX_COMP_BCAM_SetCompBcamBaseKeyData00Reg(XLNX_COMP_BCAM_CONTEXT_TYPE* ContextPtr, uint32_t Mask, uint32_t Value);
XLNX_ERROR_CODE XLNX_COMP_BCAM_GetCompBcamBaseKeyData00Reg(XLNX_COMP_BCAM_CONTEXT_TYPE* ContextPtr, uint32_t* ValuePtr);
XLNX_ERROR_CODE XLNX_COMP_BCAM_SetCompBcamBaseKeyData01KeyData01(XLNX_COMP_BCAM_CONTEXT_TYPE* ContextPtr, uint32_t KeyData01);
void XLNX_COMP_BCAM_BuildCompBcamBaseKeyData01KeyData01(uint32_t* MaskPtr, uint32_t* ValPtr, uint32_t KeyData01);
XLNX_ERROR_CODE XLNX_COMP_BCAM_GetCompBcamBaseKeyData01KeyData01(XLNX_COMP_BCAM_CONTEXT_TYPE* ContextPtr, uint32_t* KeyData01Ptr);
XLNX_ERROR_CODE XLNX_COMP_BCAM_SetCompBcamBaseKeyData01Reg(XLNX_COMP_BCAM_CONTEXT_TYPE* ContextPtr, uint32_t Mask, uint32_t Value);
XLNX_ERROR_CODE XLNX_COMP_BCAM_GetCompBcamBaseKeyData01Reg(XLNX_COMP_BCAM_CONTEXT_TYPE* ContextPtr, uint32_t* ValuePtr);
XLNX_ERROR_CODE XLNX_COMP_BCAM_SetCompBcamBaseKeyData02KeyData02(XLNX_COMP_BCAM_CONTEXT_TYPE* ContextPtr, uint32_t KeyData02);
void XLNX_COMP_BCAM_BuildCompBcamBaseKeyData02KeyData02(uint32_t* MaskPtr, uint32_t* ValPtr, uint32_t KeyData02);
XLNX_ERROR_CODE XLNX_COMP_BCAM_GetCompBcamBaseKeyData02KeyData02(XLNX_COMP_BCAM_CONTEXT_TYPE* ContextPtr, uint32_t* KeyData02Ptr);
XLNX_ERROR_CODE XLNX_COMP_BCAM_SetCompBcamBaseKeyData02Reg(XLNX_COMP_BCAM_CONTEXT_TYPE* ContextPtr, uint32_t Mask, uint32_t Value);
XLNX_ERROR_CODE XLNX_COMP_BCAM_GetCompBcamBaseKeyData02Reg(XLNX_COMP_BCAM_CONTEXT_TYPE* ContextPtr, uint32_t* ValuePtr);
XLNX_ERROR_CODE XLNX_COMP_BCAM_SetCompBcamBaseKeyData03KeyData03(XLNX_COMP_BCAM_CONTEXT_TYPE* ContextPtr, uint32_t KeyData03);
void XLNX_COMP_BCAM_BuildCompBcamBaseKeyData03KeyData03(uint32_t* MaskPtr, uint32_t* ValPtr, uint32_t KeyData03);
XLNX_ERROR_CODE XLNX_COMP_BCAM_GetCompBcamBaseKeyData03KeyData03(XLNX_COMP_BCAM_CONTEXT_TYPE* ContextPtr, uint32_t* KeyData03Ptr);
XLNX_ERROR_CODE XLNX_COMP_BCAM_SetCompBcamBaseKeyData03Reg(XLNX_COMP_BCAM_CONTEXT_TYPE* ContextPtr, uint32_t Mask, uint32_t Value);
XLNX_ERROR_CODE XLNX_COMP_BCAM_GetCompBcamBaseKeyData03Reg(XLNX_COMP_BCAM_CONTEXT_TYPE* ContextPtr, uint32_t* ValuePtr);
XLNX_ERROR_CODE XLNX_COMP_BCAM_SetCompBcamBaseKeyData04KeyData04(XLNX_COMP_BCAM_CONTEXT_TYPE* ContextPtr, uint32_t KeyData04);
void XLNX_COMP_BCAM_BuildCompBcamBaseKeyData04KeyData04(uint32_t* MaskPtr, uint32_t* ValPtr, uint32_t KeyData04);
XLNX_ERROR_CODE XLNX_COMP_BCAM_GetCompBcamBaseKeyData04KeyData04(XLNX_COMP_BCAM_CONTEXT_TYPE* ContextPtr, uint32_t* KeyData04Ptr);
XLNX_ERROR_CODE XLNX_COMP_BCAM_SetCompBcamBaseKeyData04Reg(XLNX_COMP_BCAM_CONTEXT_TYPE* ContextPtr, uint32_t Mask, uint32_t Value);
XLNX_ERROR_CODE XLNX_COMP_BCAM_GetCompBcamBaseKeyData04Reg(XLNX_COMP_BCAM_CONTEXT_TYPE* ContextPtr, uint32_t* ValuePtr);
XLNX_ERROR_CODE XLNX_COMP_BCAM_SetCompBcamBaseKeyData05KeyData05(XLNX_COMP_BCAM_CONTEXT_TYPE* ContextPtr, uint32_t KeyData05);
void XLNX_COMP_BCAM_BuildCompBcamBaseKeyData05KeyData05(uint32_t* MaskPtr, uint32_t* ValPtr, uint32_t KeyData05);
XLNX_ERROR_CODE XLNX_COMP_BCAM_GetCompBcamBaseKeyData05KeyData05(XLNX_COMP_BCAM_CONTEXT_TYPE* ContextPtr, uint32_t* KeyData05Ptr);
XLNX_ERROR_CODE XLNX_COMP_BCAM_SetCompBcamBaseKeyData05Reg(XLNX_COMP_BCAM_CONTEXT_TYPE* ContextPtr, uint32_t Mask, uint32_t Value);
XLNX_ERROR_CODE XLNX_COMP_BCAM_GetCompBcamBaseKeyData05Reg(XLNX_COMP_BCAM_CONTEXT_TYPE* ContextPtr, uint32_t* ValuePtr);
XLNX_ERROR_CODE XLNX_COMP_BCAM_SetCompBcamBaseKeyData06KeyData06(XLNX_COMP_BCAM_CONTEXT_TYPE* ContextPtr, uint32_t KeyData06);
void XLNX_COMP_BCAM_BuildCompBcamBaseKeyData06KeyData06(uint32_t* MaskPtr, uint32_t* ValPtr, uint32_t KeyData06);
XLNX_ERROR_CODE XLNX_COMP_BCAM_GetCompBcamBaseKeyData06KeyData06(XLNX_COMP_BCAM_CONTEXT_TYPE* ContextPtr, uint32_t* KeyData06Ptr);
XLNX_ERROR_CODE XLNX_COMP_BCAM_SetCompBcamBaseKeyData06Reg(XLNX_COMP_BCAM_CONTEXT_TYPE* ContextPtr, uint32_t Mask, uint32_t Value);
XLNX_ERROR_CODE XLNX_COMP_BCAM_GetCompBcamBaseKeyData06Reg(XLNX_COMP_BCAM_CONTEXT_TYPE* ContextPtr, uint32_t* ValuePtr);
XLNX_ERROR_CODE XLNX_COMP_BCAM_SetCompBcamBaseKeyData07KeyData07(XLNX_COMP_BCAM_CONTEXT_TYPE* ContextPtr, uint32_t KeyData07);
void XLNX_COMP_BCAM_BuildCompBcamBaseKeyData07KeyData07(uint32_t* MaskPtr, uint32_t* ValPtr, uint32_t KeyData07);
XLNX_ERROR_CODE XLNX_COMP_BCAM_GetCompBcamBaseKeyData07KeyData07(XLNX_COMP_BCAM_CONTEXT_TYPE* ContextPtr, uint32_t* KeyData07Ptr);
XLNX_ERROR_CODE XLNX_COMP_BCAM_SetCompBcamBaseKeyData07Reg(XLNX_COMP_BCAM_CONTEXT_TYPE* ContextPtr, uint32_t Mask, uint32_t Value);
XLNX_ERROR_CODE XLNX_COMP_BCAM_GetCompBcamBaseKeyData07Reg(XLNX_COMP_BCAM_CONTEXT_TYPE* ContextPtr, uint32_t* ValuePtr);
XLNX_ERROR_CODE XLNX_COMP_BCAM_SetCompBcamBaseKeyData08KeyData08(XLNX_COMP_BCAM_CONTEXT_TYPE* ContextPtr, uint32_t KeyData08);
void XLNX_COMP_BCAM_BuildCompBcamBaseKeyData08KeyData08(uint32_t* MaskPtr, uint32_t* ValPtr, uint32_t KeyData08);
XLNX_ERROR_CODE XLNX_COMP_BCAM_GetCompBcamBaseKeyData08KeyData08(XLNX_COMP_BCAM_CONTEXT_TYPE* ContextPtr, uint32_t* KeyData08Ptr);
XLNX_ERROR_CODE XLNX_COMP_BCAM_SetCompBcamBaseKeyData08Reg(XLNX_COMP_BCAM_CONTEXT_TYPE* ContextPtr, uint32_t Mask, uint32_t Value);
XLNX_ERROR_CODE XLNX_COMP_BCAM_GetCompBcamBaseKeyData08Reg(XLNX_COMP_BCAM_CONTEXT_TYPE* ContextPtr, uint32_t* ValuePtr);
XLNX_ERROR_CODE XLNX_COMP_BCAM_SetCompBcamBaseKeyData09KeyData09(XLNX_COMP_BCAM_CONTEXT_TYPE* ContextPtr, uint32_t KeyData09);
void XLNX_COMP_BCAM_BuildCompBcamBaseKeyData09KeyData09(uint32_t* MaskPtr, uint32_t* ValPtr, uint32_t KeyData09);
XLNX_ERROR_CODE XLNX_COMP_BCAM_GetCompBcamBaseKeyData09KeyData09(XLNX_COMP_BCAM_CONTEXT_TYPE* ContextPtr, uint32_t* KeyData09Ptr);
XLNX_ERROR_CODE XLNX_COMP_BCAM_SetCompBcamBaseKeyData09Reg(XLNX_COMP_BCAM_CONTEXT_TYPE* ContextPtr, uint32_t Mask, uint32_t Value);
XLNX_ERROR_CODE XLNX_COMP_BCAM_GetCompBcamBaseKeyData09Reg(XLNX_COMP_BCAM_CONTEXT_TYPE* ContextPtr, uint32_t* ValuePtr);
XLNX_ERROR_CODE XLNX_COMP_BCAM_SetCompBcamBaseKeyData10KeyData10(XLNX_COMP_BCAM_CONTEXT_TYPE* ContextPtr, uint32_t KeyData10);
void XLNX_COMP_BCAM_BuildCompBcamBaseKeyData10KeyData10(uint32_t* MaskPtr, uint32_t* ValPtr, uint32_t KeyData10);
XLNX_ERROR_CODE XLNX_COMP_BCAM_GetCompBcamBaseKeyData10KeyData10(XLNX_COMP_BCAM_CONTEXT_TYPE* ContextPtr, uint32_t* KeyData10Ptr);
XLNX_ERROR_CODE XLNX_COMP_BCAM_SetCompBcamBaseKeyData10Reg(XLNX_COMP_BCAM_CONTEXT_TYPE* ContextPtr, uint32_t Mask, uint32_t Value);
XLNX_ERROR_CODE XLNX_COMP_BCAM_GetCompBcamBaseKeyData10Reg(XLNX_COMP_BCAM_CONTEXT_TYPE* ContextPtr, uint32_t* ValuePtr);
XLNX_ERROR_CODE XLNX_COMP_BCAM_SetCompBcamBaseKeyData11KeyData11(XLNX_COMP_BCAM_CONTEXT_TYPE* ContextPtr, uint32_t KeyData11);
void XLNX_COMP_BCAM_BuildCompBcamBaseKeyData11KeyData11(uint32_t* MaskPtr, uint32_t* ValPtr, uint32_t KeyData11);
XLNX_ERROR_CODE XLNX_COMP_BCAM_GetCompBcamBaseKeyData11KeyData11(XLNX_COMP_BCAM_CONTEXT_TYPE* ContextPtr, uint32_t* KeyData11Ptr);
XLNX_ERROR_CODE XLNX_COMP_BCAM_SetCompBcamBaseKeyData11Reg(XLNX_COMP_BCAM_CONTEXT_TYPE* ContextPtr, uint32_t Mask, uint32_t Value);
XLNX_ERROR_CODE XLNX_COMP_BCAM_GetCompBcamBaseKeyData11Reg(XLNX_COMP_BCAM_CONTEXT_TYPE* ContextPtr, uint32_t* ValuePtr);
XLNX_ERROR_CODE XLNX_COMP_BCAM_SetCompBcamBaseKeyData12KeyData12(XLNX_COMP_BCAM_CONTEXT_TYPE* ContextPtr, uint32_t KeyData12);
void XLNX_COMP_BCAM_BuildCompBcamBaseKeyData12KeyData12(uint32_t* MaskPtr, uint32_t* ValPtr, uint32_t KeyData12);
XLNX_ERROR_CODE XLNX_COMP_BCAM_GetCompBcamBaseKeyData12KeyData12(XLNX_COMP_BCAM_CONTEXT_TYPE* ContextPtr, uint32_t* KeyData12Ptr);
XLNX_ERROR_CODE XLNX_COMP_BCAM_SetCompBcamBaseKeyData12Reg(XLNX_COMP_BCAM_CONTEXT_TYPE* ContextPtr, uint32_t Mask, uint32_t Value);
XLNX_ERROR_CODE XLNX_COMP_BCAM_GetCompBcamBaseKeyData12Reg(XLNX_COMP_BCAM_CONTEXT_TYPE* ContextPtr, uint32_t* ValuePtr);
XLNX_ERROR_CODE XLNX_COMP_BCAM_SetCompBcamBaseKeyData13KeyData13(XLNX_COMP_BCAM_CONTEXT_TYPE* ContextPtr, uint32_t KeyData13);
void XLNX_COMP_BCAM_BuildCompBcamBaseKeyData13KeyData13(uint32_t* MaskPtr, uint32_t* ValPtr, uint32_t KeyData13);
XLNX_ERROR_CODE XLNX_COMP_BCAM_GetCompBcamBaseKeyData13KeyData13(XLNX_COMP_BCAM_CONTEXT_TYPE* ContextPtr, uint32_t* KeyData13Ptr);
XLNX_ERROR_CODE XLNX_COMP_BCAM_SetCompBcamBaseKeyData13Reg(XLNX_COMP_BCAM_CONTEXT_TYPE* ContextPtr, uint32_t Mask, uint32_t Value);
XLNX_ERROR_CODE XLNX_COMP_BCAM_GetCompBcamBaseKeyData13Reg(XLNX_COMP_BCAM_CONTEXT_TYPE* ContextPtr, uint32_t* ValuePtr);
XLNX_ERROR_CODE XLNX_COMP_BCAM_SetCompBcamBaseKeyData14KeyData14(XLNX_COMP_BCAM_CONTEXT_TYPE* ContextPtr, uint32_t KeyData14);
void XLNX_COMP_BCAM_BuildCompBcamBaseKeyData14KeyData14(uint32_t* MaskPtr, uint32_t* ValPtr, uint32_t KeyData14);
XLNX_ERROR_CODE XLNX_COMP_BCAM_GetCompBcamBaseKeyData14KeyData14(XLNX_COMP_BCAM_CONTEXT_TYPE* ContextPtr, uint32_t* KeyData14Ptr);
XLNX_ERROR_CODE XLNX_COMP_BCAM_SetCompBcamBaseKeyData14Reg(XLNX_COMP_BCAM_CONTEXT_TYPE* ContextPtr, uint32_t Mask, uint32_t Value);
XLNX_ERROR_CODE XLNX_COMP_BCAM_GetCompBcamBaseKeyData14Reg(XLNX_COMP_BCAM_CONTEXT_TYPE* ContextPtr, uint32_t* ValuePtr);
XLNX_ERROR_CODE XLNX_COMP_BCAM_SetCompBcamBaseKeyData15KeyData15(XLNX_COMP_BCAM_CONTEXT_TYPE* ContextPtr, uint32_t KeyData15);
void XLNX_COMP_BCAM_BuildCompBcamBaseKeyData15KeyData15(uint32_t* MaskPtr, uint32_t* ValPtr, uint32_t KeyData15);
XLNX_ERROR_CODE XLNX_COMP_BCAM_GetCompBcamBaseKeyData15KeyData15(XLNX_COMP_BCAM_CONTEXT_TYPE* ContextPtr, uint32_t* KeyData15Ptr);
XLNX_ERROR_CODE XLNX_COMP_BCAM_SetCompBcamBaseKeyData15Reg(XLNX_COMP_BCAM_CONTEXT_TYPE* ContextPtr, uint32_t Mask, uint32_t Value);
XLNX_ERROR_CODE XLNX_COMP_BCAM_GetCompBcamBaseKeyData15Reg(XLNX_COMP_BCAM_CONTEXT_TYPE* ContextPtr, uint32_t* ValuePtr);
XLNX_ERROR_CODE XLNX_COMP_BCAM_SetCompBcamBaseKeyData16KeyData16(XLNX_COMP_BCAM_CONTEXT_TYPE* ContextPtr, uint32_t KeyData16);
void XLNX_COMP_BCAM_BuildCompBcamBaseKeyData16KeyData16(uint32_t* MaskPtr, uint32_t* ValPtr, uint32_t KeyData16);
XLNX_ERROR_CODE XLNX_COMP_BCAM_GetCompBcamBaseKeyData16KeyData16(XLNX_COMP_BCAM_CONTEXT_TYPE* ContextPtr, uint32_t* KeyData16Ptr);
XLNX_ERROR_CODE XLNX_COMP_BCAM_SetCompBcamBaseKeyData16Reg(XLNX_COMP_BCAM_CONTEXT_TYPE* ContextPtr, uint32_t Mask, uint32_t Value);
XLNX_ERROR_CODE XLNX_COMP_BCAM_GetCompBcamBaseKeyData16Reg(XLNX_COMP_BCAM_CONTEXT_TYPE* ContextPtr, uint32_t* ValuePtr);
XLNX_ERROR_CODE XLNX_COMP_BCAM_SetCompBcamBaseKeyData17KeyData17(XLNX_COMP_BCAM_CONTEXT_TYPE* ContextPtr, uint32_t KeyData17);
void XLNX_COMP_BCAM_BuildCompBcamBaseKeyData17KeyData17(uint32_t* MaskPtr, uint32_t* ValPtr, uint32_t KeyData17);
XLNX_ERROR_CODE XLNX_COMP_BCAM_GetCompBcamBaseKeyData17KeyData17(XLNX_COMP_BCAM_CONTEXT_TYPE* ContextPtr, uint32_t* KeyData17Ptr);
XLNX_ERROR_CODE XLNX_COMP_BCAM_SetCompBcamBaseKeyData17Reg(XLNX_COMP_BCAM_CONTEXT_TYPE* ContextPtr, uint32_t Mask, uint32_t Value);
XLNX_ERROR_CODE XLNX_COMP_BCAM_GetCompBcamBaseKeyData17Reg(XLNX_COMP_BCAM_CONTEXT_TYPE* ContextPtr, uint32_t* ValuePtr);
XLNX_ERROR_CODE XLNX_COMP_BCAM_SetCompBcamBaseKeyData18KeyData18(XLNX_COMP_BCAM_CONTEXT_TYPE* ContextPtr, uint32_t KeyData18);
void XLNX_COMP_BCAM_BuildCompBcamBaseKeyData18KeyData18(uint32_t* MaskPtr, uint32_t* ValPtr, uint32_t KeyData18);
XLNX_ERROR_CODE XLNX_COMP_BCAM_GetCompBcamBaseKeyData18KeyData18(XLNX_COMP_BCAM_CONTEXT_TYPE* ContextPtr, uint32_t* KeyData18Ptr);
XLNX_ERROR_CODE XLNX_COMP_BCAM_SetCompBcamBaseKeyData18Reg(XLNX_COMP_BCAM_CONTEXT_TYPE* ContextPtr, uint32_t Mask, uint32_t Value);
XLNX_ERROR_CODE XLNX_COMP_BCAM_GetCompBcamBaseKeyData18Reg(XLNX_COMP_BCAM_CONTEXT_TYPE* ContextPtr, uint32_t* ValuePtr);
XLNX_ERROR_CODE XLNX_COMP_BCAM_SetCompBcamBaseKeyData19KeyData19(XLNX_COMP_BCAM_CONTEXT_TYPE* ContextPtr, uint32_t KeyData19);
void XLNX_COMP_BCAM_BuildCompBcamBaseKeyData19KeyData19(uint32_t* MaskPtr, uint32_t* ValPtr, uint32_t KeyData19);
XLNX_ERROR_CODE XLNX_COMP_BCAM_GetCompBcamBaseKeyData19KeyData19(XLNX_COMP_BCAM_CONTEXT_TYPE* ContextPtr, uint32_t* KeyData19Ptr);
XLNX_ERROR_CODE XLNX_COMP_BCAM_SetCompBcamBaseKeyData19Reg(XLNX_COMP_BCAM_CONTEXT_TYPE* ContextPtr, uint32_t Mask, uint32_t Value);
XLNX_ERROR_CODE XLNX_COMP_BCAM_GetCompBcamBaseKeyData19Reg(XLNX_COMP_BCAM_CONTEXT_TYPE* ContextPtr, uint32_t* ValuePtr);
XLNX_ERROR_CODE XLNX_COMP_BCAM_SetCompBcamBaseKeyData20KeyData20(XLNX_COMP_BCAM_CONTEXT_TYPE* ContextPtr, uint32_t KeyData20);
void XLNX_COMP_BCAM_BuildCompBcamBaseKeyData20KeyData20(uint32_t* MaskPtr, uint32_t* ValPtr, uint32_t KeyData20);
XLNX_ERROR_CODE XLNX_COMP_BCAM_GetCompBcamBaseKeyData20KeyData20(XLNX_COMP_BCAM_CONTEXT_TYPE* ContextPtr, uint32_t* KeyData20Ptr);
XLNX_ERROR_CODE XLNX_COMP_BCAM_SetCompBcamBaseKeyData20Reg(XLNX_COMP_BCAM_CONTEXT_TYPE* ContextPtr, uint32_t Mask, uint32_t Value);
XLNX_ERROR_CODE XLNX_COMP_BCAM_GetCompBcamBaseKeyData20Reg(XLNX_COMP_BCAM_CONTEXT_TYPE* ContextPtr, uint32_t* ValuePtr);
XLNX_ERROR_CODE XLNX_COMP_BCAM_SetCompBcamBaseKeyData21KeyData21(XLNX_COMP_BCAM_CONTEXT_TYPE* ContextPtr, uint32_t KeyData21);
void XLNX_COMP_BCAM_BuildCompBcamBaseKeyData21KeyData21(uint32_t* MaskPtr, uint32_t* ValPtr, uint32_t KeyData21);
XLNX_ERROR_CODE XLNX_COMP_BCAM_GetCompBcamBaseKeyData21KeyData21(XLNX_COMP_BCAM_CONTEXT_TYPE* ContextPtr, uint32_t* KeyData21Ptr);
XLNX_ERROR_CODE XLNX_COMP_BCAM_SetCompBcamBaseKeyData21Reg(XLNX_COMP_BCAM_CONTEXT_TYPE* ContextPtr, uint32_t Mask, uint32_t Value);
XLNX_ERROR_CODE XLNX_COMP_BCAM_GetCompBcamBaseKeyData21Reg(XLNX_COMP_BCAM_CONTEXT_TYPE* ContextPtr, uint32_t* ValuePtr);
XLNX_ERROR_CODE XLNX_COMP_BCAM_SetCompBcamBaseKeyData22KeyData22(XLNX_COMP_BCAM_CONTEXT_TYPE* ContextPtr, uint32_t KeyData22);
void XLNX_COMP_BCAM_BuildCompBcamBaseKeyData22KeyData22(uint32_t* MaskPtr, uint32_t* ValPtr, uint32_t KeyData22);
XLNX_ERROR_CODE XLNX_COMP_BCAM_GetCompBcamBaseKeyData22KeyData22(XLNX_COMP_BCAM_CONTEXT_TYPE* ContextPtr, uint32_t* KeyData22Ptr);
XLNX_ERROR_CODE XLNX_COMP_BCAM_SetCompBcamBaseKeyData22Reg(XLNX_COMP_BCAM_CONTEXT_TYPE* ContextPtr, uint32_t Mask, uint32_t Value);
XLNX_ERROR_CODE XLNX_COMP_BCAM_GetCompBcamBaseKeyData22Reg(XLNX_COMP_BCAM_CONTEXT_TYPE* ContextPtr, uint32_t* ValuePtr);
XLNX_ERROR_CODE XLNX_COMP_BCAM_SetCompBcamBaseKeyData23KeyData23(XLNX_COMP_BCAM_CONTEXT_TYPE* ContextPtr, uint32_t KeyData23);
void XLNX_COMP_BCAM_BuildCompBcamBaseKeyData23KeyData23(uint32_t* MaskPtr, uint32_t* ValPtr, uint32_t KeyData23);
XLNX_ERROR_CODE XLNX_COMP_BCAM_GetCompBcamBaseKeyData23KeyData23(XLNX_COMP_BCAM_CONTEXT_TYPE* ContextPtr, uint32_t* KeyData23Ptr);
XLNX_ERROR_CODE XLNX_COMP_BCAM_SetCompBcamBaseKeyData23Reg(XLNX_COMP_BCAM_CONTEXT_TYPE* ContextPtr, uint32_t Mask, uint32_t Value);
XLNX_ERROR_CODE XLNX_COMP_BCAM_GetCompBcamBaseKeyData23Reg(XLNX_COMP_BCAM_CONTEXT_TYPE* ContextPtr, uint32_t* ValuePtr);
XLNX_ERROR_CODE XLNX_COMP_BCAM_SetCompBcamBaseKeyData24KeyData24(XLNX_COMP_BCAM_CONTEXT_TYPE* ContextPtr, uint32_t KeyData24);
void XLNX_COMP_BCAM_BuildCompBcamBaseKeyData24KeyData24(uint32_t* MaskPtr, uint32_t* ValPtr, uint32_t KeyData24);
XLNX_ERROR_CODE XLNX_COMP_BCAM_GetCompBcamBaseKeyData24KeyData24(XLNX_COMP_BCAM_CONTEXT_TYPE* ContextPtr, uint32_t* KeyData24Ptr);
XLNX_ERROR_CODE XLNX_COMP_BCAM_SetCompBcamBaseKeyData24Reg(XLNX_COMP_BCAM_CONTEXT_TYPE* ContextPtr, uint32_t Mask, uint32_t Value);
XLNX_ERROR_CODE XLNX_COMP_BCAM_GetCompBcamBaseKeyData24Reg(XLNX_COMP_BCAM_CONTEXT_TYPE* ContextPtr, uint32_t* ValuePtr);
XLNX_ERROR_CODE XLNX_COMP_BCAM_SetCompBcamBaseKeyData25KeyData25(XLNX_COMP_BCAM_CONTEXT_TYPE* ContextPtr, uint32_t KeyData25);
void XLNX_COMP_BCAM_BuildCompBcamBaseKeyData25KeyData25(uint32_t* MaskPtr, uint32_t* ValPtr, uint32_t KeyData25);
XLNX_ERROR_CODE XLNX_COMP_BCAM_GetCompBcamBaseKeyData25KeyData25(XLNX_COMP_BCAM_CONTEXT_TYPE* ContextPtr, uint32_t* KeyData25Ptr);
XLNX_ERROR_CODE XLNX_COMP_BCAM_SetCompBcamBaseKeyData25Reg(XLNX_COMP_BCAM_CONTEXT_TYPE* ContextPtr, uint32_t Mask, uint32_t Value);
XLNX_ERROR_CODE XLNX_COMP_BCAM_GetCompBcamBaseKeyData25Reg(XLNX_COMP_BCAM_CONTEXT_TYPE* ContextPtr, uint32_t* ValuePtr);
XLNX_ERROR_CODE XLNX_COMP_BCAM_SetCompBcamBaseKeyData26KeyData26(XLNX_COMP_BCAM_CONTEXT_TYPE* ContextPtr, uint32_t KeyData26);
void XLNX_COMP_BCAM_BuildCompBcamBaseKeyData26KeyData26(uint32_t* MaskPtr, uint32_t* ValPtr, uint32_t KeyData26);
XLNX_ERROR_CODE XLNX_COMP_BCAM_GetCompBcamBaseKeyData26KeyData26(XLNX_COMP_BCAM_CONTEXT_TYPE* ContextPtr, uint32_t* KeyData26Ptr);
XLNX_ERROR_CODE XLNX_COMP_BCAM_SetCompBcamBaseKeyData26Reg(XLNX_COMP_BCAM_CONTEXT_TYPE* ContextPtr, uint32_t Mask, uint32_t Value);
XLNX_ERROR_CODE XLNX_COMP_BCAM_GetCompBcamBaseKeyData26Reg(XLNX_COMP_BCAM_CONTEXT_TYPE* ContextPtr, uint32_t* ValuePtr);
XLNX_ERROR_CODE XLNX_COMP_BCAM_SetCompBcamBaseKeyData27KeyData27(XLNX_COMP_BCAM_CONTEXT_TYPE* ContextPtr, uint32_t KeyData27);
void XLNX_COMP_BCAM_BuildCompBcamBaseKeyData27KeyData27(uint32_t* MaskPtr, uint32_t* ValPtr, uint32_t KeyData27);
XLNX_ERROR_CODE XLNX_COMP_BCAM_GetCompBcamBaseKeyData27KeyData27(XLNX_COMP_BCAM_CONTEXT_TYPE* ContextPtr, uint32_t* KeyData27Ptr);
XLNX_ERROR_CODE XLNX_COMP_BCAM_SetCompBcamBaseKeyData27Reg(XLNX_COMP_BCAM_CONTEXT_TYPE* ContextPtr, uint32_t Mask, uint32_t Value);
XLNX_ERROR_CODE XLNX_COMP_BCAM_GetCompBcamBaseKeyData27Reg(XLNX_COMP_BCAM_CONTEXT_TYPE* ContextPtr, uint32_t* ValuePtr);
XLNX_ERROR_CODE XLNX_COMP_BCAM_SetCompBcamBaseKeyData28KeyData28(XLNX_COMP_BCAM_CONTEXT_TYPE* ContextPtr, uint32_t KeyData28);
void XLNX_COMP_BCAM_BuildCompBcamBaseKeyData28KeyData28(uint32_t* MaskPtr, uint32_t* ValPtr, uint32_t KeyData28);
XLNX_ERROR_CODE XLNX_COMP_BCAM_GetCompBcamBaseKeyData28KeyData28(XLNX_COMP_BCAM_CONTEXT_TYPE* ContextPtr, uint32_t* KeyData28Ptr);
XLNX_ERROR_CODE XLNX_COMP_BCAM_SetCompBcamBaseKeyData28Reg(XLNX_COMP_BCAM_CONTEXT_TYPE* ContextPtr, uint32_t Mask, uint32_t Value);
XLNX_ERROR_CODE XLNX_COMP_BCAM_GetCompBcamBaseKeyData28Reg(XLNX_COMP_BCAM_CONTEXT_TYPE* ContextPtr, uint32_t* ValuePtr);
XLNX_ERROR_CODE XLNX_COMP_BCAM_SetCompBcamBaseKeyData29KeyData29(XLNX_COMP_BCAM_CONTEXT_TYPE* ContextPtr, uint32_t KeyData29);
void XLNX_COMP_BCAM_BuildCompBcamBaseKeyData29KeyData29(uint32_t* MaskPtr, uint32_t* ValPtr, uint32_t KeyData29);
XLNX_ERROR_CODE XLNX_COMP_BCAM_GetCompBcamBaseKeyData29KeyData29(XLNX_COMP_BCAM_CONTEXT_TYPE* ContextPtr, uint32_t* KeyData29Ptr);
XLNX_ERROR_CODE XLNX_COMP_BCAM_SetCompBcamBaseKeyData29Reg(XLNX_COMP_BCAM_CONTEXT_TYPE* ContextPtr, uint32_t Mask, uint32_t Value);
XLNX_ERROR_CODE XLNX_COMP_BCAM_GetCompBcamBaseKeyData29Reg(XLNX_COMP_BCAM_CONTEXT_TYPE* ContextPtr, uint32_t* ValuePtr);
XLNX_ERROR_CODE XLNX_COMP_BCAM_SetCompBcamBaseKeyData30KeyData30(XLNX_COMP_BCAM_CONTEXT_TYPE* ContextPtr, uint32_t KeyData30);
void XLNX_COMP_BCAM_BuildCompBcamBaseKeyData30KeyData30(uint32_t* MaskPtr, uint32_t* ValPtr, uint32_t KeyData30);
XLNX_ERROR_CODE XLNX_COMP_BCAM_GetCompBcamBaseKeyData30KeyData30(XLNX_COMP_BCAM_CONTEXT_TYPE* ContextPtr, uint32_t* KeyData30Ptr);
XLNX_ERROR_CODE XLNX_COMP_BCAM_SetCompBcamBaseKeyData30Reg(XLNX_COMP_BCAM_CONTEXT_TYPE* ContextPtr, uint32_t Mask, uint32_t Value);
XLNX_ERROR_CODE XLNX_COMP_BCAM_GetCompBcamBaseKeyData30Reg(XLNX_COMP_BCAM_CONTEXT_TYPE* ContextPtr, uint32_t* ValuePtr);
XLNX_ERROR_CODE XLNX_COMP_BCAM_SetCompBcamBaseKeyData31KeyData31(XLNX_COMP_BCAM_CONTEXT_TYPE* ContextPtr, uint32_t KeyData31);
void XLNX_COMP_BCAM_BuildCompBcamBaseKeyData31KeyData31(uint32_t* MaskPtr, uint32_t* ValPtr, uint32_t KeyData31);
XLNX_ERROR_CODE XLNX_COMP_BCAM_GetCompBcamBaseKeyData31KeyData31(XLNX_COMP_BCAM_CONTEXT_TYPE* ContextPtr, uint32_t* KeyData31Ptr);
XLNX_ERROR_CODE XLNX_COMP_BCAM_SetCompBcamBaseKeyData31Reg(XLNX_COMP_BCAM_CONTEXT_TYPE* ContextPtr, uint32_t Mask, uint32_t Value);
XLNX_ERROR_CODE XLNX_COMP_BCAM_GetCompBcamBaseKeyData31Reg(XLNX_COMP_BCAM_CONTEXT_TYPE* ContextPtr, uint32_t* ValuePtr);
XLNX_ERROR_CODE XLNX_COMP_BCAM_SetCompBcamBaseResponseData00ResponseData00(XLNX_COMP_BCAM_CONTEXT_TYPE* ContextPtr, uint32_t ResponseData00);
XLNX_ERROR_CODE XLNX_COMP_BCAM_SetCompBcamData(const XLNX_COMP_BCAM_CONTEXT_TYPE* ContextPtr, uint32_t Offset, uint32_t ResponseData);
XLNX_ERROR_CODE XLNX_COMP_BCAM_GetCompBcamData(const XLNX_COMP_BCAM_CONTEXT_TYPE* ContextPtr, uint32_t Offset, uint32_t* ResponseDataPtr);
void XLNX_COMP_BCAM_BuildCompBcamBaseResponseData00ResponseData00(uint32_t* MaskPtr, uint32_t* ValPtr, uint32_t ResponseData00);
XLNX_ERROR_CODE XLNX_COMP_BCAM_GetCompBcamBaseResponseData00ResponseData00(XLNX_COMP_BCAM_CONTEXT_TYPE* ContextPtr, uint32_t* ResponseData00Ptr);
XLNX_ERROR_CODE XLNX_COMP_BCAM_SetCompBcamBaseResponseData00Reg(XLNX_COMP_BCAM_CONTEXT_TYPE* ContextPtr, uint32_t Mask, uint32_t Value);
XLNX_ERROR_CODE XLNX_COMP_BCAM_GetCompBcamBaseResponseData00Reg(XLNX_COMP_BCAM_CONTEXT_TYPE* ContextPtr, uint32_t* ValuePtr);
XLNX_ERROR_CODE XLNX_COMP_BCAM_SetCompBcamBaseResponseData01ResponseData01(XLNX_COMP_BCAM_CONTEXT_TYPE* ContextPtr, uint32_t ResponseData01);
void XLNX_COMP_BCAM_BuildCompBcamBaseResponseData01ResponseData01(uint32_t* MaskPtr, uint32_t* ValPtr, uint32_t ResponseData01);
XLNX_ERROR_CODE XLNX_COMP_BCAM_GetCompBcamBaseResponseData01ResponseData01(XLNX_COMP_BCAM_CONTEXT_TYPE* ContextPtr, uint32_t* ResponseData01Ptr);
XLNX_ERROR_CODE XLNX_COMP_BCAM_SetCompBcamBaseResponseData01Reg(XLNX_COMP_BCAM_CONTEXT_TYPE* ContextPtr, uint32_t Mask, uint32_t Value);
XLNX_ERROR_CODE XLNX_COMP_BCAM_GetCompBcamBaseResponseData01Reg(XLNX_COMP_BCAM_CONTEXT_TYPE* ContextPtr, uint32_t* ValuePtr);
XLNX_ERROR_CODE XLNX_COMP_BCAM_SetCompBcamBaseResponseData02ResponseData02(XLNX_COMP_BCAM_CONTEXT_TYPE* ContextPtr, uint32_t ResponseData02);
void XLNX_COMP_BCAM_BuildCompBcamBaseResponseData02ResponseData02(uint32_t* MaskPtr, uint32_t* ValPtr, uint32_t ResponseData02);
XLNX_ERROR_CODE XLNX_COMP_BCAM_GetCompBcamBaseResponseData02ResponseData02(XLNX_COMP_BCAM_CONTEXT_TYPE* ContextPtr, uint32_t* ResponseData02Ptr);
XLNX_ERROR_CODE XLNX_COMP_BCAM_SetCompBcamBaseResponseData02Reg(XLNX_COMP_BCAM_CONTEXT_TYPE* ContextPtr, uint32_t Mask, uint32_t Value);
XLNX_ERROR_CODE XLNX_COMP_BCAM_GetCompBcamBaseResponseData02Reg(XLNX_COMP_BCAM_CONTEXT_TYPE* ContextPtr, uint32_t* ValuePtr);
XLNX_ERROR_CODE XLNX_COMP_BCAM_SetCompBcamBaseResponseData03ResponseData03(XLNX_COMP_BCAM_CONTEXT_TYPE* ContextPtr, uint32_t ResponseData03);
void XLNX_COMP_BCAM_BuildCompBcamBaseResponseData03ResponseData03(uint32_t* MaskPtr, uint32_t* ValPtr, uint32_t ResponseData03);
XLNX_ERROR_CODE XLNX_COMP_BCAM_GetCompBcamBaseResponseData03ResponseData03(XLNX_COMP_BCAM_CONTEXT_TYPE* ContextPtr, uint32_t* ResponseData03Ptr);
XLNX_ERROR_CODE XLNX_COMP_BCAM_SetCompBcamBaseResponseData03Reg(XLNX_COMP_BCAM_CONTEXT_TYPE* ContextPtr, uint32_t Mask, uint32_t Value);
XLNX_ERROR_CODE XLNX_COMP_BCAM_GetCompBcamBaseResponseData03Reg(XLNX_COMP_BCAM_CONTEXT_TYPE* ContextPtr, uint32_t* ValuePtr);
XLNX_ERROR_CODE XLNX_COMP_BCAM_SetCompBcamBaseResponseData04ResponseData04(XLNX_COMP_BCAM_CONTEXT_TYPE* ContextPtr, uint32_t ResponseData04);
void XLNX_COMP_BCAM_BuildCompBcamBaseResponseData04ResponseData04(uint32_t* MaskPtr, uint32_t* ValPtr, uint32_t ResponseData04);
XLNX_ERROR_CODE XLNX_COMP_BCAM_GetCompBcamBaseResponseData04ResponseData04(XLNX_COMP_BCAM_CONTEXT_TYPE* ContextPtr, uint32_t* ResponseData04Ptr);
XLNX_ERROR_CODE XLNX_COMP_BCAM_SetCompBcamBaseResponseData04Reg(XLNX_COMP_BCAM_CONTEXT_TYPE* ContextPtr, uint32_t Mask, uint32_t Value);
XLNX_ERROR_CODE XLNX_COMP_BCAM_GetCompBcamBaseResponseData04Reg(XLNX_COMP_BCAM_CONTEXT_TYPE* ContextPtr, uint32_t* ValuePtr);
XLNX_ERROR_CODE XLNX_COMP_BCAM_SetCompBcamBaseResponseData05ResponseData05(XLNX_COMP_BCAM_CONTEXT_TYPE* ContextPtr, uint32_t ResponseData05);
void XLNX_COMP_BCAM_BuildCompBcamBaseResponseData05ResponseData05(uint32_t* MaskPtr, uint32_t* ValPtr, uint32_t ResponseData05);
XLNX_ERROR_CODE XLNX_COMP_BCAM_GetCompBcamBaseResponseData05ResponseData05(XLNX_COMP_BCAM_CONTEXT_TYPE* ContextPtr, uint32_t* ResponseData05Ptr);
XLNX_ERROR_CODE XLNX_COMP_BCAM_SetCompBcamBaseResponseData05Reg(XLNX_COMP_BCAM_CONTEXT_TYPE* ContextPtr, uint32_t Mask, uint32_t Value);
XLNX_ERROR_CODE XLNX_COMP_BCAM_GetCompBcamBaseResponseData05Reg(XLNX_COMP_BCAM_CONTEXT_TYPE* ContextPtr, uint32_t* ValuePtr);
XLNX_ERROR_CODE XLNX_COMP_BCAM_SetCompBcamBaseResponseData06ResponseData06(XLNX_COMP_BCAM_CONTEXT_TYPE* ContextPtr, uint32_t ResponseData06);
void XLNX_COMP_BCAM_BuildCompBcamBaseResponseData06ResponseData06(uint32_t* MaskPtr, uint32_t* ValPtr, uint32_t ResponseData06);
XLNX_ERROR_CODE XLNX_COMP_BCAM_GetCompBcamBaseResponseData06ResponseData06(XLNX_COMP_BCAM_CONTEXT_TYPE* ContextPtr, uint32_t* ResponseData06Ptr);
XLNX_ERROR_CODE XLNX_COMP_BCAM_SetCompBcamBaseResponseData06Reg(XLNX_COMP_BCAM_CONTEXT_TYPE* ContextPtr, uint32_t Mask, uint32_t Value);
XLNX_ERROR_CODE XLNX_COMP_BCAM_GetCompBcamBaseResponseData06Reg(XLNX_COMP_BCAM_CONTEXT_TYPE* ContextPtr, uint32_t* ValuePtr);
XLNX_ERROR_CODE XLNX_COMP_BCAM_SetCompBcamBaseResponseData07ResponseData07(XLNX_COMP_BCAM_CONTEXT_TYPE* ContextPtr, uint32_t ResponseData07);
void XLNX_COMP_BCAM_BuildCompBcamBaseResponseData07ResponseData07(uint32_t* MaskPtr, uint32_t* ValPtr, uint32_t ResponseData07);
XLNX_ERROR_CODE XLNX_COMP_BCAM_GetCompBcamBaseResponseData07ResponseData07(XLNX_COMP_BCAM_CONTEXT_TYPE* ContextPtr, uint32_t* ResponseData07Ptr);
XLNX_ERROR_CODE XLNX_COMP_BCAM_SetCompBcamBaseResponseData07Reg(XLNX_COMP_BCAM_CONTEXT_TYPE* ContextPtr, uint32_t Mask, uint32_t Value);
XLNX_ERROR_CODE XLNX_COMP_BCAM_GetCompBcamBaseResponseData07Reg(XLNX_COMP_BCAM_CONTEXT_TYPE* ContextPtr, uint32_t* ValuePtr);
XLNX_ERROR_CODE XLNX_COMP_BCAM_SetCompBcamBaseResponseData08ResponseData08(XLNX_COMP_BCAM_CONTEXT_TYPE* ContextPtr, uint32_t ResponseData08);
void XLNX_COMP_BCAM_BuildCompBcamBaseResponseData08ResponseData08(uint32_t* MaskPtr, uint32_t* ValPtr, uint32_t ResponseData08);
XLNX_ERROR_CODE XLNX_COMP_BCAM_GetCompBcamBaseResponseData08ResponseData08(XLNX_COMP_BCAM_CONTEXT_TYPE* ContextPtr, uint32_t* ResponseData08Ptr);
XLNX_ERROR_CODE XLNX_COMP_BCAM_SetCompBcamBaseResponseData08Reg(XLNX_COMP_BCAM_CONTEXT_TYPE* ContextPtr, uint32_t Mask, uint32_t Value);
XLNX_ERROR_CODE XLNX_COMP_BCAM_GetCompBcamBaseResponseData08Reg(XLNX_COMP_BCAM_CONTEXT_TYPE* ContextPtr, uint32_t* ValuePtr);
XLNX_ERROR_CODE XLNX_COMP_BCAM_SetCompBcamBaseResponseData09ResponseData09(XLNX_COMP_BCAM_CONTEXT_TYPE* ContextPtr, uint32_t ResponseData09);
void XLNX_COMP_BCAM_BuildCompBcamBaseResponseData09ResponseData09(uint32_t* MaskPtr, uint32_t* ValPtr, uint32_t ResponseData09);
XLNX_ERROR_CODE XLNX_COMP_BCAM_GetCompBcamBaseResponseData09ResponseData09(XLNX_COMP_BCAM_CONTEXT_TYPE* ContextPtr, uint32_t* ResponseData09Ptr);
XLNX_ERROR_CODE XLNX_COMP_BCAM_SetCompBcamBaseResponseData09Reg(XLNX_COMP_BCAM_CONTEXT_TYPE* ContextPtr, uint32_t Mask, uint32_t Value);
XLNX_ERROR_CODE XLNX_COMP_BCAM_GetCompBcamBaseResponseData09Reg(XLNX_COMP_BCAM_CONTEXT_TYPE* ContextPtr, uint32_t* ValuePtr);
XLNX_ERROR_CODE XLNX_COMP_BCAM_SetCompBcamBaseResponseData10ResponseData10(XLNX_COMP_BCAM_CONTEXT_TYPE* ContextPtr, uint32_t ResponseData10);
void XLNX_COMP_BCAM_BuildCompBcamBaseResponseData10ResponseData10(uint32_t* MaskPtr, uint32_t* ValPtr, uint32_t ResponseData10);
XLNX_ERROR_CODE XLNX_COMP_BCAM_GetCompBcamBaseResponseData10ResponseData10(XLNX_COMP_BCAM_CONTEXT_TYPE* ContextPtr, uint32_t* ResponseData10Ptr);
XLNX_ERROR_CODE XLNX_COMP_BCAM_SetCompBcamBaseResponseData10Reg(XLNX_COMP_BCAM_CONTEXT_TYPE* ContextPtr, uint32_t Mask, uint32_t Value);
XLNX_ERROR_CODE XLNX_COMP_BCAM_GetCompBcamBaseResponseData10Reg(XLNX_COMP_BCAM_CONTEXT_TYPE* ContextPtr, uint32_t* ValuePtr);
XLNX_ERROR_CODE XLNX_COMP_BCAM_SetCompBcamBaseResponseData11ResponseData11(XLNX_COMP_BCAM_CONTEXT_TYPE* ContextPtr, uint32_t ResponseData11);
void XLNX_COMP_BCAM_BuildCompBcamBaseResponseData11ResponseData11(uint32_t* MaskPtr, uint32_t* ValPtr, uint32_t ResponseData11);
XLNX_ERROR_CODE XLNX_COMP_BCAM_GetCompBcamBaseResponseData11ResponseData11(XLNX_COMP_BCAM_CONTEXT_TYPE* ContextPtr, uint32_t* ResponseData11Ptr);
XLNX_ERROR_CODE XLNX_COMP_BCAM_SetCompBcamBaseResponseData11Reg(XLNX_COMP_BCAM_CONTEXT_TYPE* ContextPtr, uint32_t Mask, uint32_t Value);
XLNX_ERROR_CODE XLNX_COMP_BCAM_GetCompBcamBaseResponseData11Reg(XLNX_COMP_BCAM_CONTEXT_TYPE* ContextPtr, uint32_t* ValuePtr);
XLNX_ERROR_CODE XLNX_COMP_BCAM_SetCompBcamBaseResponseData12ResponseData12(XLNX_COMP_BCAM_CONTEXT_TYPE* ContextPtr, uint32_t ResponseData12);
void XLNX_COMP_BCAM_BuildCompBcamBaseResponseData12ResponseData12(uint32_t* MaskPtr, uint32_t* ValPtr, uint32_t ResponseData12);
XLNX_ERROR_CODE XLNX_COMP_BCAM_GetCompBcamBaseResponseData12ResponseData12(XLNX_COMP_BCAM_CONTEXT_TYPE* ContextPtr, uint32_t* ResponseData12Ptr);
XLNX_ERROR_CODE XLNX_COMP_BCAM_SetCompBcamBaseResponseData12Reg(XLNX_COMP_BCAM_CONTEXT_TYPE* ContextPtr, uint32_t Mask, uint32_t Value);
XLNX_ERROR_CODE XLNX_COMP_BCAM_GetCompBcamBaseResponseData12Reg(XLNX_COMP_BCAM_CONTEXT_TYPE* ContextPtr, uint32_t* ValuePtr);
XLNX_ERROR_CODE XLNX_COMP_BCAM_SetCompBcamBaseResponseData13ResponseData13(XLNX_COMP_BCAM_CONTEXT_TYPE* ContextPtr, uint32_t ResponseData13);
void XLNX_COMP_BCAM_BuildCompBcamBaseResponseData13ResponseData13(uint32_t* MaskPtr, uint32_t* ValPtr, uint32_t ResponseData13);
XLNX_ERROR_CODE XLNX_COMP_BCAM_GetCompBcamBaseResponseData13ResponseData13(XLNX_COMP_BCAM_CONTEXT_TYPE* ContextPtr, uint32_t* ResponseData13Ptr);
XLNX_ERROR_CODE XLNX_COMP_BCAM_SetCompBcamBaseResponseData13Reg(XLNX_COMP_BCAM_CONTEXT_TYPE* ContextPtr, uint32_t Mask, uint32_t Value);
XLNX_ERROR_CODE XLNX_COMP_BCAM_GetCompBcamBaseResponseData13Reg(XLNX_COMP_BCAM_CONTEXT_TYPE* ContextPtr, uint32_t* ValuePtr);
XLNX_ERROR_CODE XLNX_COMP_BCAM_SetCompBcamBaseResponseData14ResponseData14(XLNX_COMP_BCAM_CONTEXT_TYPE* ContextPtr, uint32_t ResponseData14);
void XLNX_COMP_BCAM_BuildCompBcamBaseResponseData14ResponseData14(uint32_t* MaskPtr, uint32_t* ValPtr, uint32_t ResponseData14);
XLNX_ERROR_CODE XLNX_COMP_BCAM_GetCompBcamBaseResponseData14ResponseData14(XLNX_COMP_BCAM_CONTEXT_TYPE* ContextPtr, uint32_t* ResponseData14Ptr);
XLNX_ERROR_CODE XLNX_COMP_BCAM_SetCompBcamBaseResponseData14Reg(XLNX_COMP_BCAM_CONTEXT_TYPE* ContextPtr, uint32_t Mask, uint32_t Value);
XLNX_ERROR_CODE XLNX_COMP_BCAM_GetCompBcamBaseResponseData14Reg(XLNX_COMP_BCAM_CONTEXT_TYPE* ContextPtr, uint32_t* ValuePtr);
XLNX_ERROR_CODE XLNX_COMP_BCAM_SetCompBcamBaseResponseData15ResponseData15(XLNX_COMP_BCAM_CONTEXT_TYPE* ContextPtr, uint32_t ResponseData15);
void XLNX_COMP_BCAM_BuildCompBcamBaseResponseData15ResponseData15(uint32_t* MaskPtr, uint32_t* ValPtr, uint32_t ResponseData15);
XLNX_ERROR_CODE XLNX_COMP_BCAM_GetCompBcamBaseResponseData15ResponseData15(XLNX_COMP_BCAM_CONTEXT_TYPE* ContextPtr, uint32_t* ResponseData15Ptr);
XLNX_ERROR_CODE XLNX_COMP_BCAM_SetCompBcamBaseResponseData15Reg(XLNX_COMP_BCAM_CONTEXT_TYPE* ContextPtr, uint32_t Mask, uint32_t Value);
XLNX_ERROR_CODE XLNX_COMP_BCAM_GetCompBcamBaseResponseData15Reg(XLNX_COMP_BCAM_CONTEXT_TYPE* ContextPtr, uint32_t* ValuePtr);
XLNX_ERROR_CODE XLNX_COMP_BCAM_SetCompBcamBaseResponseData16ResponseData16(XLNX_COMP_BCAM_CONTEXT_TYPE* ContextPtr, uint32_t ResponseData16);
void XLNX_COMP_BCAM_BuildCompBcamBaseResponseData16ResponseData16(uint32_t* MaskPtr, uint32_t* ValPtr, uint32_t ResponseData16);
XLNX_ERROR_CODE XLNX_COMP_BCAM_GetCompBcamBaseResponseData16ResponseData16(XLNX_COMP_BCAM_CONTEXT_TYPE* ContextPtr, uint32_t* ResponseData16Ptr);
XLNX_ERROR_CODE XLNX_COMP_BCAM_SetCompBcamBaseResponseData16Reg(XLNX_COMP_BCAM_CONTEXT_TYPE* ContextPtr, uint32_t Mask, uint32_t Value);
XLNX_ERROR_CODE XLNX_COMP_BCAM_GetCompBcamBaseResponseData16Reg(XLNX_COMP_BCAM_CONTEXT_TYPE* ContextPtr, uint32_t* ValuePtr);
XLNX_ERROR_CODE XLNX_COMP_BCAM_SetCompBcamBaseResponseData17ResponseData17(XLNX_COMP_BCAM_CONTEXT_TYPE* ContextPtr, uint32_t ResponseData17);
void XLNX_COMP_BCAM_BuildCompBcamBaseResponseData17ResponseData17(uint32_t* MaskPtr, uint32_t* ValPtr, uint32_t ResponseData17);
XLNX_ERROR_CODE XLNX_COMP_BCAM_GetCompBcamBaseResponseData17ResponseData17(XLNX_COMP_BCAM_CONTEXT_TYPE* ContextPtr, uint32_t* ResponseData17Ptr);
XLNX_ERROR_CODE XLNX_COMP_BCAM_SetCompBcamBaseResponseData17Reg(XLNX_COMP_BCAM_CONTEXT_TYPE* ContextPtr, uint32_t Mask, uint32_t Value);
XLNX_ERROR_CODE XLNX_COMP_BCAM_GetCompBcamBaseResponseData17Reg(XLNX_COMP_BCAM_CONTEXT_TYPE* ContextPtr, uint32_t* ValuePtr);
XLNX_ERROR_CODE XLNX_COMP_BCAM_SetCompBcamBaseResponseData18ResponseData18(XLNX_COMP_BCAM_CONTEXT_TYPE* ContextPtr, uint32_t ResponseData18);
void XLNX_COMP_BCAM_BuildCompBcamBaseResponseData18ResponseData18(uint32_t* MaskPtr, uint32_t* ValPtr, uint32_t ResponseData18);
XLNX_ERROR_CODE XLNX_COMP_BCAM_GetCompBcamBaseResponseData18ResponseData18(XLNX_COMP_BCAM_CONTEXT_TYPE* ContextPtr, uint32_t* ResponseData18Ptr);
XLNX_ERROR_CODE XLNX_COMP_BCAM_SetCompBcamBaseResponseData18Reg(XLNX_COMP_BCAM_CONTEXT_TYPE* ContextPtr, uint32_t Mask, uint32_t Value);
XLNX_ERROR_CODE XLNX_COMP_BCAM_GetCompBcamBaseResponseData18Reg(XLNX_COMP_BCAM_CONTEXT_TYPE* ContextPtr, uint32_t* ValuePtr);
XLNX_ERROR_CODE XLNX_COMP_BCAM_SetCompBcamBaseResponseData19ResponseData19(XLNX_COMP_BCAM_CONTEXT_TYPE* ContextPtr, uint32_t ResponseData19);
void XLNX_COMP_BCAM_BuildCompBcamBaseResponseData19ResponseData19(uint32_t* MaskPtr, uint32_t* ValPtr, uint32_t ResponseData19);
XLNX_ERROR_CODE XLNX_COMP_BCAM_GetCompBcamBaseResponseData19ResponseData19(XLNX_COMP_BCAM_CONTEXT_TYPE* ContextPtr, uint32_t* ResponseData19Ptr);
XLNX_ERROR_CODE XLNX_COMP_BCAM_SetCompBcamBaseResponseData19Reg(XLNX_COMP_BCAM_CONTEXT_TYPE* ContextPtr, uint32_t Mask, uint32_t Value);
XLNX_ERROR_CODE XLNX_COMP_BCAM_GetCompBcamBaseResponseData19Reg(XLNX_COMP_BCAM_CONTEXT_TYPE* ContextPtr, uint32_t* ValuePtr);
XLNX_ERROR_CODE XLNX_COMP_BCAM_SetCompBcamBaseResponseData20ResponseData20(XLNX_COMP_BCAM_CONTEXT_TYPE* ContextPtr, uint32_t ResponseData20);
void XLNX_COMP_BCAM_BuildCompBcamBaseResponseData20ResponseData20(uint32_t* MaskPtr, uint32_t* ValPtr, uint32_t ResponseData20);
XLNX_ERROR_CODE XLNX_COMP_BCAM_GetCompBcamBaseResponseData20ResponseData20(XLNX_COMP_BCAM_CONTEXT_TYPE* ContextPtr, uint32_t* ResponseData20Ptr);
XLNX_ERROR_CODE XLNX_COMP_BCAM_SetCompBcamBaseResponseData20Reg(XLNX_COMP_BCAM_CONTEXT_TYPE* ContextPtr, uint32_t Mask, uint32_t Value);
XLNX_ERROR_CODE XLNX_COMP_BCAM_GetCompBcamBaseResponseData20Reg(XLNX_COMP_BCAM_CONTEXT_TYPE* ContextPtr, uint32_t* ValuePtr);
XLNX_ERROR_CODE XLNX_COMP_BCAM_SetCompBcamBaseResponseData21ResponseData21(XLNX_COMP_BCAM_CONTEXT_TYPE* ContextPtr, uint32_t ResponseData21);
void XLNX_COMP_BCAM_BuildCompBcamBaseResponseData21ResponseData21(uint32_t* MaskPtr, uint32_t* ValPtr, uint32_t ResponseData21);
XLNX_ERROR_CODE XLNX_COMP_BCAM_GetCompBcamBaseResponseData21ResponseData21(XLNX_COMP_BCAM_CONTEXT_TYPE* ContextPtr, uint32_t* ResponseData21Ptr);
XLNX_ERROR_CODE XLNX_COMP_BCAM_SetCompBcamBaseResponseData21Reg(XLNX_COMP_BCAM_CONTEXT_TYPE* ContextPtr, uint32_t Mask, uint32_t Value);
XLNX_ERROR_CODE XLNX_COMP_BCAM_GetCompBcamBaseResponseData21Reg(XLNX_COMP_BCAM_CONTEXT_TYPE* ContextPtr, uint32_t* ValuePtr);
XLNX_ERROR_CODE XLNX_COMP_BCAM_SetCompBcamBaseResponseData22ResponseData22(XLNX_COMP_BCAM_CONTEXT_TYPE* ContextPtr, uint32_t ResponseData22);
void XLNX_COMP_BCAM_BuildCompBcamBaseResponseData22ResponseData22(uint32_t* MaskPtr, uint32_t* ValPtr, uint32_t ResponseData22);
XLNX_ERROR_CODE XLNX_COMP_BCAM_GetCompBcamBaseResponseData22ResponseData22(XLNX_COMP_BCAM_CONTEXT_TYPE* ContextPtr, uint32_t* ResponseData22Ptr);
XLNX_ERROR_CODE XLNX_COMP_BCAM_SetCompBcamBaseResponseData22Reg(XLNX_COMP_BCAM_CONTEXT_TYPE* ContextPtr, uint32_t Mask, uint32_t Value);
XLNX_ERROR_CODE XLNX_COMP_BCAM_GetCompBcamBaseResponseData22Reg(XLNX_COMP_BCAM_CONTEXT_TYPE* ContextPtr, uint32_t* ValuePtr);
XLNX_ERROR_CODE XLNX_COMP_BCAM_SetCompBcamBaseResponseData23ResponseData23(XLNX_COMP_BCAM_CONTEXT_TYPE* ContextPtr, uint32_t ResponseData23);
void XLNX_COMP_BCAM_BuildCompBcamBaseResponseData23ResponseData23(uint32_t* MaskPtr, uint32_t* ValPtr, uint32_t ResponseData23);
XLNX_ERROR_CODE XLNX_COMP_BCAM_GetCompBcamBaseResponseData23ResponseData23(XLNX_COMP_BCAM_CONTEXT_TYPE* ContextPtr, uint32_t* ResponseData23Ptr);
XLNX_ERROR_CODE XLNX_COMP_BCAM_SetCompBcamBaseResponseData23Reg(XLNX_COMP_BCAM_CONTEXT_TYPE* ContextPtr, uint32_t Mask, uint32_t Value);
XLNX_ERROR_CODE XLNX_COMP_BCAM_GetCompBcamBaseResponseData23Reg(XLNX_COMP_BCAM_CONTEXT_TYPE* ContextPtr, uint32_t* ValuePtr);
XLNX_ERROR_CODE XLNX_COMP_BCAM_SetCompBcamBaseResponseData24ResponseData24(XLNX_COMP_BCAM_CONTEXT_TYPE* ContextPtr, uint32_t ResponseData24);
void XLNX_COMP_BCAM_BuildCompBcamBaseResponseData24ResponseData24(uint32_t* MaskPtr, uint32_t* ValPtr, uint32_t ResponseData24);
XLNX_ERROR_CODE XLNX_COMP_BCAM_GetCompBcamBaseResponseData24ResponseData24(XLNX_COMP_BCAM_CONTEXT_TYPE* ContextPtr, uint32_t* ResponseData24Ptr);
XLNX_ERROR_CODE XLNX_COMP_BCAM_SetCompBcamBaseResponseData24Reg(XLNX_COMP_BCAM_CONTEXT_TYPE* ContextPtr, uint32_t Mask, uint32_t Value);
XLNX_ERROR_CODE XLNX_COMP_BCAM_GetCompBcamBaseResponseData24Reg(XLNX_COMP_BCAM_CONTEXT_TYPE* ContextPtr, uint32_t* ValuePtr);
XLNX_ERROR_CODE XLNX_COMP_BCAM_SetCompBcamBaseResponseData25ResponseData25(XLNX_COMP_BCAM_CONTEXT_TYPE* ContextPtr, uint32_t ResponseData25);
void XLNX_COMP_BCAM_BuildCompBcamBaseResponseData25ResponseData25(uint32_t* MaskPtr, uint32_t* ValPtr, uint32_t ResponseData25);
XLNX_ERROR_CODE XLNX_COMP_BCAM_GetCompBcamBaseResponseData25ResponseData25(XLNX_COMP_BCAM_CONTEXT_TYPE* ContextPtr, uint32_t* ResponseData25Ptr);
XLNX_ERROR_CODE XLNX_COMP_BCAM_SetCompBcamBaseResponseData25Reg(XLNX_COMP_BCAM_CONTEXT_TYPE* ContextPtr, uint32_t Mask, uint32_t Value);
XLNX_ERROR_CODE XLNX_COMP_BCAM_GetCompBcamBaseResponseData25Reg(XLNX_COMP_BCAM_CONTEXT_TYPE* ContextPtr, uint32_t* ValuePtr);
XLNX_ERROR_CODE XLNX_COMP_BCAM_SetCompBcamBaseResponseData26ResponseData26(XLNX_COMP_BCAM_CONTEXT_TYPE* ContextPtr, uint32_t ResponseData26);
void XLNX_COMP_BCAM_BuildCompBcamBaseResponseData26ResponseData26(uint32_t* MaskPtr, uint32_t* ValPtr, uint32_t ResponseData26);
XLNX_ERROR_CODE XLNX_COMP_BCAM_GetCompBcamBaseResponseData26ResponseData26(XLNX_COMP_BCAM_CONTEXT_TYPE* ContextPtr, uint32_t* ResponseData26Ptr);
XLNX_ERROR_CODE XLNX_COMP_BCAM_SetCompBcamBaseResponseData26Reg(XLNX_COMP_BCAM_CONTEXT_TYPE* ContextPtr, uint32_t Mask, uint32_t Value);
XLNX_ERROR_CODE XLNX_COMP_BCAM_GetCompBcamBaseResponseData26Reg(XLNX_COMP_BCAM_CONTEXT_TYPE* ContextPtr, uint32_t* ValuePtr);
XLNX_ERROR_CODE XLNX_COMP_BCAM_SetCompBcamBaseResponseData27ResponseData27(XLNX_COMP_BCAM_CONTEXT_TYPE* ContextPtr, uint32_t ResponseData27);
void XLNX_COMP_BCAM_BuildCompBcamBaseResponseData27ResponseData27(uint32_t* MaskPtr, uint32_t* ValPtr, uint32_t ResponseData27);
XLNX_ERROR_CODE XLNX_COMP_BCAM_GetCompBcamBaseResponseData27ResponseData27(XLNX_COMP_BCAM_CONTEXT_TYPE* ContextPtr, uint32_t* ResponseData27Ptr);
XLNX_ERROR_CODE XLNX_COMP_BCAM_SetCompBcamBaseResponseData27Reg(XLNX_COMP_BCAM_CONTEXT_TYPE* ContextPtr, uint32_t Mask, uint32_t Value);
XLNX_ERROR_CODE XLNX_COMP_BCAM_GetCompBcamBaseResponseData27Reg(XLNX_COMP_BCAM_CONTEXT_TYPE* ContextPtr, uint32_t* ValuePtr);
XLNX_ERROR_CODE XLNX_COMP_BCAM_SetCompBcamBaseResponseData28ResponseData28(XLNX_COMP_BCAM_CONTEXT_TYPE* ContextPtr, uint32_t ResponseData28);
void XLNX_COMP_BCAM_BuildCompBcamBaseResponseData28ResponseData28(uint32_t* MaskPtr, uint32_t* ValPtr, uint32_t ResponseData28);
XLNX_ERROR_CODE XLNX_COMP_BCAM_GetCompBcamBaseResponseData28ResponseData28(XLNX_COMP_BCAM_CONTEXT_TYPE* ContextPtr, uint32_t* ResponseData28Ptr);
XLNX_ERROR_CODE XLNX_COMP_BCAM_SetCompBcamBaseResponseData28Reg(XLNX_COMP_BCAM_CONTEXT_TYPE* ContextPtr, uint32_t Mask, uint32_t Value);
XLNX_ERROR_CODE XLNX_COMP_BCAM_GetCompBcamBaseResponseData28Reg(XLNX_COMP_BCAM_CONTEXT_TYPE* ContextPtr, uint32_t* ValuePtr);
XLNX_ERROR_CODE XLNX_COMP_BCAM_SetCompBcamBaseResponseData29ResponseData29(XLNX_COMP_BCAM_CONTEXT_TYPE* ContextPtr, uint32_t ResponseData29);
void XLNX_COMP_BCAM_BuildCompBcamBaseResponseData29ResponseData29(uint32_t* MaskPtr, uint32_t* ValPtr, uint32_t ResponseData29);
XLNX_ERROR_CODE XLNX_COMP_BCAM_GetCompBcamBaseResponseData29ResponseData29(XLNX_COMP_BCAM_CONTEXT_TYPE* ContextPtr, uint32_t* ResponseData29Ptr);
XLNX_ERROR_CODE XLNX_COMP_BCAM_SetCompBcamBaseResponseData29Reg(XLNX_COMP_BCAM_CONTEXT_TYPE* ContextPtr, uint32_t Mask, uint32_t Value);
XLNX_ERROR_CODE XLNX_COMP_BCAM_GetCompBcamBaseResponseData29Reg(XLNX_COMP_BCAM_CONTEXT_TYPE* ContextPtr, uint32_t* ValuePtr);
XLNX_ERROR_CODE XLNX_COMP_BCAM_SetCompBcamBaseResponseData30ResponseData30(XLNX_COMP_BCAM_CONTEXT_TYPE* ContextPtr, uint32_t ResponseData30);
void XLNX_COMP_BCAM_BuildCompBcamBaseResponseData30ResponseData30(uint32_t* MaskPtr, uint32_t* ValPtr, uint32_t ResponseData30);
XLNX_ERROR_CODE XLNX_COMP_BCAM_GetCompBcamBaseResponseData30ResponseData30(XLNX_COMP_BCAM_CONTEXT_TYPE* ContextPtr, uint32_t* ResponseData30Ptr);
XLNX_ERROR_CODE XLNX_COMP_BCAM_SetCompBcamBaseResponseData30Reg(XLNX_COMP_BCAM_CONTEXT_TYPE* ContextPtr, uint32_t Mask, uint32_t Value);
XLNX_ERROR_CODE XLNX_COMP_BCAM_GetCompBcamBaseResponseData30Reg(XLNX_COMP_BCAM_CONTEXT_TYPE* ContextPtr, uint32_t* ValuePtr);
XLNX_ERROR_CODE XLNX_COMP_BCAM_SetCompBcamBaseResponseData31ResponseData31(XLNX_COMP_BCAM_CONTEXT_TYPE* ContextPtr, uint32_t ResponseData31);
void XLNX_COMP_BCAM_BuildCompBcamBaseResponseData31ResponseData31(uint32_t* MaskPtr, uint32_t* ValPtr, uint32_t ResponseData31);
XLNX_ERROR_CODE XLNX_COMP_BCAM_GetCompBcamBaseResponseData31ResponseData31(XLNX_COMP_BCAM_CONTEXT_TYPE* ContextPtr, uint32_t* ResponseData31Ptr);
XLNX_ERROR_CODE XLNX_COMP_BCAM_SetCompBcamBaseResponseData31Reg(XLNX_COMP_BCAM_CONTEXT_TYPE* ContextPtr, uint32_t Mask, uint32_t Value);
XLNX_ERROR_CODE XLNX_COMP_BCAM_GetCompBcamBaseResponseData31Reg(XLNX_COMP_BCAM_CONTEXT_TYPE* ContextPtr, uint32_t* ValuePtr);
XLNX_ERROR_CODE XLNX_COMP_BCAM_SetBcsBaseModeMode(XLNX_COMP_BCAM_CONTEXT_TYPE* ContextPtr, uint32_t Mode);
void XLNX_COMP_BCAM_BuildBcsBaseModeMode(uint32_t* MaskPtr, uint32_t* ValPtr, uint32_t Mode);
XLNX_ERROR_CODE XLNX_COMP_BCAM_GetBcsBaseModeMode(XLNX_COMP_BCAM_CONTEXT_TYPE* ContextPtr, uint32_t* ModePtr);
XLNX_ERROR_CODE XLNX_COMP_BCAM_SetBcsBaseModeReg(XLNX_COMP_BCAM_CONTEXT_TYPE* ContextPtr, uint32_t Mask, uint32_t Value);
XLNX_ERROR_CODE XLNX_COMP_BCAM_GetBcsBaseModeReg(XLNX_COMP_BCAM_CONTEXT_TYPE* ContextPtr, uint32_t* ValuePtr);
XLNX_ERROR_CODE XLNX_COMP_BCAM_GetBcsBaseCrfSbiterrCountCrfSbiterrCount(XLNX_COMP_BCAM_CONTEXT_TYPE* ContextPtr, uint32_t* CrfSbiterrCountPtr);
XLNX_ERROR_CODE XLNX_COMP_BCAM_GetBcsBaseCrfSbiterrCountReg(XLNX_COMP_BCAM_CONTEXT_TYPE* ContextPtr, uint32_t* ValuePtr);
XLNX_ERROR_CODE XLNX_COMP_BCAM_GetBcsBaseCrfDbiterrCountCrfDbiterrCount(XLNX_COMP_BCAM_CONTEXT_TYPE* ContextPtr, uint32_t* CrfDbiterrCountPtr);
XLNX_ERROR_CODE XLNX_COMP_BCAM_GetBcsBaseCrfDbiterrCountReg(XLNX_COMP_BCAM_CONTEXT_TYPE* ContextPtr, uint32_t* ValuePtr);
XLNX_ERROR_CODE XLNX_COMP_BCAM_GetBcsBaseRroSbiterrCountRroSbiterrCount(XLNX_COMP_BCAM_CONTEXT_TYPE* ContextPtr, uint32_t* RroSbiterrCountPtr);
XLNX_ERROR_CODE XLNX_COMP_BCAM_GetBcsBaseRroSbiterrCountReg(XLNX_COMP_BCAM_CONTEXT_TYPE* ContextPtr, uint32_t* ValuePtr);
#ifdef __cplusplus
}
#endif
#endif 
#ifndef COMP_BCAM_ASSEMBLY_MEMMAP_H_
#define COMP_BCAM_ASSEMBLY_MEMMAP_H_
#ifdef __cplusplus
extern "C"
{
#endif
#define ASSEMBLY_COMP_BCAM_REGPAGE_SIZE (0x1000)
#define ASSEMBLY_COMP_BCAM_OFFSET (0x0)
#define ASSEMBLY_BCS_REGPAGE_SIZE (0x1000)
#define ASSEMBLY_BCS_OFFSET (0x1000)
#ifdef __cplusplus
}
#endif
#endif 
#ifndef COMP_BCAM_COMP_BCAM_MEMMAP_H_
#define COMP_BCAM_COMP_BCAM_MEMMAP_H_
#ifdef __cplusplus
extern "C"
{
#endif
#define COMP_BCAM_BASE_1_OF_1_OFFSET (0x0) 
#define COMP_BCAM_BASE_1_OF_1_MASK (0xffffffff)
#define COMP_BCAM_BASE_1_OF_1_SHIFT (0)
#define COMP_BCAM_BASE_NUM (1)
#define COMP_BCAM_BASE_VERSION_REG_OFFSET (0x0) 
#define COMP_BCAM_BASE_VERSION_REG_MASK (0xffffffff)
#define COMP_BCAM_BASE_VERSION_REG_SHIFT (0)
#define COMP_BCAM_BASE_VERSION_MAJOR_OFFSET (0x0) 
#define COMP_BCAM_BASE_VERSION_MAJOR_ACCESS (XLNX_RO)
#define COMP_BCAM_BASE_VERSION_REG_NUM (0x1)
#define COMP_BCAM_BASE_VERSION_MAJOR_MASK (0xff00)
#define COMP_BCAM_BASE_VERSION_MAJOR_SHIFT (8)
#define COMP_BCAM_BASE_VERSION_MINOR_OFFSET (0x0) 
#define COMP_BCAM_BASE_VERSION_MINOR_ACCESS (XLNX_RO)
#define COMP_BCAM_BASE_VERSION_MINOR_MASK (0xff)
#define COMP_BCAM_BASE_VERSION_MINOR_SHIFT (0)
#define COMP_BCAM_BASE_SCRATCH_REG_OFFSET (0x4) 
#define COMP_BCAM_BASE_SCRATCH_REG_MASK (0xffffffff)
#define COMP_BCAM_BASE_SCRATCH_REG_SHIFT (0)
#define COMP_BCAM_BASE_SCRATCH_SCRATCH_OFFSET (0x4) 
#define COMP_BCAM_BASE_SCRATCH_SCRATCH_ACCESS (XLNX_RW)
#define COMP_BCAM_BASE_SCRATCH_REG_NUM (0x1)
#define COMP_BCAM_BASE_SCRATCH_SCRATCH_MASK (0xffffffff)
#define COMP_BCAM_BASE_SCRATCH_SCRATCH_SHIFT (0)
#define COMP_BCAM_BASE_AGE_THRESHOLD_REG_OFFSET (0x8) 
#define COMP_BCAM_BASE_AGE_THRESHOLD_REG_MASK (0xffffffff)
#define COMP_BCAM_BASE_AGE_THRESHOLD_REG_SHIFT (0)
#define COMP_BCAM_BASE_AGE_THRESHOLD_AGE_THRESHOLD_OFFSET (0x8) 
#define COMP_BCAM_BASE_AGE_THRESHOLD_AGE_THRESHOLD_ACCESS (XLNX_RW)
#define COMP_BCAM_BASE_AGE_THRESHOLD_REG_NUM (0x1)
#define COMP_BCAM_BASE_AGE_THRESHOLD_AGE_THRESHOLD_MASK (0x3ff)
#define COMP_BCAM_BASE_AGE_THRESHOLD_AGE_THRESHOLD_SHIFT (0)
#define COMP_BCAM_BASE_NUMBER_PASSES_REG_OFFSET (0xc) 
#define COMP_BCAM_BASE_NUMBER_PASSES_REG_MASK (0xffffffff)
#define COMP_BCAM_BASE_NUMBER_PASSES_REG_SHIFT (0)
#define COMP_BCAM_BASE_NUMBER_PASSES_NUMBER_PASSES_OFFSET (0xc) 
#define COMP_BCAM_BASE_NUMBER_PASSES_NUMBER_PASSES_ACCESS (XLNX_RW)
#define COMP_BCAM_BASE_NUMBER_PASSES_REG_NUM (0x1)
#define COMP_BCAM_BASE_NUMBER_PASSES_NUMBER_PASSES_MASK (0xff)
#define COMP_BCAM_BASE_NUMBER_PASSES_NUMBER_PASSES_SHIFT (0)
#define COMP_BCAM_BASE_INSERT_COUNT_REG_OFFSET (0x10) 
#define COMP_BCAM_BASE_INSERT_COUNT_REG_MASK (0xffffffff)
#define COMP_BCAM_BASE_INSERT_COUNT_REG_SHIFT (0)
#define COMP_BCAM_BASE_INSERT_COUNT_INSERT_COUNT_OFFSET (0x10) 
#define COMP_BCAM_BASE_INSERT_COUNT_INSERT_COUNT_ACCESS (XLNX_RO)
#define COMP_BCAM_BASE_INSERT_COUNT_REG_NUM (0x1)
#define COMP_BCAM_BASE_INSERT_COUNT_INSERT_COUNT_MASK (0x3ffffff)
#define COMP_BCAM_BASE_INSERT_COUNT_INSERT_COUNT_SHIFT (0)
#define COMP_BCAM_BASE_INSERT_COUNT_TIMER_COUNT_OFFSET (0x10) 
#define COMP_BCAM_BASE_INSERT_COUNT_TIMER_COUNT_ACCESS (XLNX_RO)
#define COMP_BCAM_BASE_INSERT_COUNT_TIMER_COUNT_MASK (0xfc000000)
#define COMP_BCAM_BASE_INSERT_COUNT_TIMER_COUNT_SHIFT (26)
#define COMP_BCAM_BASE_UPDATE_COUNT_REG_OFFSET (0x14) 
#define COMP_BCAM_BASE_UPDATE_COUNT_REG_MASK (0xffffffff)
#define COMP_BCAM_BASE_UPDATE_COUNT_REG_SHIFT (0)
#define COMP_BCAM_BASE_UPDATE_COUNT_UPDATE_COUNT_OFFSET (0x14) 
#define COMP_BCAM_BASE_UPDATE_COUNT_UPDATE_COUNT_ACCESS (XLNX_RO)
#define COMP_BCAM_BASE_UPDATE_COUNT_REG_NUM (0x1)
#define COMP_BCAM_BASE_UPDATE_COUNT_UPDATE_COUNT_MASK (0x3ffffff)
#define COMP_BCAM_BASE_UPDATE_COUNT_UPDATE_COUNT_SHIFT (0)
#define COMP_BCAM_BASE_UPDATE_COUNT_TIMER_COUNT_OFFSET (0x14) 
#define COMP_BCAM_BASE_UPDATE_COUNT_TIMER_COUNT_ACCESS (XLNX_RO)
#define COMP_BCAM_BASE_UPDATE_COUNT_TIMER_COUNT_MASK (0xfc000000)
#define COMP_BCAM_BASE_UPDATE_COUNT_TIMER_COUNT_SHIFT (26)
#define COMP_BCAM_BASE_DELETE_COUNT_REG_OFFSET (0x18) 
#define COMP_BCAM_BASE_DELETE_COUNT_REG_MASK (0xffffffff)
#define COMP_BCAM_BASE_DELETE_COUNT_REG_SHIFT (0)
#define COMP_BCAM_BASE_DELETE_COUNT_DELETE_COUNT_OFFSET (0x18) 
#define COMP_BCAM_BASE_DELETE_COUNT_DELETE_COUNT_ACCESS (XLNX_RO)
#define COMP_BCAM_BASE_DELETE_COUNT_REG_NUM (0x1)
#define COMP_BCAM_BASE_DELETE_COUNT_DELETE_COUNT_MASK (0x3ffffff)
#define COMP_BCAM_BASE_DELETE_COUNT_DELETE_COUNT_SHIFT (0)
#define COMP_BCAM_BASE_DELETE_COUNT_TIMER_COUNT_OFFSET (0x18) 
#define COMP_BCAM_BASE_DELETE_COUNT_TIMER_COUNT_ACCESS (XLNX_RO)
#define COMP_BCAM_BASE_DELETE_COUNT_TIMER_COUNT_MASK (0xfc000000)
#define COMP_BCAM_BASE_DELETE_COUNT_TIMER_COUNT_SHIFT (26)
#define COMP_BCAM_BASE_GETBYKEY_COUNT_REG_OFFSET (0x1c) 
#define COMP_BCAM_BASE_GETBYKEY_COUNT_REG_MASK (0xffffffff)
#define COMP_BCAM_BASE_GETBYKEY_COUNT_REG_SHIFT (0)
#define COMP_BCAM_BASE_GETBYKEY_COUNT_GETBYKEY_COUNT_OFFSET (0x1c) 
#define COMP_BCAM_BASE_GETBYKEY_COUNT_GETBYKEY_COUNT_ACCESS (XLNX_RO)
#define COMP_BCAM_BASE_GETBYKEY_COUNT_REG_NUM (0x1)
#define COMP_BCAM_BASE_GETBYKEY_COUNT_GETBYKEY_COUNT_MASK (0x3ffffff)
#define COMP_BCAM_BASE_GETBYKEY_COUNT_GETBYKEY_COUNT_SHIFT (0)
#define COMP_BCAM_BASE_GETBYKEY_COUNT_TIMER_COUNT_OFFSET (0x1c) 
#define COMP_BCAM_BASE_GETBYKEY_COUNT_TIMER_COUNT_ACCESS (XLNX_RO)
#define COMP_BCAM_BASE_GETBYKEY_COUNT_TIMER_COUNT_MASK (0xfc000000)
#define COMP_BCAM_BASE_GETBYKEY_COUNT_TIMER_COUNT_SHIFT (26)
#define COMP_BCAM_BASE_LOOKUP_COUNT_REG_OFFSET (0x20) 
#define COMP_BCAM_BASE_LOOKUP_COUNT_REG_MASK (0xffffffff)
#define COMP_BCAM_BASE_LOOKUP_COUNT_REG_SHIFT (0)
#define COMP_BCAM_BASE_LOOKUP_COUNT_LOOKUP_COUNT_OFFSET (0x20) 
#define COMP_BCAM_BASE_LOOKUP_COUNT_LOOKUP_COUNT_ACCESS (XLNX_RO)
#define COMP_BCAM_BASE_LOOKUP_COUNT_REG_NUM (0x1)
#define COMP_BCAM_BASE_LOOKUP_COUNT_LOOKUP_COUNT_MASK (0x3ffffff)
#define COMP_BCAM_BASE_LOOKUP_COUNT_LOOKUP_COUNT_SHIFT (0)
#define COMP_BCAM_BASE_LOOKUP_COUNT_TIMER_COUNT_OFFSET (0x20) 
#define COMP_BCAM_BASE_LOOKUP_COUNT_TIMER_COUNT_ACCESS (XLNX_RO)
#define COMP_BCAM_BASE_LOOKUP_COUNT_TIMER_COUNT_MASK (0xfc000000)
#define COMP_BCAM_BASE_LOOKUP_COUNT_TIMER_COUNT_SHIFT (26)
#define COMP_BCAM_BASE_HIT_COUNT_REG_OFFSET (0x24) 
#define COMP_BCAM_BASE_HIT_COUNT_REG_MASK (0xffffffff)
#define COMP_BCAM_BASE_HIT_COUNT_REG_SHIFT (0)
#define COMP_BCAM_BASE_HIT_COUNT_HIT_COUNT_OFFSET (0x24) 
#define COMP_BCAM_BASE_HIT_COUNT_HIT_COUNT_ACCESS (XLNX_RO)
#define COMP_BCAM_BASE_HIT_COUNT_REG_NUM (0x1)
#define COMP_BCAM_BASE_HIT_COUNT_HIT_COUNT_MASK (0x3ffffff)
#define COMP_BCAM_BASE_HIT_COUNT_HIT_COUNT_SHIFT (0)
#define COMP_BCAM_BASE_HIT_COUNT_TIMER_COUNT_OFFSET (0x24) 
#define COMP_BCAM_BASE_HIT_COUNT_TIMER_COUNT_ACCESS (XLNX_RO)
#define COMP_BCAM_BASE_HIT_COUNT_TIMER_COUNT_MASK (0xfc000000)
#define COMP_BCAM_BASE_HIT_COUNT_TIMER_COUNT_SHIFT (26)
#define COMP_BCAM_BASE_SBITERR_COUNT_REG_OFFSET (0x28) 
#define COMP_BCAM_BASE_SBITERR_COUNT_REG_MASK (0xffffffff)
#define COMP_BCAM_BASE_SBITERR_COUNT_REG_SHIFT (0)
#define COMP_BCAM_BASE_SBITERR_COUNT_SBITERR_COUNT_OFFSET (0x28) 
#define COMP_BCAM_BASE_SBITERR_COUNT_SBITERR_COUNT_ACCESS (XLNX_RO)
#define COMP_BCAM_BASE_SBITERR_COUNT_REG_NUM (0x1)
#define COMP_BCAM_BASE_SBITERR_COUNT_SBITERR_COUNT_MASK (0xffffffff)
#define COMP_BCAM_BASE_SBITERR_COUNT_SBITERR_COUNT_SHIFT (0)
#define COMP_BCAM_BASE_DBITERR_COUNT_REG_OFFSET (0x2c) 
#define COMP_BCAM_BASE_DBITERR_COUNT_REG_MASK (0xffffffff)
#define COMP_BCAM_BASE_DBITERR_COUNT_REG_SHIFT (0)
#define COMP_BCAM_BASE_DBITERR_COUNT_DBITERR_COUNT_OFFSET (0x2c) 
#define COMP_BCAM_BASE_DBITERR_COUNT_DBITERR_COUNT_ACCESS (XLNX_RO)
#define COMP_BCAM_BASE_DBITERR_COUNT_REG_NUM (0x1)
#define COMP_BCAM_BASE_DBITERR_COUNT_DBITERR_COUNT_MASK (0xffffffff)
#define COMP_BCAM_BASE_DBITERR_COUNT_DBITERR_COUNT_SHIFT (0)
#define COMP_BCAM_BASE_EXT_EVENT_COUNT_REG_OFFSET (0x30) 
#define COMP_BCAM_BASE_EXT_EVENT_COUNT_REG_MASK (0xffffffff)
#define COMP_BCAM_BASE_EXT_EVENT_COUNT_REG_SHIFT (0)
#define COMP_BCAM_BASE_EXT_EVENT_COUNT_EXT_EVENT_COUNT_OFFSET (0x30) 
#define COMP_BCAM_BASE_EXT_EVENT_COUNT_EXT_EVENT_COUNT_ACCESS (XLNX_RO)
#define COMP_BCAM_BASE_EXT_EVENT_COUNT_REG_NUM (0x1)
#define COMP_BCAM_BASE_EXT_EVENT_COUNT_EXT_EVENT_COUNT_MASK (0x3ffffff)
#define COMP_BCAM_BASE_EXT_EVENT_COUNT_EXT_EVENT_COUNT_SHIFT (0)
#define COMP_BCAM_BASE_EXT_EVENT_COUNT_TIMER_COUNT_OFFSET (0x30) 
#define COMP_BCAM_BASE_EXT_EVENT_COUNT_TIMER_COUNT_ACCESS (XLNX_RO)
#define COMP_BCAM_BASE_EXT_EVENT_COUNT_TIMER_COUNT_MASK (0xfc000000)
#define COMP_BCAM_BASE_EXT_EVENT_COUNT_TIMER_COUNT_SHIFT (26)
#define COMP_BCAM_BASE_LI_REQ_WS_COUNT_REG_OFFSET (0x34) 
#define COMP_BCAM_BASE_LI_REQ_WS_COUNT_REG_MASK (0xffffffff)
#define COMP_BCAM_BASE_LI_REQ_WS_COUNT_REG_SHIFT (0)
#define COMP_BCAM_BASE_LI_REQ_WS_COUNT_LI_REQ_WS_COUNT_OFFSET (0x34) 
#define COMP_BCAM_BASE_LI_REQ_WS_COUNT_LI_REQ_WS_COUNT_ACCESS (XLNX_RO)
#define COMP_BCAM_BASE_LI_REQ_WS_COUNT_REG_NUM (0x1)
#define COMP_BCAM_BASE_LI_REQ_WS_COUNT_LI_REQ_WS_COUNT_MASK (0x3ffffff)
#define COMP_BCAM_BASE_LI_REQ_WS_COUNT_LI_REQ_WS_COUNT_SHIFT (0)
#define COMP_BCAM_BASE_LI_REQ_WS_COUNT_TIMER_COUNT_OFFSET (0x34) 
#define COMP_BCAM_BASE_LI_REQ_WS_COUNT_TIMER_COUNT_ACCESS (XLNX_RO)
#define COMP_BCAM_BASE_LI_REQ_WS_COUNT_TIMER_COUNT_MASK (0xfc000000)
#define COMP_BCAM_BASE_LI_REQ_WS_COUNT_TIMER_COUNT_SHIFT (26)
#define COMP_BCAM_BASE_TOTAL_NUM_PASSES_LO_REG_OFFSET (0x3c) 
#define COMP_BCAM_BASE_TOTAL_NUM_PASSES_LO_REG_MASK (0xffffffff)
#define COMP_BCAM_BASE_TOTAL_NUM_PASSES_LO_REG_SHIFT (0)
#define COMP_BCAM_BASE_TOTAL_NUM_PASSES_LO_TOTAL_NUM_PASSES_LO_OFFSET (0x3c) 
#define COMP_BCAM_BASE_TOTAL_NUM_PASSES_LO_TOTAL_NUM_PASSES_LO_ACCESS (XLNX_RO)
#define COMP_BCAM_BASE_TOTAL_NUM_PASSES_LO_REG_NUM (0x1)
#define COMP_BCAM_BASE_TOTAL_NUM_PASSES_LO_TOTAL_NUM_PASSES_LO_MASK (0xffffffff)
#define COMP_BCAM_BASE_TOTAL_NUM_PASSES_LO_TOTAL_NUM_PASSES_LO_SHIFT (0)
#define COMP_BCAM_BASE_TOTAL_NUM_PASSES_HI_REG_OFFSET (0x40) 
#define COMP_BCAM_BASE_TOTAL_NUM_PASSES_HI_REG_MASK (0xffffffff)
#define COMP_BCAM_BASE_TOTAL_NUM_PASSES_HI_REG_SHIFT (0)
#define COMP_BCAM_BASE_TOTAL_NUM_PASSES_HI_TOTAL_NUM_PASSES_HI_OFFSET (0x40) 
#define COMP_BCAM_BASE_TOTAL_NUM_PASSES_HI_TOTAL_NUM_PASSES_HI_ACCESS (XLNX_RO)
#define COMP_BCAM_BASE_TOTAL_NUM_PASSES_HI_REG_NUM (0x1)
#define COMP_BCAM_BASE_TOTAL_NUM_PASSES_HI_TOTAL_NUM_PASSES_HI_MASK (0xffffffff)
#define COMP_BCAM_BASE_TOTAL_NUM_PASSES_HI_TOTAL_NUM_PASSES_HI_SHIFT (0)
#define COMP_BCAM_BASE_LAST_DET_NUM_PASSES_REG_OFFSET (0x44) 
#define COMP_BCAM_BASE_LAST_DET_NUM_PASSES_REG_MASK (0xffffffff)
#define COMP_BCAM_BASE_LAST_DET_NUM_PASSES_REG_SHIFT (0)
#define COMP_BCAM_BASE_LAST_DET_NUM_PASSES_LAST_DET_NUM_PASSES_OFFSET (0x44) 
#define COMP_BCAM_BASE_LAST_DET_NUM_PASSES_LAST_DET_NUM_PASSES_ACCESS (XLNX_RO)
#define COMP_BCAM_BASE_LAST_DET_NUM_PASSES_REG_NUM (0x1)
#define COMP_BCAM_BASE_LAST_DET_NUM_PASSES_LAST_DET_NUM_PASSES_MASK (0xffff)
#define COMP_BCAM_BASE_LAST_DET_NUM_PASSES_LAST_DET_NUM_PASSES_SHIFT (0)
#define COMP_BCAM_BASE_MAX_DET_NUM_PASSES_REG_OFFSET (0x48) 
#define COMP_BCAM_BASE_MAX_DET_NUM_PASSES_REG_MASK (0xffffffff)
#define COMP_BCAM_BASE_MAX_DET_NUM_PASSES_REG_SHIFT (0)
#define COMP_BCAM_BASE_MAX_DET_NUM_PASSES_MAX_DET_NUM_PASSES_OFFSET (0x48) 
#define COMP_BCAM_BASE_MAX_DET_NUM_PASSES_MAX_DET_NUM_PASSES_ACCESS (XLNX_RO)
#define COMP_BCAM_BASE_MAX_DET_NUM_PASSES_REG_NUM (0x1)
#define COMP_BCAM_BASE_MAX_DET_NUM_PASSES_MAX_DET_NUM_PASSES_MASK (0xffff)
#define COMP_BCAM_BASE_MAX_DET_NUM_PASSES_MAX_DET_NUM_PASSES_SHIFT (0)
#define COMP_BCAM_BASE_FREEZE_COUNTERS_REG_OFFSET (0x4c) 
#define COMP_BCAM_BASE_FREEZE_COUNTERS_REG_MASK (0xffffffff)
#define COMP_BCAM_BASE_FREEZE_COUNTERS_REG_SHIFT (0)
#define COMP_BCAM_BASE_FREEZE_COUNTERS_FREEZE_COUNTERS_OFFSET (0x4c) 
#define COMP_BCAM_BASE_FREEZE_COUNTERS_FREEZE_COUNTERS_ACCESS (XLNX_RW)
#define COMP_BCAM_BASE_FREEZE_COUNTERS_REG_NUM (0x1)
#define COMP_BCAM_BASE_FREEZE_COUNTERS_FREEZE_COUNTERS_MASK (0x1)
#define COMP_BCAM_BASE_FREEZE_COUNTERS_FREEZE_COUNTERS_SHIFT (0)
#define COMP_BCAM_BASE_INDIRECT_ADDR_REG_OFFSET (0x100) 
#define COMP_BCAM_BASE_INDIRECT_ADDR_REG_MASK (0xffffffff)
#define COMP_BCAM_BASE_INDIRECT_ADDR_REG_SHIFT (0)
#define COMP_BCAM_BASE_INDIRECT_ADDR_INDIRECT_ADDR_OFFSET (0x100) 
#define COMP_BCAM_BASE_INDIRECT_ADDR_INDIRECT_ADDR_ACCESS (XLNX_RW)
#define COMP_BCAM_BASE_INDIRECT_ADDR_REG_NUM (0x1)
#define COMP_BCAM_BASE_INDIRECT_ADDR_INDIRECT_ADDR_MASK (0xffffffff)
#define COMP_BCAM_BASE_INDIRECT_ADDR_INDIRECT_ADDR_SHIFT (0)
#define COMP_BCAM_BASE_INDIRECT_RD_DATA_00_REG_OFFSET (0x104) 
#define COMP_BCAM_BASE_INDIRECT_RD_DATA_00_REG_MASK (0xffffffff)
#define COMP_BCAM_BASE_INDIRECT_RD_DATA_00_REG_SHIFT (0)
#define COMP_BCAM_BASE_INDIRECT_RD_DATA_00_INDIRECT_RD_DATA_00_OFFSET (0x104) 
#define COMP_BCAM_BASE_INDIRECT_RD_DATA_00_INDIRECT_RD_DATA_00_ACCESS (XLNX_RO)
#define COMP_BCAM_BASE_INDIRECT_RD_DATA_00_REG_NUM (0x1)
#define COMP_BCAM_BASE_INDIRECT_RD_DATA_00_INDIRECT_RD_DATA_00_MASK (0xffffffff)
#define COMP_BCAM_BASE_INDIRECT_RD_DATA_00_INDIRECT_RD_DATA_00_SHIFT (0)
#define COMP_BCAM_BASE_INDIRECT_WR_DATA_00_REG_OFFSET (0x108) 
#define COMP_BCAM_BASE_INDIRECT_WR_DATA_00_REG_MASK (0xffffffff)
#define COMP_BCAM_BASE_INDIRECT_WR_DATA_00_REG_SHIFT (0)
#define COMP_BCAM_BASE_INDIRECT_WR_DATA_00_INDIRECT_WR_DATA_00_OFFSET (0x108) 
#define COMP_BCAM_BASE_INDIRECT_WR_DATA_00_INDIRECT_WR_DATA_00_ACCESS (XLNX_RW)
#define COMP_BCAM_BASE_INDIRECT_WR_DATA_00_REG_NUM (0x1)
#define COMP_BCAM_BASE_INDIRECT_WR_DATA_00_INDIRECT_WR_DATA_00_MASK (0xffffffff)
#define COMP_BCAM_BASE_INDIRECT_WR_DATA_00_INDIRECT_WR_DATA_00_SHIFT (0)
#define COMP_BCAM_BASE_INDIRECT_WR_DATA_01_REG_OFFSET (0x10c) 
#define COMP_BCAM_BASE_INDIRECT_WR_DATA_01_REG_MASK (0xffffffff)
#define COMP_BCAM_BASE_INDIRECT_WR_DATA_01_REG_SHIFT (0)
#define COMP_BCAM_BASE_INDIRECT_WR_DATA_01_INDIRECT_WR_DATA_01_OFFSET (0x10c) 
#define COMP_BCAM_BASE_INDIRECT_WR_DATA_01_INDIRECT_WR_DATA_01_ACCESS (XLNX_RW)
#define COMP_BCAM_BASE_INDIRECT_WR_DATA_01_REG_NUM (0x1)
#define COMP_BCAM_BASE_INDIRECT_WR_DATA_01_INDIRECT_WR_DATA_01_MASK (0xffffffff)
#define COMP_BCAM_BASE_INDIRECT_WR_DATA_01_INDIRECT_WR_DATA_01_SHIFT (0)
#define COMP_BCAM_BASE_STATUS_REG_OFFSET (0x110) 
#define COMP_BCAM_BASE_STATUS_REG_MASK (0xffffffff)
#define COMP_BCAM_BASE_STATUS_REG_SHIFT (0)
#define COMP_BCAM_BASE_STATUS_STATUS_OFFSET (0x110) 
#define COMP_BCAM_BASE_STATUS_STATUS_ACCESS (XLNX_RO)
#define COMP_BCAM_BASE_STATUS_REG_NUM (0x1)
#define COMP_BCAM_BASE_STATUS_STATUS_MASK (0x7)
#define COMP_BCAM_BASE_STATUS_STATUS_SHIFT (0)
#define COMP_BCAM_BASE_OPERATION_REG_OFFSET (0x114) 
#define COMP_BCAM_BASE_OPERATION_REG_MASK (0xffffffff)
#define COMP_BCAM_BASE_OPERATION_REG_SHIFT (0)
#define COMP_BCAM_BASE_OPERATION_OPERATION_OFFSET (0x114) 
#define COMP_BCAM_BASE_OPERATION_OPERATION_ACCESS (XLNX_WO)
#define COMP_BCAM_BASE_OPERATION_REG_NUM (0x1)
#define COMP_BCAM_BASE_OPERATION_OPERATION_MASK (0x3)
#define COMP_BCAM_BASE_OPERATION_OPERATION_SHIFT (0)
#define COMP_BCAM_BASE_SAMPLE_RATE_REG_OFFSET (0x118) 
#define COMP_BCAM_BASE_SAMPLE_RATE_REG_MASK (0xffffffff)
#define COMP_BCAM_BASE_SAMPLE_RATE_REG_SHIFT (0)
#define COMP_BCAM_BASE_SAMPLE_RATE_SAMPLE_RATE_OFFSET (0x118) 
#define COMP_BCAM_BASE_SAMPLE_RATE_SAMPLE_RATE_ACCESS (XLNX_RW)
#define COMP_BCAM_BASE_SAMPLE_RATE_REG_NUM (0x1)
#define COMP_BCAM_BASE_SAMPLE_RATE_SAMPLE_RATE_MASK (0x3)
#define COMP_BCAM_BASE_SAMPLE_RATE_SAMPLE_RATE_SHIFT (0)
#define COMP_BCAM_BASE_CAM_CLEAR_REG_OFFSET (0x11c) 
#define COMP_BCAM_BASE_CAM_CLEAR_REG_MASK (0xffffffff)
#define COMP_BCAM_BASE_CAM_CLEAR_REG_SHIFT (0)
#define COMP_BCAM_BASE_CAM_CLEAR_CAM_CLEAR_OFFSET (0x11c) 
#define COMP_BCAM_BASE_CAM_CLEAR_CAM_CLEAR_ACCESS (XLNX_RW)
#define COMP_BCAM_BASE_CAM_CLEAR_REG_NUM (0x1)
#define COMP_BCAM_BASE_CAM_CLEAR_CAM_CLEAR_MASK (0x1)
#define COMP_BCAM_BASE_CAM_CLEAR_CAM_CLEAR_SHIFT (0)
#define COMP_BCAM_BASE_KEY_DATA_00_REG_OFFSET (0x200) 
#define COMP_BCAM_BASE_KEY_DATA_00_REG_MASK (0xffffffff)
#define COMP_BCAM_BASE_KEY_DATA_00_REG_SHIFT (0)
#define COMP_BCAM_BASE_KEY_DATA_00_KEY_DATA_00_OFFSET (0x200) 
#define COMP_BCAM_BASE_KEY_DATA_00_KEY_DATA_00_ACCESS (XLNX_RW)
#define COMP_BCAM_BASE_KEY_DATA_00_REG_NUM (0x1)
#define COMP_BCAM_BASE_KEY_DATA_00_KEY_DATA_00_MASK (0xffffffff)
#define COMP_BCAM_BASE_KEY_DATA_00_KEY_DATA_00_SHIFT (0)
#define COMP_BCAM_BASE_KEY_DATA_01_REG_OFFSET (0x204) 
#define COMP_BCAM_BASE_KEY_DATA_01_REG_MASK (0xffffffff)
#define COMP_BCAM_BASE_KEY_DATA_01_REG_SHIFT (0)
#define COMP_BCAM_BASE_KEY_DATA_01_KEY_DATA_01_OFFSET (0x204) 
#define COMP_BCAM_BASE_KEY_DATA_01_KEY_DATA_01_ACCESS (XLNX_RW)
#define COMP_BCAM_BASE_KEY_DATA_01_REG_NUM (0x1)
#define COMP_BCAM_BASE_KEY_DATA_01_KEY_DATA_01_MASK (0xffffffff)
#define COMP_BCAM_BASE_KEY_DATA_01_KEY_DATA_01_SHIFT (0)
#define COMP_BCAM_BASE_KEY_DATA_02_REG_OFFSET (0x208) 
#define COMP_BCAM_BASE_KEY_DATA_02_REG_MASK (0xffffffff)
#define COMP_BCAM_BASE_KEY_DATA_02_REG_SHIFT (0)
#define COMP_BCAM_BASE_KEY_DATA_02_KEY_DATA_02_OFFSET (0x208) 
#define COMP_BCAM_BASE_KEY_DATA_02_KEY_DATA_02_ACCESS (XLNX_RW)
#define COMP_BCAM_BASE_KEY_DATA_02_REG_NUM (0x1)
#define COMP_BCAM_BASE_KEY_DATA_02_KEY_DATA_02_MASK (0xffffffff)
#define COMP_BCAM_BASE_KEY_DATA_02_KEY_DATA_02_SHIFT (0)
#define COMP_BCAM_BASE_KEY_DATA_03_REG_OFFSET (0x20c) 
#define COMP_BCAM_BASE_KEY_DATA_03_REG_MASK (0xffffffff)
#define COMP_BCAM_BASE_KEY_DATA_03_REG_SHIFT (0)
#define COMP_BCAM_BASE_KEY_DATA_03_KEY_DATA_03_OFFSET (0x20c) 
#define COMP_BCAM_BASE_KEY_DATA_03_KEY_DATA_03_ACCESS (XLNX_RW)
#define COMP_BCAM_BASE_KEY_DATA_03_REG_NUM (0x1)
#define COMP_BCAM_BASE_KEY_DATA_03_KEY_DATA_03_MASK (0xffffffff)
#define COMP_BCAM_BASE_KEY_DATA_03_KEY_DATA_03_SHIFT (0)
#define COMP_BCAM_BASE_KEY_DATA_04_REG_OFFSET (0x210) 
#define COMP_BCAM_BASE_KEY_DATA_04_REG_MASK (0xffffffff)
#define COMP_BCAM_BASE_KEY_DATA_04_REG_SHIFT (0)
#define COMP_BCAM_BASE_KEY_DATA_04_KEY_DATA_04_OFFSET (0x210) 
#define COMP_BCAM_BASE_KEY_DATA_04_KEY_DATA_04_ACCESS (XLNX_RW)
#define COMP_BCAM_BASE_KEY_DATA_04_REG_NUM (0x1)
#define COMP_BCAM_BASE_KEY_DATA_04_KEY_DATA_04_MASK (0xffffffff)
#define COMP_BCAM_BASE_KEY_DATA_04_KEY_DATA_04_SHIFT (0)
#define COMP_BCAM_BASE_KEY_DATA_05_REG_OFFSET (0x214) 
#define COMP_BCAM_BASE_KEY_DATA_05_REG_MASK (0xffffffff)
#define COMP_BCAM_BASE_KEY_DATA_05_REG_SHIFT (0)
#define COMP_BCAM_BASE_KEY_DATA_05_KEY_DATA_05_OFFSET (0x214) 
#define COMP_BCAM_BASE_KEY_DATA_05_KEY_DATA_05_ACCESS (XLNX_RW)
#define COMP_BCAM_BASE_KEY_DATA_05_REG_NUM (0x1)
#define COMP_BCAM_BASE_KEY_DATA_05_KEY_DATA_05_MASK (0xffffffff)
#define COMP_BCAM_BASE_KEY_DATA_05_KEY_DATA_05_SHIFT (0)
#define COMP_BCAM_BASE_KEY_DATA_06_REG_OFFSET (0x218) 
#define COMP_BCAM_BASE_KEY_DATA_06_REG_MASK (0xffffffff)
#define COMP_BCAM_BASE_KEY_DATA_06_REG_SHIFT (0)
#define COMP_BCAM_BASE_KEY_DATA_06_KEY_DATA_06_OFFSET (0x218) 
#define COMP_BCAM_BASE_KEY_DATA_06_KEY_DATA_06_ACCESS (XLNX_RW)
#define COMP_BCAM_BASE_KEY_DATA_06_REG_NUM (0x1)
#define COMP_BCAM_BASE_KEY_DATA_06_KEY_DATA_06_MASK (0xffffffff)
#define COMP_BCAM_BASE_KEY_DATA_06_KEY_DATA_06_SHIFT (0)
#define COMP_BCAM_BASE_KEY_DATA_07_REG_OFFSET (0x21c) 
#define COMP_BCAM_BASE_KEY_DATA_07_REG_MASK (0xffffffff)
#define COMP_BCAM_BASE_KEY_DATA_07_REG_SHIFT (0)
#define COMP_BCAM_BASE_KEY_DATA_07_KEY_DATA_07_OFFSET (0x21c) 
#define COMP_BCAM_BASE_KEY_DATA_07_KEY_DATA_07_ACCESS (XLNX_RW)
#define COMP_BCAM_BASE_KEY_DATA_07_REG_NUM (0x1)
#define COMP_BCAM_BASE_KEY_DATA_07_KEY_DATA_07_MASK (0xffffffff)
#define COMP_BCAM_BASE_KEY_DATA_07_KEY_DATA_07_SHIFT (0)
#define COMP_BCAM_BASE_KEY_DATA_08_REG_OFFSET (0x220) 
#define COMP_BCAM_BASE_KEY_DATA_08_REG_MASK (0xffffffff)
#define COMP_BCAM_BASE_KEY_DATA_08_REG_SHIFT (0)
#define COMP_BCAM_BASE_KEY_DATA_08_KEY_DATA_08_OFFSET (0x220) 
#define COMP_BCAM_BASE_KEY_DATA_08_KEY_DATA_08_ACCESS (XLNX_RW)
#define COMP_BCAM_BASE_KEY_DATA_08_REG_NUM (0x1)
#define COMP_BCAM_BASE_KEY_DATA_08_KEY_DATA_08_MASK (0xffffffff)
#define COMP_BCAM_BASE_KEY_DATA_08_KEY_DATA_08_SHIFT (0)
#define COMP_BCAM_BASE_KEY_DATA_09_REG_OFFSET (0x224) 
#define COMP_BCAM_BASE_KEY_DATA_09_REG_MASK (0xffffffff)
#define COMP_BCAM_BASE_KEY_DATA_09_REG_SHIFT (0)
#define COMP_BCAM_BASE_KEY_DATA_09_KEY_DATA_09_OFFSET (0x224) 
#define COMP_BCAM_BASE_KEY_DATA_09_KEY_DATA_09_ACCESS (XLNX_RW)
#define COMP_BCAM_BASE_KEY_DATA_09_REG_NUM (0x1)
#define COMP_BCAM_BASE_KEY_DATA_09_KEY_DATA_09_MASK (0xffffffff)
#define COMP_BCAM_BASE_KEY_DATA_09_KEY_DATA_09_SHIFT (0)
#define COMP_BCAM_BASE_KEY_DATA_10_REG_OFFSET (0x228) 
#define COMP_BCAM_BASE_KEY_DATA_10_REG_MASK (0xffffffff)
#define COMP_BCAM_BASE_KEY_DATA_10_REG_SHIFT (0)
#define COMP_BCAM_BASE_KEY_DATA_10_KEY_DATA_10_OFFSET (0x228) 
#define COMP_BCAM_BASE_KEY_DATA_10_KEY_DATA_10_ACCESS (XLNX_RW)
#define COMP_BCAM_BASE_KEY_DATA_10_REG_NUM (0x1)
#define COMP_BCAM_BASE_KEY_DATA_10_KEY_DATA_10_MASK (0xffffffff)
#define COMP_BCAM_BASE_KEY_DATA_10_KEY_DATA_10_SHIFT (0)
#define COMP_BCAM_BASE_KEY_DATA_11_REG_OFFSET (0x22c) 
#define COMP_BCAM_BASE_KEY_DATA_11_REG_MASK (0xffffffff)
#define COMP_BCAM_BASE_KEY_DATA_11_REG_SHIFT (0)
#define COMP_BCAM_BASE_KEY_DATA_11_KEY_DATA_11_OFFSET (0x22c) 
#define COMP_BCAM_BASE_KEY_DATA_11_KEY_DATA_11_ACCESS (XLNX_RW)
#define COMP_BCAM_BASE_KEY_DATA_11_REG_NUM (0x1)
#define COMP_BCAM_BASE_KEY_DATA_11_KEY_DATA_11_MASK (0xffffffff)
#define COMP_BCAM_BASE_KEY_DATA_11_KEY_DATA_11_SHIFT (0)
#define COMP_BCAM_BASE_KEY_DATA_12_REG_OFFSET (0x230) 
#define COMP_BCAM_BASE_KEY_DATA_12_REG_MASK (0xffffffff)
#define COMP_BCAM_BASE_KEY_DATA_12_REG_SHIFT (0)
#define COMP_BCAM_BASE_KEY_DATA_12_KEY_DATA_12_OFFSET (0x230) 
#define COMP_BCAM_BASE_KEY_DATA_12_KEY_DATA_12_ACCESS (XLNX_RW)
#define COMP_BCAM_BASE_KEY_DATA_12_REG_NUM (0x1)
#define COMP_BCAM_BASE_KEY_DATA_12_KEY_DATA_12_MASK (0xffffffff)
#define COMP_BCAM_BASE_KEY_DATA_12_KEY_DATA_12_SHIFT (0)
#define COMP_BCAM_BASE_KEY_DATA_13_REG_OFFSET (0x234) 
#define COMP_BCAM_BASE_KEY_DATA_13_REG_MASK (0xffffffff)
#define COMP_BCAM_BASE_KEY_DATA_13_REG_SHIFT (0)
#define COMP_BCAM_BASE_KEY_DATA_13_KEY_DATA_13_OFFSET (0x234) 
#define COMP_BCAM_BASE_KEY_DATA_13_KEY_DATA_13_ACCESS (XLNX_RW)
#define COMP_BCAM_BASE_KEY_DATA_13_REG_NUM (0x1)
#define COMP_BCAM_BASE_KEY_DATA_13_KEY_DATA_13_MASK (0xffffffff)
#define COMP_BCAM_BASE_KEY_DATA_13_KEY_DATA_13_SHIFT (0)
#define COMP_BCAM_BASE_KEY_DATA_14_REG_OFFSET (0x238) 
#define COMP_BCAM_BASE_KEY_DATA_14_REG_MASK (0xffffffff)
#define COMP_BCAM_BASE_KEY_DATA_14_REG_SHIFT (0)
#define COMP_BCAM_BASE_KEY_DATA_14_KEY_DATA_14_OFFSET (0x238) 
#define COMP_BCAM_BASE_KEY_DATA_14_KEY_DATA_14_ACCESS (XLNX_RW)
#define COMP_BCAM_BASE_KEY_DATA_14_REG_NUM (0x1)
#define COMP_BCAM_BASE_KEY_DATA_14_KEY_DATA_14_MASK (0xffffffff)
#define COMP_BCAM_BASE_KEY_DATA_14_KEY_DATA_14_SHIFT (0)
#define COMP_BCAM_BASE_KEY_DATA_15_REG_OFFSET (0x23c) 
#define COMP_BCAM_BASE_KEY_DATA_15_REG_MASK (0xffffffff)
#define COMP_BCAM_BASE_KEY_DATA_15_REG_SHIFT (0)
#define COMP_BCAM_BASE_KEY_DATA_15_KEY_DATA_15_OFFSET (0x23c) 
#define COMP_BCAM_BASE_KEY_DATA_15_KEY_DATA_15_ACCESS (XLNX_RW)
#define COMP_BCAM_BASE_KEY_DATA_15_REG_NUM (0x1)
#define COMP_BCAM_BASE_KEY_DATA_15_KEY_DATA_15_MASK (0xffffffff)
#define COMP_BCAM_BASE_KEY_DATA_15_KEY_DATA_15_SHIFT (0)
#define COMP_BCAM_BASE_KEY_DATA_16_REG_OFFSET (0x240) 
#define COMP_BCAM_BASE_KEY_DATA_16_REG_MASK (0xffffffff)
#define COMP_BCAM_BASE_KEY_DATA_16_REG_SHIFT (0)
#define COMP_BCAM_BASE_KEY_DATA_16_KEY_DATA_16_OFFSET (0x240) 
#define COMP_BCAM_BASE_KEY_DATA_16_KEY_DATA_16_ACCESS (XLNX_RW)
#define COMP_BCAM_BASE_KEY_DATA_16_REG_NUM (0x1)
#define COMP_BCAM_BASE_KEY_DATA_16_KEY_DATA_16_MASK (0xffffffff)
#define COMP_BCAM_BASE_KEY_DATA_16_KEY_DATA_16_SHIFT (0)
#define COMP_BCAM_BASE_KEY_DATA_17_REG_OFFSET (0x244) 
#define COMP_BCAM_BASE_KEY_DATA_17_REG_MASK (0xffffffff)
#define COMP_BCAM_BASE_KEY_DATA_17_REG_SHIFT (0)
#define COMP_BCAM_BASE_KEY_DATA_17_KEY_DATA_17_OFFSET (0x244) 
#define COMP_BCAM_BASE_KEY_DATA_17_KEY_DATA_17_ACCESS (XLNX_RW)
#define COMP_BCAM_BASE_KEY_DATA_17_REG_NUM (0x1)
#define COMP_BCAM_BASE_KEY_DATA_17_KEY_DATA_17_MASK (0xffffffff)
#define COMP_BCAM_BASE_KEY_DATA_17_KEY_DATA_17_SHIFT (0)
#define COMP_BCAM_BASE_KEY_DATA_18_REG_OFFSET (0x248) 
#define COMP_BCAM_BASE_KEY_DATA_18_REG_MASK (0xffffffff)
#define COMP_BCAM_BASE_KEY_DATA_18_REG_SHIFT (0)
#define COMP_BCAM_BASE_KEY_DATA_18_KEY_DATA_18_OFFSET (0x248) 
#define COMP_BCAM_BASE_KEY_DATA_18_KEY_DATA_18_ACCESS (XLNX_RW)
#define COMP_BCAM_BASE_KEY_DATA_18_REG_NUM (0x1)
#define COMP_BCAM_BASE_KEY_DATA_18_KEY_DATA_18_MASK (0xffffffff)
#define COMP_BCAM_BASE_KEY_DATA_18_KEY_DATA_18_SHIFT (0)
#define COMP_BCAM_BASE_KEY_DATA_19_REG_OFFSET (0x24c) 
#define COMP_BCAM_BASE_KEY_DATA_19_REG_MASK (0xffffffff)
#define COMP_BCAM_BASE_KEY_DATA_19_REG_SHIFT (0)
#define COMP_BCAM_BASE_KEY_DATA_19_KEY_DATA_19_OFFSET (0x24c) 
#define COMP_BCAM_BASE_KEY_DATA_19_KEY_DATA_19_ACCESS (XLNX_RW)
#define COMP_BCAM_BASE_KEY_DATA_19_REG_NUM (0x1)
#define COMP_BCAM_BASE_KEY_DATA_19_KEY_DATA_19_MASK (0xffffffff)
#define COMP_BCAM_BASE_KEY_DATA_19_KEY_DATA_19_SHIFT (0)
#define COMP_BCAM_BASE_KEY_DATA_20_REG_OFFSET (0x250) 
#define COMP_BCAM_BASE_KEY_DATA_20_REG_MASK (0xffffffff)
#define COMP_BCAM_BASE_KEY_DATA_20_REG_SHIFT (0)
#define COMP_BCAM_BASE_KEY_DATA_20_KEY_DATA_20_OFFSET (0x250) 
#define COMP_BCAM_BASE_KEY_DATA_20_KEY_DATA_20_ACCESS (XLNX_RW)
#define COMP_BCAM_BASE_KEY_DATA_20_REG_NUM (0x1)
#define COMP_BCAM_BASE_KEY_DATA_20_KEY_DATA_20_MASK (0xffffffff)
#define COMP_BCAM_BASE_KEY_DATA_20_KEY_DATA_20_SHIFT (0)
#define COMP_BCAM_BASE_KEY_DATA_21_REG_OFFSET (0x254) 
#define COMP_BCAM_BASE_KEY_DATA_21_REG_MASK (0xffffffff)
#define COMP_BCAM_BASE_KEY_DATA_21_REG_SHIFT (0)
#define COMP_BCAM_BASE_KEY_DATA_21_KEY_DATA_21_OFFSET (0x254) 
#define COMP_BCAM_BASE_KEY_DATA_21_KEY_DATA_21_ACCESS (XLNX_RW)
#define COMP_BCAM_BASE_KEY_DATA_21_REG_NUM (0x1)
#define COMP_BCAM_BASE_KEY_DATA_21_KEY_DATA_21_MASK (0xffffffff)
#define COMP_BCAM_BASE_KEY_DATA_21_KEY_DATA_21_SHIFT (0)
#define COMP_BCAM_BASE_KEY_DATA_22_REG_OFFSET (0x258) 
#define COMP_BCAM_BASE_KEY_DATA_22_REG_MASK (0xffffffff)
#define COMP_BCAM_BASE_KEY_DATA_22_REG_SHIFT (0)
#define COMP_BCAM_BASE_KEY_DATA_22_KEY_DATA_22_OFFSET (0x258) 
#define COMP_BCAM_BASE_KEY_DATA_22_KEY_DATA_22_ACCESS (XLNX_RW)
#define COMP_BCAM_BASE_KEY_DATA_22_REG_NUM (0x1)
#define COMP_BCAM_BASE_KEY_DATA_22_KEY_DATA_22_MASK (0xffffffff)
#define COMP_BCAM_BASE_KEY_DATA_22_KEY_DATA_22_SHIFT (0)
#define COMP_BCAM_BASE_KEY_DATA_23_REG_OFFSET (0x25c) 
#define COMP_BCAM_BASE_KEY_DATA_23_REG_MASK (0xffffffff)
#define COMP_BCAM_BASE_KEY_DATA_23_REG_SHIFT (0)
#define COMP_BCAM_BASE_KEY_DATA_23_KEY_DATA_23_OFFSET (0x25c) 
#define COMP_BCAM_BASE_KEY_DATA_23_KEY_DATA_23_ACCESS (XLNX_RW)
#define COMP_BCAM_BASE_KEY_DATA_23_REG_NUM (0x1)
#define COMP_BCAM_BASE_KEY_DATA_23_KEY_DATA_23_MASK (0xffffffff)
#define COMP_BCAM_BASE_KEY_DATA_23_KEY_DATA_23_SHIFT (0)
#define COMP_BCAM_BASE_KEY_DATA_24_REG_OFFSET (0x260) 
#define COMP_BCAM_BASE_KEY_DATA_24_REG_MASK (0xffffffff)
#define COMP_BCAM_BASE_KEY_DATA_24_REG_SHIFT (0)
#define COMP_BCAM_BASE_KEY_DATA_24_KEY_DATA_24_OFFSET (0x260) 
#define COMP_BCAM_BASE_KEY_DATA_24_KEY_DATA_24_ACCESS (XLNX_RW)
#define COMP_BCAM_BASE_KEY_DATA_24_REG_NUM (0x1)
#define COMP_BCAM_BASE_KEY_DATA_24_KEY_DATA_24_MASK (0xffffffff)
#define COMP_BCAM_BASE_KEY_DATA_24_KEY_DATA_24_SHIFT (0)
#define COMP_BCAM_BASE_KEY_DATA_25_REG_OFFSET (0x264) 
#define COMP_BCAM_BASE_KEY_DATA_25_REG_MASK (0xffffffff)
#define COMP_BCAM_BASE_KEY_DATA_25_REG_SHIFT (0)
#define COMP_BCAM_BASE_KEY_DATA_25_KEY_DATA_25_OFFSET (0x264) 
#define COMP_BCAM_BASE_KEY_DATA_25_KEY_DATA_25_ACCESS (XLNX_RW)
#define COMP_BCAM_BASE_KEY_DATA_25_REG_NUM (0x1)
#define COMP_BCAM_BASE_KEY_DATA_25_KEY_DATA_25_MASK (0xffffffff)
#define COMP_BCAM_BASE_KEY_DATA_25_KEY_DATA_25_SHIFT (0)
#define COMP_BCAM_BASE_KEY_DATA_26_REG_OFFSET (0x268) 
#define COMP_BCAM_BASE_KEY_DATA_26_REG_MASK (0xffffffff)
#define COMP_BCAM_BASE_KEY_DATA_26_REG_SHIFT (0)
#define COMP_BCAM_BASE_KEY_DATA_26_KEY_DATA_26_OFFSET (0x268) 
#define COMP_BCAM_BASE_KEY_DATA_26_KEY_DATA_26_ACCESS (XLNX_RW)
#define COMP_BCAM_BASE_KEY_DATA_26_REG_NUM (0x1)
#define COMP_BCAM_BASE_KEY_DATA_26_KEY_DATA_26_MASK (0xffffffff)
#define COMP_BCAM_BASE_KEY_DATA_26_KEY_DATA_26_SHIFT (0)
#define COMP_BCAM_BASE_KEY_DATA_27_REG_OFFSET (0x26c) 
#define COMP_BCAM_BASE_KEY_DATA_27_REG_MASK (0xffffffff)
#define COMP_BCAM_BASE_KEY_DATA_27_REG_SHIFT (0)
#define COMP_BCAM_BASE_KEY_DATA_27_KEY_DATA_27_OFFSET (0x26c) 
#define COMP_BCAM_BASE_KEY_DATA_27_KEY_DATA_27_ACCESS (XLNX_RW)
#define COMP_BCAM_BASE_KEY_DATA_27_REG_NUM (0x1)
#define COMP_BCAM_BASE_KEY_DATA_27_KEY_DATA_27_MASK (0xffffffff)
#define COMP_BCAM_BASE_KEY_DATA_27_KEY_DATA_27_SHIFT (0)
#define COMP_BCAM_BASE_KEY_DATA_28_REG_OFFSET (0x270) 
#define COMP_BCAM_BASE_KEY_DATA_28_REG_MASK (0xffffffff)
#define COMP_BCAM_BASE_KEY_DATA_28_REG_SHIFT (0)
#define COMP_BCAM_BASE_KEY_DATA_28_KEY_DATA_28_OFFSET (0x270) 
#define COMP_BCAM_BASE_KEY_DATA_28_KEY_DATA_28_ACCESS (XLNX_RW)
#define COMP_BCAM_BASE_KEY_DATA_28_REG_NUM (0x1)
#define COMP_BCAM_BASE_KEY_DATA_28_KEY_DATA_28_MASK (0xffffffff)
#define COMP_BCAM_BASE_KEY_DATA_28_KEY_DATA_28_SHIFT (0)
#define COMP_BCAM_BASE_KEY_DATA_29_REG_OFFSET (0x274) 
#define COMP_BCAM_BASE_KEY_DATA_29_REG_MASK (0xffffffff)
#define COMP_BCAM_BASE_KEY_DATA_29_REG_SHIFT (0)
#define COMP_BCAM_BASE_KEY_DATA_29_KEY_DATA_29_OFFSET (0x274) 
#define COMP_BCAM_BASE_KEY_DATA_29_KEY_DATA_29_ACCESS (XLNX_RW)
#define COMP_BCAM_BASE_KEY_DATA_29_REG_NUM (0x1)
#define COMP_BCAM_BASE_KEY_DATA_29_KEY_DATA_29_MASK (0xffffffff)
#define COMP_BCAM_BASE_KEY_DATA_29_KEY_DATA_29_SHIFT (0)
#define COMP_BCAM_BASE_KEY_DATA_30_REG_OFFSET (0x278) 
#define COMP_BCAM_BASE_KEY_DATA_30_REG_MASK (0xffffffff)
#define COMP_BCAM_BASE_KEY_DATA_30_REG_SHIFT (0)
#define COMP_BCAM_BASE_KEY_DATA_30_KEY_DATA_30_OFFSET (0x278) 
#define COMP_BCAM_BASE_KEY_DATA_30_KEY_DATA_30_ACCESS (XLNX_RW)
#define COMP_BCAM_BASE_KEY_DATA_30_REG_NUM (0x1)
#define COMP_BCAM_BASE_KEY_DATA_30_KEY_DATA_30_MASK (0xffffffff)
#define COMP_BCAM_BASE_KEY_DATA_30_KEY_DATA_30_SHIFT (0)
#define COMP_BCAM_BASE_KEY_DATA_31_REG_OFFSET (0x27c) 
#define COMP_BCAM_BASE_KEY_DATA_31_REG_MASK (0xffffffff)
#define COMP_BCAM_BASE_KEY_DATA_31_REG_SHIFT (0)
#define COMP_BCAM_BASE_KEY_DATA_31_KEY_DATA_31_OFFSET (0x27c) 
#define COMP_BCAM_BASE_KEY_DATA_31_KEY_DATA_31_ACCESS (XLNX_RW)
#define COMP_BCAM_BASE_KEY_DATA_31_REG_NUM (0x1)
#define COMP_BCAM_BASE_KEY_DATA_31_KEY_DATA_31_MASK (0xffffffff)
#define COMP_BCAM_BASE_KEY_DATA_31_KEY_DATA_31_SHIFT (0)
#define COMP_BCAM_BASE_RESPONSE_DATA_00_REG_OFFSET (0x300) 
#define COMP_BCAM_BASE_RESPONSE_DATA_00_REG_MASK (0xffffffff)
#define COMP_BCAM_BASE_RESPONSE_DATA_00_REG_SHIFT (0)
#define COMP_BCAM_BASE_RESPONSE_DATA_00_RESPONSE_DATA_00_OFFSET (0x300) 
#define COMP_BCAM_BASE_RESPONSE_DATA_00_RESPONSE_DATA_00_ACCESS (XLNX_RW)
#define COMP_BCAM_BASE_RESPONSE_DATA_00_REG_NUM (0x1)
#define COMP_BCAM_BASE_RESPONSE_DATA_00_RESPONSE_DATA_00_MASK (0xffffffff)
#define COMP_BCAM_BASE_RESPONSE_DATA_00_RESPONSE_DATA_00_SHIFT (0)
#define COMP_BCAM_BASE_RESPONSE_DATA_01_REG_OFFSET (0x304) 
#define COMP_BCAM_BASE_RESPONSE_DATA_01_REG_MASK (0xffffffff)
#define COMP_BCAM_BASE_RESPONSE_DATA_01_REG_SHIFT (0)
#define COMP_BCAM_BASE_RESPONSE_DATA_01_RESPONSE_DATA_01_OFFSET (0x304) 
#define COMP_BCAM_BASE_RESPONSE_DATA_01_RESPONSE_DATA_01_ACCESS (XLNX_RW)
#define COMP_BCAM_BASE_RESPONSE_DATA_01_REG_NUM (0x1)
#define COMP_BCAM_BASE_RESPONSE_DATA_01_RESPONSE_DATA_01_MASK (0xffffffff)
#define COMP_BCAM_BASE_RESPONSE_DATA_01_RESPONSE_DATA_01_SHIFT (0)
#define COMP_BCAM_BASE_RESPONSE_DATA_02_REG_OFFSET (0x308) 
#define COMP_BCAM_BASE_RESPONSE_DATA_02_REG_MASK (0xffffffff)
#define COMP_BCAM_BASE_RESPONSE_DATA_02_REG_SHIFT (0)
#define COMP_BCAM_BASE_RESPONSE_DATA_02_RESPONSE_DATA_02_OFFSET (0x308) 
#define COMP_BCAM_BASE_RESPONSE_DATA_02_RESPONSE_DATA_02_ACCESS (XLNX_RW)
#define COMP_BCAM_BASE_RESPONSE_DATA_02_REG_NUM (0x1)
#define COMP_BCAM_BASE_RESPONSE_DATA_02_RESPONSE_DATA_02_MASK (0xffffffff)
#define COMP_BCAM_BASE_RESPONSE_DATA_02_RESPONSE_DATA_02_SHIFT (0)
#define COMP_BCAM_BASE_RESPONSE_DATA_03_REG_OFFSET (0x30c) 
#define COMP_BCAM_BASE_RESPONSE_DATA_03_REG_MASK (0xffffffff)
#define COMP_BCAM_BASE_RESPONSE_DATA_03_REG_SHIFT (0)
#define COMP_BCAM_BASE_RESPONSE_DATA_03_RESPONSE_DATA_03_OFFSET (0x30c) 
#define COMP_BCAM_BASE_RESPONSE_DATA_03_RESPONSE_DATA_03_ACCESS (XLNX_RW)
#define COMP_BCAM_BASE_RESPONSE_DATA_03_REG_NUM (0x1)
#define COMP_BCAM_BASE_RESPONSE_DATA_03_RESPONSE_DATA_03_MASK (0xffffffff)
#define COMP_BCAM_BASE_RESPONSE_DATA_03_RESPONSE_DATA_03_SHIFT (0)
#define COMP_BCAM_BASE_RESPONSE_DATA_04_REG_OFFSET (0x310) 
#define COMP_BCAM_BASE_RESPONSE_DATA_04_REG_MASK (0xffffffff)
#define COMP_BCAM_BASE_RESPONSE_DATA_04_REG_SHIFT (0)
#define COMP_BCAM_BASE_RESPONSE_DATA_04_RESPONSE_DATA_04_OFFSET (0x310) 
#define COMP_BCAM_BASE_RESPONSE_DATA_04_RESPONSE_DATA_04_ACCESS (XLNX_RW)
#define COMP_BCAM_BASE_RESPONSE_DATA_04_REG_NUM (0x1)
#define COMP_BCAM_BASE_RESPONSE_DATA_04_RESPONSE_DATA_04_MASK (0xffffffff)
#define COMP_BCAM_BASE_RESPONSE_DATA_04_RESPONSE_DATA_04_SHIFT (0)
#define COMP_BCAM_BASE_RESPONSE_DATA_05_REG_OFFSET (0x314) 
#define COMP_BCAM_BASE_RESPONSE_DATA_05_REG_MASK (0xffffffff)
#define COMP_BCAM_BASE_RESPONSE_DATA_05_REG_SHIFT (0)
#define COMP_BCAM_BASE_RESPONSE_DATA_05_RESPONSE_DATA_05_OFFSET (0x314) 
#define COMP_BCAM_BASE_RESPONSE_DATA_05_RESPONSE_DATA_05_ACCESS (XLNX_RW)
#define COMP_BCAM_BASE_RESPONSE_DATA_05_REG_NUM (0x1)
#define COMP_BCAM_BASE_RESPONSE_DATA_05_RESPONSE_DATA_05_MASK (0xffffffff)
#define COMP_BCAM_BASE_RESPONSE_DATA_05_RESPONSE_DATA_05_SHIFT (0)
#define COMP_BCAM_BASE_RESPONSE_DATA_06_REG_OFFSET (0x318) 
#define COMP_BCAM_BASE_RESPONSE_DATA_06_REG_MASK (0xffffffff)
#define COMP_BCAM_BASE_RESPONSE_DATA_06_REG_SHIFT (0)
#define COMP_BCAM_BASE_RESPONSE_DATA_06_RESPONSE_DATA_06_OFFSET (0x318) 
#define COMP_BCAM_BASE_RESPONSE_DATA_06_RESPONSE_DATA_06_ACCESS (XLNX_RW)
#define COMP_BCAM_BASE_RESPONSE_DATA_06_REG_NUM (0x1)
#define COMP_BCAM_BASE_RESPONSE_DATA_06_RESPONSE_DATA_06_MASK (0xffffffff)
#define COMP_BCAM_BASE_RESPONSE_DATA_06_RESPONSE_DATA_06_SHIFT (0)
#define COMP_BCAM_BASE_RESPONSE_DATA_07_REG_OFFSET (0x31c) 
#define COMP_BCAM_BASE_RESPONSE_DATA_07_REG_MASK (0xffffffff)
#define COMP_BCAM_BASE_RESPONSE_DATA_07_REG_SHIFT (0)
#define COMP_BCAM_BASE_RESPONSE_DATA_07_RESPONSE_DATA_07_OFFSET (0x31c) 
#define COMP_BCAM_BASE_RESPONSE_DATA_07_RESPONSE_DATA_07_ACCESS (XLNX_RW)
#define COMP_BCAM_BASE_RESPONSE_DATA_07_REG_NUM (0x1)
#define COMP_BCAM_BASE_RESPONSE_DATA_07_RESPONSE_DATA_07_MASK (0xffffffff)
#define COMP_BCAM_BASE_RESPONSE_DATA_07_RESPONSE_DATA_07_SHIFT (0)
#define COMP_BCAM_BASE_RESPONSE_DATA_08_REG_OFFSET (0x320) 
#define COMP_BCAM_BASE_RESPONSE_DATA_08_REG_MASK (0xffffffff)
#define COMP_BCAM_BASE_RESPONSE_DATA_08_REG_SHIFT (0)
#define COMP_BCAM_BASE_RESPONSE_DATA_08_RESPONSE_DATA_08_OFFSET (0x320) 
#define COMP_BCAM_BASE_RESPONSE_DATA_08_RESPONSE_DATA_08_ACCESS (XLNX_RW)
#define COMP_BCAM_BASE_RESPONSE_DATA_08_REG_NUM (0x1)
#define COMP_BCAM_BASE_RESPONSE_DATA_08_RESPONSE_DATA_08_MASK (0xffffffff)
#define COMP_BCAM_BASE_RESPONSE_DATA_08_RESPONSE_DATA_08_SHIFT (0)
#define COMP_BCAM_BASE_RESPONSE_DATA_09_REG_OFFSET (0x324) 
#define COMP_BCAM_BASE_RESPONSE_DATA_09_REG_MASK (0xffffffff)
#define COMP_BCAM_BASE_RESPONSE_DATA_09_REG_SHIFT (0)
#define COMP_BCAM_BASE_RESPONSE_DATA_09_RESPONSE_DATA_09_OFFSET (0x324) 
#define COMP_BCAM_BASE_RESPONSE_DATA_09_RESPONSE_DATA_09_ACCESS (XLNX_RW)
#define COMP_BCAM_BASE_RESPONSE_DATA_09_REG_NUM (0x1)
#define COMP_BCAM_BASE_RESPONSE_DATA_09_RESPONSE_DATA_09_MASK (0xffffffff)
#define COMP_BCAM_BASE_RESPONSE_DATA_09_RESPONSE_DATA_09_SHIFT (0)
#define COMP_BCAM_BASE_RESPONSE_DATA_10_REG_OFFSET (0x328) 
#define COMP_BCAM_BASE_RESPONSE_DATA_10_REG_MASK (0xffffffff)
#define COMP_BCAM_BASE_RESPONSE_DATA_10_REG_SHIFT (0)
#define COMP_BCAM_BASE_RESPONSE_DATA_10_RESPONSE_DATA_10_OFFSET (0x328) 
#define COMP_BCAM_BASE_RESPONSE_DATA_10_RESPONSE_DATA_10_ACCESS (XLNX_RW)
#define COMP_BCAM_BASE_RESPONSE_DATA_10_REG_NUM (0x1)
#define COMP_BCAM_BASE_RESPONSE_DATA_10_RESPONSE_DATA_10_MASK (0xffffffff)
#define COMP_BCAM_BASE_RESPONSE_DATA_10_RESPONSE_DATA_10_SHIFT (0)
#define COMP_BCAM_BASE_RESPONSE_DATA_11_REG_OFFSET (0x32c) 
#define COMP_BCAM_BASE_RESPONSE_DATA_11_REG_MASK (0xffffffff)
#define COMP_BCAM_BASE_RESPONSE_DATA_11_REG_SHIFT (0)
#define COMP_BCAM_BASE_RESPONSE_DATA_11_RESPONSE_DATA_11_OFFSET (0x32c) 
#define COMP_BCAM_BASE_RESPONSE_DATA_11_RESPONSE_DATA_11_ACCESS (XLNX_RW)
#define COMP_BCAM_BASE_RESPONSE_DATA_11_REG_NUM (0x1)
#define COMP_BCAM_BASE_RESPONSE_DATA_11_RESPONSE_DATA_11_MASK (0xffffffff)
#define COMP_BCAM_BASE_RESPONSE_DATA_11_RESPONSE_DATA_11_SHIFT (0)
#define COMP_BCAM_BASE_RESPONSE_DATA_12_REG_OFFSET (0x330) 
#define COMP_BCAM_BASE_RESPONSE_DATA_12_REG_MASK (0xffffffff)
#define COMP_BCAM_BASE_RESPONSE_DATA_12_REG_SHIFT (0)
#define COMP_BCAM_BASE_RESPONSE_DATA_12_RESPONSE_DATA_12_OFFSET (0x330) 
#define COMP_BCAM_BASE_RESPONSE_DATA_12_RESPONSE_DATA_12_ACCESS (XLNX_RW)
#define COMP_BCAM_BASE_RESPONSE_DATA_12_REG_NUM (0x1)
#define COMP_BCAM_BASE_RESPONSE_DATA_12_RESPONSE_DATA_12_MASK (0xffffffff)
#define COMP_BCAM_BASE_RESPONSE_DATA_12_RESPONSE_DATA_12_SHIFT (0)
#define COMP_BCAM_BASE_RESPONSE_DATA_13_REG_OFFSET (0x334) 
#define COMP_BCAM_BASE_RESPONSE_DATA_13_REG_MASK (0xffffffff)
#define COMP_BCAM_BASE_RESPONSE_DATA_13_REG_SHIFT (0)
#define COMP_BCAM_BASE_RESPONSE_DATA_13_RESPONSE_DATA_13_OFFSET (0x334) 
#define COMP_BCAM_BASE_RESPONSE_DATA_13_RESPONSE_DATA_13_ACCESS (XLNX_RW)
#define COMP_BCAM_BASE_RESPONSE_DATA_13_REG_NUM (0x1)
#define COMP_BCAM_BASE_RESPONSE_DATA_13_RESPONSE_DATA_13_MASK (0xffffffff)
#define COMP_BCAM_BASE_RESPONSE_DATA_13_RESPONSE_DATA_13_SHIFT (0)
#define COMP_BCAM_BASE_RESPONSE_DATA_14_REG_OFFSET (0x338) 
#define COMP_BCAM_BASE_RESPONSE_DATA_14_REG_MASK (0xffffffff)
#define COMP_BCAM_BASE_RESPONSE_DATA_14_REG_SHIFT (0)
#define COMP_BCAM_BASE_RESPONSE_DATA_14_RESPONSE_DATA_14_OFFSET (0x338) 
#define COMP_BCAM_BASE_RESPONSE_DATA_14_RESPONSE_DATA_14_ACCESS (XLNX_RW)
#define COMP_BCAM_BASE_RESPONSE_DATA_14_REG_NUM (0x1)
#define COMP_BCAM_BASE_RESPONSE_DATA_14_RESPONSE_DATA_14_MASK (0xffffffff)
#define COMP_BCAM_BASE_RESPONSE_DATA_14_RESPONSE_DATA_14_SHIFT (0)
#define COMP_BCAM_BASE_RESPONSE_DATA_15_REG_OFFSET (0x33c) 
#define COMP_BCAM_BASE_RESPONSE_DATA_15_REG_MASK (0xffffffff)
#define COMP_BCAM_BASE_RESPONSE_DATA_15_REG_SHIFT (0)
#define COMP_BCAM_BASE_RESPONSE_DATA_15_RESPONSE_DATA_15_OFFSET (0x33c) 
#define COMP_BCAM_BASE_RESPONSE_DATA_15_RESPONSE_DATA_15_ACCESS (XLNX_RW)
#define COMP_BCAM_BASE_RESPONSE_DATA_15_REG_NUM (0x1)
#define COMP_BCAM_BASE_RESPONSE_DATA_15_RESPONSE_DATA_15_MASK (0xffffffff)
#define COMP_BCAM_BASE_RESPONSE_DATA_15_RESPONSE_DATA_15_SHIFT (0)
#define COMP_BCAM_BASE_RESPONSE_DATA_16_REG_OFFSET (0x340) 
#define COMP_BCAM_BASE_RESPONSE_DATA_16_REG_MASK (0xffffffff)
#define COMP_BCAM_BASE_RESPONSE_DATA_16_REG_SHIFT (0)
#define COMP_BCAM_BASE_RESPONSE_DATA_16_RESPONSE_DATA_16_OFFSET (0x340) 
#define COMP_BCAM_BASE_RESPONSE_DATA_16_RESPONSE_DATA_16_ACCESS (XLNX_RW)
#define COMP_BCAM_BASE_RESPONSE_DATA_16_REG_NUM (0x1)
#define COMP_BCAM_BASE_RESPONSE_DATA_16_RESPONSE_DATA_16_MASK (0xffffffff)
#define COMP_BCAM_BASE_RESPONSE_DATA_16_RESPONSE_DATA_16_SHIFT (0)
#define COMP_BCAM_BASE_RESPONSE_DATA_17_REG_OFFSET (0x344) 
#define COMP_BCAM_BASE_RESPONSE_DATA_17_REG_MASK (0xffffffff)
#define COMP_BCAM_BASE_RESPONSE_DATA_17_REG_SHIFT (0)
#define COMP_BCAM_BASE_RESPONSE_DATA_17_RESPONSE_DATA_17_OFFSET (0x344) 
#define COMP_BCAM_BASE_RESPONSE_DATA_17_RESPONSE_DATA_17_ACCESS (XLNX_RW)
#define COMP_BCAM_BASE_RESPONSE_DATA_17_REG_NUM (0x1)
#define COMP_BCAM_BASE_RESPONSE_DATA_17_RESPONSE_DATA_17_MASK (0xffffffff)
#define COMP_BCAM_BASE_RESPONSE_DATA_17_RESPONSE_DATA_17_SHIFT (0)
#define COMP_BCAM_BASE_RESPONSE_DATA_18_REG_OFFSET (0x348) 
#define COMP_BCAM_BASE_RESPONSE_DATA_18_REG_MASK (0xffffffff)
#define COMP_BCAM_BASE_RESPONSE_DATA_18_REG_SHIFT (0)
#define COMP_BCAM_BASE_RESPONSE_DATA_18_RESPONSE_DATA_18_OFFSET (0x348) 
#define COMP_BCAM_BASE_RESPONSE_DATA_18_RESPONSE_DATA_18_ACCESS (XLNX_RW)
#define COMP_BCAM_BASE_RESPONSE_DATA_18_REG_NUM (0x1)
#define COMP_BCAM_BASE_RESPONSE_DATA_18_RESPONSE_DATA_18_MASK (0xffffffff)
#define COMP_BCAM_BASE_RESPONSE_DATA_18_RESPONSE_DATA_18_SHIFT (0)
#define COMP_BCAM_BASE_RESPONSE_DATA_19_REG_OFFSET (0x34c) 
#define COMP_BCAM_BASE_RESPONSE_DATA_19_REG_MASK (0xffffffff)
#define COMP_BCAM_BASE_RESPONSE_DATA_19_REG_SHIFT (0)
#define COMP_BCAM_BASE_RESPONSE_DATA_19_RESPONSE_DATA_19_OFFSET (0x34c) 
#define COMP_BCAM_BASE_RESPONSE_DATA_19_RESPONSE_DATA_19_ACCESS (XLNX_RW)
#define COMP_BCAM_BASE_RESPONSE_DATA_19_REG_NUM (0x1)
#define COMP_BCAM_BASE_RESPONSE_DATA_19_RESPONSE_DATA_19_MASK (0xffffffff)
#define COMP_BCAM_BASE_RESPONSE_DATA_19_RESPONSE_DATA_19_SHIFT (0)
#define COMP_BCAM_BASE_RESPONSE_DATA_20_REG_OFFSET (0x350) 
#define COMP_BCAM_BASE_RESPONSE_DATA_20_REG_MASK (0xffffffff)
#define COMP_BCAM_BASE_RESPONSE_DATA_20_REG_SHIFT (0)
#define COMP_BCAM_BASE_RESPONSE_DATA_20_RESPONSE_DATA_20_OFFSET (0x350) 
#define COMP_BCAM_BASE_RESPONSE_DATA_20_RESPONSE_DATA_20_ACCESS (XLNX_RW)
#define COMP_BCAM_BASE_RESPONSE_DATA_20_REG_NUM (0x1)
#define COMP_BCAM_BASE_RESPONSE_DATA_20_RESPONSE_DATA_20_MASK (0xffffffff)
#define COMP_BCAM_BASE_RESPONSE_DATA_20_RESPONSE_DATA_20_SHIFT (0)
#define COMP_BCAM_BASE_RESPONSE_DATA_21_REG_OFFSET (0x354) 
#define COMP_BCAM_BASE_RESPONSE_DATA_21_REG_MASK (0xffffffff)
#define COMP_BCAM_BASE_RESPONSE_DATA_21_REG_SHIFT (0)
#define COMP_BCAM_BASE_RESPONSE_DATA_21_RESPONSE_DATA_21_OFFSET (0x354) 
#define COMP_BCAM_BASE_RESPONSE_DATA_21_RESPONSE_DATA_21_ACCESS (XLNX_RW)
#define COMP_BCAM_BASE_RESPONSE_DATA_21_REG_NUM (0x1)
#define COMP_BCAM_BASE_RESPONSE_DATA_21_RESPONSE_DATA_21_MASK (0xffffffff)
#define COMP_BCAM_BASE_RESPONSE_DATA_21_RESPONSE_DATA_21_SHIFT (0)
#define COMP_BCAM_BASE_RESPONSE_DATA_22_REG_OFFSET (0x358) 
#define COMP_BCAM_BASE_RESPONSE_DATA_22_REG_MASK (0xffffffff)
#define COMP_BCAM_BASE_RESPONSE_DATA_22_REG_SHIFT (0)
#define COMP_BCAM_BASE_RESPONSE_DATA_22_RESPONSE_DATA_22_OFFSET (0x358) 
#define COMP_BCAM_BASE_RESPONSE_DATA_22_RESPONSE_DATA_22_ACCESS (XLNX_RW)
#define COMP_BCAM_BASE_RESPONSE_DATA_22_REG_NUM (0x1)
#define COMP_BCAM_BASE_RESPONSE_DATA_22_RESPONSE_DATA_22_MASK (0xffffffff)
#define COMP_BCAM_BASE_RESPONSE_DATA_22_RESPONSE_DATA_22_SHIFT (0)
#define COMP_BCAM_BASE_RESPONSE_DATA_23_REG_OFFSET (0x35c) 
#define COMP_BCAM_BASE_RESPONSE_DATA_23_REG_MASK (0xffffffff)
#define COMP_BCAM_BASE_RESPONSE_DATA_23_REG_SHIFT (0)
#define COMP_BCAM_BASE_RESPONSE_DATA_23_RESPONSE_DATA_23_OFFSET (0x35c) 
#define COMP_BCAM_BASE_RESPONSE_DATA_23_RESPONSE_DATA_23_ACCESS (XLNX_RW)
#define COMP_BCAM_BASE_RESPONSE_DATA_23_REG_NUM (0x1)
#define COMP_BCAM_BASE_RESPONSE_DATA_23_RESPONSE_DATA_23_MASK (0xffffffff)
#define COMP_BCAM_BASE_RESPONSE_DATA_23_RESPONSE_DATA_23_SHIFT (0)
#define COMP_BCAM_BASE_RESPONSE_DATA_24_REG_OFFSET (0x360) 
#define COMP_BCAM_BASE_RESPONSE_DATA_24_REG_MASK (0xffffffff)
#define COMP_BCAM_BASE_RESPONSE_DATA_24_REG_SHIFT (0)
#define COMP_BCAM_BASE_RESPONSE_DATA_24_RESPONSE_DATA_24_OFFSET (0x360) 
#define COMP_BCAM_BASE_RESPONSE_DATA_24_RESPONSE_DATA_24_ACCESS (XLNX_RW)
#define COMP_BCAM_BASE_RESPONSE_DATA_24_REG_NUM (0x1)
#define COMP_BCAM_BASE_RESPONSE_DATA_24_RESPONSE_DATA_24_MASK (0xffffffff)
#define COMP_BCAM_BASE_RESPONSE_DATA_24_RESPONSE_DATA_24_SHIFT (0)
#define COMP_BCAM_BASE_RESPONSE_DATA_25_REG_OFFSET (0x364) 
#define COMP_BCAM_BASE_RESPONSE_DATA_25_REG_MASK (0xffffffff)
#define COMP_BCAM_BASE_RESPONSE_DATA_25_REG_SHIFT (0)
#define COMP_BCAM_BASE_RESPONSE_DATA_25_RESPONSE_DATA_25_OFFSET (0x364) 
#define COMP_BCAM_BASE_RESPONSE_DATA_25_RESPONSE_DATA_25_ACCESS (XLNX_RW)
#define COMP_BCAM_BASE_RESPONSE_DATA_25_REG_NUM (0x1)
#define COMP_BCAM_BASE_RESPONSE_DATA_25_RESPONSE_DATA_25_MASK (0xffffffff)
#define COMP_BCAM_BASE_RESPONSE_DATA_25_RESPONSE_DATA_25_SHIFT (0)
#define COMP_BCAM_BASE_RESPONSE_DATA_26_REG_OFFSET (0x368) 
#define COMP_BCAM_BASE_RESPONSE_DATA_26_REG_MASK (0xffffffff)
#define COMP_BCAM_BASE_RESPONSE_DATA_26_REG_SHIFT (0)
#define COMP_BCAM_BASE_RESPONSE_DATA_26_RESPONSE_DATA_26_OFFSET (0x368) 
#define COMP_BCAM_BASE_RESPONSE_DATA_26_RESPONSE_DATA_26_ACCESS (XLNX_RW)
#define COMP_BCAM_BASE_RESPONSE_DATA_26_REG_NUM (0x1)
#define COMP_BCAM_BASE_RESPONSE_DATA_26_RESPONSE_DATA_26_MASK (0xffffffff)
#define COMP_BCAM_BASE_RESPONSE_DATA_26_RESPONSE_DATA_26_SHIFT (0)
#define COMP_BCAM_BASE_RESPONSE_DATA_27_REG_OFFSET (0x36c) 
#define COMP_BCAM_BASE_RESPONSE_DATA_27_REG_MASK (0xffffffff)
#define COMP_BCAM_BASE_RESPONSE_DATA_27_REG_SHIFT (0)
#define COMP_BCAM_BASE_RESPONSE_DATA_27_RESPONSE_DATA_27_OFFSET (0x36c) 
#define COMP_BCAM_BASE_RESPONSE_DATA_27_RESPONSE_DATA_27_ACCESS (XLNX_RW)
#define COMP_BCAM_BASE_RESPONSE_DATA_27_REG_NUM (0x1)
#define COMP_BCAM_BASE_RESPONSE_DATA_27_RESPONSE_DATA_27_MASK (0xffffffff)
#define COMP_BCAM_BASE_RESPONSE_DATA_27_RESPONSE_DATA_27_SHIFT (0)
#define COMP_BCAM_BASE_RESPONSE_DATA_28_REG_OFFSET (0x370) 
#define COMP_BCAM_BASE_RESPONSE_DATA_28_REG_MASK (0xffffffff)
#define COMP_BCAM_BASE_RESPONSE_DATA_28_REG_SHIFT (0)
#define COMP_BCAM_BASE_RESPONSE_DATA_28_RESPONSE_DATA_28_OFFSET (0x370) 
#define COMP_BCAM_BASE_RESPONSE_DATA_28_RESPONSE_DATA_28_ACCESS (XLNX_RW)
#define COMP_BCAM_BASE_RESPONSE_DATA_28_REG_NUM (0x1)
#define COMP_BCAM_BASE_RESPONSE_DATA_28_RESPONSE_DATA_28_MASK (0xffffffff)
#define COMP_BCAM_BASE_RESPONSE_DATA_28_RESPONSE_DATA_28_SHIFT (0)
#define COMP_BCAM_BASE_RESPONSE_DATA_29_REG_OFFSET (0x374) 
#define COMP_BCAM_BASE_RESPONSE_DATA_29_REG_MASK (0xffffffff)
#define COMP_BCAM_BASE_RESPONSE_DATA_29_REG_SHIFT (0)
#define COMP_BCAM_BASE_RESPONSE_DATA_29_RESPONSE_DATA_29_OFFSET (0x374) 
#define COMP_BCAM_BASE_RESPONSE_DATA_29_RESPONSE_DATA_29_ACCESS (XLNX_RW)
#define COMP_BCAM_BASE_RESPONSE_DATA_29_REG_NUM (0x1)
#define COMP_BCAM_BASE_RESPONSE_DATA_29_RESPONSE_DATA_29_MASK (0xffffffff)
#define COMP_BCAM_BASE_RESPONSE_DATA_29_RESPONSE_DATA_29_SHIFT (0)
#define COMP_BCAM_BASE_RESPONSE_DATA_30_REG_OFFSET (0x378) 
#define COMP_BCAM_BASE_RESPONSE_DATA_30_REG_MASK (0xffffffff)
#define COMP_BCAM_BASE_RESPONSE_DATA_30_REG_SHIFT (0)
#define COMP_BCAM_BASE_RESPONSE_DATA_30_RESPONSE_DATA_30_OFFSET (0x378) 
#define COMP_BCAM_BASE_RESPONSE_DATA_30_RESPONSE_DATA_30_ACCESS (XLNX_RW)
#define COMP_BCAM_BASE_RESPONSE_DATA_30_REG_NUM (0x1)
#define COMP_BCAM_BASE_RESPONSE_DATA_30_RESPONSE_DATA_30_MASK (0xffffffff)
#define COMP_BCAM_BASE_RESPONSE_DATA_30_RESPONSE_DATA_30_SHIFT (0)
#define COMP_BCAM_BASE_RESPONSE_DATA_31_REG_OFFSET (0x37c) 
#define COMP_BCAM_BASE_RESPONSE_DATA_31_REG_MASK (0xffffffff)
#define COMP_BCAM_BASE_RESPONSE_DATA_31_REG_SHIFT (0)
#define COMP_BCAM_BASE_RESPONSE_DATA_31_RESPONSE_DATA_31_OFFSET (0x37c) 
#define COMP_BCAM_BASE_RESPONSE_DATA_31_RESPONSE_DATA_31_ACCESS (XLNX_RW)
#define COMP_BCAM_BASE_RESPONSE_DATA_31_REG_NUM (0x1)
#define COMP_BCAM_BASE_RESPONSE_DATA_31_RESPONSE_DATA_31_MASK (0xffffffff)
#define COMP_BCAM_BASE_RESPONSE_DATA_31_RESPONSE_DATA_31_SHIFT (0)
#ifdef __cplusplus
}
#endif
#endif 
#ifndef COMP_BCAM_BCS_MEMMAP_H_
#define COMP_BCAM_BCS_MEMMAP_H_
#ifdef __cplusplus
extern "C"
{
#endif
#define BCS_BASE_1_OF_1_OFFSET (0x0) 
#define BCS_BASE_1_OF_1_MASK (0xffffffff)
#define BCS_BASE_1_OF_1_SHIFT (0)
#define BCS_BASE_NUM (1)
#define BCS_BASE_MODE_REG_OFFSET (0x0) 
#define BCS_BASE_MODE_REG_MASK (0xffffffff)
#define BCS_BASE_MODE_REG_SHIFT (0)
#define BCS_BASE_MODE_MODE_OFFSET (0x0) 
#define BCS_BASE_MODE_MODE_ACCESS (XLNX_RW)
#define BCS_BASE_MODE_REG_NUM (0x1)
#define BCS_BASE_MODE_MODE_MASK (0x3)
#define BCS_BASE_MODE_MODE_SHIFT (0)
#define BCS_BASE_CRF_SBITERR_COUNT_REG_OFFSET (0x4) 
#define BCS_BASE_CRF_SBITERR_COUNT_REG_MASK (0xffffffff)
#define BCS_BASE_CRF_SBITERR_COUNT_REG_SHIFT (0)
#define BCS_BASE_CRF_SBITERR_COUNT_CRF_SBITERR_COUNT_OFFSET (0x4) 
#define BCS_BASE_CRF_SBITERR_COUNT_CRF_SBITERR_COUNT_ACCESS (XLNX_RO)
#define BCS_BASE_CRF_SBITERR_COUNT_REG_NUM (0x1)
#define BCS_BASE_CRF_SBITERR_COUNT_CRF_SBITERR_COUNT_MASK (0xffffffff)
#define BCS_BASE_CRF_SBITERR_COUNT_CRF_SBITERR_COUNT_SHIFT (0)
#define BCS_BASE_CRF_DBITERR_COUNT_REG_OFFSET (0x8) 
#define BCS_BASE_CRF_DBITERR_COUNT_REG_MASK (0xffffffff)
#define BCS_BASE_CRF_DBITERR_COUNT_REG_SHIFT (0)
#define BCS_BASE_CRF_DBITERR_COUNT_CRF_DBITERR_COUNT_OFFSET (0x8) 
#define BCS_BASE_CRF_DBITERR_COUNT_CRF_DBITERR_COUNT_ACCESS (XLNX_RO)
#define BCS_BASE_CRF_DBITERR_COUNT_REG_NUM (0x1)
#define BCS_BASE_CRF_DBITERR_COUNT_CRF_DBITERR_COUNT_MASK (0xffffffff)
#define BCS_BASE_CRF_DBITERR_COUNT_CRF_DBITERR_COUNT_SHIFT (0)
#define BCS_BASE_RRO_SBITERR_COUNT_REG_OFFSET (0xc) 
#define BCS_BASE_RRO_SBITERR_COUNT_REG_MASK (0xffffffff)
#define BCS_BASE_RRO_SBITERR_COUNT_REG_SHIFT (0)
#define BCS_BASE_RRO_SBITERR_COUNT_RRO_SBITERR_COUNT_OFFSET (0xc) 
#define BCS_BASE_RRO_SBITERR_COUNT_RRO_SBITERR_COUNT_ACCESS (XLNX_RO)
#define BCS_BASE_RRO_SBITERR_COUNT_REG_NUM (0x1)
#define BCS_BASE_RRO_SBITERR_COUNT_RRO_SBITERR_COUNT_MASK (0xffffffff)
#define BCS_BASE_RRO_SBITERR_COUNT_RRO_SBITERR_COUNT_SHIFT (0)
#ifdef __cplusplus
}
#endif
#endif 
#ifdef __cplusplus
}
#endif
#endif 
XLNX_ERROR_CODE XLNX_COMP_BCAM_GetCompBcamBaseVersionMajor(XLNX_COMP_BCAM_CONTEXT_TYPE* ContextPtr, uint32_t* MajorPtr)
{
XLNX_ERROR_CODE ret_val = XLNX_OK;
uint32_t Offset, Mask, Shift, Buffer;
XLNX_COMPONENT_ADDRESS_TYPE WorkingAddr;
Offset = (COMP_BCAM_BASE_VERSION_REG_OFFSET);
Mask = COMP_BCAM_BASE_VERSION_MAJOR_MASK;
Shift = COMP_BCAM_BASE_VERSION_MAJOR_SHIFT;
WorkingAddr = (XLNX_COMPONENT_ADDRESS_TYPE)((ContextPtr->ComponentBaseAddress) + Offset);
ret_val = XLNX_Environment_Wrapper_Read32(ContextPtr->UserEnvironment.Device_IO.Read32, ContextPtr->UserContextPtr, &Buffer, WorkingAddr);
if (XLNX_OK == ret_val)
{
*MajorPtr = ((Buffer & Mask) >> Shift);
}
return ret_val;
}
XLNX_ERROR_CODE XLNX_COMP_BCAM_GetCompBcamBaseVersionMinor(XLNX_COMP_BCAM_CONTEXT_TYPE* ContextPtr, uint32_t* MinorPtr)
{
XLNX_ERROR_CODE ret_val = XLNX_OK;
uint32_t Offset, Mask, Shift, Buffer;
XLNX_COMPONENT_ADDRESS_TYPE WorkingAddr;
Offset = (COMP_BCAM_BASE_VERSION_REG_OFFSET);
Mask = COMP_BCAM_BASE_VERSION_MINOR_MASK;
Shift = COMP_BCAM_BASE_VERSION_MINOR_SHIFT;
WorkingAddr = (XLNX_COMPONENT_ADDRESS_TYPE)((ContextPtr->ComponentBaseAddress) + Offset);
ret_val = XLNX_Environment_Wrapper_Read32(ContextPtr->UserEnvironment.Device_IO.Read32, ContextPtr->UserContextPtr, &Buffer, WorkingAddr);
if (XLNX_OK == ret_val)
{
*MinorPtr = ((Buffer & Mask) >> Shift);
}
return ret_val;
}
XLNX_ERROR_CODE XLNX_COMP_BCAM_GetCompBcamBaseVersionReg(XLNX_COMP_BCAM_CONTEXT_TYPE* ContextPtr, uint32_t* ValuePtr)
{
XLNX_ERROR_CODE ret_val = XLNX_OK;
uint32_t Offset;
XLNX_COMPONENT_ADDRESS_TYPE WorkingAddr;
Offset = (COMP_BCAM_BASE_VERSION_REG_OFFSET);
WorkingAddr = (XLNX_COMPONENT_ADDRESS_TYPE)((ContextPtr->ComponentBaseAddress) + Offset);
ret_val = XLNX_Environment_Wrapper_Read32(ContextPtr->UserEnvironment.Device_IO.Read32, ContextPtr->UserContextPtr, ValuePtr, WorkingAddr);
return ret_val;
}
XLNX_ERROR_CODE XLNX_COMP_BCAM_SetCompBcamBaseScratchScratch(XLNX_COMP_BCAM_CONTEXT_TYPE* ContextPtr, uint32_t Scratch)
{
XLNX_ERROR_CODE ret_val = XLNX_OK;
uint32_t Offset, Mask, Shift, Buffer;
XLNX_COMPONENT_ADDRESS_TYPE WorkingAddr;
Offset = (COMP_BCAM_BASE_SCRATCH_REG_OFFSET);
Mask = COMP_BCAM_BASE_SCRATCH_SCRATCH_MASK;
Shift = COMP_BCAM_BASE_SCRATCH_SCRATCH_SHIFT;
WorkingAddr = (XLNX_COMPONENT_ADDRESS_TYPE)((ContextPtr->ComponentBaseAddress) + Offset);
Buffer = (Scratch << Shift);
ret_val = XLNX_Environment_Wrapper_Write32_WithMask(ContextPtr->UserEnvironment.Device_IO.Write32WithMask, ContextPtr->UserContextPtr, WorkingAddr, Buffer, Mask);
return ret_val;
}
void XLNX_COMP_BCAM_BuildCompBcamBaseScratchScratch(uint32_t* MaskPtr, uint32_t* ValPtr, uint32_t Scratch)
{
*MaskPtr |= COMP_BCAM_BASE_SCRATCH_SCRATCH_MASK;
*ValPtr |= (Scratch << COMP_BCAM_BASE_SCRATCH_SCRATCH_SHIFT);
}
XLNX_ERROR_CODE XLNX_COMP_BCAM_GetCompBcamBaseScratchScratch(XLNX_COMP_BCAM_CONTEXT_TYPE* ContextPtr, uint32_t* ScratchPtr)
{
XLNX_ERROR_CODE ret_val = XLNX_OK;
uint32_t Offset, Mask, Shift, Buffer;
XLNX_COMPONENT_ADDRESS_TYPE WorkingAddr;
Offset = (COMP_BCAM_BASE_SCRATCH_REG_OFFSET);
Mask = COMP_BCAM_BASE_SCRATCH_SCRATCH_MASK;
Shift = COMP_BCAM_BASE_SCRATCH_SCRATCH_SHIFT;
WorkingAddr = (XLNX_COMPONENT_ADDRESS_TYPE)((ContextPtr->ComponentBaseAddress) + Offset);
ret_val = XLNX_Environment_Wrapper_Read32(ContextPtr->UserEnvironment.Device_IO.Read32, ContextPtr->UserContextPtr, &Buffer, WorkingAddr);
if (XLNX_OK == ret_val)
{
*ScratchPtr = ((Buffer & Mask) >> Shift);
}
return ret_val;
}
XLNX_ERROR_CODE XLNX_COMP_BCAM_SetCompBcamBaseScratchReg(XLNX_COMP_BCAM_CONTEXT_TYPE* ContextPtr, uint32_t Mask, uint32_t Value)
{
XLNX_ERROR_CODE ret_val = XLNX_OK;
uint32_t Offset;
XLNX_COMPONENT_ADDRESS_TYPE WorkingAddr;
Offset = (COMP_BCAM_BASE_SCRATCH_REG_OFFSET);
WorkingAddr = (XLNX_COMPONENT_ADDRESS_TYPE)((ContextPtr->ComponentBaseAddress) + Offset);
ret_val = XLNX_Environment_Wrapper_Write32_WithMask(ContextPtr->UserEnvironment.Device_IO.Write32WithMask, ContextPtr->UserContextPtr, WorkingAddr, Value, Mask);
return ret_val;
}
XLNX_ERROR_CODE XLNX_COMP_BCAM_GetCompBcamBaseScratchReg(XLNX_COMP_BCAM_CONTEXT_TYPE* ContextPtr, uint32_t* ValuePtr)
{
XLNX_ERROR_CODE ret_val = XLNX_OK;
uint32_t Offset;
XLNX_COMPONENT_ADDRESS_TYPE WorkingAddr;
Offset = (COMP_BCAM_BASE_SCRATCH_REG_OFFSET);
WorkingAddr = (XLNX_COMPONENT_ADDRESS_TYPE)((ContextPtr->ComponentBaseAddress) + Offset);
ret_val = XLNX_Environment_Wrapper_Read32(ContextPtr->UserEnvironment.Device_IO.Read32, ContextPtr->UserContextPtr, ValuePtr, WorkingAddr);
return ret_val;
}
XLNX_ERROR_CODE XLNX_COMP_BCAM_SetCompBcamBaseAgeThresholdAgeThreshold(XLNX_COMP_BCAM_CONTEXT_TYPE* ContextPtr, uint32_t AgeThreshold)
{
XLNX_ERROR_CODE ret_val = XLNX_OK;
uint32_t Offset, Mask, Shift, Buffer;
XLNX_COMPONENT_ADDRESS_TYPE WorkingAddr;
Offset = (COMP_BCAM_BASE_AGE_THRESHOLD_REG_OFFSET);
Mask = COMP_BCAM_BASE_AGE_THRESHOLD_AGE_THRESHOLD_MASK;
Shift = COMP_BCAM_BASE_AGE_THRESHOLD_AGE_THRESHOLD_SHIFT;
WorkingAddr = (XLNX_COMPONENT_ADDRESS_TYPE)((ContextPtr->ComponentBaseAddress) + Offset);
Buffer = (AgeThreshold << Shift);
ret_val = XLNX_Environment_Wrapper_Write32_WithMask(ContextPtr->UserEnvironment.Device_IO.Write32WithMask, ContextPtr->UserContextPtr, WorkingAddr, Buffer, Mask);
return ret_val;
}
void XLNX_COMP_BCAM_BuildCompBcamBaseAgeThresholdAgeThreshold(uint32_t* MaskPtr, uint32_t* ValPtr, uint32_t AgeThreshold)
{
*MaskPtr |= COMP_BCAM_BASE_AGE_THRESHOLD_AGE_THRESHOLD_MASK;
*ValPtr |= (AgeThreshold << COMP_BCAM_BASE_AGE_THRESHOLD_AGE_THRESHOLD_SHIFT);
}
XLNX_ERROR_CODE XLNX_COMP_BCAM_GetCompBcamBaseAgeThresholdAgeThreshold(XLNX_COMP_BCAM_CONTEXT_TYPE* ContextPtr, uint32_t* AgeThresholdPtr)
{
XLNX_ERROR_CODE ret_val = XLNX_OK;
uint32_t Offset, Mask, Shift, Buffer;
XLNX_COMPONENT_ADDRESS_TYPE WorkingAddr;
Offset = (COMP_BCAM_BASE_AGE_THRESHOLD_REG_OFFSET);
Mask = COMP_BCAM_BASE_AGE_THRESHOLD_AGE_THRESHOLD_MASK;
Shift = COMP_BCAM_BASE_AGE_THRESHOLD_AGE_THRESHOLD_SHIFT;
WorkingAddr = (XLNX_COMPONENT_ADDRESS_TYPE)((ContextPtr->ComponentBaseAddress) + Offset);
ret_val = XLNX_Environment_Wrapper_Read32(ContextPtr->UserEnvironment.Device_IO.Read32, ContextPtr->UserContextPtr, &Buffer, WorkingAddr);
if (XLNX_OK == ret_val)
{
*AgeThresholdPtr = ((Buffer & Mask) >> Shift);
}
return ret_val;
}
XLNX_ERROR_CODE XLNX_COMP_BCAM_SetCompBcamBaseAgeThresholdReg(XLNX_COMP_BCAM_CONTEXT_TYPE* ContextPtr, uint32_t Mask, uint32_t Value)
{
XLNX_ERROR_CODE ret_val = XLNX_OK;
uint32_t Offset;
XLNX_COMPONENT_ADDRESS_TYPE WorkingAddr;
Offset = (COMP_BCAM_BASE_AGE_THRESHOLD_REG_OFFSET);
WorkingAddr = (XLNX_COMPONENT_ADDRESS_TYPE)((ContextPtr->ComponentBaseAddress) + Offset);
ret_val = XLNX_Environment_Wrapper_Write32_WithMask(ContextPtr->UserEnvironment.Device_IO.Write32WithMask, ContextPtr->UserContextPtr, WorkingAddr, Value, Mask);
return ret_val;
}
XLNX_ERROR_CODE XLNX_COMP_BCAM_GetCompBcamBaseAgeThresholdReg(XLNX_COMP_BCAM_CONTEXT_TYPE* ContextPtr, uint32_t* ValuePtr)
{
XLNX_ERROR_CODE ret_val = XLNX_OK;
uint32_t Offset;
XLNX_COMPONENT_ADDRESS_TYPE WorkingAddr;
Offset = (COMP_BCAM_BASE_AGE_THRESHOLD_REG_OFFSET);
WorkingAddr = (XLNX_COMPONENT_ADDRESS_TYPE)((ContextPtr->ComponentBaseAddress) + Offset);
ret_val = XLNX_Environment_Wrapper_Read32(ContextPtr->UserEnvironment.Device_IO.Read32, ContextPtr->UserContextPtr, ValuePtr, WorkingAddr);
return ret_val;
}
XLNX_ERROR_CODE XLNX_COMP_BCAM_SetCompBcamBaseNumberPassesNumberPasses(XLNX_COMP_BCAM_CONTEXT_TYPE* ContextPtr, uint32_t NumberPasses)
{
XLNX_ERROR_CODE ret_val = XLNX_OK;
uint32_t Offset, Mask, Shift, Buffer;
XLNX_COMPONENT_ADDRESS_TYPE WorkingAddr;
Offset = (COMP_BCAM_BASE_NUMBER_PASSES_REG_OFFSET);
Mask = COMP_BCAM_BASE_NUMBER_PASSES_NUMBER_PASSES_MASK;
Shift = COMP_BCAM_BASE_NUMBER_PASSES_NUMBER_PASSES_SHIFT;
WorkingAddr = (XLNX_COMPONENT_ADDRESS_TYPE)((ContextPtr->ComponentBaseAddress) + Offset);
Buffer = (NumberPasses << Shift);
ret_val = XLNX_Environment_Wrapper_Write32_WithMask(ContextPtr->UserEnvironment.Device_IO.Write32WithMask, ContextPtr->UserContextPtr, WorkingAddr, Buffer, Mask);
return ret_val;
}
void XLNX_COMP_BCAM_BuildCompBcamBaseNumberPassesNumberPasses(uint32_t* MaskPtr, uint32_t* ValPtr, uint32_t NumberPasses)
{
*MaskPtr |= COMP_BCAM_BASE_NUMBER_PASSES_NUMBER_PASSES_MASK;
*ValPtr |= (NumberPasses << COMP_BCAM_BASE_NUMBER_PASSES_NUMBER_PASSES_SHIFT);
}
XLNX_ERROR_CODE XLNX_COMP_BCAM_GetCompBcamBaseNumberPassesNumberPasses(XLNX_COMP_BCAM_CONTEXT_TYPE* ContextPtr, uint32_t* NumberPassesPtr)
{
XLNX_ERROR_CODE ret_val = XLNX_OK;
uint32_t Offset, Mask, Shift, Buffer;
XLNX_COMPONENT_ADDRESS_TYPE WorkingAddr;
Offset = (COMP_BCAM_BASE_NUMBER_PASSES_REG_OFFSET);
Mask = COMP_BCAM_BASE_NUMBER_PASSES_NUMBER_PASSES_MASK;
Shift = COMP_BCAM_BASE_NUMBER_PASSES_NUMBER_PASSES_SHIFT;
WorkingAddr = (XLNX_COMPONENT_ADDRESS_TYPE)((ContextPtr->ComponentBaseAddress) + Offset);
ret_val = XLNX_Environment_Wrapper_Read32(ContextPtr->UserEnvironment.Device_IO.Read32, ContextPtr->UserContextPtr, &Buffer, WorkingAddr);
if (XLNX_OK == ret_val)
{
*NumberPassesPtr = ((Buffer & Mask) >> Shift);
}
return ret_val;
}
XLNX_ERROR_CODE XLNX_COMP_BCAM_SetCompBcamBaseNumberPassesReg(XLNX_COMP_BCAM_CONTEXT_TYPE* ContextPtr, uint32_t Mask, uint32_t Value)
{
XLNX_ERROR_CODE ret_val = XLNX_OK;
uint32_t Offset;
XLNX_COMPONENT_ADDRESS_TYPE WorkingAddr;
Offset = (COMP_BCAM_BASE_NUMBER_PASSES_REG_OFFSET);
WorkingAddr = (XLNX_COMPONENT_ADDRESS_TYPE)((ContextPtr->ComponentBaseAddress) + Offset);
ret_val = XLNX_Environment_Wrapper_Write32_WithMask(ContextPtr->UserEnvironment.Device_IO.Write32WithMask, ContextPtr->UserContextPtr, WorkingAddr, Value, Mask);
return ret_val;
}
XLNX_ERROR_CODE XLNX_COMP_BCAM_GetCompBcamBaseNumberPassesReg(XLNX_COMP_BCAM_CONTEXT_TYPE* ContextPtr, uint32_t* ValuePtr)
{
XLNX_ERROR_CODE ret_val = XLNX_OK;
uint32_t Offset;
XLNX_COMPONENT_ADDRESS_TYPE WorkingAddr;
Offset = (COMP_BCAM_BASE_NUMBER_PASSES_REG_OFFSET);
WorkingAddr = (XLNX_COMPONENT_ADDRESS_TYPE)((ContextPtr->ComponentBaseAddress) + Offset);
ret_val = XLNX_Environment_Wrapper_Read32(ContextPtr->UserEnvironment.Device_IO.Read32, ContextPtr->UserContextPtr, ValuePtr, WorkingAddr);
return ret_val;
}
XLNX_ERROR_CODE XLNX_COMP_BCAM_GetCompBcamBaseInsertCountInsertCount(XLNX_COMP_BCAM_CONTEXT_TYPE* ContextPtr, uint32_t* InsertCountPtr)
{
XLNX_ERROR_CODE ret_val = XLNX_OK;
uint32_t Offset, Mask, Shift, Buffer;
XLNX_COMPONENT_ADDRESS_TYPE WorkingAddr;
Offset = (COMP_BCAM_BASE_INSERT_COUNT_REG_OFFSET);
Mask = COMP_BCAM_BASE_INSERT_COUNT_INSERT_COUNT_MASK;
Shift = COMP_BCAM_BASE_INSERT_COUNT_INSERT_COUNT_SHIFT;
WorkingAddr = (XLNX_COMPONENT_ADDRESS_TYPE)((ContextPtr->ComponentBaseAddress) + Offset);
ret_val = XLNX_Environment_Wrapper_Read32(ContextPtr->UserEnvironment.Device_IO.Read32, ContextPtr->UserContextPtr, &Buffer, WorkingAddr);
if (XLNX_OK == ret_val)
{
*InsertCountPtr = ((Buffer & Mask) >> Shift);
}
return ret_val;
}
XLNX_ERROR_CODE XLNX_COMP_BCAM_GetCompBcamBaseInsertCountTimerCount(XLNX_COMP_BCAM_CONTEXT_TYPE* ContextPtr, uint32_t* TimerCountPtr)
{
XLNX_ERROR_CODE ret_val = XLNX_OK;
uint32_t Offset, Mask, Shift, Buffer;
XLNX_COMPONENT_ADDRESS_TYPE WorkingAddr;
Offset = (COMP_BCAM_BASE_INSERT_COUNT_REG_OFFSET);
Mask = COMP_BCAM_BASE_INSERT_COUNT_TIMER_COUNT_MASK;
Shift = COMP_BCAM_BASE_INSERT_COUNT_TIMER_COUNT_SHIFT;
WorkingAddr = (XLNX_COMPONENT_ADDRESS_TYPE)((ContextPtr->ComponentBaseAddress) + Offset);
ret_val = XLNX_Environment_Wrapper_Read32(ContextPtr->UserEnvironment.Device_IO.Read32, ContextPtr->UserContextPtr, &Buffer, WorkingAddr);
if (XLNX_OK == ret_val)
{
*TimerCountPtr = ((Buffer & Mask) >> Shift);
}
return ret_val;
}
XLNX_ERROR_CODE XLNX_COMP_BCAM_GetCompBcamBaseInsertCountReg(XLNX_COMP_BCAM_CONTEXT_TYPE* ContextPtr, uint32_t* ValuePtr)
{
XLNX_ERROR_CODE ret_val = XLNX_OK;
uint32_t Offset;
XLNX_COMPONENT_ADDRESS_TYPE WorkingAddr;
Offset = (COMP_BCAM_BASE_INSERT_COUNT_REG_OFFSET);
WorkingAddr = (XLNX_COMPONENT_ADDRESS_TYPE)((ContextPtr->ComponentBaseAddress) + Offset);
ret_val = XLNX_Environment_Wrapper_Read32(ContextPtr->UserEnvironment.Device_IO.Read32, ContextPtr->UserContextPtr, ValuePtr, WorkingAddr);
return ret_val;
}
XLNX_ERROR_CODE XLNX_COMP_BCAM_GetCompBcamBaseUpdateCountUpdateCount(XLNX_COMP_BCAM_CONTEXT_TYPE* ContextPtr, uint32_t* UpdateCountPtr)
{
XLNX_ERROR_CODE ret_val = XLNX_OK;
uint32_t Offset, Mask, Shift, Buffer;
XLNX_COMPONENT_ADDRESS_TYPE WorkingAddr;
Offset = (COMP_BCAM_BASE_UPDATE_COUNT_REG_OFFSET);
Mask = COMP_BCAM_BASE_UPDATE_COUNT_UPDATE_COUNT_MASK;
Shift = COMP_BCAM_BASE_UPDATE_COUNT_UPDATE_COUNT_SHIFT;
WorkingAddr = (XLNX_COMPONENT_ADDRESS_TYPE)((ContextPtr->ComponentBaseAddress) + Offset);
ret_val = XLNX_Environment_Wrapper_Read32(ContextPtr->UserEnvironment.Device_IO.Read32, ContextPtr->UserContextPtr, &Buffer, WorkingAddr);
if (XLNX_OK == ret_val)
{
*UpdateCountPtr = ((Buffer & Mask) >> Shift);
}
return ret_val;
}
XLNX_ERROR_CODE XLNX_COMP_BCAM_GetCompBcamBaseUpdateCountTimerCount(XLNX_COMP_BCAM_CONTEXT_TYPE* ContextPtr, uint32_t* TimerCountPtr)
{
XLNX_ERROR_CODE ret_val = XLNX_OK;
uint32_t Offset, Mask, Shift, Buffer;
XLNX_COMPONENT_ADDRESS_TYPE WorkingAddr;
Offset = (COMP_BCAM_BASE_UPDATE_COUNT_REG_OFFSET);
Mask = COMP_BCAM_BASE_UPDATE_COUNT_TIMER_COUNT_MASK;
Shift = COMP_BCAM_BASE_UPDATE_COUNT_TIMER_COUNT_SHIFT;
WorkingAddr = (XLNX_COMPONENT_ADDRESS_TYPE)((ContextPtr->ComponentBaseAddress) + Offset);
ret_val = XLNX_Environment_Wrapper_Read32(ContextPtr->UserEnvironment.Device_IO.Read32, ContextPtr->UserContextPtr, &Buffer, WorkingAddr);
if (XLNX_OK == ret_val)
{
*TimerCountPtr = ((Buffer & Mask) >> Shift);
}
return ret_val;
}
XLNX_ERROR_CODE XLNX_COMP_BCAM_GetCompBcamBaseUpdateCountReg(XLNX_COMP_BCAM_CONTEXT_TYPE* ContextPtr, uint32_t* ValuePtr)
{
XLNX_ERROR_CODE ret_val = XLNX_OK;
uint32_t Offset;
XLNX_COMPONENT_ADDRESS_TYPE WorkingAddr;
Offset = (COMP_BCAM_BASE_UPDATE_COUNT_REG_OFFSET);
WorkingAddr = (XLNX_COMPONENT_ADDRESS_TYPE)((ContextPtr->ComponentBaseAddress) + Offset);
ret_val = XLNX_Environment_Wrapper_Read32(ContextPtr->UserEnvironment.Device_IO.Read32, ContextPtr->UserContextPtr, ValuePtr, WorkingAddr);
return ret_val;
}
XLNX_ERROR_CODE XLNX_COMP_BCAM_GetCompBcamBaseDeleteCountDeleteCount(XLNX_COMP_BCAM_CONTEXT_TYPE* ContextPtr, uint32_t* DeleteCountPtr)
{
XLNX_ERROR_CODE ret_val = XLNX_OK;
uint32_t Offset, Mask, Shift, Buffer;
XLNX_COMPONENT_ADDRESS_TYPE WorkingAddr;
Offset = (COMP_BCAM_BASE_DELETE_COUNT_REG_OFFSET);
Mask = COMP_BCAM_BASE_DELETE_COUNT_DELETE_COUNT_MASK;
Shift = COMP_BCAM_BASE_DELETE_COUNT_DELETE_COUNT_SHIFT;
WorkingAddr = (XLNX_COMPONENT_ADDRESS_TYPE)((ContextPtr->ComponentBaseAddress) + Offset);
ret_val = XLNX_Environment_Wrapper_Read32(ContextPtr->UserEnvironment.Device_IO.Read32, ContextPtr->UserContextPtr, &Buffer, WorkingAddr);
if (XLNX_OK == ret_val)
{
*DeleteCountPtr = ((Buffer & Mask) >> Shift);
}
return ret_val;
}
XLNX_ERROR_CODE XLNX_COMP_BCAM_GetCompBcamBaseDeleteCountTimerCount(XLNX_COMP_BCAM_CONTEXT_TYPE* ContextPtr, uint32_t* TimerCountPtr)
{
XLNX_ERROR_CODE ret_val = XLNX_OK;
uint32_t Offset, Mask, Shift, Buffer;
XLNX_COMPONENT_ADDRESS_TYPE WorkingAddr;
Offset = (COMP_BCAM_BASE_DELETE_COUNT_REG_OFFSET);
Mask = COMP_BCAM_BASE_DELETE_COUNT_TIMER_COUNT_MASK;
Shift = COMP_BCAM_BASE_DELETE_COUNT_TIMER_COUNT_SHIFT;
WorkingAddr = (XLNX_COMPONENT_ADDRESS_TYPE)((ContextPtr->ComponentBaseAddress) + Offset);
ret_val = XLNX_Environment_Wrapper_Read32(ContextPtr->UserEnvironment.Device_IO.Read32, ContextPtr->UserContextPtr, &Buffer, WorkingAddr);
if (XLNX_OK == ret_val)
{
*TimerCountPtr = ((Buffer & Mask) >> Shift);
}
return ret_val;
}
XLNX_ERROR_CODE XLNX_COMP_BCAM_GetCompBcamBaseDeleteCountReg(XLNX_COMP_BCAM_CONTEXT_TYPE* ContextPtr, uint32_t* ValuePtr)
{
XLNX_ERROR_CODE ret_val = XLNX_OK;
uint32_t Offset;
XLNX_COMPONENT_ADDRESS_TYPE WorkingAddr;
Offset = (COMP_BCAM_BASE_DELETE_COUNT_REG_OFFSET);
WorkingAddr = (XLNX_COMPONENT_ADDRESS_TYPE)((ContextPtr->ComponentBaseAddress) + Offset);
ret_val = XLNX_Environment_Wrapper_Read32(ContextPtr->UserEnvironment.Device_IO.Read32, ContextPtr->UserContextPtr, ValuePtr, WorkingAddr);
return ret_val;
}
XLNX_ERROR_CODE XLNX_COMP_BCAM_GetCompBcamBaseGetbykeyCountGetbykeyCount(XLNX_COMP_BCAM_CONTEXT_TYPE* ContextPtr, uint32_t* GetbykeyCountPtr)
{
XLNX_ERROR_CODE ret_val = XLNX_OK;
uint32_t Offset, Mask, Shift, Buffer;
XLNX_COMPONENT_ADDRESS_TYPE WorkingAddr;
Offset = (COMP_BCAM_BASE_GETBYKEY_COUNT_REG_OFFSET);
Mask = COMP_BCAM_BASE_GETBYKEY_COUNT_GETBYKEY_COUNT_MASK;
Shift = COMP_BCAM_BASE_GETBYKEY_COUNT_GETBYKEY_COUNT_SHIFT;
WorkingAddr = (XLNX_COMPONENT_ADDRESS_TYPE)((ContextPtr->ComponentBaseAddress) + Offset);
ret_val = XLNX_Environment_Wrapper_Read32(ContextPtr->UserEnvironment.Device_IO.Read32, ContextPtr->UserContextPtr, &Buffer, WorkingAddr);
if (XLNX_OK == ret_val)
{
*GetbykeyCountPtr = ((Buffer & Mask) >> Shift);
}
return ret_val;
}
XLNX_ERROR_CODE XLNX_COMP_BCAM_GetCompBcamBaseGetbykeyCountTimerCount(XLNX_COMP_BCAM_CONTEXT_TYPE* ContextPtr, uint32_t* TimerCountPtr)
{
XLNX_ERROR_CODE ret_val = XLNX_OK;
uint32_t Offset, Mask, Shift, Buffer;
XLNX_COMPONENT_ADDRESS_TYPE WorkingAddr;
Offset = (COMP_BCAM_BASE_GETBYKEY_COUNT_REG_OFFSET);
Mask = COMP_BCAM_BASE_GETBYKEY_COUNT_TIMER_COUNT_MASK;
Shift = COMP_BCAM_BASE_GETBYKEY_COUNT_TIMER_COUNT_SHIFT;
WorkingAddr = (XLNX_COMPONENT_ADDRESS_TYPE)((ContextPtr->ComponentBaseAddress) + Offset);
ret_val = XLNX_Environment_Wrapper_Read32(ContextPtr->UserEnvironment.Device_IO.Read32, ContextPtr->UserContextPtr, &Buffer, WorkingAddr);
if (XLNX_OK == ret_val)
{
*TimerCountPtr = ((Buffer & Mask) >> Shift);
}
return ret_val;
}
XLNX_ERROR_CODE XLNX_COMP_BCAM_GetCompBcamBaseGetbykeyCountReg(XLNX_COMP_BCAM_CONTEXT_TYPE* ContextPtr, uint32_t* ValuePtr)
{
XLNX_ERROR_CODE ret_val = XLNX_OK;
uint32_t Offset;
XLNX_COMPONENT_ADDRESS_TYPE WorkingAddr;
Offset = (COMP_BCAM_BASE_GETBYKEY_COUNT_REG_OFFSET);
WorkingAddr = (XLNX_COMPONENT_ADDRESS_TYPE)((ContextPtr->ComponentBaseAddress) + Offset);
ret_val = XLNX_Environment_Wrapper_Read32(ContextPtr->UserEnvironment.Device_IO.Read32, ContextPtr->UserContextPtr, ValuePtr, WorkingAddr);
return ret_val;
}
XLNX_ERROR_CODE XLNX_COMP_BCAM_GetCompBcamBaseLookupCountLookupCount(XLNX_COMP_BCAM_CONTEXT_TYPE* ContextPtr, uint32_t* LookupCountPtr)
{
XLNX_ERROR_CODE ret_val = XLNX_OK;
uint32_t Offset, Mask, Shift, Buffer;
XLNX_COMPONENT_ADDRESS_TYPE WorkingAddr;
Offset = (COMP_BCAM_BASE_LOOKUP_COUNT_REG_OFFSET);
Mask = COMP_BCAM_BASE_LOOKUP_COUNT_LOOKUP_COUNT_MASK;
Shift = COMP_BCAM_BASE_LOOKUP_COUNT_LOOKUP_COUNT_SHIFT;
WorkingAddr = (XLNX_COMPONENT_ADDRESS_TYPE)((ContextPtr->ComponentBaseAddress) + Offset);
ret_val = XLNX_Environment_Wrapper_Read32(ContextPtr->UserEnvironment.Device_IO.Read32, ContextPtr->UserContextPtr, &Buffer, WorkingAddr);
if (XLNX_OK == ret_val)
{
*LookupCountPtr = ((Buffer & Mask) >> Shift);
}
return ret_val;
}
XLNX_ERROR_CODE XLNX_COMP_BCAM_GetCompBcamBaseLookupCountTimerCount(XLNX_COMP_BCAM_CONTEXT_TYPE* ContextPtr, uint32_t* TimerCountPtr)
{
XLNX_ERROR_CODE ret_val = XLNX_OK;
uint32_t Offset, Mask, Shift, Buffer;
XLNX_COMPONENT_ADDRESS_TYPE WorkingAddr;
Offset = (COMP_BCAM_BASE_LOOKUP_COUNT_REG_OFFSET);
Mask = COMP_BCAM_BASE_LOOKUP_COUNT_TIMER_COUNT_MASK;
Shift = COMP_BCAM_BASE_LOOKUP_COUNT_TIMER_COUNT_SHIFT;
WorkingAddr = (XLNX_COMPONENT_ADDRESS_TYPE)((ContextPtr->ComponentBaseAddress) + Offset);
ret_val = XLNX_Environment_Wrapper_Read32(ContextPtr->UserEnvironment.Device_IO.Read32, ContextPtr->UserContextPtr, &Buffer, WorkingAddr);
if (XLNX_OK == ret_val)
{
*TimerCountPtr = ((Buffer & Mask) >> Shift);
}
return ret_val;
}
XLNX_ERROR_CODE XLNX_COMP_BCAM_GetCompBcamBaseLookupCountReg(XLNX_COMP_BCAM_CONTEXT_TYPE* ContextPtr, uint32_t* ValuePtr)
{
XLNX_ERROR_CODE ret_val = XLNX_OK;
uint32_t Offset;
XLNX_COMPONENT_ADDRESS_TYPE WorkingAddr;
Offset = (COMP_BCAM_BASE_LOOKUP_COUNT_REG_OFFSET);
WorkingAddr = (XLNX_COMPONENT_ADDRESS_TYPE)((ContextPtr->ComponentBaseAddress) + Offset);
ret_val = XLNX_Environment_Wrapper_Read32(ContextPtr->UserEnvironment.Device_IO.Read32, ContextPtr->UserContextPtr, ValuePtr, WorkingAddr);
return ret_val;
}
XLNX_ERROR_CODE XLNX_COMP_BCAM_GetCompBcamBaseHitCountHitCount(XLNX_COMP_BCAM_CONTEXT_TYPE* ContextPtr, uint32_t* HitCountPtr)
{
XLNX_ERROR_CODE ret_val = XLNX_OK;
uint32_t Offset, Mask, Shift, Buffer;
XLNX_COMPONENT_ADDRESS_TYPE WorkingAddr;
Offset = (COMP_BCAM_BASE_HIT_COUNT_REG_OFFSET);
Mask = COMP_BCAM_BASE_HIT_COUNT_HIT_COUNT_MASK;
Shift = COMP_BCAM_BASE_HIT_COUNT_HIT_COUNT_SHIFT;
WorkingAddr = (XLNX_COMPONENT_ADDRESS_TYPE)((ContextPtr->ComponentBaseAddress) + Offset);
ret_val = XLNX_Environment_Wrapper_Read32(ContextPtr->UserEnvironment.Device_IO.Read32, ContextPtr->UserContextPtr, &Buffer, WorkingAddr);
if (XLNX_OK == ret_val)
{
*HitCountPtr = ((Buffer & Mask) >> Shift);
}
return ret_val;
}
XLNX_ERROR_CODE XLNX_COMP_BCAM_GetCompBcamBaseHitCountTimerCount(XLNX_COMP_BCAM_CONTEXT_TYPE* ContextPtr, uint32_t* TimerCountPtr)
{
XLNX_ERROR_CODE ret_val = XLNX_OK;
uint32_t Offset, Mask, Shift, Buffer;
XLNX_COMPONENT_ADDRESS_TYPE WorkingAddr;
Offset = (COMP_BCAM_BASE_HIT_COUNT_REG_OFFSET);
Mask = COMP_BCAM_BASE_HIT_COUNT_TIMER_COUNT_MASK;
Shift = COMP_BCAM_BASE_HIT_COUNT_TIMER_COUNT_SHIFT;
WorkingAddr = (XLNX_COMPONENT_ADDRESS_TYPE)((ContextPtr->ComponentBaseAddress) + Offset);
ret_val = XLNX_Environment_Wrapper_Read32(ContextPtr->UserEnvironment.Device_IO.Read32, ContextPtr->UserContextPtr, &Buffer, WorkingAddr);
if (XLNX_OK == ret_val)
{
*TimerCountPtr = ((Buffer & Mask) >> Shift);
}
return ret_val;
}
XLNX_ERROR_CODE XLNX_COMP_BCAM_GetCompBcamBaseHitCountReg(XLNX_COMP_BCAM_CONTEXT_TYPE* ContextPtr, uint32_t* ValuePtr)
{
XLNX_ERROR_CODE ret_val = XLNX_OK;
uint32_t Offset;
XLNX_COMPONENT_ADDRESS_TYPE WorkingAddr;
Offset = (COMP_BCAM_BASE_HIT_COUNT_REG_OFFSET);
WorkingAddr = (XLNX_COMPONENT_ADDRESS_TYPE)((ContextPtr->ComponentBaseAddress) + Offset);
ret_val = XLNX_Environment_Wrapper_Read32(ContextPtr->UserEnvironment.Device_IO.Read32, ContextPtr->UserContextPtr, ValuePtr, WorkingAddr);
return ret_val;
}
XLNX_ERROR_CODE XLNX_COMP_BCAM_GetCompBcamBaseSbiterrCountSbiterrCount(XLNX_COMP_BCAM_CONTEXT_TYPE* ContextPtr, uint32_t* SbiterrCountPtr)
{
XLNX_ERROR_CODE ret_val = XLNX_OK;
uint32_t Offset, Mask, Shift, Buffer;
XLNX_COMPONENT_ADDRESS_TYPE WorkingAddr;
Offset = (COMP_BCAM_BASE_SBITERR_COUNT_REG_OFFSET);
Mask = COMP_BCAM_BASE_SBITERR_COUNT_SBITERR_COUNT_MASK;
Shift = COMP_BCAM_BASE_SBITERR_COUNT_SBITERR_COUNT_SHIFT;
WorkingAddr = (XLNX_COMPONENT_ADDRESS_TYPE)((ContextPtr->ComponentBaseAddress) + Offset);
ret_val = XLNX_Environment_Wrapper_Read32(ContextPtr->UserEnvironment.Device_IO.Read32, ContextPtr->UserContextPtr, &Buffer, WorkingAddr);
if (XLNX_OK == ret_val)
{
*SbiterrCountPtr = ((Buffer & Mask) >> Shift);
}
return ret_val;
}
XLNX_ERROR_CODE XLNX_COMP_BCAM_GetCompBcamBaseSbiterrCountReg(XLNX_COMP_BCAM_CONTEXT_TYPE* ContextPtr, uint32_t* ValuePtr)
{
XLNX_ERROR_CODE ret_val = XLNX_OK;
uint32_t Offset;
XLNX_COMPONENT_ADDRESS_TYPE WorkingAddr;
Offset = (COMP_BCAM_BASE_SBITERR_COUNT_REG_OFFSET);
WorkingAddr = (XLNX_COMPONENT_ADDRESS_TYPE)((ContextPtr->ComponentBaseAddress) + Offset);
ret_val = XLNX_Environment_Wrapper_Read32(ContextPtr->UserEnvironment.Device_IO.Read32, ContextPtr->UserContextPtr, ValuePtr, WorkingAddr);
return ret_val;
}
XLNX_ERROR_CODE XLNX_COMP_BCAM_GetCompBcamBaseDbiterrCountDbiterrCount(XLNX_COMP_BCAM_CONTEXT_TYPE* ContextPtr, uint32_t* DbiterrCountPtr)
{
XLNX_ERROR_CODE ret_val = XLNX_OK;
uint32_t Offset, Mask, Shift, Buffer;
XLNX_COMPONENT_ADDRESS_TYPE WorkingAddr;
Offset = (COMP_BCAM_BASE_DBITERR_COUNT_REG_OFFSET);
Mask = COMP_BCAM_BASE_DBITERR_COUNT_DBITERR_COUNT_MASK;
Shift = COMP_BCAM_BASE_DBITERR_COUNT_DBITERR_COUNT_SHIFT;
WorkingAddr = (XLNX_COMPONENT_ADDRESS_TYPE)((ContextPtr->ComponentBaseAddress) + Offset);
ret_val = XLNX_Environment_Wrapper_Read32(ContextPtr->UserEnvironment.Device_IO.Read32, ContextPtr->UserContextPtr, &Buffer, WorkingAddr);
if (XLNX_OK == ret_val)
{
*DbiterrCountPtr = ((Buffer & Mask) >> Shift);
}
return ret_val;
}
XLNX_ERROR_CODE XLNX_COMP_BCAM_GetCompBcamBaseDbiterrCountReg(XLNX_COMP_BCAM_CONTEXT_TYPE* ContextPtr, uint32_t* ValuePtr)
{
XLNX_ERROR_CODE ret_val = XLNX_OK;
uint32_t Offset;
XLNX_COMPONENT_ADDRESS_TYPE WorkingAddr;
Offset = (COMP_BCAM_BASE_DBITERR_COUNT_REG_OFFSET);
WorkingAddr = (XLNX_COMPONENT_ADDRESS_TYPE)((ContextPtr->ComponentBaseAddress) + Offset);
ret_val = XLNX_Environment_Wrapper_Read32(ContextPtr->UserEnvironment.Device_IO.Read32, ContextPtr->UserContextPtr, ValuePtr, WorkingAddr);
return ret_val;
}
XLNX_ERROR_CODE XLNX_COMP_BCAM_GetCompBcamBaseExtEventCountExtEventCount(XLNX_COMP_BCAM_CONTEXT_TYPE* ContextPtr, uint32_t* ExtEventCountPtr)
{
XLNX_ERROR_CODE ret_val = XLNX_OK;
uint32_t Offset, Mask, Shift, Buffer;
XLNX_COMPONENT_ADDRESS_TYPE WorkingAddr;
Offset = (COMP_BCAM_BASE_EXT_EVENT_COUNT_REG_OFFSET);
Mask = COMP_BCAM_BASE_EXT_EVENT_COUNT_EXT_EVENT_COUNT_MASK;
Shift = COMP_BCAM_BASE_EXT_EVENT_COUNT_EXT_EVENT_COUNT_SHIFT;
WorkingAddr = (XLNX_COMPONENT_ADDRESS_TYPE)((ContextPtr->ComponentBaseAddress) + Offset);
ret_val = XLNX_Environment_Wrapper_Read32(ContextPtr->UserEnvironment.Device_IO.Read32, ContextPtr->UserContextPtr, &Buffer, WorkingAddr);
if (XLNX_OK == ret_val)
{
*ExtEventCountPtr = ((Buffer & Mask) >> Shift);
}
return ret_val;
}
XLNX_ERROR_CODE XLNX_COMP_BCAM_GetCompBcamBaseExtEventCountTimerCount(XLNX_COMP_BCAM_CONTEXT_TYPE* ContextPtr, uint32_t* TimerCountPtr)
{
XLNX_ERROR_CODE ret_val = XLNX_OK;
uint32_t Offset, Mask, Shift, Buffer;
XLNX_COMPONENT_ADDRESS_TYPE WorkingAddr;
Offset = (COMP_BCAM_BASE_EXT_EVENT_COUNT_REG_OFFSET);
Mask = COMP_BCAM_BASE_EXT_EVENT_COUNT_TIMER_COUNT_MASK;
Shift = COMP_BCAM_BASE_EXT_EVENT_COUNT_TIMER_COUNT_SHIFT;
WorkingAddr = (XLNX_COMPONENT_ADDRESS_TYPE)((ContextPtr->ComponentBaseAddress) + Offset);
ret_val = XLNX_Environment_Wrapper_Read32(ContextPtr->UserEnvironment.Device_IO.Read32, ContextPtr->UserContextPtr, &Buffer, WorkingAddr);
if (XLNX_OK == ret_val)
{
*TimerCountPtr = ((Buffer & Mask) >> Shift);
}
return ret_val;
}
XLNX_ERROR_CODE XLNX_COMP_BCAM_GetCompBcamBaseExtEventCountReg(XLNX_COMP_BCAM_CONTEXT_TYPE* ContextPtr, uint32_t* ValuePtr)
{
XLNX_ERROR_CODE ret_val = XLNX_OK;
uint32_t Offset;
XLNX_COMPONENT_ADDRESS_TYPE WorkingAddr;
Offset = (COMP_BCAM_BASE_EXT_EVENT_COUNT_REG_OFFSET);
WorkingAddr = (XLNX_COMPONENT_ADDRESS_TYPE)((ContextPtr->ComponentBaseAddress) + Offset);
ret_val = XLNX_Environment_Wrapper_Read32(ContextPtr->UserEnvironment.Device_IO.Read32, ContextPtr->UserContextPtr, ValuePtr, WorkingAddr);
return ret_val;
}
XLNX_ERROR_CODE XLNX_COMP_BCAM_GetCompBcamBaseLiReqWsCountLiReqWsCount(XLNX_COMP_BCAM_CONTEXT_TYPE* ContextPtr, uint32_t* LiReqWsCountPtr)
{
XLNX_ERROR_CODE ret_val = XLNX_OK;
uint32_t Offset, Mask, Shift, Buffer;
XLNX_COMPONENT_ADDRESS_TYPE WorkingAddr;
Offset = (COMP_BCAM_BASE_LI_REQ_WS_COUNT_REG_OFFSET);
Mask = COMP_BCAM_BASE_LI_REQ_WS_COUNT_LI_REQ_WS_COUNT_MASK;
Shift = COMP_BCAM_BASE_LI_REQ_WS_COUNT_LI_REQ_WS_COUNT_SHIFT;
WorkingAddr = (XLNX_COMPONENT_ADDRESS_TYPE)((ContextPtr->ComponentBaseAddress) + Offset);
ret_val = XLNX_Environment_Wrapper_Read32(ContextPtr->UserEnvironment.Device_IO.Read32, ContextPtr->UserContextPtr, &Buffer, WorkingAddr);
if (XLNX_OK == ret_val)
{
*LiReqWsCountPtr = ((Buffer & Mask) >> Shift);
}
return ret_val;
}
XLNX_ERROR_CODE XLNX_COMP_BCAM_GetCompBcamBaseLiReqWsCountTimerCount(XLNX_COMP_BCAM_CONTEXT_TYPE* ContextPtr, uint32_t* TimerCountPtr)
{
XLNX_ERROR_CODE ret_val = XLNX_OK;
uint32_t Offset, Mask, Shift, Buffer;
XLNX_COMPONENT_ADDRESS_TYPE WorkingAddr;
Offset = (COMP_BCAM_BASE_LI_REQ_WS_COUNT_REG_OFFSET);
Mask = COMP_BCAM_BASE_LI_REQ_WS_COUNT_TIMER_COUNT_MASK;
Shift = COMP_BCAM_BASE_LI_REQ_WS_COUNT_TIMER_COUNT_SHIFT;
WorkingAddr = (XLNX_COMPONENT_ADDRESS_TYPE)((ContextPtr->ComponentBaseAddress) + Offset);
ret_val = XLNX_Environment_Wrapper_Read32(ContextPtr->UserEnvironment.Device_IO.Read32, ContextPtr->UserContextPtr, &Buffer, WorkingAddr);
if (XLNX_OK == ret_val)
{
*TimerCountPtr = ((Buffer & Mask) >> Shift);
}
return ret_val;
}
XLNX_ERROR_CODE XLNX_COMP_BCAM_GetCompBcamBaseLiReqWsCountReg(XLNX_COMP_BCAM_CONTEXT_TYPE* ContextPtr, uint32_t* ValuePtr)
{
XLNX_ERROR_CODE ret_val = XLNX_OK;
uint32_t Offset;
XLNX_COMPONENT_ADDRESS_TYPE WorkingAddr;
Offset = (COMP_BCAM_BASE_LI_REQ_WS_COUNT_REG_OFFSET);
WorkingAddr = (XLNX_COMPONENT_ADDRESS_TYPE)((ContextPtr->ComponentBaseAddress) + Offset);
ret_val = XLNX_Environment_Wrapper_Read32(ContextPtr->UserEnvironment.Device_IO.Read32, ContextPtr->UserContextPtr, ValuePtr, WorkingAddr);
return ret_val;
}
XLNX_ERROR_CODE XLNX_COMP_BCAM_GetCompBcamBaseTotalNumPassesLoTotalNumPassesLo(XLNX_COMP_BCAM_CONTEXT_TYPE* ContextPtr,
uint32_t* TotalNumPassesLoPtr)
{
XLNX_ERROR_CODE ret_val = XLNX_OK;
uint32_t Offset, Mask, Shift, Buffer;
XLNX_COMPONENT_ADDRESS_TYPE WorkingAddr;
Offset = (COMP_BCAM_BASE_TOTAL_NUM_PASSES_LO_REG_OFFSET);
Mask = COMP_BCAM_BASE_TOTAL_NUM_PASSES_LO_TOTAL_NUM_PASSES_LO_MASK;
Shift = COMP_BCAM_BASE_TOTAL_NUM_PASSES_LO_TOTAL_NUM_PASSES_LO_SHIFT;
WorkingAddr = (XLNX_COMPONENT_ADDRESS_TYPE)((ContextPtr->ComponentBaseAddress) + Offset);
ret_val = XLNX_Environment_Wrapper_Read32(ContextPtr->UserEnvironment.Device_IO.Read32, ContextPtr->UserContextPtr, &Buffer, WorkingAddr);
if (XLNX_OK == ret_val)
{
*TotalNumPassesLoPtr = ((Buffer & Mask) >> Shift);
}
return ret_val;
}
XLNX_ERROR_CODE XLNX_COMP_BCAM_GetCompBcamBaseTotalNumPassesLoReg(XLNX_COMP_BCAM_CONTEXT_TYPE* ContextPtr, uint32_t* ValuePtr)
{
XLNX_ERROR_CODE ret_val = XLNX_OK;
uint32_t Offset;
XLNX_COMPONENT_ADDRESS_TYPE WorkingAddr;
Offset = (COMP_BCAM_BASE_TOTAL_NUM_PASSES_LO_REG_OFFSET);
WorkingAddr = (XLNX_COMPONENT_ADDRESS_TYPE)((ContextPtr->ComponentBaseAddress) + Offset);
ret_val = XLNX_Environment_Wrapper_Read32(ContextPtr->UserEnvironment.Device_IO.Read32, ContextPtr->UserContextPtr, ValuePtr, WorkingAddr);
return ret_val;
}
XLNX_ERROR_CODE XLNX_COMP_BCAM_GetCompBcamBaseTotalNumPassesHiTotalNumPassesHi(XLNX_COMP_BCAM_CONTEXT_TYPE* ContextPtr,
uint32_t* TotalNumPassesHiPtr)
{
XLNX_ERROR_CODE ret_val = XLNX_OK;
uint32_t Offset, Mask, Shift, Buffer;
XLNX_COMPONENT_ADDRESS_TYPE WorkingAddr;
Offset = (COMP_BCAM_BASE_TOTAL_NUM_PASSES_HI_REG_OFFSET);
Mask = COMP_BCAM_BASE_TOTAL_NUM_PASSES_HI_TOTAL_NUM_PASSES_HI_MASK;
Shift = COMP_BCAM_BASE_TOTAL_NUM_PASSES_HI_TOTAL_NUM_PASSES_HI_SHIFT;
WorkingAddr = (XLNX_COMPONENT_ADDRESS_TYPE)((ContextPtr->ComponentBaseAddress) + Offset);
ret_val = XLNX_Environment_Wrapper_Read32(ContextPtr->UserEnvironment.Device_IO.Read32, ContextPtr->UserContextPtr, &Buffer, WorkingAddr);
if (XLNX_OK == ret_val)
{
*TotalNumPassesHiPtr = ((Buffer & Mask) >> Shift);
}
return ret_val;
}
XLNX_ERROR_CODE XLNX_COMP_BCAM_GetCompBcamBaseTotalNumPassesHiReg(XLNX_COMP_BCAM_CONTEXT_TYPE* ContextPtr, uint32_t* ValuePtr)
{
XLNX_ERROR_CODE ret_val = XLNX_OK;
uint32_t Offset;
XLNX_COMPONENT_ADDRESS_TYPE WorkingAddr;
Offset = (COMP_BCAM_BASE_TOTAL_NUM_PASSES_HI_REG_OFFSET);
WorkingAddr = (XLNX_COMPONENT_ADDRESS_TYPE)((ContextPtr->ComponentBaseAddress) + Offset);
ret_val = XLNX_Environment_Wrapper_Read32(ContextPtr->UserEnvironment.Device_IO.Read32, ContextPtr->UserContextPtr, ValuePtr, WorkingAddr);
return ret_val;
}
XLNX_ERROR_CODE XLNX_COMP_BCAM_GetCompBcamBaseLastDetNumPassesLastDetNumPasses(XLNX_COMP_BCAM_CONTEXT_TYPE* ContextPtr,
uint32_t* LastDetNumPassesPtr)
{
XLNX_ERROR_CODE ret_val = XLNX_OK;
uint32_t Offset, Mask, Shift, Buffer;
XLNX_COMPONENT_ADDRESS_TYPE WorkingAddr;
Offset = (COMP_BCAM_BASE_LAST_DET_NUM_PASSES_REG_OFFSET);
Mask = COMP_BCAM_BASE_LAST_DET_NUM_PASSES_LAST_DET_NUM_PASSES_MASK;
Shift = COMP_BCAM_BASE_LAST_DET_NUM_PASSES_LAST_DET_NUM_PASSES_SHIFT;
WorkingAddr = (XLNX_COMPONENT_ADDRESS_TYPE)((ContextPtr->ComponentBaseAddress) + Offset);
ret_val = XLNX_Environment_Wrapper_Read32(ContextPtr->UserEnvironment.Device_IO.Read32, ContextPtr->UserContextPtr, &Buffer, WorkingAddr);
if (XLNX_OK == ret_val)
{
*LastDetNumPassesPtr = ((Buffer & Mask) >> Shift);
}
return ret_val;
}
XLNX_ERROR_CODE XLNX_COMP_BCAM_GetCompBcamBaseLastDetNumPassesReg(XLNX_COMP_BCAM_CONTEXT_TYPE* ContextPtr, uint32_t* ValuePtr)
{
XLNX_ERROR_CODE ret_val = XLNX_OK;
uint32_t Offset;
XLNX_COMPONENT_ADDRESS_TYPE WorkingAddr;
Offset = (COMP_BCAM_BASE_LAST_DET_NUM_PASSES_REG_OFFSET);
WorkingAddr = (XLNX_COMPONENT_ADDRESS_TYPE)((ContextPtr->ComponentBaseAddress) + Offset);
ret_val = XLNX_Environment_Wrapper_Read32(ContextPtr->UserEnvironment.Device_IO.Read32, ContextPtr->UserContextPtr, ValuePtr, WorkingAddr);
return ret_val;
}
XLNX_ERROR_CODE XLNX_COMP_BCAM_GetCompBcamBaseMaxDetNumPassesMaxDetNumPasses(XLNX_COMP_BCAM_CONTEXT_TYPE* ContextPtr, uint32_t* MaxDetNumPassesPtr)
{
XLNX_ERROR_CODE ret_val = XLNX_OK;
uint32_t Offset, Mask, Shift, Buffer;
XLNX_COMPONENT_ADDRESS_TYPE WorkingAddr;
Offset = (COMP_BCAM_BASE_MAX_DET_NUM_PASSES_REG_OFFSET);
Mask = COMP_BCAM_BASE_MAX_DET_NUM_PASSES_MAX_DET_NUM_PASSES_MASK;
Shift = COMP_BCAM_BASE_MAX_DET_NUM_PASSES_MAX_DET_NUM_PASSES_SHIFT;
WorkingAddr = (XLNX_COMPONENT_ADDRESS_TYPE)((ContextPtr->ComponentBaseAddress) + Offset);
ret_val = XLNX_Environment_Wrapper_Read32(ContextPtr->UserEnvironment.Device_IO.Read32, ContextPtr->UserContextPtr, &Buffer, WorkingAddr);
if (XLNX_OK == ret_val)
{
*MaxDetNumPassesPtr = ((Buffer & Mask) >> Shift);
}
return ret_val;
}
XLNX_ERROR_CODE XLNX_COMP_BCAM_GetCompBcamBaseMaxDetNumPassesReg(XLNX_COMP_BCAM_CONTEXT_TYPE* ContextPtr, uint32_t* ValuePtr)
{
XLNX_ERROR_CODE ret_val = XLNX_OK;
uint32_t Offset;
XLNX_COMPONENT_ADDRESS_TYPE WorkingAddr;
Offset = (COMP_BCAM_BASE_MAX_DET_NUM_PASSES_REG_OFFSET);
WorkingAddr = (XLNX_COMPONENT_ADDRESS_TYPE)((ContextPtr->ComponentBaseAddress) + Offset);
ret_val = XLNX_Environment_Wrapper_Read32(ContextPtr->UserEnvironment.Device_IO.Read32, ContextPtr->UserContextPtr, ValuePtr, WorkingAddr);
return ret_val;
}
XLNX_ERROR_CODE XLNX_COMP_BCAM_SetCompBcamBaseFreezeCountersFreezeCounters(XLNX_COMP_BCAM_CONTEXT_TYPE* ContextPtr, uint32_t FreezeCounters)
{
XLNX_ERROR_CODE ret_val = XLNX_OK;
uint32_t Offset, Mask, Shift, Buffer;
XLNX_COMPONENT_ADDRESS_TYPE WorkingAddr;
Offset = (COMP_BCAM_BASE_FREEZE_COUNTERS_REG_OFFSET);
Mask = COMP_BCAM_BASE_FREEZE_COUNTERS_FREEZE_COUNTERS_MASK;
Shift = COMP_BCAM_BASE_FREEZE_COUNTERS_FREEZE_COUNTERS_SHIFT;
WorkingAddr = (XLNX_COMPONENT_ADDRESS_TYPE)((ContextPtr->ComponentBaseAddress) + Offset);
Buffer = (FreezeCounters << Shift);
ret_val = XLNX_Environment_Wrapper_Write32_WithMask(ContextPtr->UserEnvironment.Device_IO.Write32WithMask, ContextPtr->UserContextPtr, WorkingAddr, Buffer, Mask);
return ret_val;
}
void XLNX_COMP_BCAM_BuildCompBcamBaseFreezeCountersFreezeCounters(uint32_t* MaskPtr, uint32_t* ValPtr, uint32_t FreezeCounters)
{
*MaskPtr |= COMP_BCAM_BASE_FREEZE_COUNTERS_FREEZE_COUNTERS_MASK;
*ValPtr |= (FreezeCounters << COMP_BCAM_BASE_FREEZE_COUNTERS_FREEZE_COUNTERS_SHIFT);
}
XLNX_ERROR_CODE XLNX_COMP_BCAM_GetCompBcamBaseFreezeCountersFreezeCounters(XLNX_COMP_BCAM_CONTEXT_TYPE* ContextPtr, uint32_t* FreezeCountersPtr)
{
XLNX_ERROR_CODE ret_val = XLNX_OK;
uint32_t Offset, Mask, Shift, Buffer;
XLNX_COMPONENT_ADDRESS_TYPE WorkingAddr;
Offset = (COMP_BCAM_BASE_FREEZE_COUNTERS_REG_OFFSET);
Mask = COMP_BCAM_BASE_FREEZE_COUNTERS_FREEZE_COUNTERS_MASK;
Shift = COMP_BCAM_BASE_FREEZE_COUNTERS_FREEZE_COUNTERS_SHIFT;
WorkingAddr = (XLNX_COMPONENT_ADDRESS_TYPE)((ContextPtr->ComponentBaseAddress) + Offset);
ret_val = XLNX_Environment_Wrapper_Read32(ContextPtr->UserEnvironment.Device_IO.Read32, ContextPtr->UserContextPtr, &Buffer, WorkingAddr);
if (XLNX_OK == ret_val)
{
*FreezeCountersPtr = ((Buffer & Mask) >> Shift);
}
return ret_val;
}
XLNX_ERROR_CODE XLNX_COMP_BCAM_SetCompBcamBaseFreezeCountersReg(XLNX_COMP_BCAM_CONTEXT_TYPE* ContextPtr, uint32_t Mask, uint32_t Value)
{
XLNX_ERROR_CODE ret_val = XLNX_OK;
uint32_t Offset;
XLNX_COMPONENT_ADDRESS_TYPE WorkingAddr;
Offset = (COMP_BCAM_BASE_FREEZE_COUNTERS_REG_OFFSET);
WorkingAddr = (XLNX_COMPONENT_ADDRESS_TYPE)((ContextPtr->ComponentBaseAddress) + Offset);
ret_val = XLNX_Environment_Wrapper_Write32_WithMask(ContextPtr->UserEnvironment.Device_IO.Write32WithMask, ContextPtr->UserContextPtr, WorkingAddr, Value, Mask);
return ret_val;
}
XLNX_ERROR_CODE XLNX_COMP_BCAM_SetCompBcamBaseFreezeCountersOperationReg(const XLNX_COMP_BCAM_CONTEXT_TYPE* ContextPtr, uint32_t Value)
{
XLNX_ERROR_CODE ret_val = XLNX_OK;
uint32_t Offset;
uint32_t WorkingAddr;
Offset = (COMP_BCAM_BASE_FREEZE_COUNTERS_REG_OFFSET);
WorkingAddr = (XLNX_COMPONENT_ADDRESS_TYPE) ((ContextPtr->ComponentBaseAddress) + Offset);
ContextPtr->UserEnvironment.Device_IO.Write32(ContextPtr->UserContextPtr, WorkingAddr, Value);
return ret_val;
}
XLNX_ERROR_CODE XLNX_COMP_BCAM_GetCompBcamBaseFreezeCountersReg(XLNX_COMP_BCAM_CONTEXT_TYPE* ContextPtr, uint32_t* ValuePtr)
{
XLNX_ERROR_CODE ret_val = XLNX_OK;
uint32_t Offset;
XLNX_COMPONENT_ADDRESS_TYPE WorkingAddr;
Offset = (COMP_BCAM_BASE_FREEZE_COUNTERS_REG_OFFSET);
WorkingAddr = (XLNX_COMPONENT_ADDRESS_TYPE)((ContextPtr->ComponentBaseAddress) + Offset);
ret_val = XLNX_Environment_Wrapper_Read32(ContextPtr->UserEnvironment.Device_IO.Read32, ContextPtr->UserContextPtr, ValuePtr, WorkingAddr);
return ret_val;
}
XLNX_ERROR_CODE XLNX_COMP_BCAM_SetCompBcamBaseIndirectAddrIndirectAddr(const XLNX_COMP_BCAM_CONTEXT_TYPE* ContextPtr, uint32_t IndirectAddr)
{
XLNX_ERROR_CODE ret_val = XLNX_OK;
uint32_t Offset, Mask, Shift, Buffer;
XLNX_COMPONENT_ADDRESS_TYPE WorkingAddr;
Offset = (COMP_BCAM_BASE_INDIRECT_ADDR_REG_OFFSET);
Mask = COMP_BCAM_BASE_INDIRECT_ADDR_INDIRECT_ADDR_MASK;
Shift = COMP_BCAM_BASE_INDIRECT_ADDR_INDIRECT_ADDR_SHIFT;
WorkingAddr = (XLNX_COMPONENT_ADDRESS_TYPE)((ContextPtr->ComponentBaseAddress) + Offset);
Buffer = (IndirectAddr << Shift);
ret_val = XLNX_Environment_Wrapper_Write32_WithMask(ContextPtr->UserEnvironment.Device_IO.Write32WithMask, ContextPtr->UserContextPtr, WorkingAddr, Buffer, Mask);
return ret_val;
}
void XLNX_COMP_BCAM_BuildCompBcamBaseIndirectAddrIndirectAddr(uint32_t* MaskPtr, uint32_t* ValPtr, uint32_t IndirectAddr)
{
*MaskPtr |= COMP_BCAM_BASE_INDIRECT_ADDR_INDIRECT_ADDR_MASK;
*ValPtr |= (IndirectAddr << COMP_BCAM_BASE_INDIRECT_ADDR_INDIRECT_ADDR_SHIFT);
}
XLNX_ERROR_CODE XLNX_COMP_BCAM_GetCompBcamBaseIndirectAddrIndirectAddr(XLNX_COMP_BCAM_CONTEXT_TYPE* ContextPtr, uint32_t* IndirectAddrPtr)
{
XLNX_ERROR_CODE ret_val = XLNX_OK;
uint32_t Offset, Mask, Shift, Buffer;
XLNX_COMPONENT_ADDRESS_TYPE WorkingAddr;
Offset = (COMP_BCAM_BASE_INDIRECT_ADDR_REG_OFFSET);
Mask = COMP_BCAM_BASE_INDIRECT_ADDR_INDIRECT_ADDR_MASK;
Shift = COMP_BCAM_BASE_INDIRECT_ADDR_INDIRECT_ADDR_SHIFT;
WorkingAddr = (XLNX_COMPONENT_ADDRESS_TYPE)((ContextPtr->ComponentBaseAddress) + Offset);
ret_val = XLNX_Environment_Wrapper_Read32(ContextPtr->UserEnvironment.Device_IO.Read32, ContextPtr->UserContextPtr, &Buffer, WorkingAddr);
if (XLNX_OK == ret_val)
{
*IndirectAddrPtr = ((Buffer & Mask) >> Shift);
}
return ret_val;
}
XLNX_ERROR_CODE XLNX_COMP_BCAM_SetCompBcamBaseIndirectAddrReg(const XLNX_COMP_BCAM_CONTEXT_TYPE* ContextPtr, uint32_t Value)
{
XLNX_ERROR_CODE ret_val = XLNX_OK;
uint32_t Offset;
XLNX_COMPONENT_ADDRESS_TYPE WorkingAddr;
Offset = (COMP_BCAM_BASE_INDIRECT_ADDR_REG_OFFSET);
WorkingAddr = (XLNX_COMPONENT_ADDRESS_TYPE)((ContextPtr->ComponentBaseAddress) + Offset);
ret_val = XLNX_Environment_Wrapper_Write32(ContextPtr->UserEnvironment.Device_IO.Write32, ContextPtr->UserContextPtr, WorkingAddr, Value);
return ret_val;
}
XLNX_ERROR_CODE XLNX_COMP_BCAM_GetCompBcamBaseIndirectAddrReg(XLNX_COMP_BCAM_CONTEXT_TYPE* ContextPtr, uint32_t* ValuePtr)
{
XLNX_ERROR_CODE ret_val = XLNX_OK;
uint32_t Offset;
XLNX_COMPONENT_ADDRESS_TYPE WorkingAddr;
Offset = (COMP_BCAM_BASE_INDIRECT_ADDR_REG_OFFSET);
WorkingAddr = (XLNX_COMPONENT_ADDRESS_TYPE)((ContextPtr->ComponentBaseAddress) + Offset);
ret_val = XLNX_Environment_Wrapper_Read32(ContextPtr->UserEnvironment.Device_IO.Read32, ContextPtr->UserContextPtr, ValuePtr, WorkingAddr);
return ret_val;
}
XLNX_ERROR_CODE XLNX_COMP_BCAM_GetCompBcamBaseIndirectRdData00IndirectRdData00(const XLNX_COMP_BCAM_CONTEXT_TYPE* ContextPtr,
uint32_t* IndirectRdData00Ptr)
{
XLNX_ERROR_CODE ret_val = XLNX_OK;
uint32_t Offset, Mask, Shift, Buffer;
XLNX_COMPONENT_ADDRESS_TYPE WorkingAddr;
Offset = (COMP_BCAM_BASE_INDIRECT_RD_DATA_00_REG_OFFSET);
Mask = COMP_BCAM_BASE_INDIRECT_RD_DATA_00_INDIRECT_RD_DATA_00_MASK;
Shift = COMP_BCAM_BASE_INDIRECT_RD_DATA_00_INDIRECT_RD_DATA_00_SHIFT;
WorkingAddr = (XLNX_COMPONENT_ADDRESS_TYPE)((ContextPtr->ComponentBaseAddress) + Offset);
ret_val = XLNX_Environment_Wrapper_Read32(ContextPtr->UserEnvironment.Device_IO.Read32, ContextPtr->UserContextPtr, &Buffer, WorkingAddr);
if (XLNX_OK == ret_val)
{
*IndirectRdData00Ptr = ((Buffer & Mask) >> Shift);
}
return ret_val;
}
XLNX_ERROR_CODE XLNX_COMP_BCAM_GetCompBcamBaseIndirectRdData00Reg(const XLNX_COMP_BCAM_CONTEXT_TYPE* ContextPtr, uint32_t* ValuePtr)
{
XLNX_ERROR_CODE ret_val = XLNX_OK;
uint32_t Offset;
XLNX_COMPONENT_ADDRESS_TYPE WorkingAddr;
Offset = (COMP_BCAM_BASE_INDIRECT_RD_DATA_00_REG_OFFSET);
WorkingAddr = (XLNX_COMPONENT_ADDRESS_TYPE)((ContextPtr->ComponentBaseAddress) + Offset);
ret_val = XLNX_Environment_Wrapper_Read32(ContextPtr->UserEnvironment.Device_IO.Read32, ContextPtr->UserContextPtr, ValuePtr, WorkingAddr);
return ret_val;
}
XLNX_ERROR_CODE XLNX_COMP_BCAM_SetCompBcamBaseIndirectWrData00IndirectWrData00(XLNX_COMP_BCAM_CONTEXT_TYPE* ContextPtr, uint32_t IndirectWrData00)
{
XLNX_ERROR_CODE ret_val = XLNX_OK;
uint32_t Offset, Mask, Shift, Buffer;
XLNX_COMPONENT_ADDRESS_TYPE WorkingAddr;
Offset = (COMP_BCAM_BASE_INDIRECT_WR_DATA_00_REG_OFFSET);
Mask = COMP_BCAM_BASE_INDIRECT_WR_DATA_00_INDIRECT_WR_DATA_00_MASK;
Shift = COMP_BCAM_BASE_INDIRECT_WR_DATA_00_INDIRECT_WR_DATA_00_SHIFT;
WorkingAddr = (XLNX_COMPONENT_ADDRESS_TYPE)((ContextPtr->ComponentBaseAddress) + Offset);
Buffer = (IndirectWrData00 << Shift);
ret_val = XLNX_Environment_Wrapper_Write32_WithMask(ContextPtr->UserEnvironment.Device_IO.Write32WithMask, ContextPtr->UserContextPtr, WorkingAddr, Buffer, Mask);
return ret_val;
}
void XLNX_COMP_BCAM_BuildCompBcamBaseIndirectWrData00IndirectWrData00(uint32_t* MaskPtr, uint32_t* ValPtr, uint32_t IndirectWrData00)
{
*MaskPtr |= COMP_BCAM_BASE_INDIRECT_WR_DATA_00_INDIRECT_WR_DATA_00_MASK;
*ValPtr |= (IndirectWrData00 << COMP_BCAM_BASE_INDIRECT_WR_DATA_00_INDIRECT_WR_DATA_00_SHIFT);
}
XLNX_ERROR_CODE XLNX_COMP_BCAM_GetCompBcamBaseIndirectWrData00IndirectWrData00(XLNX_COMP_BCAM_CONTEXT_TYPE* ContextPtr,
uint32_t* IndirectWrData00Ptr)
{
XLNX_ERROR_CODE ret_val = XLNX_OK;
uint32_t Offset, Mask, Shift, Buffer;
XLNX_COMPONENT_ADDRESS_TYPE WorkingAddr;
Offset = (COMP_BCAM_BASE_INDIRECT_WR_DATA_00_REG_OFFSET);
Mask = COMP_BCAM_BASE_INDIRECT_WR_DATA_00_INDIRECT_WR_DATA_00_MASK;
Shift = COMP_BCAM_BASE_INDIRECT_WR_DATA_00_INDIRECT_WR_DATA_00_SHIFT;
WorkingAddr = (XLNX_COMPONENT_ADDRESS_TYPE)((ContextPtr->ComponentBaseAddress) + Offset);
ret_val = XLNX_Environment_Wrapper_Read32(ContextPtr->UserEnvironment.Device_IO.Read32, ContextPtr->UserContextPtr, &Buffer, WorkingAddr);
if (XLNX_OK == ret_val)
{
*IndirectWrData00Ptr = ((Buffer & Mask) >> Shift);
}
return ret_val;
}
XLNX_ERROR_CODE XLNX_COMP_BCAM_SetCompBcamBaseIndirectWrData00Reg(XLNX_COMP_BCAM_CONTEXT_TYPE* ContextPtr, uint32_t Mask, uint32_t Value)
{
XLNX_ERROR_CODE ret_val = XLNX_OK;
uint32_t Offset;
XLNX_COMPONENT_ADDRESS_TYPE WorkingAddr;
Offset = (COMP_BCAM_BASE_INDIRECT_WR_DATA_00_REG_OFFSET);
WorkingAddr = (XLNX_COMPONENT_ADDRESS_TYPE)((ContextPtr->ComponentBaseAddress) + Offset);
ret_val = XLNX_Environment_Wrapper_Write32_WithMask(ContextPtr->UserEnvironment.Device_IO.Write32WithMask, ContextPtr->UserContextPtr, WorkingAddr, Value, Mask);
return ret_val;
}
XLNX_ERROR_CODE XLNX_COMP_BCAM_GetCompBcamBaseIndirectWrData00Reg(XLNX_COMP_BCAM_CONTEXT_TYPE* ContextPtr, uint32_t* ValuePtr)
{
XLNX_ERROR_CODE ret_val = XLNX_OK;
uint32_t Offset;
XLNX_COMPONENT_ADDRESS_TYPE WorkingAddr;
Offset = (COMP_BCAM_BASE_INDIRECT_WR_DATA_00_REG_OFFSET);
WorkingAddr = (XLNX_COMPONENT_ADDRESS_TYPE)((ContextPtr->ComponentBaseAddress) + Offset);
ret_val = XLNX_Environment_Wrapper_Read32(ContextPtr->UserEnvironment.Device_IO.Read32, ContextPtr->UserContextPtr, ValuePtr, WorkingAddr);
return ret_val;
}
XLNX_ERROR_CODE XLNX_COMP_BCAM_SetCompBcamBaseIndirectWrData01IndirectWrData01(XLNX_COMP_BCAM_CONTEXT_TYPE* ContextPtr, uint32_t IndirectWrData01)
{
XLNX_ERROR_CODE ret_val = XLNX_OK;
uint32_t Offset, Mask, Shift, Buffer;
XLNX_COMPONENT_ADDRESS_TYPE WorkingAddr;
Offset = (COMP_BCAM_BASE_INDIRECT_WR_DATA_01_REG_OFFSET);
Mask = COMP_BCAM_BASE_INDIRECT_WR_DATA_01_INDIRECT_WR_DATA_01_MASK;
Shift = COMP_BCAM_BASE_INDIRECT_WR_DATA_01_INDIRECT_WR_DATA_01_SHIFT;
WorkingAddr = (XLNX_COMPONENT_ADDRESS_TYPE)((ContextPtr->ComponentBaseAddress) + Offset);
Buffer = (IndirectWrData01 << Shift);
ret_val = XLNX_Environment_Wrapper_Write32_WithMask(ContextPtr->UserEnvironment.Device_IO.Write32WithMask, ContextPtr->UserContextPtr, WorkingAddr, Buffer, Mask);
return ret_val;
}
void XLNX_COMP_BCAM_BuildCompBcamBaseIndirectWrData01IndirectWrData01(uint32_t* MaskPtr, uint32_t* ValPtr, uint32_t IndirectWrData01)
{
*MaskPtr |= COMP_BCAM_BASE_INDIRECT_WR_DATA_01_INDIRECT_WR_DATA_01_MASK;
*ValPtr |= (IndirectWrData01 << COMP_BCAM_BASE_INDIRECT_WR_DATA_01_INDIRECT_WR_DATA_01_SHIFT);
}
XLNX_ERROR_CODE XLNX_COMP_BCAM_GetCompBcamBaseIndirectWrData01IndirectWrData01(XLNX_COMP_BCAM_CONTEXT_TYPE* ContextPtr,
uint32_t* IndirectWrData01Ptr)
{
XLNX_ERROR_CODE ret_val = XLNX_OK;
uint32_t Offset, Mask, Shift, Buffer;
XLNX_COMPONENT_ADDRESS_TYPE WorkingAddr;
Offset = (COMP_BCAM_BASE_INDIRECT_WR_DATA_01_REG_OFFSET);
Mask = COMP_BCAM_BASE_INDIRECT_WR_DATA_01_INDIRECT_WR_DATA_01_MASK;
Shift = COMP_BCAM_BASE_INDIRECT_WR_DATA_01_INDIRECT_WR_DATA_01_SHIFT;
WorkingAddr = (XLNX_COMPONENT_ADDRESS_TYPE)((ContextPtr->ComponentBaseAddress) + Offset);
ret_val = XLNX_Environment_Wrapper_Read32(ContextPtr->UserEnvironment.Device_IO.Read32, ContextPtr->UserContextPtr, &Buffer, WorkingAddr);
if (XLNX_OK == ret_val)
{
*IndirectWrData01Ptr = ((Buffer & Mask) >> Shift);
}
return ret_val;
}
XLNX_ERROR_CODE XLNX_COMP_BCAM_SetCompBcamBaseIndirectWrData01Reg(XLNX_COMP_BCAM_CONTEXT_TYPE* ContextPtr, uint32_t Mask, uint32_t Value)
{
XLNX_ERROR_CODE ret_val = XLNX_OK;
uint32_t Offset;
XLNX_COMPONENT_ADDRESS_TYPE WorkingAddr;
Offset = (COMP_BCAM_BASE_INDIRECT_WR_DATA_01_REG_OFFSET);
WorkingAddr = (XLNX_COMPONENT_ADDRESS_TYPE)((ContextPtr->ComponentBaseAddress) + Offset);
ret_val = XLNX_Environment_Wrapper_Write32_WithMask(ContextPtr->UserEnvironment.Device_IO.Write32WithMask, ContextPtr->UserContextPtr, WorkingAddr, Value, Mask);
return ret_val;
}
XLNX_ERROR_CODE XLNX_COMP_BCAM_GetCompBcamBaseIndirectWrData01Reg(XLNX_COMP_BCAM_CONTEXT_TYPE* ContextPtr, uint32_t* ValuePtr)
{
XLNX_ERROR_CODE ret_val = XLNX_OK;
uint32_t Offset;
XLNX_COMPONENT_ADDRESS_TYPE WorkingAddr;
Offset = (COMP_BCAM_BASE_INDIRECT_WR_DATA_01_REG_OFFSET);
WorkingAddr = (XLNX_COMPONENT_ADDRESS_TYPE)((ContextPtr->ComponentBaseAddress) + Offset);
ret_val = XLNX_Environment_Wrapper_Read32(ContextPtr->UserEnvironment.Device_IO.Read32, ContextPtr->UserContextPtr, ValuePtr, WorkingAddr);
return ret_val;
}
XLNX_ERROR_CODE XLNX_COMP_BCAM_GetCompBcamBaseStatusStatus(XLNX_COMP_BCAM_CONTEXT_TYPE* ContextPtr, uint32_t* StatusPtr)
{
XLNX_ERROR_CODE ret_val = XLNX_OK;
uint32_t Offset, Mask, Shift, Buffer;
XLNX_COMPONENT_ADDRESS_TYPE WorkingAddr;
Offset = (COMP_BCAM_BASE_STATUS_REG_OFFSET);
Mask = COMP_BCAM_BASE_STATUS_STATUS_MASK;
Shift = COMP_BCAM_BASE_STATUS_STATUS_SHIFT;
WorkingAddr = (XLNX_COMPONENT_ADDRESS_TYPE)((ContextPtr->ComponentBaseAddress) + Offset);
ret_val = XLNX_Environment_Wrapper_Read32(ContextPtr->UserEnvironment.Device_IO.Read32, ContextPtr->UserContextPtr, &Buffer, WorkingAddr);
if (XLNX_OK == ret_val)
{
*StatusPtr = ((Buffer & Mask) >> Shift);
}
return ret_val;
}
XLNX_ERROR_CODE XLNX_COMP_BCAM_GetCompBcamBaseStatusReg(XLNX_COMP_BCAM_CONTEXT_TYPE* ContextPtr, uint32_t* ValuePtr)
{
XLNX_ERROR_CODE ret_val = XLNX_OK;
uint32_t Offset;
XLNX_COMPONENT_ADDRESS_TYPE WorkingAddr;
Offset = (COMP_BCAM_BASE_STATUS_REG_OFFSET);
WorkingAddr = (XLNX_COMPONENT_ADDRESS_TYPE)((ContextPtr->ComponentBaseAddress) + Offset);
ret_val = XLNX_Environment_Wrapper_Read32(ContextPtr->UserEnvironment.Device_IO.Read32, ContextPtr->UserContextPtr, ValuePtr, WorkingAddr);
return ret_val;
}
XLNX_ERROR_CODE XLNX_COMP_BCAM_SetCompBcamBaseOperationOperation(XLNX_COMP_BCAM_CONTEXT_TYPE* ContextPtr, uint32_t Operation)
{
XLNX_ERROR_CODE ret_val = XLNX_OK;
uint32_t Offset, Mask, Shift, Buffer;
XLNX_COMPONENT_ADDRESS_TYPE WorkingAddr;
Offset = (COMP_BCAM_BASE_OPERATION_REG_OFFSET);
Mask = COMP_BCAM_BASE_OPERATION_OPERATION_MASK;
Shift = COMP_BCAM_BASE_OPERATION_OPERATION_SHIFT;
WorkingAddr = (XLNX_COMPONENT_ADDRESS_TYPE)((ContextPtr->ComponentBaseAddress) + Offset);
Buffer = (Operation << Shift);
ret_val = XLNX_Environment_Wrapper_Write32_WithMask(ContextPtr->UserEnvironment.Device_IO.Write32WithMask, ContextPtr->UserContextPtr, WorkingAddr, Buffer, Mask);
return ret_val;
}
void XLNX_COMP_BCAM_BuildCompBcamBaseOperationOperation(uint32_t* MaskPtr, uint32_t* ValPtr, uint32_t Operation)
{
*MaskPtr |= COMP_BCAM_BASE_OPERATION_OPERATION_MASK;
*ValPtr |= (Operation << COMP_BCAM_BASE_OPERATION_OPERATION_SHIFT);
}
XLNX_ERROR_CODE XLNX_COMP_BCAM_SetCompBcamBaseOperationReg(const XLNX_COMP_BCAM_CONTEXT_TYPE* ContextPtr, uint32_t Value)
{
XLNX_ERROR_CODE ret_val = XLNX_OK;
uint32_t WorkingAddr;
WorkingAddr = ASSEMBLY_COMP_BCAM_OFFSET + COMP_BCAM_BASE_OPERATION_REG_OFFSET;
ContextPtr->UserEnvironment.Device_IO.Write32(ContextPtr->UserContextPtr, WorkingAddr, Value);
return ret_val;
}
XLNX_ERROR_CODE XLNX_COMP_BCAM_SetCompBcamBaseSampleRateSampleRate(XLNX_COMP_BCAM_CONTEXT_TYPE* ContextPtr, uint32_t SampleRate)
{
XLNX_ERROR_CODE ret_val = XLNX_OK;
uint32_t Offset, Mask, Shift, Buffer;
XLNX_COMPONENT_ADDRESS_TYPE WorkingAddr;
Offset = (COMP_BCAM_BASE_SAMPLE_RATE_REG_OFFSET);
Mask = COMP_BCAM_BASE_SAMPLE_RATE_SAMPLE_RATE_MASK;
Shift = COMP_BCAM_BASE_SAMPLE_RATE_SAMPLE_RATE_SHIFT;
WorkingAddr = (XLNX_COMPONENT_ADDRESS_TYPE)((ContextPtr->ComponentBaseAddress) + Offset);
Buffer = (SampleRate << Shift);
ret_val = XLNX_Environment_Wrapper_Write32_WithMask(ContextPtr->UserEnvironment.Device_IO.Write32WithMask, ContextPtr->UserContextPtr, WorkingAddr, Buffer, Mask);
return ret_val;
}
void XLNX_COMP_BCAM_BuildCompBcamBaseSampleRateSampleRate(uint32_t* MaskPtr, uint32_t* ValPtr, uint32_t SampleRate)
{
*MaskPtr |= COMP_BCAM_BASE_SAMPLE_RATE_SAMPLE_RATE_MASK;
*ValPtr |= (SampleRate << COMP_BCAM_BASE_SAMPLE_RATE_SAMPLE_RATE_SHIFT);
}
XLNX_ERROR_CODE XLNX_COMP_BCAM_GetCompBcamBaseSampleRateSampleRate(XLNX_COMP_BCAM_CONTEXT_TYPE* ContextPtr, uint32_t* SampleRatePtr)
{
XLNX_ERROR_CODE ret_val = XLNX_OK;
uint32_t Offset, Mask, Shift, Buffer;
XLNX_COMPONENT_ADDRESS_TYPE WorkingAddr;
Offset = (COMP_BCAM_BASE_SAMPLE_RATE_REG_OFFSET);
Mask = COMP_BCAM_BASE_SAMPLE_RATE_SAMPLE_RATE_MASK;
Shift = COMP_BCAM_BASE_SAMPLE_RATE_SAMPLE_RATE_SHIFT;
WorkingAddr = (XLNX_COMPONENT_ADDRESS_TYPE)((ContextPtr->ComponentBaseAddress) + Offset);
ret_val = XLNX_Environment_Wrapper_Read32(ContextPtr->UserEnvironment.Device_IO.Read32, ContextPtr->UserContextPtr, &Buffer, WorkingAddr);
if (XLNX_OK == ret_val)
{
*SampleRatePtr = ((Buffer & Mask) >> Shift);
}
return ret_val;
}
XLNX_ERROR_CODE XLNX_COMP_BCAM_SetCompBcamBaseSampleRateReg(XLNX_COMP_BCAM_CONTEXT_TYPE* ContextPtr, uint32_t Mask, uint32_t Value)
{
XLNX_ERROR_CODE ret_val = XLNX_OK;
uint32_t Offset;
XLNX_COMPONENT_ADDRESS_TYPE WorkingAddr;
Offset = (COMP_BCAM_BASE_SAMPLE_RATE_REG_OFFSET);
WorkingAddr = (XLNX_COMPONENT_ADDRESS_TYPE)((ContextPtr->ComponentBaseAddress) + Offset);
ret_val = XLNX_Environment_Wrapper_Write32_WithMask(ContextPtr->UserEnvironment.Device_IO.Write32WithMask, ContextPtr->UserContextPtr, WorkingAddr, Value, Mask);
return ret_val;
}
XLNX_ERROR_CODE XLNX_COMP_BCAM_GetCompBcamBaseSampleRateReg(XLNX_COMP_BCAM_CONTEXT_TYPE* ContextPtr, uint32_t* ValuePtr)
{
XLNX_ERROR_CODE ret_val = XLNX_OK;
uint32_t Offset;
XLNX_COMPONENT_ADDRESS_TYPE WorkingAddr;
Offset = (COMP_BCAM_BASE_SAMPLE_RATE_REG_OFFSET);
WorkingAddr = (XLNX_COMPONENT_ADDRESS_TYPE)((ContextPtr->ComponentBaseAddress) + Offset);
ret_val = XLNX_Environment_Wrapper_Read32(ContextPtr->UserEnvironment.Device_IO.Read32, ContextPtr->UserContextPtr, ValuePtr, WorkingAddr);
return ret_val;
}
XLNX_ERROR_CODE XLNX_COMP_BCAM_SetCompBcamBaseCamClearCamClear(XLNX_COMP_BCAM_CONTEXT_TYPE* ContextPtr, uint32_t CamClear)
{
XLNX_ERROR_CODE ret_val = XLNX_OK;
uint32_t Offset, Mask, Shift, Buffer;
XLNX_COMPONENT_ADDRESS_TYPE WorkingAddr;
Offset = (COMP_BCAM_BASE_CAM_CLEAR_REG_OFFSET);
Mask = COMP_BCAM_BASE_CAM_CLEAR_CAM_CLEAR_MASK;
Shift = COMP_BCAM_BASE_CAM_CLEAR_CAM_CLEAR_SHIFT;
WorkingAddr = (XLNX_COMPONENT_ADDRESS_TYPE)((ContextPtr->ComponentBaseAddress) + Offset);
Buffer = (CamClear << Shift);
ret_val = XLNX_Environment_Wrapper_Write32_WithMask(ContextPtr->UserEnvironment.Device_IO.Write32WithMask, ContextPtr->UserContextPtr, WorkingAddr, Buffer, Mask);
return ret_val;
}
void XLNX_COMP_BCAM_BuildCompBcamBaseCamClearCamClear(uint32_t* MaskPtr, uint32_t* ValPtr, uint32_t CamClear)
{
*MaskPtr |= COMP_BCAM_BASE_CAM_CLEAR_CAM_CLEAR_MASK;
*ValPtr |= (CamClear << COMP_BCAM_BASE_CAM_CLEAR_CAM_CLEAR_SHIFT);
}
XLNX_ERROR_CODE XLNX_COMP_BCAM_GetCompBcamBaseCamClearCamClear(XLNX_COMP_BCAM_CONTEXT_TYPE* ContextPtr, uint32_t* CamClearPtr)
{
XLNX_ERROR_CODE ret_val = XLNX_OK;
uint32_t Offset, Mask, Shift, Buffer;
XLNX_COMPONENT_ADDRESS_TYPE WorkingAddr;
Offset = (COMP_BCAM_BASE_CAM_CLEAR_REG_OFFSET);
Mask = COMP_BCAM_BASE_CAM_CLEAR_CAM_CLEAR_MASK;
Shift = COMP_BCAM_BASE_CAM_CLEAR_CAM_CLEAR_SHIFT;
WorkingAddr = (XLNX_COMPONENT_ADDRESS_TYPE)((ContextPtr->ComponentBaseAddress) + Offset);
ret_val = XLNX_Environment_Wrapper_Read32(ContextPtr->UserEnvironment.Device_IO.Read32, ContextPtr->UserContextPtr, &Buffer, WorkingAddr);
if (XLNX_OK == ret_val)
{
*CamClearPtr = ((Buffer & Mask) >> Shift);
}
return ret_val;
}
XLNX_ERROR_CODE XLNX_COMP_BCAM_SetCompBcamBaseCamClearReg(XLNX_COMP_BCAM_CONTEXT_TYPE* ContextPtr, uint32_t Mask, uint32_t Value)
{
XLNX_ERROR_CODE ret_val = XLNX_OK;
uint32_t Offset;
XLNX_COMPONENT_ADDRESS_TYPE WorkingAddr;
Offset = (COMP_BCAM_BASE_CAM_CLEAR_REG_OFFSET);
WorkingAddr = (XLNX_COMPONENT_ADDRESS_TYPE)((ContextPtr->ComponentBaseAddress) + Offset);
ret_val = XLNX_Environment_Wrapper_Write32_WithMask(ContextPtr->UserEnvironment.Device_IO.Write32WithMask, ContextPtr->UserContextPtr, WorkingAddr, Value, Mask);
return ret_val;
}
XLNX_ERROR_CODE XLNX_COMP_BCAM_GetCompBcamBaseCamClearReg(XLNX_COMP_BCAM_CONTEXT_TYPE* ContextPtr, uint32_t* ValuePtr)
{
XLNX_ERROR_CODE ret_val = XLNX_OK;
uint32_t Offset;
XLNX_COMPONENT_ADDRESS_TYPE WorkingAddr;
Offset = (COMP_BCAM_BASE_CAM_CLEAR_REG_OFFSET);
WorkingAddr = (XLNX_COMPONENT_ADDRESS_TYPE)((ContextPtr->ComponentBaseAddress) + Offset);
ret_val = XLNX_Environment_Wrapper_Read32(ContextPtr->UserEnvironment.Device_IO.Read32, ContextPtr->UserContextPtr, ValuePtr, WorkingAddr);
return ret_val;
}
XLNX_ERROR_CODE XLNX_COMP_BCAM_SetCompBcamBaseKeyData00KeyData00(XLNX_COMP_BCAM_CONTEXT_TYPE* ContextPtr, uint32_t KeyData00)
{
XLNX_ERROR_CODE ret_val = XLNX_OK;
uint32_t Offset, Mask, Shift, Buffer;
XLNX_COMPONENT_ADDRESS_TYPE WorkingAddr;
Offset = (COMP_BCAM_BASE_KEY_DATA_00_REG_OFFSET);
Mask = COMP_BCAM_BASE_KEY_DATA_00_KEY_DATA_00_MASK;
Shift = COMP_BCAM_BASE_KEY_DATA_00_KEY_DATA_00_SHIFT;
WorkingAddr = (XLNX_COMPONENT_ADDRESS_TYPE)((ContextPtr->ComponentBaseAddress) + Offset);
Buffer = (KeyData00 << Shift);
ret_val = XLNX_Environment_Wrapper_Write32_WithMask(ContextPtr->UserEnvironment.Device_IO.Write32WithMask, ContextPtr->UserContextPtr, WorkingAddr, Buffer, Mask);
return ret_val;
}
void XLNX_COMP_BCAM_BuildCompBcamBaseKeyData00KeyData00(uint32_t* MaskPtr, uint32_t* ValPtr, uint32_t KeyData00)
{
*MaskPtr |= COMP_BCAM_BASE_KEY_DATA_00_KEY_DATA_00_MASK;
*ValPtr |= (KeyData00 << COMP_BCAM_BASE_KEY_DATA_00_KEY_DATA_00_SHIFT);
}
XLNX_ERROR_CODE XLNX_COMP_BCAM_GetCompBcamBaseKeyData00KeyData00(XLNX_COMP_BCAM_CONTEXT_TYPE* ContextPtr, uint32_t* KeyData00Ptr)
{
XLNX_ERROR_CODE ret_val = XLNX_OK;
uint32_t Offset, Mask, Shift, Buffer;
XLNX_COMPONENT_ADDRESS_TYPE WorkingAddr;
Offset = (COMP_BCAM_BASE_KEY_DATA_00_REG_OFFSET);
Mask = COMP_BCAM_BASE_KEY_DATA_00_KEY_DATA_00_MASK;
Shift = COMP_BCAM_BASE_KEY_DATA_00_KEY_DATA_00_SHIFT;
WorkingAddr = (XLNX_COMPONENT_ADDRESS_TYPE)((ContextPtr->ComponentBaseAddress) + Offset);
ret_val = XLNX_Environment_Wrapper_Read32(ContextPtr->UserEnvironment.Device_IO.Read32, ContextPtr->UserContextPtr, &Buffer, WorkingAddr);
if (XLNX_OK == ret_val)
{
*KeyData00Ptr = ((Buffer & Mask) >> Shift);
}
return ret_val;
}
XLNX_ERROR_CODE XLNX_COMP_BCAM_SetCompBcamBaseKeyData00Reg(XLNX_COMP_BCAM_CONTEXT_TYPE* ContextPtr, uint32_t Mask, uint32_t Value)
{
XLNX_ERROR_CODE ret_val = XLNX_OK;
uint32_t Offset;
XLNX_COMPONENT_ADDRESS_TYPE WorkingAddr;
Offset = (COMP_BCAM_BASE_KEY_DATA_00_REG_OFFSET);
WorkingAddr = (XLNX_COMPONENT_ADDRESS_TYPE)((ContextPtr->ComponentBaseAddress) + Offset);
ret_val = XLNX_Environment_Wrapper_Write32_WithMask(ContextPtr->UserEnvironment.Device_IO.Write32WithMask, ContextPtr->UserContextPtr, WorkingAddr, Value, Mask);
return ret_val;
}
XLNX_ERROR_CODE XLNX_COMP_BCAM_GetCompBcamBaseKeyData00Reg(XLNX_COMP_BCAM_CONTEXT_TYPE* ContextPtr, uint32_t* ValuePtr)
{
XLNX_ERROR_CODE ret_val = XLNX_OK;
uint32_t Offset;
XLNX_COMPONENT_ADDRESS_TYPE WorkingAddr;
Offset = (COMP_BCAM_BASE_KEY_DATA_00_REG_OFFSET);
WorkingAddr = (XLNX_COMPONENT_ADDRESS_TYPE)((ContextPtr->ComponentBaseAddress) + Offset);
ret_val = XLNX_Environment_Wrapper_Read32(ContextPtr->UserEnvironment.Device_IO.Read32, ContextPtr->UserContextPtr, ValuePtr, WorkingAddr);
return ret_val;
}
XLNX_ERROR_CODE XLNX_COMP_BCAM_SetCompBcamBaseKeyData01KeyData01(XLNX_COMP_BCAM_CONTEXT_TYPE* ContextPtr, uint32_t KeyData01)
{
XLNX_ERROR_CODE ret_val = XLNX_OK;
uint32_t Offset, Mask, Shift, Buffer;
XLNX_COMPONENT_ADDRESS_TYPE WorkingAddr;
Offset = (COMP_BCAM_BASE_KEY_DATA_01_REG_OFFSET);
Mask = COMP_BCAM_BASE_KEY_DATA_01_KEY_DATA_01_MASK;
Shift = COMP_BCAM_BASE_KEY_DATA_01_KEY_DATA_01_SHIFT;
WorkingAddr = (XLNX_COMPONENT_ADDRESS_TYPE)((ContextPtr->ComponentBaseAddress) + Offset);
Buffer = (KeyData01 << Shift);
ret_val = XLNX_Environment_Wrapper_Write32_WithMask(ContextPtr->UserEnvironment.Device_IO.Write32WithMask, ContextPtr->UserContextPtr, WorkingAddr, Buffer, Mask);
return ret_val;
}
void XLNX_COMP_BCAM_BuildCompBcamBaseKeyData01KeyData01(uint32_t* MaskPtr, uint32_t* ValPtr, uint32_t KeyData01)
{
*MaskPtr |= COMP_BCAM_BASE_KEY_DATA_01_KEY_DATA_01_MASK;
*ValPtr |= (KeyData01 << COMP_BCAM_BASE_KEY_DATA_01_KEY_DATA_01_SHIFT);
}
XLNX_ERROR_CODE XLNX_COMP_BCAM_GetCompBcamBaseKeyData01KeyData01(XLNX_COMP_BCAM_CONTEXT_TYPE* ContextPtr, uint32_t* KeyData01Ptr)
{
XLNX_ERROR_CODE ret_val = XLNX_OK;
uint32_t Offset, Mask, Shift, Buffer;
XLNX_COMPONENT_ADDRESS_TYPE WorkingAddr;
Offset = (COMP_BCAM_BASE_KEY_DATA_01_REG_OFFSET);
Mask = COMP_BCAM_BASE_KEY_DATA_01_KEY_DATA_01_MASK;
Shift = COMP_BCAM_BASE_KEY_DATA_01_KEY_DATA_01_SHIFT;
WorkingAddr = (XLNX_COMPONENT_ADDRESS_TYPE)((ContextPtr->ComponentBaseAddress) + Offset);
ret_val = XLNX_Environment_Wrapper_Read32(ContextPtr->UserEnvironment.Device_IO.Read32, ContextPtr->UserContextPtr, &Buffer, WorkingAddr);
if (XLNX_OK == ret_val)
{
*KeyData01Ptr = ((Buffer & Mask) >> Shift);
}
return ret_val;
}
XLNX_ERROR_CODE XLNX_COMP_BCAM_SetCompBcamBaseKeyData01Reg(XLNX_COMP_BCAM_CONTEXT_TYPE* ContextPtr, uint32_t Mask, uint32_t Value)
{
XLNX_ERROR_CODE ret_val = XLNX_OK;
uint32_t Offset;
XLNX_COMPONENT_ADDRESS_TYPE WorkingAddr;
Offset = (COMP_BCAM_BASE_KEY_DATA_01_REG_OFFSET);
WorkingAddr = (XLNX_COMPONENT_ADDRESS_TYPE)((ContextPtr->ComponentBaseAddress) + Offset);
ret_val = XLNX_Environment_Wrapper_Write32_WithMask(ContextPtr->UserEnvironment.Device_IO.Write32WithMask, ContextPtr->UserContextPtr, WorkingAddr, Value, Mask);
return ret_val;
}
XLNX_ERROR_CODE XLNX_COMP_BCAM_GetCompBcamBaseKeyData01Reg(XLNX_COMP_BCAM_CONTEXT_TYPE* ContextPtr, uint32_t* ValuePtr)
{
XLNX_ERROR_CODE ret_val = XLNX_OK;
uint32_t Offset;
XLNX_COMPONENT_ADDRESS_TYPE WorkingAddr;
Offset = (COMP_BCAM_BASE_KEY_DATA_01_REG_OFFSET);
WorkingAddr = (XLNX_COMPONENT_ADDRESS_TYPE)((ContextPtr->ComponentBaseAddress) + Offset);
ret_val = XLNX_Environment_Wrapper_Read32(ContextPtr->UserEnvironment.Device_IO.Read32, ContextPtr->UserContextPtr, ValuePtr, WorkingAddr);
return ret_val;
}
XLNX_ERROR_CODE XLNX_COMP_BCAM_SetCompBcamBaseKeyData02KeyData02(XLNX_COMP_BCAM_CONTEXT_TYPE* ContextPtr, uint32_t KeyData02)
{
XLNX_ERROR_CODE ret_val = XLNX_OK;
uint32_t Offset, Mask, Shift, Buffer;
XLNX_COMPONENT_ADDRESS_TYPE WorkingAddr;
Offset = (COMP_BCAM_BASE_KEY_DATA_02_REG_OFFSET);
Mask = COMP_BCAM_BASE_KEY_DATA_02_KEY_DATA_02_MASK;
Shift = COMP_BCAM_BASE_KEY_DATA_02_KEY_DATA_02_SHIFT;
WorkingAddr = (XLNX_COMPONENT_ADDRESS_TYPE)((ContextPtr->ComponentBaseAddress) + Offset);
Buffer = (KeyData02 << Shift);
ret_val = XLNX_Environment_Wrapper_Write32_WithMask(ContextPtr->UserEnvironment.Device_IO.Write32WithMask, ContextPtr->UserContextPtr, WorkingAddr, Buffer, Mask);
return ret_val;
}
void XLNX_COMP_BCAM_BuildCompBcamBaseKeyData02KeyData02(uint32_t* MaskPtr, uint32_t* ValPtr, uint32_t KeyData02)
{
*MaskPtr |= COMP_BCAM_BASE_KEY_DATA_02_KEY_DATA_02_MASK;
*ValPtr |= (KeyData02 << COMP_BCAM_BASE_KEY_DATA_02_KEY_DATA_02_SHIFT);
}
XLNX_ERROR_CODE XLNX_COMP_BCAM_GetCompBcamBaseKeyData02KeyData02(XLNX_COMP_BCAM_CONTEXT_TYPE* ContextPtr, uint32_t* KeyData02Ptr)
{
XLNX_ERROR_CODE ret_val = XLNX_OK;
uint32_t Offset, Mask, Shift, Buffer;
XLNX_COMPONENT_ADDRESS_TYPE WorkingAddr;
Offset = (COMP_BCAM_BASE_KEY_DATA_02_REG_OFFSET);
Mask = COMP_BCAM_BASE_KEY_DATA_02_KEY_DATA_02_MASK;
Shift = COMP_BCAM_BASE_KEY_DATA_02_KEY_DATA_02_SHIFT;
WorkingAddr = (XLNX_COMPONENT_ADDRESS_TYPE)((ContextPtr->ComponentBaseAddress) + Offset);
ret_val = XLNX_Environment_Wrapper_Read32(ContextPtr->UserEnvironment.Device_IO.Read32, ContextPtr->UserContextPtr, &Buffer, WorkingAddr);
if (XLNX_OK == ret_val)
{
*KeyData02Ptr = ((Buffer & Mask) >> Shift);
}
return ret_val;
}
XLNX_ERROR_CODE XLNX_COMP_BCAM_SetCompBcamBaseKeyData02Reg(XLNX_COMP_BCAM_CONTEXT_TYPE* ContextPtr, uint32_t Mask, uint32_t Value)
{
XLNX_ERROR_CODE ret_val = XLNX_OK;
uint32_t Offset;
XLNX_COMPONENT_ADDRESS_TYPE WorkingAddr;
Offset = (COMP_BCAM_BASE_KEY_DATA_02_REG_OFFSET);
WorkingAddr = (XLNX_COMPONENT_ADDRESS_TYPE)((ContextPtr->ComponentBaseAddress) + Offset);
ret_val = XLNX_Environment_Wrapper_Write32_WithMask(ContextPtr->UserEnvironment.Device_IO.Write32WithMask, ContextPtr->UserContextPtr, WorkingAddr, Value, Mask);
return ret_val;
}
XLNX_ERROR_CODE XLNX_COMP_BCAM_GetCompBcamBaseKeyData02Reg(XLNX_COMP_BCAM_CONTEXT_TYPE* ContextPtr, uint32_t* ValuePtr)
{
XLNX_ERROR_CODE ret_val = XLNX_OK;
uint32_t Offset;
XLNX_COMPONENT_ADDRESS_TYPE WorkingAddr;
Offset = (COMP_BCAM_BASE_KEY_DATA_02_REG_OFFSET);
WorkingAddr = (XLNX_COMPONENT_ADDRESS_TYPE)((ContextPtr->ComponentBaseAddress) + Offset);
ret_val = XLNX_Environment_Wrapper_Read32(ContextPtr->UserEnvironment.Device_IO.Read32, ContextPtr->UserContextPtr, ValuePtr, WorkingAddr);
return ret_val;
}
XLNX_ERROR_CODE XLNX_COMP_BCAM_SetCompBcamBaseKeyData03KeyData03(XLNX_COMP_BCAM_CONTEXT_TYPE* ContextPtr, uint32_t KeyData03)
{
XLNX_ERROR_CODE ret_val = XLNX_OK;
uint32_t Offset, Mask, Shift, Buffer;
XLNX_COMPONENT_ADDRESS_TYPE WorkingAddr;
Offset = (COMP_BCAM_BASE_KEY_DATA_03_REG_OFFSET);
Mask = COMP_BCAM_BASE_KEY_DATA_03_KEY_DATA_03_MASK;
Shift = COMP_BCAM_BASE_KEY_DATA_03_KEY_DATA_03_SHIFT;
WorkingAddr = (XLNX_COMPONENT_ADDRESS_TYPE)((ContextPtr->ComponentBaseAddress) + Offset);
Buffer = (KeyData03 << Shift);
ret_val = XLNX_Environment_Wrapper_Write32_WithMask(ContextPtr->UserEnvironment.Device_IO.Write32WithMask, ContextPtr->UserContextPtr, WorkingAddr, Buffer, Mask);
return ret_val;
}
void XLNX_COMP_BCAM_BuildCompBcamBaseKeyData03KeyData03(uint32_t* MaskPtr, uint32_t* ValPtr, uint32_t KeyData03)
{
*MaskPtr |= COMP_BCAM_BASE_KEY_DATA_03_KEY_DATA_03_MASK;
*ValPtr |= (KeyData03 << COMP_BCAM_BASE_KEY_DATA_03_KEY_DATA_03_SHIFT);
}
XLNX_ERROR_CODE XLNX_COMP_BCAM_GetCompBcamBaseKeyData03KeyData03(XLNX_COMP_BCAM_CONTEXT_TYPE* ContextPtr, uint32_t* KeyData03Ptr)
{
XLNX_ERROR_CODE ret_val = XLNX_OK;
uint32_t Offset, Mask, Shift, Buffer;
XLNX_COMPONENT_ADDRESS_TYPE WorkingAddr;
Offset = (COMP_BCAM_BASE_KEY_DATA_03_REG_OFFSET);
Mask = COMP_BCAM_BASE_KEY_DATA_03_KEY_DATA_03_MASK;
Shift = COMP_BCAM_BASE_KEY_DATA_03_KEY_DATA_03_SHIFT;
WorkingAddr = (XLNX_COMPONENT_ADDRESS_TYPE)((ContextPtr->ComponentBaseAddress) + Offset);
ret_val = XLNX_Environment_Wrapper_Read32(ContextPtr->UserEnvironment.Device_IO.Read32, ContextPtr->UserContextPtr, &Buffer, WorkingAddr);
if (XLNX_OK == ret_val)
{
*KeyData03Ptr = ((Buffer & Mask) >> Shift);
}
return ret_val;
}
XLNX_ERROR_CODE XLNX_COMP_BCAM_SetCompBcamBaseKeyData03Reg(XLNX_COMP_BCAM_CONTEXT_TYPE* ContextPtr, uint32_t Mask, uint32_t Value)
{
XLNX_ERROR_CODE ret_val = XLNX_OK;
uint32_t Offset;
XLNX_COMPONENT_ADDRESS_TYPE WorkingAddr;
Offset = (COMP_BCAM_BASE_KEY_DATA_03_REG_OFFSET);
WorkingAddr = (XLNX_COMPONENT_ADDRESS_TYPE)((ContextPtr->ComponentBaseAddress) + Offset);
ret_val = XLNX_Environment_Wrapper_Write32_WithMask(ContextPtr->UserEnvironment.Device_IO.Write32WithMask, ContextPtr->UserContextPtr, WorkingAddr, Value, Mask);
return ret_val;
}
XLNX_ERROR_CODE XLNX_COMP_BCAM_GetCompBcamBaseKeyData03Reg(XLNX_COMP_BCAM_CONTEXT_TYPE* ContextPtr, uint32_t* ValuePtr)
{
XLNX_ERROR_CODE ret_val = XLNX_OK;
uint32_t Offset;
XLNX_COMPONENT_ADDRESS_TYPE WorkingAddr;
Offset = (COMP_BCAM_BASE_KEY_DATA_03_REG_OFFSET);
WorkingAddr = (XLNX_COMPONENT_ADDRESS_TYPE)((ContextPtr->ComponentBaseAddress) + Offset);
ret_val = XLNX_Environment_Wrapper_Read32(ContextPtr->UserEnvironment.Device_IO.Read32, ContextPtr->UserContextPtr, ValuePtr, WorkingAddr);
return ret_val;
}
XLNX_ERROR_CODE XLNX_COMP_BCAM_SetCompBcamBaseKeyData04KeyData04(XLNX_COMP_BCAM_CONTEXT_TYPE* ContextPtr, uint32_t KeyData04)
{
XLNX_ERROR_CODE ret_val = XLNX_OK;
uint32_t Offset, Mask, Shift, Buffer;
XLNX_COMPONENT_ADDRESS_TYPE WorkingAddr;
Offset = (COMP_BCAM_BASE_KEY_DATA_04_REG_OFFSET);
Mask = COMP_BCAM_BASE_KEY_DATA_04_KEY_DATA_04_MASK;
Shift = COMP_BCAM_BASE_KEY_DATA_04_KEY_DATA_04_SHIFT;
WorkingAddr = (XLNX_COMPONENT_ADDRESS_TYPE)((ContextPtr->ComponentBaseAddress) + Offset);
Buffer = (KeyData04 << Shift);
ret_val = XLNX_Environment_Wrapper_Write32_WithMask(ContextPtr->UserEnvironment.Device_IO.Write32WithMask, ContextPtr->UserContextPtr, WorkingAddr, Buffer, Mask);
return ret_val;
}
void XLNX_COMP_BCAM_BuildCompBcamBaseKeyData04KeyData04(uint32_t* MaskPtr, uint32_t* ValPtr, uint32_t KeyData04)
{
*MaskPtr |= COMP_BCAM_BASE_KEY_DATA_04_KEY_DATA_04_MASK;
*ValPtr |= (KeyData04 << COMP_BCAM_BASE_KEY_DATA_04_KEY_DATA_04_SHIFT);
}
XLNX_ERROR_CODE XLNX_COMP_BCAM_GetCompBcamBaseKeyData04KeyData04(XLNX_COMP_BCAM_CONTEXT_TYPE* ContextPtr, uint32_t* KeyData04Ptr)
{
XLNX_ERROR_CODE ret_val = XLNX_OK;
uint32_t Offset, Mask, Shift, Buffer;
XLNX_COMPONENT_ADDRESS_TYPE WorkingAddr;
Offset = (COMP_BCAM_BASE_KEY_DATA_04_REG_OFFSET);
Mask = COMP_BCAM_BASE_KEY_DATA_04_KEY_DATA_04_MASK;
Shift = COMP_BCAM_BASE_KEY_DATA_04_KEY_DATA_04_SHIFT;
WorkingAddr = (XLNX_COMPONENT_ADDRESS_TYPE)((ContextPtr->ComponentBaseAddress) + Offset);
ret_val = XLNX_Environment_Wrapper_Read32(ContextPtr->UserEnvironment.Device_IO.Read32, ContextPtr->UserContextPtr, &Buffer, WorkingAddr);
if (XLNX_OK == ret_val)
{
*KeyData04Ptr = ((Buffer & Mask) >> Shift);
}
return ret_val;
}
XLNX_ERROR_CODE XLNX_COMP_BCAM_SetCompBcamBaseKeyData04Reg(XLNX_COMP_BCAM_CONTEXT_TYPE* ContextPtr, uint32_t Mask, uint32_t Value)
{
XLNX_ERROR_CODE ret_val = XLNX_OK;
uint32_t Offset;
XLNX_COMPONENT_ADDRESS_TYPE WorkingAddr;
Offset = (COMP_BCAM_BASE_KEY_DATA_04_REG_OFFSET);
WorkingAddr = (XLNX_COMPONENT_ADDRESS_TYPE)((ContextPtr->ComponentBaseAddress) + Offset);
ret_val = XLNX_Environment_Wrapper_Write32_WithMask(ContextPtr->UserEnvironment.Device_IO.Write32WithMask, ContextPtr->UserContextPtr, WorkingAddr, Value, Mask);
return ret_val;
}
XLNX_ERROR_CODE XLNX_COMP_BCAM_GetCompBcamBaseKeyData04Reg(XLNX_COMP_BCAM_CONTEXT_TYPE* ContextPtr, uint32_t* ValuePtr)
{
XLNX_ERROR_CODE ret_val = XLNX_OK;
uint32_t Offset;
XLNX_COMPONENT_ADDRESS_TYPE WorkingAddr;
Offset = (COMP_BCAM_BASE_KEY_DATA_04_REG_OFFSET);
WorkingAddr = (XLNX_COMPONENT_ADDRESS_TYPE)((ContextPtr->ComponentBaseAddress) + Offset);
ret_val = XLNX_Environment_Wrapper_Read32(ContextPtr->UserEnvironment.Device_IO.Read32, ContextPtr->UserContextPtr, ValuePtr, WorkingAddr);
return ret_val;
}
XLNX_ERROR_CODE XLNX_COMP_BCAM_SetCompBcamBaseKeyData05KeyData05(XLNX_COMP_BCAM_CONTEXT_TYPE* ContextPtr, uint32_t KeyData05)
{
XLNX_ERROR_CODE ret_val = XLNX_OK;
uint32_t Offset, Mask, Shift, Buffer;
XLNX_COMPONENT_ADDRESS_TYPE WorkingAddr;
Offset = (COMP_BCAM_BASE_KEY_DATA_05_REG_OFFSET);
Mask = COMP_BCAM_BASE_KEY_DATA_05_KEY_DATA_05_MASK;
Shift = COMP_BCAM_BASE_KEY_DATA_05_KEY_DATA_05_SHIFT;
WorkingAddr = (XLNX_COMPONENT_ADDRESS_TYPE)((ContextPtr->ComponentBaseAddress) + Offset);
Buffer = (KeyData05 << Shift);
ret_val = XLNX_Environment_Wrapper_Write32_WithMask(ContextPtr->UserEnvironment.Device_IO.Write32WithMask, ContextPtr->UserContextPtr, WorkingAddr, Buffer, Mask);
return ret_val;
}
void XLNX_COMP_BCAM_BuildCompBcamBaseKeyData05KeyData05(uint32_t* MaskPtr, uint32_t* ValPtr, uint32_t KeyData05)
{
*MaskPtr |= COMP_BCAM_BASE_KEY_DATA_05_KEY_DATA_05_MASK;
*ValPtr |= (KeyData05 << COMP_BCAM_BASE_KEY_DATA_05_KEY_DATA_05_SHIFT);
}
XLNX_ERROR_CODE XLNX_COMP_BCAM_GetCompBcamBaseKeyData05KeyData05(XLNX_COMP_BCAM_CONTEXT_TYPE* ContextPtr, uint32_t* KeyData05Ptr)
{
XLNX_ERROR_CODE ret_val = XLNX_OK;
uint32_t Offset, Mask, Shift, Buffer;
XLNX_COMPONENT_ADDRESS_TYPE WorkingAddr;
Offset = (COMP_BCAM_BASE_KEY_DATA_05_REG_OFFSET);
Mask = COMP_BCAM_BASE_KEY_DATA_05_KEY_DATA_05_MASK;
Shift = COMP_BCAM_BASE_KEY_DATA_05_KEY_DATA_05_SHIFT;
WorkingAddr = (XLNX_COMPONENT_ADDRESS_TYPE)((ContextPtr->ComponentBaseAddress) + Offset);
ret_val = XLNX_Environment_Wrapper_Read32(ContextPtr->UserEnvironment.Device_IO.Read32, ContextPtr->UserContextPtr, &Buffer, WorkingAddr);
if (XLNX_OK == ret_val)
{
*KeyData05Ptr = ((Buffer & Mask) >> Shift);
}
return ret_val;
}
XLNX_ERROR_CODE XLNX_COMP_BCAM_SetCompBcamBaseKeyData05Reg(XLNX_COMP_BCAM_CONTEXT_TYPE* ContextPtr, uint32_t Mask, uint32_t Value)
{
XLNX_ERROR_CODE ret_val = XLNX_OK;
uint32_t Offset;
XLNX_COMPONENT_ADDRESS_TYPE WorkingAddr;
Offset = (COMP_BCAM_BASE_KEY_DATA_05_REG_OFFSET);
WorkingAddr = (XLNX_COMPONENT_ADDRESS_TYPE)((ContextPtr->ComponentBaseAddress) + Offset);
ret_val = XLNX_Environment_Wrapper_Write32_WithMask(ContextPtr->UserEnvironment.Device_IO.Write32WithMask, ContextPtr->UserContextPtr, WorkingAddr, Value, Mask);
return ret_val;
}
XLNX_ERROR_CODE XLNX_COMP_BCAM_GetCompBcamBaseKeyData05Reg(XLNX_COMP_BCAM_CONTEXT_TYPE* ContextPtr, uint32_t* ValuePtr)
{
XLNX_ERROR_CODE ret_val = XLNX_OK;
uint32_t Offset;
XLNX_COMPONENT_ADDRESS_TYPE WorkingAddr;
Offset = (COMP_BCAM_BASE_KEY_DATA_05_REG_OFFSET);
WorkingAddr = (XLNX_COMPONENT_ADDRESS_TYPE)((ContextPtr->ComponentBaseAddress) + Offset);
ret_val = XLNX_Environment_Wrapper_Read32(ContextPtr->UserEnvironment.Device_IO.Read32, ContextPtr->UserContextPtr, ValuePtr, WorkingAddr);
return ret_val;
}
XLNX_ERROR_CODE XLNX_COMP_BCAM_SetCompBcamBaseKeyData06KeyData06(XLNX_COMP_BCAM_CONTEXT_TYPE* ContextPtr, uint32_t KeyData06)
{
XLNX_ERROR_CODE ret_val = XLNX_OK;
uint32_t Offset, Mask, Shift, Buffer;
XLNX_COMPONENT_ADDRESS_TYPE WorkingAddr;
Offset = (COMP_BCAM_BASE_KEY_DATA_06_REG_OFFSET);
Mask = COMP_BCAM_BASE_KEY_DATA_06_KEY_DATA_06_MASK;
Shift = COMP_BCAM_BASE_KEY_DATA_06_KEY_DATA_06_SHIFT;
WorkingAddr = (XLNX_COMPONENT_ADDRESS_TYPE)((ContextPtr->ComponentBaseAddress) + Offset);
Buffer = (KeyData06 << Shift);
ret_val = XLNX_Environment_Wrapper_Write32_WithMask(ContextPtr->UserEnvironment.Device_IO.Write32WithMask, ContextPtr->UserContextPtr, WorkingAddr, Buffer, Mask);
return ret_val;
}
void XLNX_COMP_BCAM_BuildCompBcamBaseKeyData06KeyData06(uint32_t* MaskPtr, uint32_t* ValPtr, uint32_t KeyData06)
{
*MaskPtr |= COMP_BCAM_BASE_KEY_DATA_06_KEY_DATA_06_MASK;
*ValPtr |= (KeyData06 << COMP_BCAM_BASE_KEY_DATA_06_KEY_DATA_06_SHIFT);
}
XLNX_ERROR_CODE XLNX_COMP_BCAM_GetCompBcamBaseKeyData06KeyData06(XLNX_COMP_BCAM_CONTEXT_TYPE* ContextPtr, uint32_t* KeyData06Ptr)
{
XLNX_ERROR_CODE ret_val = XLNX_OK;
uint32_t Offset, Mask, Shift, Buffer;
XLNX_COMPONENT_ADDRESS_TYPE WorkingAddr;
Offset = (COMP_BCAM_BASE_KEY_DATA_06_REG_OFFSET);
Mask = COMP_BCAM_BASE_KEY_DATA_06_KEY_DATA_06_MASK;
Shift = COMP_BCAM_BASE_KEY_DATA_06_KEY_DATA_06_SHIFT;
WorkingAddr = (XLNX_COMPONENT_ADDRESS_TYPE)((ContextPtr->ComponentBaseAddress) + Offset);
ret_val = XLNX_Environment_Wrapper_Read32(ContextPtr->UserEnvironment.Device_IO.Read32, ContextPtr->UserContextPtr, &Buffer, WorkingAddr);
if (XLNX_OK == ret_val)
{
*KeyData06Ptr = ((Buffer & Mask) >> Shift);
}
return ret_val;
}
XLNX_ERROR_CODE XLNX_COMP_BCAM_SetCompBcamBaseKeyData06Reg(XLNX_COMP_BCAM_CONTEXT_TYPE* ContextPtr, uint32_t Mask, uint32_t Value)
{
XLNX_ERROR_CODE ret_val = XLNX_OK;
uint32_t Offset;
XLNX_COMPONENT_ADDRESS_TYPE WorkingAddr;
Offset = (COMP_BCAM_BASE_KEY_DATA_06_REG_OFFSET);
WorkingAddr = (XLNX_COMPONENT_ADDRESS_TYPE)((ContextPtr->ComponentBaseAddress) + Offset);
ret_val = XLNX_Environment_Wrapper_Write32_WithMask(ContextPtr->UserEnvironment.Device_IO.Write32WithMask, ContextPtr->UserContextPtr, WorkingAddr, Value, Mask);
return ret_val;
}
XLNX_ERROR_CODE XLNX_COMP_BCAM_GetCompBcamBaseKeyData06Reg(XLNX_COMP_BCAM_CONTEXT_TYPE* ContextPtr, uint32_t* ValuePtr)
{
XLNX_ERROR_CODE ret_val = XLNX_OK;
uint32_t Offset;
XLNX_COMPONENT_ADDRESS_TYPE WorkingAddr;
Offset = (COMP_BCAM_BASE_KEY_DATA_06_REG_OFFSET);
WorkingAddr = (XLNX_COMPONENT_ADDRESS_TYPE)((ContextPtr->ComponentBaseAddress) + Offset);
ret_val = XLNX_Environment_Wrapper_Read32(ContextPtr->UserEnvironment.Device_IO.Read32, ContextPtr->UserContextPtr, ValuePtr, WorkingAddr);
return ret_val;
}
XLNX_ERROR_CODE XLNX_COMP_BCAM_SetCompBcamBaseKeyData07KeyData07(XLNX_COMP_BCAM_CONTEXT_TYPE* ContextPtr, uint32_t KeyData07)
{
XLNX_ERROR_CODE ret_val = XLNX_OK;
uint32_t Offset, Mask, Shift, Buffer;
XLNX_COMPONENT_ADDRESS_TYPE WorkingAddr;
Offset = (COMP_BCAM_BASE_KEY_DATA_07_REG_OFFSET);
Mask = COMP_BCAM_BASE_KEY_DATA_07_KEY_DATA_07_MASK;
Shift = COMP_BCAM_BASE_KEY_DATA_07_KEY_DATA_07_SHIFT;
WorkingAddr = (XLNX_COMPONENT_ADDRESS_TYPE)((ContextPtr->ComponentBaseAddress) + Offset);
Buffer = (KeyData07 << Shift);
ret_val = XLNX_Environment_Wrapper_Write32_WithMask(ContextPtr->UserEnvironment.Device_IO.Write32WithMask, ContextPtr->UserContextPtr, WorkingAddr, Buffer, Mask);
return ret_val;
}
void XLNX_COMP_BCAM_BuildCompBcamBaseKeyData07KeyData07(uint32_t* MaskPtr, uint32_t* ValPtr, uint32_t KeyData07)
{
*MaskPtr |= COMP_BCAM_BASE_KEY_DATA_07_KEY_DATA_07_MASK;
*ValPtr |= (KeyData07 << COMP_BCAM_BASE_KEY_DATA_07_KEY_DATA_07_SHIFT);
}
XLNX_ERROR_CODE XLNX_COMP_BCAM_GetCompBcamBaseKeyData07KeyData07(XLNX_COMP_BCAM_CONTEXT_TYPE* ContextPtr, uint32_t* KeyData07Ptr)
{
XLNX_ERROR_CODE ret_val = XLNX_OK;
uint32_t Offset, Mask, Shift, Buffer;
XLNX_COMPONENT_ADDRESS_TYPE WorkingAddr;
Offset = (COMP_BCAM_BASE_KEY_DATA_07_REG_OFFSET);
Mask = COMP_BCAM_BASE_KEY_DATA_07_KEY_DATA_07_MASK;
Shift = COMP_BCAM_BASE_KEY_DATA_07_KEY_DATA_07_SHIFT;
WorkingAddr = (XLNX_COMPONENT_ADDRESS_TYPE)((ContextPtr->ComponentBaseAddress) + Offset);
ret_val = XLNX_Environment_Wrapper_Read32(ContextPtr->UserEnvironment.Device_IO.Read32, ContextPtr->UserContextPtr, &Buffer, WorkingAddr);
if (XLNX_OK == ret_val)
{
*KeyData07Ptr = ((Buffer & Mask) >> Shift);
}
return ret_val;
}
XLNX_ERROR_CODE XLNX_COMP_BCAM_SetCompBcamBaseKeyData07Reg(XLNX_COMP_BCAM_CONTEXT_TYPE* ContextPtr, uint32_t Mask, uint32_t Value)
{
XLNX_ERROR_CODE ret_val = XLNX_OK;
uint32_t Offset;
XLNX_COMPONENT_ADDRESS_TYPE WorkingAddr;
Offset = (COMP_BCAM_BASE_KEY_DATA_07_REG_OFFSET);
WorkingAddr = (XLNX_COMPONENT_ADDRESS_TYPE)((ContextPtr->ComponentBaseAddress) + Offset);
ret_val = XLNX_Environment_Wrapper_Write32_WithMask(ContextPtr->UserEnvironment.Device_IO.Write32WithMask, ContextPtr->UserContextPtr, WorkingAddr, Value, Mask);
return ret_val;
}
XLNX_ERROR_CODE XLNX_COMP_BCAM_GetCompBcamBaseKeyData07Reg(XLNX_COMP_BCAM_CONTEXT_TYPE* ContextPtr, uint32_t* ValuePtr)
{
XLNX_ERROR_CODE ret_val = XLNX_OK;
uint32_t Offset;
XLNX_COMPONENT_ADDRESS_TYPE WorkingAddr;
Offset = (COMP_BCAM_BASE_KEY_DATA_07_REG_OFFSET);
WorkingAddr = (XLNX_COMPONENT_ADDRESS_TYPE)((ContextPtr->ComponentBaseAddress) + Offset);
ret_val = XLNX_Environment_Wrapper_Read32(ContextPtr->UserEnvironment.Device_IO.Read32, ContextPtr->UserContextPtr, ValuePtr, WorkingAddr);
return ret_val;
}
XLNX_ERROR_CODE XLNX_COMP_BCAM_SetCompBcamBaseKeyData08KeyData08(XLNX_COMP_BCAM_CONTEXT_TYPE* ContextPtr, uint32_t KeyData08)
{
XLNX_ERROR_CODE ret_val = XLNX_OK;
uint32_t Offset, Mask, Shift, Buffer;
XLNX_COMPONENT_ADDRESS_TYPE WorkingAddr;
Offset = (COMP_BCAM_BASE_KEY_DATA_08_REG_OFFSET);
Mask = COMP_BCAM_BASE_KEY_DATA_08_KEY_DATA_08_MASK;
Shift = COMP_BCAM_BASE_KEY_DATA_08_KEY_DATA_08_SHIFT;
WorkingAddr = (XLNX_COMPONENT_ADDRESS_TYPE)((ContextPtr->ComponentBaseAddress) + Offset);
Buffer = (KeyData08 << Shift);
ret_val = XLNX_Environment_Wrapper_Write32_WithMask(ContextPtr->UserEnvironment.Device_IO.Write32WithMask, ContextPtr->UserContextPtr, WorkingAddr, Buffer, Mask);
return ret_val;
}
void XLNX_COMP_BCAM_BuildCompBcamBaseKeyData08KeyData08(uint32_t* MaskPtr, uint32_t* ValPtr, uint32_t KeyData08)
{
*MaskPtr |= COMP_BCAM_BASE_KEY_DATA_08_KEY_DATA_08_MASK;
*ValPtr |= (KeyData08 << COMP_BCAM_BASE_KEY_DATA_08_KEY_DATA_08_SHIFT);
}
XLNX_ERROR_CODE XLNX_COMP_BCAM_GetCompBcamBaseKeyData08KeyData08(XLNX_COMP_BCAM_CONTEXT_TYPE* ContextPtr, uint32_t* KeyData08Ptr)
{
XLNX_ERROR_CODE ret_val = XLNX_OK;
uint32_t Offset, Mask, Shift, Buffer;
XLNX_COMPONENT_ADDRESS_TYPE WorkingAddr;
Offset = (COMP_BCAM_BASE_KEY_DATA_08_REG_OFFSET);
Mask = COMP_BCAM_BASE_KEY_DATA_08_KEY_DATA_08_MASK;
Shift = COMP_BCAM_BASE_KEY_DATA_08_KEY_DATA_08_SHIFT;
WorkingAddr = (XLNX_COMPONENT_ADDRESS_TYPE)((ContextPtr->ComponentBaseAddress) + Offset);
ret_val = XLNX_Environment_Wrapper_Read32(ContextPtr->UserEnvironment.Device_IO.Read32, ContextPtr->UserContextPtr, &Buffer, WorkingAddr);
if (XLNX_OK == ret_val)
{
*KeyData08Ptr = ((Buffer & Mask) >> Shift);
}
return ret_val;
}
XLNX_ERROR_CODE XLNX_COMP_BCAM_SetCompBcamBaseKeyData08Reg(XLNX_COMP_BCAM_CONTEXT_TYPE* ContextPtr, uint32_t Mask, uint32_t Value)
{
XLNX_ERROR_CODE ret_val = XLNX_OK;
uint32_t Offset;
XLNX_COMPONENT_ADDRESS_TYPE WorkingAddr;
Offset = (COMP_BCAM_BASE_KEY_DATA_08_REG_OFFSET);
WorkingAddr = (XLNX_COMPONENT_ADDRESS_TYPE)((ContextPtr->ComponentBaseAddress) + Offset);
ret_val = XLNX_Environment_Wrapper_Write32_WithMask(ContextPtr->UserEnvironment.Device_IO.Write32WithMask, ContextPtr->UserContextPtr, WorkingAddr, Value, Mask);
return ret_val;
}
XLNX_ERROR_CODE XLNX_COMP_BCAM_GetCompBcamBaseKeyData08Reg(XLNX_COMP_BCAM_CONTEXT_TYPE* ContextPtr, uint32_t* ValuePtr)
{
XLNX_ERROR_CODE ret_val = XLNX_OK;
uint32_t Offset;
XLNX_COMPONENT_ADDRESS_TYPE WorkingAddr;
Offset = (COMP_BCAM_BASE_KEY_DATA_08_REG_OFFSET);
WorkingAddr = (XLNX_COMPONENT_ADDRESS_TYPE)((ContextPtr->ComponentBaseAddress) + Offset);
ret_val = XLNX_Environment_Wrapper_Read32(ContextPtr->UserEnvironment.Device_IO.Read32, ContextPtr->UserContextPtr, ValuePtr, WorkingAddr);
return ret_val;
}
XLNX_ERROR_CODE XLNX_COMP_BCAM_SetCompBcamBaseKeyData09KeyData09(XLNX_COMP_BCAM_CONTEXT_TYPE* ContextPtr, uint32_t KeyData09)
{
XLNX_ERROR_CODE ret_val = XLNX_OK;
uint32_t Offset, Mask, Shift, Buffer;
XLNX_COMPONENT_ADDRESS_TYPE WorkingAddr;
Offset = (COMP_BCAM_BASE_KEY_DATA_09_REG_OFFSET);
Mask = COMP_BCAM_BASE_KEY_DATA_09_KEY_DATA_09_MASK;
Shift = COMP_BCAM_BASE_KEY_DATA_09_KEY_DATA_09_SHIFT;
WorkingAddr = (XLNX_COMPONENT_ADDRESS_TYPE)((ContextPtr->ComponentBaseAddress) + Offset);
Buffer = (KeyData09 << Shift);
ret_val = XLNX_Environment_Wrapper_Write32_WithMask(ContextPtr->UserEnvironment.Device_IO.Write32WithMask, ContextPtr->UserContextPtr, WorkingAddr, Buffer, Mask);
return ret_val;
}
void XLNX_COMP_BCAM_BuildCompBcamBaseKeyData09KeyData09(uint32_t* MaskPtr, uint32_t* ValPtr, uint32_t KeyData09)
{
*MaskPtr |= COMP_BCAM_BASE_KEY_DATA_09_KEY_DATA_09_MASK;
*ValPtr |= (KeyData09 << COMP_BCAM_BASE_KEY_DATA_09_KEY_DATA_09_SHIFT);
}
XLNX_ERROR_CODE XLNX_COMP_BCAM_GetCompBcamBaseKeyData09KeyData09(XLNX_COMP_BCAM_CONTEXT_TYPE* ContextPtr, uint32_t* KeyData09Ptr)
{
XLNX_ERROR_CODE ret_val = XLNX_OK;
uint32_t Offset, Mask, Shift, Buffer;
XLNX_COMPONENT_ADDRESS_TYPE WorkingAddr;
Offset = (COMP_BCAM_BASE_KEY_DATA_09_REG_OFFSET);
Mask = COMP_BCAM_BASE_KEY_DATA_09_KEY_DATA_09_MASK;
Shift = COMP_BCAM_BASE_KEY_DATA_09_KEY_DATA_09_SHIFT;
WorkingAddr = (XLNX_COMPONENT_ADDRESS_TYPE)((ContextPtr->ComponentBaseAddress) + Offset);
ret_val = XLNX_Environment_Wrapper_Read32(ContextPtr->UserEnvironment.Device_IO.Read32, ContextPtr->UserContextPtr, &Buffer, WorkingAddr);
if (XLNX_OK == ret_val)
{
*KeyData09Ptr = ((Buffer & Mask) >> Shift);
}
return ret_val;
}
XLNX_ERROR_CODE XLNX_COMP_BCAM_SetCompBcamBaseKeyData09Reg(XLNX_COMP_BCAM_CONTEXT_TYPE* ContextPtr, uint32_t Mask, uint32_t Value)
{
XLNX_ERROR_CODE ret_val = XLNX_OK;
uint32_t Offset;
XLNX_COMPONENT_ADDRESS_TYPE WorkingAddr;
Offset = (COMP_BCAM_BASE_KEY_DATA_09_REG_OFFSET);
WorkingAddr = (XLNX_COMPONENT_ADDRESS_TYPE)((ContextPtr->ComponentBaseAddress) + Offset);
ret_val = XLNX_Environment_Wrapper_Write32_WithMask(ContextPtr->UserEnvironment.Device_IO.Write32WithMask, ContextPtr->UserContextPtr, WorkingAddr, Value, Mask);
return ret_val;
}
XLNX_ERROR_CODE XLNX_COMP_BCAM_GetCompBcamBaseKeyData09Reg(XLNX_COMP_BCAM_CONTEXT_TYPE* ContextPtr, uint32_t* ValuePtr)
{
XLNX_ERROR_CODE ret_val = XLNX_OK;
uint32_t Offset;
XLNX_COMPONENT_ADDRESS_TYPE WorkingAddr;
Offset = (COMP_BCAM_BASE_KEY_DATA_09_REG_OFFSET);
WorkingAddr = (XLNX_COMPONENT_ADDRESS_TYPE)((ContextPtr->ComponentBaseAddress) + Offset);
ret_val = XLNX_Environment_Wrapper_Read32(ContextPtr->UserEnvironment.Device_IO.Read32, ContextPtr->UserContextPtr, ValuePtr, WorkingAddr);
return ret_val;
}
XLNX_ERROR_CODE XLNX_COMP_BCAM_SetCompBcamBaseKeyData10KeyData10(XLNX_COMP_BCAM_CONTEXT_TYPE* ContextPtr, uint32_t KeyData10)
{
XLNX_ERROR_CODE ret_val = XLNX_OK;
uint32_t Offset, Mask, Shift, Buffer;
XLNX_COMPONENT_ADDRESS_TYPE WorkingAddr;
Offset = (COMP_BCAM_BASE_KEY_DATA_10_REG_OFFSET);
Mask = COMP_BCAM_BASE_KEY_DATA_10_KEY_DATA_10_MASK;
Shift = COMP_BCAM_BASE_KEY_DATA_10_KEY_DATA_10_SHIFT;
WorkingAddr = (XLNX_COMPONENT_ADDRESS_TYPE)((ContextPtr->ComponentBaseAddress) + Offset);
Buffer = (KeyData10 << Shift);
ret_val = XLNX_Environment_Wrapper_Write32_WithMask(ContextPtr->UserEnvironment.Device_IO.Write32WithMask, ContextPtr->UserContextPtr, WorkingAddr, Buffer, Mask);
return ret_val;
}
void XLNX_COMP_BCAM_BuildCompBcamBaseKeyData10KeyData10(uint32_t* MaskPtr, uint32_t* ValPtr, uint32_t KeyData10)
{
*MaskPtr |= COMP_BCAM_BASE_KEY_DATA_10_KEY_DATA_10_MASK;
*ValPtr |= (KeyData10 << COMP_BCAM_BASE_KEY_DATA_10_KEY_DATA_10_SHIFT);
}
XLNX_ERROR_CODE XLNX_COMP_BCAM_GetCompBcamBaseKeyData10KeyData10(XLNX_COMP_BCAM_CONTEXT_TYPE* ContextPtr, uint32_t* KeyData10Ptr)
{
XLNX_ERROR_CODE ret_val = XLNX_OK;
uint32_t Offset, Mask, Shift, Buffer;
XLNX_COMPONENT_ADDRESS_TYPE WorkingAddr;
Offset = (COMP_BCAM_BASE_KEY_DATA_10_REG_OFFSET);
Mask = COMP_BCAM_BASE_KEY_DATA_10_KEY_DATA_10_MASK;
Shift = COMP_BCAM_BASE_KEY_DATA_10_KEY_DATA_10_SHIFT;
WorkingAddr = (XLNX_COMPONENT_ADDRESS_TYPE)((ContextPtr->ComponentBaseAddress) + Offset);
ret_val = XLNX_Environment_Wrapper_Read32(ContextPtr->UserEnvironment.Device_IO.Read32, ContextPtr->UserContextPtr, &Buffer, WorkingAddr);
if (XLNX_OK == ret_val)
{
*KeyData10Ptr = ((Buffer & Mask) >> Shift);
}
return ret_val;
}
XLNX_ERROR_CODE XLNX_COMP_BCAM_SetCompBcamBaseKeyData10Reg(XLNX_COMP_BCAM_CONTEXT_TYPE* ContextPtr, uint32_t Mask, uint32_t Value)
{
XLNX_ERROR_CODE ret_val = XLNX_OK;
uint32_t Offset;
XLNX_COMPONENT_ADDRESS_TYPE WorkingAddr;
Offset = (COMP_BCAM_BASE_KEY_DATA_10_REG_OFFSET);
WorkingAddr = (XLNX_COMPONENT_ADDRESS_TYPE)((ContextPtr->ComponentBaseAddress) + Offset);
ret_val = XLNX_Environment_Wrapper_Write32_WithMask(ContextPtr->UserEnvironment.Device_IO.Write32WithMask, ContextPtr->UserContextPtr, WorkingAddr, Value, Mask);
return ret_val;
}
XLNX_ERROR_CODE XLNX_COMP_BCAM_GetCompBcamBaseKeyData10Reg(XLNX_COMP_BCAM_CONTEXT_TYPE* ContextPtr, uint32_t* ValuePtr)
{
XLNX_ERROR_CODE ret_val = XLNX_OK;
uint32_t Offset;
XLNX_COMPONENT_ADDRESS_TYPE WorkingAddr;
Offset = (COMP_BCAM_BASE_KEY_DATA_10_REG_OFFSET);
WorkingAddr = (XLNX_COMPONENT_ADDRESS_TYPE)((ContextPtr->ComponentBaseAddress) + Offset);
ret_val = XLNX_Environment_Wrapper_Read32(ContextPtr->UserEnvironment.Device_IO.Read32, ContextPtr->UserContextPtr, ValuePtr, WorkingAddr);
return ret_val;
}
XLNX_ERROR_CODE XLNX_COMP_BCAM_SetCompBcamBaseKeyData11KeyData11(XLNX_COMP_BCAM_CONTEXT_TYPE* ContextPtr, uint32_t KeyData11)
{
XLNX_ERROR_CODE ret_val = XLNX_OK;
uint32_t Offset, Mask, Shift, Buffer;
XLNX_COMPONENT_ADDRESS_TYPE WorkingAddr;
Offset = (COMP_BCAM_BASE_KEY_DATA_11_REG_OFFSET);
Mask = COMP_BCAM_BASE_KEY_DATA_11_KEY_DATA_11_MASK;
Shift = COMP_BCAM_BASE_KEY_DATA_11_KEY_DATA_11_SHIFT;
WorkingAddr = (XLNX_COMPONENT_ADDRESS_TYPE)((ContextPtr->ComponentBaseAddress) + Offset);
Buffer = (KeyData11 << Shift);
ret_val = XLNX_Environment_Wrapper_Write32_WithMask(ContextPtr->UserEnvironment.Device_IO.Write32WithMask, ContextPtr->UserContextPtr, WorkingAddr, Buffer, Mask);
return ret_val;
}
void XLNX_COMP_BCAM_BuildCompBcamBaseKeyData11KeyData11(uint32_t* MaskPtr, uint32_t* ValPtr, uint32_t KeyData11)
{
*MaskPtr |= COMP_BCAM_BASE_KEY_DATA_11_KEY_DATA_11_MASK;
*ValPtr |= (KeyData11 << COMP_BCAM_BASE_KEY_DATA_11_KEY_DATA_11_SHIFT);
}
XLNX_ERROR_CODE XLNX_COMP_BCAM_GetCompBcamBaseKeyData11KeyData11(XLNX_COMP_BCAM_CONTEXT_TYPE* ContextPtr, uint32_t* KeyData11Ptr)
{
XLNX_ERROR_CODE ret_val = XLNX_OK;
uint32_t Offset, Mask, Shift, Buffer;
XLNX_COMPONENT_ADDRESS_TYPE WorkingAddr;
Offset = (COMP_BCAM_BASE_KEY_DATA_11_REG_OFFSET);
Mask = COMP_BCAM_BASE_KEY_DATA_11_KEY_DATA_11_MASK;
Shift = COMP_BCAM_BASE_KEY_DATA_11_KEY_DATA_11_SHIFT;
WorkingAddr = (XLNX_COMPONENT_ADDRESS_TYPE)((ContextPtr->ComponentBaseAddress) + Offset);
ret_val = XLNX_Environment_Wrapper_Read32(ContextPtr->UserEnvironment.Device_IO.Read32, ContextPtr->UserContextPtr, &Buffer, WorkingAddr);
if (XLNX_OK == ret_val)
{
*KeyData11Ptr = ((Buffer & Mask) >> Shift);
}
return ret_val;
}
XLNX_ERROR_CODE XLNX_COMP_BCAM_SetCompBcamBaseKeyData11Reg(XLNX_COMP_BCAM_CONTEXT_TYPE* ContextPtr, uint32_t Mask, uint32_t Value)
{
XLNX_ERROR_CODE ret_val = XLNX_OK;
uint32_t Offset;
XLNX_COMPONENT_ADDRESS_TYPE WorkingAddr;
Offset = (COMP_BCAM_BASE_KEY_DATA_11_REG_OFFSET);
WorkingAddr = (XLNX_COMPONENT_ADDRESS_TYPE)((ContextPtr->ComponentBaseAddress) + Offset);
ret_val = XLNX_Environment_Wrapper_Write32_WithMask(ContextPtr->UserEnvironment.Device_IO.Write32WithMask, ContextPtr->UserContextPtr, WorkingAddr, Value, Mask);
return ret_val;
}
XLNX_ERROR_CODE XLNX_COMP_BCAM_GetCompBcamBaseKeyData11Reg(XLNX_COMP_BCAM_CONTEXT_TYPE* ContextPtr, uint32_t* ValuePtr)
{
XLNX_ERROR_CODE ret_val = XLNX_OK;
uint32_t Offset;
XLNX_COMPONENT_ADDRESS_TYPE WorkingAddr;
Offset = (COMP_BCAM_BASE_KEY_DATA_11_REG_OFFSET);
WorkingAddr = (XLNX_COMPONENT_ADDRESS_TYPE)((ContextPtr->ComponentBaseAddress) + Offset);
ret_val = XLNX_Environment_Wrapper_Read32(ContextPtr->UserEnvironment.Device_IO.Read32, ContextPtr->UserContextPtr, ValuePtr, WorkingAddr);
return ret_val;
}
XLNX_ERROR_CODE XLNX_COMP_BCAM_SetCompBcamBaseKeyData12KeyData12(XLNX_COMP_BCAM_CONTEXT_TYPE* ContextPtr, uint32_t KeyData12)
{
XLNX_ERROR_CODE ret_val = XLNX_OK;
uint32_t Offset, Mask, Shift, Buffer;
XLNX_COMPONENT_ADDRESS_TYPE WorkingAddr;
Offset = (COMP_BCAM_BASE_KEY_DATA_12_REG_OFFSET);
Mask = COMP_BCAM_BASE_KEY_DATA_12_KEY_DATA_12_MASK;
Shift = COMP_BCAM_BASE_KEY_DATA_12_KEY_DATA_12_SHIFT;
WorkingAddr = (XLNX_COMPONENT_ADDRESS_TYPE)((ContextPtr->ComponentBaseAddress) + Offset);
Buffer = (KeyData12 << Shift);
ret_val = XLNX_Environment_Wrapper_Write32_WithMask(ContextPtr->UserEnvironment.Device_IO.Write32WithMask, ContextPtr->UserContextPtr, WorkingAddr, Buffer, Mask);
return ret_val;
}
void XLNX_COMP_BCAM_BuildCompBcamBaseKeyData12KeyData12(uint32_t* MaskPtr, uint32_t* ValPtr, uint32_t KeyData12)
{
*MaskPtr |= COMP_BCAM_BASE_KEY_DATA_12_KEY_DATA_12_MASK;
*ValPtr |= (KeyData12 << COMP_BCAM_BASE_KEY_DATA_12_KEY_DATA_12_SHIFT);
}
XLNX_ERROR_CODE XLNX_COMP_BCAM_GetCompBcamBaseKeyData12KeyData12(XLNX_COMP_BCAM_CONTEXT_TYPE* ContextPtr, uint32_t* KeyData12Ptr)
{
XLNX_ERROR_CODE ret_val = XLNX_OK;
uint32_t Offset, Mask, Shift, Buffer;
XLNX_COMPONENT_ADDRESS_TYPE WorkingAddr;
Offset = (COMP_BCAM_BASE_KEY_DATA_12_REG_OFFSET);
Mask = COMP_BCAM_BASE_KEY_DATA_12_KEY_DATA_12_MASK;
Shift = COMP_BCAM_BASE_KEY_DATA_12_KEY_DATA_12_SHIFT;
WorkingAddr = (XLNX_COMPONENT_ADDRESS_TYPE)((ContextPtr->ComponentBaseAddress) + Offset);
ret_val = XLNX_Environment_Wrapper_Read32(ContextPtr->UserEnvironment.Device_IO.Read32, ContextPtr->UserContextPtr, &Buffer, WorkingAddr);
if (XLNX_OK == ret_val)
{
*KeyData12Ptr = ((Buffer & Mask) >> Shift);
}
return ret_val;
}
XLNX_ERROR_CODE XLNX_COMP_BCAM_SetCompBcamBaseKeyData12Reg(XLNX_COMP_BCAM_CONTEXT_TYPE* ContextPtr, uint32_t Mask, uint32_t Value)
{
XLNX_ERROR_CODE ret_val = XLNX_OK;
uint32_t Offset;
XLNX_COMPONENT_ADDRESS_TYPE WorkingAddr;
Offset = (COMP_BCAM_BASE_KEY_DATA_12_REG_OFFSET);
WorkingAddr = (XLNX_COMPONENT_ADDRESS_TYPE)((ContextPtr->ComponentBaseAddress) + Offset);
ret_val = XLNX_Environment_Wrapper_Write32_WithMask(ContextPtr->UserEnvironment.Device_IO.Write32WithMask, ContextPtr->UserContextPtr, WorkingAddr, Value, Mask);
return ret_val;
}
XLNX_ERROR_CODE XLNX_COMP_BCAM_GetCompBcamBaseKeyData12Reg(XLNX_COMP_BCAM_CONTEXT_TYPE* ContextPtr, uint32_t* ValuePtr)
{
XLNX_ERROR_CODE ret_val = XLNX_OK;
uint32_t Offset;
XLNX_COMPONENT_ADDRESS_TYPE WorkingAddr;
Offset = (COMP_BCAM_BASE_KEY_DATA_12_REG_OFFSET);
WorkingAddr = (XLNX_COMPONENT_ADDRESS_TYPE)((ContextPtr->ComponentBaseAddress) + Offset);
ret_val = XLNX_Environment_Wrapper_Read32(ContextPtr->UserEnvironment.Device_IO.Read32, ContextPtr->UserContextPtr, ValuePtr, WorkingAddr);
return ret_val;
}
XLNX_ERROR_CODE XLNX_COMP_BCAM_SetCompBcamBaseKeyData13KeyData13(XLNX_COMP_BCAM_CONTEXT_TYPE* ContextPtr, uint32_t KeyData13)
{
XLNX_ERROR_CODE ret_val = XLNX_OK;
uint32_t Offset, Mask, Shift, Buffer;
XLNX_COMPONENT_ADDRESS_TYPE WorkingAddr;
Offset = (COMP_BCAM_BASE_KEY_DATA_13_REG_OFFSET);
Mask = COMP_BCAM_BASE_KEY_DATA_13_KEY_DATA_13_MASK;
Shift = COMP_BCAM_BASE_KEY_DATA_13_KEY_DATA_13_SHIFT;
WorkingAddr = (XLNX_COMPONENT_ADDRESS_TYPE)((ContextPtr->ComponentBaseAddress) + Offset);
Buffer = (KeyData13 << Shift);
ret_val = XLNX_Environment_Wrapper_Write32_WithMask(ContextPtr->UserEnvironment.Device_IO.Write32WithMask, ContextPtr->UserContextPtr, WorkingAddr, Buffer, Mask);
return ret_val;
}
void XLNX_COMP_BCAM_BuildCompBcamBaseKeyData13KeyData13(uint32_t* MaskPtr, uint32_t* ValPtr, uint32_t KeyData13)
{
*MaskPtr |= COMP_BCAM_BASE_KEY_DATA_13_KEY_DATA_13_MASK;
*ValPtr |= (KeyData13 << COMP_BCAM_BASE_KEY_DATA_13_KEY_DATA_13_SHIFT);
}
XLNX_ERROR_CODE XLNX_COMP_BCAM_GetCompBcamBaseKeyData13KeyData13(XLNX_COMP_BCAM_CONTEXT_TYPE* ContextPtr, uint32_t* KeyData13Ptr)
{
XLNX_ERROR_CODE ret_val = XLNX_OK;
uint32_t Offset, Mask, Shift, Buffer;
XLNX_COMPONENT_ADDRESS_TYPE WorkingAddr;
Offset = (COMP_BCAM_BASE_KEY_DATA_13_REG_OFFSET);
Mask = COMP_BCAM_BASE_KEY_DATA_13_KEY_DATA_13_MASK;
Shift = COMP_BCAM_BASE_KEY_DATA_13_KEY_DATA_13_SHIFT;
WorkingAddr = (XLNX_COMPONENT_ADDRESS_TYPE)((ContextPtr->ComponentBaseAddress) + Offset);
ret_val = XLNX_Environment_Wrapper_Read32(ContextPtr->UserEnvironment.Device_IO.Read32, ContextPtr->UserContextPtr, &Buffer, WorkingAddr);
if (XLNX_OK == ret_val)
{
*KeyData13Ptr = ((Buffer & Mask) >> Shift);
}
return ret_val;
}
XLNX_ERROR_CODE XLNX_COMP_BCAM_SetCompBcamBaseKeyData13Reg(XLNX_COMP_BCAM_CONTEXT_TYPE* ContextPtr, uint32_t Mask, uint32_t Value)
{
XLNX_ERROR_CODE ret_val = XLNX_OK;
uint32_t Offset;
XLNX_COMPONENT_ADDRESS_TYPE WorkingAddr;
Offset = (COMP_BCAM_BASE_KEY_DATA_13_REG_OFFSET);
WorkingAddr = (XLNX_COMPONENT_ADDRESS_TYPE)((ContextPtr->ComponentBaseAddress) + Offset);
ret_val = XLNX_Environment_Wrapper_Write32_WithMask(ContextPtr->UserEnvironment.Device_IO.Write32WithMask, ContextPtr->UserContextPtr, WorkingAddr, Value, Mask);
return ret_val;
}
XLNX_ERROR_CODE XLNX_COMP_BCAM_GetCompBcamBaseKeyData13Reg(XLNX_COMP_BCAM_CONTEXT_TYPE* ContextPtr, uint32_t* ValuePtr)
{
XLNX_ERROR_CODE ret_val = XLNX_OK;
uint32_t Offset;
XLNX_COMPONENT_ADDRESS_TYPE WorkingAddr;
Offset = (COMP_BCAM_BASE_KEY_DATA_13_REG_OFFSET);
WorkingAddr = (XLNX_COMPONENT_ADDRESS_TYPE)((ContextPtr->ComponentBaseAddress) + Offset);
ret_val = XLNX_Environment_Wrapper_Read32(ContextPtr->UserEnvironment.Device_IO.Read32, ContextPtr->UserContextPtr, ValuePtr, WorkingAddr);
return ret_val;
}
XLNX_ERROR_CODE XLNX_COMP_BCAM_SetCompBcamBaseKeyData14KeyData14(XLNX_COMP_BCAM_CONTEXT_TYPE* ContextPtr, uint32_t KeyData14)
{
XLNX_ERROR_CODE ret_val = XLNX_OK;
uint32_t Offset, Mask, Shift, Buffer;
XLNX_COMPONENT_ADDRESS_TYPE WorkingAddr;
Offset = (COMP_BCAM_BASE_KEY_DATA_14_REG_OFFSET);
Mask = COMP_BCAM_BASE_KEY_DATA_14_KEY_DATA_14_MASK;
Shift = COMP_BCAM_BASE_KEY_DATA_14_KEY_DATA_14_SHIFT;
WorkingAddr = (XLNX_COMPONENT_ADDRESS_TYPE)((ContextPtr->ComponentBaseAddress) + Offset);
Buffer = (KeyData14 << Shift);
ret_val = XLNX_Environment_Wrapper_Write32_WithMask(ContextPtr->UserEnvironment.Device_IO.Write32WithMask, ContextPtr->UserContextPtr, WorkingAddr, Buffer, Mask);
return ret_val;
}
void XLNX_COMP_BCAM_BuildCompBcamBaseKeyData14KeyData14(uint32_t* MaskPtr, uint32_t* ValPtr, uint32_t KeyData14)
{
*MaskPtr |= COMP_BCAM_BASE_KEY_DATA_14_KEY_DATA_14_MASK;
*ValPtr |= (KeyData14 << COMP_BCAM_BASE_KEY_DATA_14_KEY_DATA_14_SHIFT);
}
XLNX_ERROR_CODE XLNX_COMP_BCAM_GetCompBcamBaseKeyData14KeyData14(XLNX_COMP_BCAM_CONTEXT_TYPE* ContextPtr, uint32_t* KeyData14Ptr)
{
XLNX_ERROR_CODE ret_val = XLNX_OK;
uint32_t Offset, Mask, Shift, Buffer;
XLNX_COMPONENT_ADDRESS_TYPE WorkingAddr;
Offset = (COMP_BCAM_BASE_KEY_DATA_14_REG_OFFSET);
Mask = COMP_BCAM_BASE_KEY_DATA_14_KEY_DATA_14_MASK;
Shift = COMP_BCAM_BASE_KEY_DATA_14_KEY_DATA_14_SHIFT;
WorkingAddr = (XLNX_COMPONENT_ADDRESS_TYPE)((ContextPtr->ComponentBaseAddress) + Offset);
ret_val = XLNX_Environment_Wrapper_Read32(ContextPtr->UserEnvironment.Device_IO.Read32, ContextPtr->UserContextPtr, &Buffer, WorkingAddr);
if (XLNX_OK == ret_val)
{
*KeyData14Ptr = ((Buffer & Mask) >> Shift);
}
return ret_val;
}
XLNX_ERROR_CODE XLNX_COMP_BCAM_SetCompBcamBaseKeyData14Reg(XLNX_COMP_BCAM_CONTEXT_TYPE* ContextPtr, uint32_t Mask, uint32_t Value)
{
XLNX_ERROR_CODE ret_val = XLNX_OK;
uint32_t Offset;
XLNX_COMPONENT_ADDRESS_TYPE WorkingAddr;
Offset = (COMP_BCAM_BASE_KEY_DATA_14_REG_OFFSET);
WorkingAddr = (XLNX_COMPONENT_ADDRESS_TYPE)((ContextPtr->ComponentBaseAddress) + Offset);
ret_val = XLNX_Environment_Wrapper_Write32_WithMask(ContextPtr->UserEnvironment.Device_IO.Write32WithMask, ContextPtr->UserContextPtr, WorkingAddr, Value, Mask);
return ret_val;
}
XLNX_ERROR_CODE XLNX_COMP_BCAM_GetCompBcamBaseKeyData14Reg(XLNX_COMP_BCAM_CONTEXT_TYPE* ContextPtr, uint32_t* ValuePtr)
{
XLNX_ERROR_CODE ret_val = XLNX_OK;
uint32_t Offset;
XLNX_COMPONENT_ADDRESS_TYPE WorkingAddr;
Offset = (COMP_BCAM_BASE_KEY_DATA_14_REG_OFFSET);
WorkingAddr = (XLNX_COMPONENT_ADDRESS_TYPE)((ContextPtr->ComponentBaseAddress) + Offset);
ret_val = XLNX_Environment_Wrapper_Read32(ContextPtr->UserEnvironment.Device_IO.Read32, ContextPtr->UserContextPtr, ValuePtr, WorkingAddr);
return ret_val;
}
XLNX_ERROR_CODE XLNX_COMP_BCAM_SetCompBcamBaseKeyData15KeyData15(XLNX_COMP_BCAM_CONTEXT_TYPE* ContextPtr, uint32_t KeyData15)
{
XLNX_ERROR_CODE ret_val = XLNX_OK;
uint32_t Offset, Mask, Shift, Buffer;
XLNX_COMPONENT_ADDRESS_TYPE WorkingAddr;
Offset = (COMP_BCAM_BASE_KEY_DATA_15_REG_OFFSET);
Mask = COMP_BCAM_BASE_KEY_DATA_15_KEY_DATA_15_MASK;
Shift = COMP_BCAM_BASE_KEY_DATA_15_KEY_DATA_15_SHIFT;
WorkingAddr = (XLNX_COMPONENT_ADDRESS_TYPE)((ContextPtr->ComponentBaseAddress) + Offset);
Buffer = (KeyData15 << Shift);
ret_val = XLNX_Environment_Wrapper_Write32_WithMask(ContextPtr->UserEnvironment.Device_IO.Write32WithMask, ContextPtr->UserContextPtr, WorkingAddr, Buffer, Mask);
return ret_val;
}
void XLNX_COMP_BCAM_BuildCompBcamBaseKeyData15KeyData15(uint32_t* MaskPtr, uint32_t* ValPtr, uint32_t KeyData15)
{
*MaskPtr |= COMP_BCAM_BASE_KEY_DATA_15_KEY_DATA_15_MASK;
*ValPtr |= (KeyData15 << COMP_BCAM_BASE_KEY_DATA_15_KEY_DATA_15_SHIFT);
}
XLNX_ERROR_CODE XLNX_COMP_BCAM_GetCompBcamBaseKeyData15KeyData15(XLNX_COMP_BCAM_CONTEXT_TYPE* ContextPtr, uint32_t* KeyData15Ptr)
{
XLNX_ERROR_CODE ret_val = XLNX_OK;
uint32_t Offset, Mask, Shift, Buffer;
XLNX_COMPONENT_ADDRESS_TYPE WorkingAddr;
Offset = (COMP_BCAM_BASE_KEY_DATA_15_REG_OFFSET);
Mask = COMP_BCAM_BASE_KEY_DATA_15_KEY_DATA_15_MASK;
Shift = COMP_BCAM_BASE_KEY_DATA_15_KEY_DATA_15_SHIFT;
WorkingAddr = (XLNX_COMPONENT_ADDRESS_TYPE)((ContextPtr->ComponentBaseAddress) + Offset);
ret_val = XLNX_Environment_Wrapper_Read32(ContextPtr->UserEnvironment.Device_IO.Read32, ContextPtr->UserContextPtr, &Buffer, WorkingAddr);
if (XLNX_OK == ret_val)
{
*KeyData15Ptr = ((Buffer & Mask) >> Shift);
}
return ret_val;
}
XLNX_ERROR_CODE XLNX_COMP_BCAM_SetCompBcamBaseKeyData15Reg(XLNX_COMP_BCAM_CONTEXT_TYPE* ContextPtr, uint32_t Mask, uint32_t Value)
{
XLNX_ERROR_CODE ret_val = XLNX_OK;
uint32_t Offset;
XLNX_COMPONENT_ADDRESS_TYPE WorkingAddr;
Offset = (COMP_BCAM_BASE_KEY_DATA_15_REG_OFFSET);
WorkingAddr = (XLNX_COMPONENT_ADDRESS_TYPE)((ContextPtr->ComponentBaseAddress) + Offset);
ret_val = XLNX_Environment_Wrapper_Write32_WithMask(ContextPtr->UserEnvironment.Device_IO.Write32WithMask, ContextPtr->UserContextPtr, WorkingAddr, Value, Mask);
return ret_val;
}
XLNX_ERROR_CODE XLNX_COMP_BCAM_GetCompBcamBaseKeyData15Reg(XLNX_COMP_BCAM_CONTEXT_TYPE* ContextPtr, uint32_t* ValuePtr)
{
XLNX_ERROR_CODE ret_val = XLNX_OK;
uint32_t Offset;
XLNX_COMPONENT_ADDRESS_TYPE WorkingAddr;
Offset = (COMP_BCAM_BASE_KEY_DATA_15_REG_OFFSET);
WorkingAddr = (XLNX_COMPONENT_ADDRESS_TYPE)((ContextPtr->ComponentBaseAddress) + Offset);
ret_val = XLNX_Environment_Wrapper_Read32(ContextPtr->UserEnvironment.Device_IO.Read32, ContextPtr->UserContextPtr, ValuePtr, WorkingAddr);
return ret_val;
}
XLNX_ERROR_CODE XLNX_COMP_BCAM_SetCompBcamBaseKeyData16KeyData16(XLNX_COMP_BCAM_CONTEXT_TYPE* ContextPtr, uint32_t KeyData16)
{
XLNX_ERROR_CODE ret_val = XLNX_OK;
uint32_t Offset, Mask, Shift, Buffer;
XLNX_COMPONENT_ADDRESS_TYPE WorkingAddr;
Offset = (COMP_BCAM_BASE_KEY_DATA_16_REG_OFFSET);
Mask = COMP_BCAM_BASE_KEY_DATA_16_KEY_DATA_16_MASK;
Shift = COMP_BCAM_BASE_KEY_DATA_16_KEY_DATA_16_SHIFT;
WorkingAddr = (XLNX_COMPONENT_ADDRESS_TYPE)((ContextPtr->ComponentBaseAddress) + Offset);
Buffer = (KeyData16 << Shift);
ret_val = XLNX_Environment_Wrapper_Write32_WithMask(ContextPtr->UserEnvironment.Device_IO.Write32WithMask, ContextPtr->UserContextPtr, WorkingAddr, Buffer, Mask);
return ret_val;
}
void XLNX_COMP_BCAM_BuildCompBcamBaseKeyData16KeyData16(uint32_t* MaskPtr, uint32_t* ValPtr, uint32_t KeyData16)
{
*MaskPtr |= COMP_BCAM_BASE_KEY_DATA_16_KEY_DATA_16_MASK;
*ValPtr |= (KeyData16 << COMP_BCAM_BASE_KEY_DATA_16_KEY_DATA_16_SHIFT);
}
XLNX_ERROR_CODE XLNX_COMP_BCAM_GetCompBcamBaseKeyData16KeyData16(XLNX_COMP_BCAM_CONTEXT_TYPE* ContextPtr, uint32_t* KeyData16Ptr)
{
XLNX_ERROR_CODE ret_val = XLNX_OK;
uint32_t Offset, Mask, Shift, Buffer;
XLNX_COMPONENT_ADDRESS_TYPE WorkingAddr;
Offset = (COMP_BCAM_BASE_KEY_DATA_16_REG_OFFSET);
Mask = COMP_BCAM_BASE_KEY_DATA_16_KEY_DATA_16_MASK;
Shift = COMP_BCAM_BASE_KEY_DATA_16_KEY_DATA_16_SHIFT;
WorkingAddr = (XLNX_COMPONENT_ADDRESS_TYPE)((ContextPtr->ComponentBaseAddress) + Offset);
ret_val = XLNX_Environment_Wrapper_Read32(ContextPtr->UserEnvironment.Device_IO.Read32, ContextPtr->UserContextPtr, &Buffer, WorkingAddr);
if (XLNX_OK == ret_val)
{
*KeyData16Ptr = ((Buffer & Mask) >> Shift);
}
return ret_val;
}
XLNX_ERROR_CODE XLNX_COMP_BCAM_SetCompBcamBaseKeyData16Reg(XLNX_COMP_BCAM_CONTEXT_TYPE* ContextPtr, uint32_t Mask, uint32_t Value)
{
XLNX_ERROR_CODE ret_val = XLNX_OK;
uint32_t Offset;
XLNX_COMPONENT_ADDRESS_TYPE WorkingAddr;
Offset = (COMP_BCAM_BASE_KEY_DATA_16_REG_OFFSET);
WorkingAddr = (XLNX_COMPONENT_ADDRESS_TYPE)((ContextPtr->ComponentBaseAddress) + Offset);
ret_val = XLNX_Environment_Wrapper_Write32_WithMask(ContextPtr->UserEnvironment.Device_IO.Write32WithMask, ContextPtr->UserContextPtr, WorkingAddr, Value, Mask);
return ret_val;
}
XLNX_ERROR_CODE XLNX_COMP_BCAM_GetCompBcamBaseKeyData16Reg(XLNX_COMP_BCAM_CONTEXT_TYPE* ContextPtr, uint32_t* ValuePtr)
{
XLNX_ERROR_CODE ret_val = XLNX_OK;
uint32_t Offset;
XLNX_COMPONENT_ADDRESS_TYPE WorkingAddr;
Offset = (COMP_BCAM_BASE_KEY_DATA_16_REG_OFFSET);
WorkingAddr = (XLNX_COMPONENT_ADDRESS_TYPE)((ContextPtr->ComponentBaseAddress) + Offset);
ret_val = XLNX_Environment_Wrapper_Read32(ContextPtr->UserEnvironment.Device_IO.Read32, ContextPtr->UserContextPtr, ValuePtr, WorkingAddr);
return ret_val;
}
XLNX_ERROR_CODE XLNX_COMP_BCAM_SetCompBcamBaseKeyData17KeyData17(XLNX_COMP_BCAM_CONTEXT_TYPE* ContextPtr, uint32_t KeyData17)
{
XLNX_ERROR_CODE ret_val = XLNX_OK;
uint32_t Offset, Mask, Shift, Buffer;
XLNX_COMPONENT_ADDRESS_TYPE WorkingAddr;
Offset = (COMP_BCAM_BASE_KEY_DATA_17_REG_OFFSET);
Mask = COMP_BCAM_BASE_KEY_DATA_17_KEY_DATA_17_MASK;
Shift = COMP_BCAM_BASE_KEY_DATA_17_KEY_DATA_17_SHIFT;
WorkingAddr = (XLNX_COMPONENT_ADDRESS_TYPE)((ContextPtr->ComponentBaseAddress) + Offset);
Buffer = (KeyData17 << Shift);
ret_val = XLNX_Environment_Wrapper_Write32_WithMask(ContextPtr->UserEnvironment.Device_IO.Write32WithMask, ContextPtr->UserContextPtr, WorkingAddr, Buffer, Mask);
return ret_val;
}
void XLNX_COMP_BCAM_BuildCompBcamBaseKeyData17KeyData17(uint32_t* MaskPtr, uint32_t* ValPtr, uint32_t KeyData17)
{
*MaskPtr |= COMP_BCAM_BASE_KEY_DATA_17_KEY_DATA_17_MASK;
*ValPtr |= (KeyData17 << COMP_BCAM_BASE_KEY_DATA_17_KEY_DATA_17_SHIFT);
}
XLNX_ERROR_CODE XLNX_COMP_BCAM_GetCompBcamBaseKeyData17KeyData17(XLNX_COMP_BCAM_CONTEXT_TYPE* ContextPtr, uint32_t* KeyData17Ptr)
{
XLNX_ERROR_CODE ret_val = XLNX_OK;
uint32_t Offset, Mask, Shift, Buffer;
XLNX_COMPONENT_ADDRESS_TYPE WorkingAddr;
Offset = (COMP_BCAM_BASE_KEY_DATA_17_REG_OFFSET);
Mask = COMP_BCAM_BASE_KEY_DATA_17_KEY_DATA_17_MASK;
Shift = COMP_BCAM_BASE_KEY_DATA_17_KEY_DATA_17_SHIFT;
WorkingAddr = (XLNX_COMPONENT_ADDRESS_TYPE)((ContextPtr->ComponentBaseAddress) + Offset);
ret_val = XLNX_Environment_Wrapper_Read32(ContextPtr->UserEnvironment.Device_IO.Read32, ContextPtr->UserContextPtr, &Buffer, WorkingAddr);
if (XLNX_OK == ret_val)
{
*KeyData17Ptr = ((Buffer & Mask) >> Shift);
}
return ret_val;
}
XLNX_ERROR_CODE XLNX_COMP_BCAM_SetCompBcamBaseKeyData17Reg(XLNX_COMP_BCAM_CONTEXT_TYPE* ContextPtr, uint32_t Mask, uint32_t Value)
{
XLNX_ERROR_CODE ret_val = XLNX_OK;
uint32_t Offset;
XLNX_COMPONENT_ADDRESS_TYPE WorkingAddr;
Offset = (COMP_BCAM_BASE_KEY_DATA_17_REG_OFFSET);
WorkingAddr = (XLNX_COMPONENT_ADDRESS_TYPE)((ContextPtr->ComponentBaseAddress) + Offset);
ret_val = XLNX_Environment_Wrapper_Write32_WithMask(ContextPtr->UserEnvironment.Device_IO.Write32WithMask, ContextPtr->UserContextPtr, WorkingAddr, Value, Mask);
return ret_val;
}
XLNX_ERROR_CODE XLNX_COMP_BCAM_GetCompBcamBaseKeyData17Reg(XLNX_COMP_BCAM_CONTEXT_TYPE* ContextPtr, uint32_t* ValuePtr)
{
XLNX_ERROR_CODE ret_val = XLNX_OK;
uint32_t Offset;
XLNX_COMPONENT_ADDRESS_TYPE WorkingAddr;
Offset = (COMP_BCAM_BASE_KEY_DATA_17_REG_OFFSET);
WorkingAddr = (XLNX_COMPONENT_ADDRESS_TYPE)((ContextPtr->ComponentBaseAddress) + Offset);
ret_val = XLNX_Environment_Wrapper_Read32(ContextPtr->UserEnvironment.Device_IO.Read32, ContextPtr->UserContextPtr, ValuePtr, WorkingAddr);
return ret_val;
}
XLNX_ERROR_CODE XLNX_COMP_BCAM_SetCompBcamBaseKeyData18KeyData18(XLNX_COMP_BCAM_CONTEXT_TYPE* ContextPtr, uint32_t KeyData18)
{
XLNX_ERROR_CODE ret_val = XLNX_OK;
uint32_t Offset, Mask, Shift, Buffer;
XLNX_COMPONENT_ADDRESS_TYPE WorkingAddr;
Offset = (COMP_BCAM_BASE_KEY_DATA_18_REG_OFFSET);
Mask = COMP_BCAM_BASE_KEY_DATA_18_KEY_DATA_18_MASK;
Shift = COMP_BCAM_BASE_KEY_DATA_18_KEY_DATA_18_SHIFT;
WorkingAddr = (XLNX_COMPONENT_ADDRESS_TYPE)((ContextPtr->ComponentBaseAddress) + Offset);
Buffer = (KeyData18 << Shift);
ret_val = XLNX_Environment_Wrapper_Write32_WithMask(ContextPtr->UserEnvironment.Device_IO.Write32WithMask, ContextPtr->UserContextPtr, WorkingAddr, Buffer, Mask);
return ret_val;
}
void XLNX_COMP_BCAM_BuildCompBcamBaseKeyData18KeyData18(uint32_t* MaskPtr, uint32_t* ValPtr, uint32_t KeyData18)
{
*MaskPtr |= COMP_BCAM_BASE_KEY_DATA_18_KEY_DATA_18_MASK;
*ValPtr |= (KeyData18 << COMP_BCAM_BASE_KEY_DATA_18_KEY_DATA_18_SHIFT);
}
XLNX_ERROR_CODE XLNX_COMP_BCAM_GetCompBcamBaseKeyData18KeyData18(XLNX_COMP_BCAM_CONTEXT_TYPE* ContextPtr, uint32_t* KeyData18Ptr)
{
XLNX_ERROR_CODE ret_val = XLNX_OK;
uint32_t Offset, Mask, Shift, Buffer;
XLNX_COMPONENT_ADDRESS_TYPE WorkingAddr;
Offset = (COMP_BCAM_BASE_KEY_DATA_18_REG_OFFSET);
Mask = COMP_BCAM_BASE_KEY_DATA_18_KEY_DATA_18_MASK;
Shift = COMP_BCAM_BASE_KEY_DATA_18_KEY_DATA_18_SHIFT;
WorkingAddr = (XLNX_COMPONENT_ADDRESS_TYPE)((ContextPtr->ComponentBaseAddress) + Offset);
ret_val = XLNX_Environment_Wrapper_Read32(ContextPtr->UserEnvironment.Device_IO.Read32, ContextPtr->UserContextPtr, &Buffer, WorkingAddr);
if (XLNX_OK == ret_val)
{
*KeyData18Ptr = ((Buffer & Mask) >> Shift);
}
return ret_val;
}
XLNX_ERROR_CODE XLNX_COMP_BCAM_SetCompBcamBaseKeyData18Reg(XLNX_COMP_BCAM_CONTEXT_TYPE* ContextPtr, uint32_t Mask, uint32_t Value)
{
XLNX_ERROR_CODE ret_val = XLNX_OK;
uint32_t Offset;
XLNX_COMPONENT_ADDRESS_TYPE WorkingAddr;
Offset = (COMP_BCAM_BASE_KEY_DATA_18_REG_OFFSET);
WorkingAddr = (XLNX_COMPONENT_ADDRESS_TYPE)((ContextPtr->ComponentBaseAddress) + Offset);
ret_val = XLNX_Environment_Wrapper_Write32_WithMask(ContextPtr->UserEnvironment.Device_IO.Write32WithMask, ContextPtr->UserContextPtr, WorkingAddr, Value, Mask);
return ret_val;
}
XLNX_ERROR_CODE XLNX_COMP_BCAM_GetCompBcamBaseKeyData18Reg(XLNX_COMP_BCAM_CONTEXT_TYPE* ContextPtr, uint32_t* ValuePtr)
{
XLNX_ERROR_CODE ret_val = XLNX_OK;
uint32_t Offset;
XLNX_COMPONENT_ADDRESS_TYPE WorkingAddr;
Offset = (COMP_BCAM_BASE_KEY_DATA_18_REG_OFFSET);
WorkingAddr = (XLNX_COMPONENT_ADDRESS_TYPE)((ContextPtr->ComponentBaseAddress) + Offset);
ret_val = XLNX_Environment_Wrapper_Read32(ContextPtr->UserEnvironment.Device_IO.Read32, ContextPtr->UserContextPtr, ValuePtr, WorkingAddr);
return ret_val;
}
XLNX_ERROR_CODE XLNX_COMP_BCAM_SetCompBcamBaseKeyData19KeyData19(XLNX_COMP_BCAM_CONTEXT_TYPE* ContextPtr, uint32_t KeyData19)
{
XLNX_ERROR_CODE ret_val = XLNX_OK;
uint32_t Offset, Mask, Shift, Buffer;
XLNX_COMPONENT_ADDRESS_TYPE WorkingAddr;
Offset = (COMP_BCAM_BASE_KEY_DATA_19_REG_OFFSET);
Mask = COMP_BCAM_BASE_KEY_DATA_19_KEY_DATA_19_MASK;
Shift = COMP_BCAM_BASE_KEY_DATA_19_KEY_DATA_19_SHIFT;
WorkingAddr = (XLNX_COMPONENT_ADDRESS_TYPE)((ContextPtr->ComponentBaseAddress) + Offset);
Buffer = (KeyData19 << Shift);
ret_val = XLNX_Environment_Wrapper_Write32_WithMask(ContextPtr->UserEnvironment.Device_IO.Write32WithMask, ContextPtr->UserContextPtr, WorkingAddr, Buffer, Mask);
return ret_val;
}
void XLNX_COMP_BCAM_BuildCompBcamBaseKeyData19KeyData19(uint32_t* MaskPtr, uint32_t* ValPtr, uint32_t KeyData19)
{
*MaskPtr |= COMP_BCAM_BASE_KEY_DATA_19_KEY_DATA_19_MASK;
*ValPtr |= (KeyData19 << COMP_BCAM_BASE_KEY_DATA_19_KEY_DATA_19_SHIFT);
}
XLNX_ERROR_CODE XLNX_COMP_BCAM_GetCompBcamBaseKeyData19KeyData19(XLNX_COMP_BCAM_CONTEXT_TYPE* ContextPtr, uint32_t* KeyData19Ptr)
{
XLNX_ERROR_CODE ret_val = XLNX_OK;
uint32_t Offset, Mask, Shift, Buffer;
XLNX_COMPONENT_ADDRESS_TYPE WorkingAddr;
Offset = (COMP_BCAM_BASE_KEY_DATA_19_REG_OFFSET);
Mask = COMP_BCAM_BASE_KEY_DATA_19_KEY_DATA_19_MASK;
Shift = COMP_BCAM_BASE_KEY_DATA_19_KEY_DATA_19_SHIFT;
WorkingAddr = (XLNX_COMPONENT_ADDRESS_TYPE)((ContextPtr->ComponentBaseAddress) + Offset);
ret_val = XLNX_Environment_Wrapper_Read32(ContextPtr->UserEnvironment.Device_IO.Read32, ContextPtr->UserContextPtr, &Buffer, WorkingAddr);
if (XLNX_OK == ret_val)
{
*KeyData19Ptr = ((Buffer & Mask) >> Shift);
}
return ret_val;
}
XLNX_ERROR_CODE XLNX_COMP_BCAM_SetCompBcamBaseKeyData19Reg(XLNX_COMP_BCAM_CONTEXT_TYPE* ContextPtr, uint32_t Mask, uint32_t Value)
{
XLNX_ERROR_CODE ret_val = XLNX_OK;
uint32_t Offset;
XLNX_COMPONENT_ADDRESS_TYPE WorkingAddr;
Offset = (COMP_BCAM_BASE_KEY_DATA_19_REG_OFFSET);
WorkingAddr = (XLNX_COMPONENT_ADDRESS_TYPE)((ContextPtr->ComponentBaseAddress) + Offset);
ret_val = XLNX_Environment_Wrapper_Write32_WithMask(ContextPtr->UserEnvironment.Device_IO.Write32WithMask, ContextPtr->UserContextPtr, WorkingAddr, Value, Mask);
return ret_val;
}
XLNX_ERROR_CODE XLNX_COMP_BCAM_GetCompBcamBaseKeyData19Reg(XLNX_COMP_BCAM_CONTEXT_TYPE* ContextPtr, uint32_t* ValuePtr)
{
XLNX_ERROR_CODE ret_val = XLNX_OK;
uint32_t Offset;
XLNX_COMPONENT_ADDRESS_TYPE WorkingAddr;
Offset = (COMP_BCAM_BASE_KEY_DATA_19_REG_OFFSET);
WorkingAddr = (XLNX_COMPONENT_ADDRESS_TYPE)((ContextPtr->ComponentBaseAddress) + Offset);
ret_val = XLNX_Environment_Wrapper_Read32(ContextPtr->UserEnvironment.Device_IO.Read32, ContextPtr->UserContextPtr, ValuePtr, WorkingAddr);
return ret_val;
}
XLNX_ERROR_CODE XLNX_COMP_BCAM_SetCompBcamBaseKeyData20KeyData20(XLNX_COMP_BCAM_CONTEXT_TYPE* ContextPtr, uint32_t KeyData20)
{
XLNX_ERROR_CODE ret_val = XLNX_OK;
uint32_t Offset, Mask, Shift, Buffer;
XLNX_COMPONENT_ADDRESS_TYPE WorkingAddr;
Offset = (COMP_BCAM_BASE_KEY_DATA_20_REG_OFFSET);
Mask = COMP_BCAM_BASE_KEY_DATA_20_KEY_DATA_20_MASK;
Shift = COMP_BCAM_BASE_KEY_DATA_20_KEY_DATA_20_SHIFT;
WorkingAddr = (XLNX_COMPONENT_ADDRESS_TYPE)((ContextPtr->ComponentBaseAddress) + Offset);
Buffer = (KeyData20 << Shift);
ret_val = XLNX_Environment_Wrapper_Write32_WithMask(ContextPtr->UserEnvironment.Device_IO.Write32WithMask, ContextPtr->UserContextPtr, WorkingAddr, Buffer, Mask);
return ret_val;
}
void XLNX_COMP_BCAM_BuildCompBcamBaseKeyData20KeyData20(uint32_t* MaskPtr, uint32_t* ValPtr, uint32_t KeyData20)
{
*MaskPtr |= COMP_BCAM_BASE_KEY_DATA_20_KEY_DATA_20_MASK;
*ValPtr |= (KeyData20 << COMP_BCAM_BASE_KEY_DATA_20_KEY_DATA_20_SHIFT);
}
XLNX_ERROR_CODE XLNX_COMP_BCAM_GetCompBcamBaseKeyData20KeyData20(XLNX_COMP_BCAM_CONTEXT_TYPE* ContextPtr, uint32_t* KeyData20Ptr)
{
XLNX_ERROR_CODE ret_val = XLNX_OK;
uint32_t Offset, Mask, Shift, Buffer;
XLNX_COMPONENT_ADDRESS_TYPE WorkingAddr;
Offset = (COMP_BCAM_BASE_KEY_DATA_20_REG_OFFSET);
Mask = COMP_BCAM_BASE_KEY_DATA_20_KEY_DATA_20_MASK;
Shift = COMP_BCAM_BASE_KEY_DATA_20_KEY_DATA_20_SHIFT;
WorkingAddr = (XLNX_COMPONENT_ADDRESS_TYPE)((ContextPtr->ComponentBaseAddress) + Offset);
ret_val = XLNX_Environment_Wrapper_Read32(ContextPtr->UserEnvironment.Device_IO.Read32, ContextPtr->UserContextPtr, &Buffer, WorkingAddr);
if (XLNX_OK == ret_val)
{
*KeyData20Ptr = ((Buffer & Mask) >> Shift);
}
return ret_val;
}
XLNX_ERROR_CODE XLNX_COMP_BCAM_SetCompBcamBaseKeyData20Reg(XLNX_COMP_BCAM_CONTEXT_TYPE* ContextPtr, uint32_t Mask, uint32_t Value)
{
XLNX_ERROR_CODE ret_val = XLNX_OK;
uint32_t Offset;
XLNX_COMPONENT_ADDRESS_TYPE WorkingAddr;
Offset = (COMP_BCAM_BASE_KEY_DATA_20_REG_OFFSET);
WorkingAddr = (XLNX_COMPONENT_ADDRESS_TYPE)((ContextPtr->ComponentBaseAddress) + Offset);
ret_val = XLNX_Environment_Wrapper_Write32_WithMask(ContextPtr->UserEnvironment.Device_IO.Write32WithMask, ContextPtr->UserContextPtr, WorkingAddr, Value, Mask);
return ret_val;
}
XLNX_ERROR_CODE XLNX_COMP_BCAM_GetCompBcamBaseKeyData20Reg(XLNX_COMP_BCAM_CONTEXT_TYPE* ContextPtr, uint32_t* ValuePtr)
{
XLNX_ERROR_CODE ret_val = XLNX_OK;
uint32_t Offset;
XLNX_COMPONENT_ADDRESS_TYPE WorkingAddr;
Offset = (COMP_BCAM_BASE_KEY_DATA_20_REG_OFFSET);
WorkingAddr = (XLNX_COMPONENT_ADDRESS_TYPE)((ContextPtr->ComponentBaseAddress) + Offset);
ret_val = XLNX_Environment_Wrapper_Read32(ContextPtr->UserEnvironment.Device_IO.Read32, ContextPtr->UserContextPtr, ValuePtr, WorkingAddr);
return ret_val;
}
XLNX_ERROR_CODE XLNX_COMP_BCAM_SetCompBcamBaseKeyData21KeyData21(XLNX_COMP_BCAM_CONTEXT_TYPE* ContextPtr, uint32_t KeyData21)
{
XLNX_ERROR_CODE ret_val = XLNX_OK;
uint32_t Offset, Mask, Shift, Buffer;
XLNX_COMPONENT_ADDRESS_TYPE WorkingAddr;
Offset = (COMP_BCAM_BASE_KEY_DATA_21_REG_OFFSET);
Mask = COMP_BCAM_BASE_KEY_DATA_21_KEY_DATA_21_MASK;
Shift = COMP_BCAM_BASE_KEY_DATA_21_KEY_DATA_21_SHIFT;
WorkingAddr = (XLNX_COMPONENT_ADDRESS_TYPE)((ContextPtr->ComponentBaseAddress) + Offset);
Buffer = (KeyData21 << Shift);
ret_val = XLNX_Environment_Wrapper_Write32_WithMask(ContextPtr->UserEnvironment.Device_IO.Write32WithMask, ContextPtr->UserContextPtr, WorkingAddr, Buffer, Mask);
return ret_val;
}
void XLNX_COMP_BCAM_BuildCompBcamBaseKeyData21KeyData21(uint32_t* MaskPtr, uint32_t* ValPtr, uint32_t KeyData21)
{
*MaskPtr |= COMP_BCAM_BASE_KEY_DATA_21_KEY_DATA_21_MASK;
*ValPtr |= (KeyData21 << COMP_BCAM_BASE_KEY_DATA_21_KEY_DATA_21_SHIFT);
}
XLNX_ERROR_CODE XLNX_COMP_BCAM_GetCompBcamBaseKeyData21KeyData21(XLNX_COMP_BCAM_CONTEXT_TYPE* ContextPtr, uint32_t* KeyData21Ptr)
{
XLNX_ERROR_CODE ret_val = XLNX_OK;
uint32_t Offset, Mask, Shift, Buffer;
XLNX_COMPONENT_ADDRESS_TYPE WorkingAddr;
Offset = (COMP_BCAM_BASE_KEY_DATA_21_REG_OFFSET);
Mask = COMP_BCAM_BASE_KEY_DATA_21_KEY_DATA_21_MASK;
Shift = COMP_BCAM_BASE_KEY_DATA_21_KEY_DATA_21_SHIFT;
WorkingAddr = (XLNX_COMPONENT_ADDRESS_TYPE)((ContextPtr->ComponentBaseAddress) + Offset);
ret_val = XLNX_Environment_Wrapper_Read32(ContextPtr->UserEnvironment.Device_IO.Read32, ContextPtr->UserContextPtr, &Buffer, WorkingAddr);
if (XLNX_OK == ret_val)
{
*KeyData21Ptr = ((Buffer & Mask) >> Shift);
}
return ret_val;
}
XLNX_ERROR_CODE XLNX_COMP_BCAM_SetCompBcamBaseKeyData21Reg(XLNX_COMP_BCAM_CONTEXT_TYPE* ContextPtr, uint32_t Mask, uint32_t Value)
{
XLNX_ERROR_CODE ret_val = XLNX_OK;
uint32_t Offset;
XLNX_COMPONENT_ADDRESS_TYPE WorkingAddr;
Offset = (COMP_BCAM_BASE_KEY_DATA_21_REG_OFFSET);
WorkingAddr = (XLNX_COMPONENT_ADDRESS_TYPE)((ContextPtr->ComponentBaseAddress) + Offset);
ret_val = XLNX_Environment_Wrapper_Write32_WithMask(ContextPtr->UserEnvironment.Device_IO.Write32WithMask, ContextPtr->UserContextPtr, WorkingAddr, Value, Mask);
return ret_val;
}
XLNX_ERROR_CODE XLNX_COMP_BCAM_GetCompBcamBaseKeyData21Reg(XLNX_COMP_BCAM_CONTEXT_TYPE* ContextPtr, uint32_t* ValuePtr)
{
XLNX_ERROR_CODE ret_val = XLNX_OK;
uint32_t Offset;
XLNX_COMPONENT_ADDRESS_TYPE WorkingAddr;
Offset = (COMP_BCAM_BASE_KEY_DATA_21_REG_OFFSET);
WorkingAddr = (XLNX_COMPONENT_ADDRESS_TYPE)((ContextPtr->ComponentBaseAddress) + Offset);
ret_val = XLNX_Environment_Wrapper_Read32(ContextPtr->UserEnvironment.Device_IO.Read32, ContextPtr->UserContextPtr, ValuePtr, WorkingAddr);
return ret_val;
}
XLNX_ERROR_CODE XLNX_COMP_BCAM_SetCompBcamBaseKeyData22KeyData22(XLNX_COMP_BCAM_CONTEXT_TYPE* ContextPtr, uint32_t KeyData22)
{
XLNX_ERROR_CODE ret_val = XLNX_OK;
uint32_t Offset, Mask, Shift, Buffer;
XLNX_COMPONENT_ADDRESS_TYPE WorkingAddr;
Offset = (COMP_BCAM_BASE_KEY_DATA_22_REG_OFFSET);
Mask = COMP_BCAM_BASE_KEY_DATA_22_KEY_DATA_22_MASK;
Shift = COMP_BCAM_BASE_KEY_DATA_22_KEY_DATA_22_SHIFT;
WorkingAddr = (XLNX_COMPONENT_ADDRESS_TYPE)((ContextPtr->ComponentBaseAddress) + Offset);
Buffer = (KeyData22 << Shift);
ret_val = XLNX_Environment_Wrapper_Write32_WithMask(ContextPtr->UserEnvironment.Device_IO.Write32WithMask, ContextPtr->UserContextPtr, WorkingAddr, Buffer, Mask);
return ret_val;
}
void XLNX_COMP_BCAM_BuildCompBcamBaseKeyData22KeyData22(uint32_t* MaskPtr, uint32_t* ValPtr, uint32_t KeyData22)
{
*MaskPtr |= COMP_BCAM_BASE_KEY_DATA_22_KEY_DATA_22_MASK;
*ValPtr |= (KeyData22 << COMP_BCAM_BASE_KEY_DATA_22_KEY_DATA_22_SHIFT);
}
XLNX_ERROR_CODE XLNX_COMP_BCAM_GetCompBcamBaseKeyData22KeyData22(XLNX_COMP_BCAM_CONTEXT_TYPE* ContextPtr, uint32_t* KeyData22Ptr)
{
XLNX_ERROR_CODE ret_val = XLNX_OK;
uint32_t Offset, Mask, Shift, Buffer;
XLNX_COMPONENT_ADDRESS_TYPE WorkingAddr;
Offset = (COMP_BCAM_BASE_KEY_DATA_22_REG_OFFSET);
Mask = COMP_BCAM_BASE_KEY_DATA_22_KEY_DATA_22_MASK;
Shift = COMP_BCAM_BASE_KEY_DATA_22_KEY_DATA_22_SHIFT;
WorkingAddr = (XLNX_COMPONENT_ADDRESS_TYPE)((ContextPtr->ComponentBaseAddress) + Offset);
ret_val = XLNX_Environment_Wrapper_Read32(ContextPtr->UserEnvironment.Device_IO.Read32, ContextPtr->UserContextPtr, &Buffer, WorkingAddr);
if (XLNX_OK == ret_val)
{
*KeyData22Ptr = ((Buffer & Mask) >> Shift);
}
return ret_val;
}
XLNX_ERROR_CODE XLNX_COMP_BCAM_SetCompBcamBaseKeyData22Reg(XLNX_COMP_BCAM_CONTEXT_TYPE* ContextPtr, uint32_t Mask, uint32_t Value)
{
XLNX_ERROR_CODE ret_val = XLNX_OK;
uint32_t Offset;
XLNX_COMPONENT_ADDRESS_TYPE WorkingAddr;
Offset = (COMP_BCAM_BASE_KEY_DATA_22_REG_OFFSET);
WorkingAddr = (XLNX_COMPONENT_ADDRESS_TYPE)((ContextPtr->ComponentBaseAddress) + Offset);
ret_val = XLNX_Environment_Wrapper_Write32_WithMask(ContextPtr->UserEnvironment.Device_IO.Write32WithMask, ContextPtr->UserContextPtr, WorkingAddr, Value, Mask);
return ret_val;
}
XLNX_ERROR_CODE XLNX_COMP_BCAM_GetCompBcamBaseKeyData22Reg(XLNX_COMP_BCAM_CONTEXT_TYPE* ContextPtr, uint32_t* ValuePtr)
{
XLNX_ERROR_CODE ret_val = XLNX_OK;
uint32_t Offset;
XLNX_COMPONENT_ADDRESS_TYPE WorkingAddr;
Offset = (COMP_BCAM_BASE_KEY_DATA_22_REG_OFFSET);
WorkingAddr = (XLNX_COMPONENT_ADDRESS_TYPE)((ContextPtr->ComponentBaseAddress) + Offset);
ret_val = XLNX_Environment_Wrapper_Read32(ContextPtr->UserEnvironment.Device_IO.Read32, ContextPtr->UserContextPtr, ValuePtr, WorkingAddr);
return ret_val;
}
XLNX_ERROR_CODE XLNX_COMP_BCAM_SetCompBcamBaseKeyData23KeyData23(XLNX_COMP_BCAM_CONTEXT_TYPE* ContextPtr, uint32_t KeyData23)
{
XLNX_ERROR_CODE ret_val = XLNX_OK;
uint32_t Offset, Mask, Shift, Buffer;
XLNX_COMPONENT_ADDRESS_TYPE WorkingAddr;
Offset = (COMP_BCAM_BASE_KEY_DATA_23_REG_OFFSET);
Mask = COMP_BCAM_BASE_KEY_DATA_23_KEY_DATA_23_MASK;
Shift = COMP_BCAM_BASE_KEY_DATA_23_KEY_DATA_23_SHIFT;
WorkingAddr = (XLNX_COMPONENT_ADDRESS_TYPE)((ContextPtr->ComponentBaseAddress) + Offset);
Buffer = (KeyData23 << Shift);
ret_val = XLNX_Environment_Wrapper_Write32_WithMask(ContextPtr->UserEnvironment.Device_IO.Write32WithMask, ContextPtr->UserContextPtr, WorkingAddr, Buffer, Mask);
return ret_val;
}
void XLNX_COMP_BCAM_BuildCompBcamBaseKeyData23KeyData23(uint32_t* MaskPtr, uint32_t* ValPtr, uint32_t KeyData23)
{
*MaskPtr |= COMP_BCAM_BASE_KEY_DATA_23_KEY_DATA_23_MASK;
*ValPtr |= (KeyData23 << COMP_BCAM_BASE_KEY_DATA_23_KEY_DATA_23_SHIFT);
}
XLNX_ERROR_CODE XLNX_COMP_BCAM_GetCompBcamBaseKeyData23KeyData23(XLNX_COMP_BCAM_CONTEXT_TYPE* ContextPtr, uint32_t* KeyData23Ptr)
{
XLNX_ERROR_CODE ret_val = XLNX_OK;
uint32_t Offset, Mask, Shift, Buffer;
XLNX_COMPONENT_ADDRESS_TYPE WorkingAddr;
Offset = (COMP_BCAM_BASE_KEY_DATA_23_REG_OFFSET);
Mask = COMP_BCAM_BASE_KEY_DATA_23_KEY_DATA_23_MASK;
Shift = COMP_BCAM_BASE_KEY_DATA_23_KEY_DATA_23_SHIFT;
WorkingAddr = (XLNX_COMPONENT_ADDRESS_TYPE)((ContextPtr->ComponentBaseAddress) + Offset);
ret_val = XLNX_Environment_Wrapper_Read32(ContextPtr->UserEnvironment.Device_IO.Read32, ContextPtr->UserContextPtr, &Buffer, WorkingAddr);
if (XLNX_OK == ret_val)
{
*KeyData23Ptr = ((Buffer & Mask) >> Shift);
}
return ret_val;
}
XLNX_ERROR_CODE XLNX_COMP_BCAM_SetCompBcamBaseKeyData23Reg(XLNX_COMP_BCAM_CONTEXT_TYPE* ContextPtr, uint32_t Mask, uint32_t Value)
{
XLNX_ERROR_CODE ret_val = XLNX_OK;
uint32_t Offset;
XLNX_COMPONENT_ADDRESS_TYPE WorkingAddr;
Offset = (COMP_BCAM_BASE_KEY_DATA_23_REG_OFFSET);
WorkingAddr = (XLNX_COMPONENT_ADDRESS_TYPE)((ContextPtr->ComponentBaseAddress) + Offset);
ret_val = XLNX_Environment_Wrapper_Write32_WithMask(ContextPtr->UserEnvironment.Device_IO.Write32WithMask, ContextPtr->UserContextPtr, WorkingAddr, Value, Mask);
return ret_val;
}
XLNX_ERROR_CODE XLNX_COMP_BCAM_GetCompBcamBaseKeyData23Reg(XLNX_COMP_BCAM_CONTEXT_TYPE* ContextPtr, uint32_t* ValuePtr)
{
XLNX_ERROR_CODE ret_val = XLNX_OK;
uint32_t Offset;
XLNX_COMPONENT_ADDRESS_TYPE WorkingAddr;
Offset = (COMP_BCAM_BASE_KEY_DATA_23_REG_OFFSET);
WorkingAddr = (XLNX_COMPONENT_ADDRESS_TYPE)((ContextPtr->ComponentBaseAddress) + Offset);
ret_val = XLNX_Environment_Wrapper_Read32(ContextPtr->UserEnvironment.Device_IO.Read32, ContextPtr->UserContextPtr, ValuePtr, WorkingAddr);
return ret_val;
}
XLNX_ERROR_CODE XLNX_COMP_BCAM_SetCompBcamBaseKeyData24KeyData24(XLNX_COMP_BCAM_CONTEXT_TYPE* ContextPtr, uint32_t KeyData24)
{
XLNX_ERROR_CODE ret_val = XLNX_OK;
uint32_t Offset, Mask, Shift, Buffer;
XLNX_COMPONENT_ADDRESS_TYPE WorkingAddr;
Offset = (COMP_BCAM_BASE_KEY_DATA_24_REG_OFFSET);
Mask = COMP_BCAM_BASE_KEY_DATA_24_KEY_DATA_24_MASK;
Shift = COMP_BCAM_BASE_KEY_DATA_24_KEY_DATA_24_SHIFT;
WorkingAddr = (XLNX_COMPONENT_ADDRESS_TYPE)((ContextPtr->ComponentBaseAddress) + Offset);
Buffer = (KeyData24 << Shift);
ret_val = XLNX_Environment_Wrapper_Write32_WithMask(ContextPtr->UserEnvironment.Device_IO.Write32WithMask, ContextPtr->UserContextPtr, WorkingAddr, Buffer, Mask);
return ret_val;
}
void XLNX_COMP_BCAM_BuildCompBcamBaseKeyData24KeyData24(uint32_t* MaskPtr, uint32_t* ValPtr, uint32_t KeyData24)
{
*MaskPtr |= COMP_BCAM_BASE_KEY_DATA_24_KEY_DATA_24_MASK;
*ValPtr |= (KeyData24 << COMP_BCAM_BASE_KEY_DATA_24_KEY_DATA_24_SHIFT);
}
XLNX_ERROR_CODE XLNX_COMP_BCAM_GetCompBcamBaseKeyData24KeyData24(XLNX_COMP_BCAM_CONTEXT_TYPE* ContextPtr, uint32_t* KeyData24Ptr)
{
XLNX_ERROR_CODE ret_val = XLNX_OK;
uint32_t Offset, Mask, Shift, Buffer;
XLNX_COMPONENT_ADDRESS_TYPE WorkingAddr;
Offset = (COMP_BCAM_BASE_KEY_DATA_24_REG_OFFSET);
Mask = COMP_BCAM_BASE_KEY_DATA_24_KEY_DATA_24_MASK;
Shift = COMP_BCAM_BASE_KEY_DATA_24_KEY_DATA_24_SHIFT;
WorkingAddr = (XLNX_COMPONENT_ADDRESS_TYPE)((ContextPtr->ComponentBaseAddress) + Offset);
ret_val = XLNX_Environment_Wrapper_Read32(ContextPtr->UserEnvironment.Device_IO.Read32, ContextPtr->UserContextPtr, &Buffer, WorkingAddr);
if (XLNX_OK == ret_val)
{
*KeyData24Ptr = ((Buffer & Mask) >> Shift);
}
return ret_val;
}
XLNX_ERROR_CODE XLNX_COMP_BCAM_SetCompBcamBaseKeyData24Reg(XLNX_COMP_BCAM_CONTEXT_TYPE* ContextPtr, uint32_t Mask, uint32_t Value)
{
XLNX_ERROR_CODE ret_val = XLNX_OK;
uint32_t Offset;
XLNX_COMPONENT_ADDRESS_TYPE WorkingAddr;
Offset = (COMP_BCAM_BASE_KEY_DATA_24_REG_OFFSET);
WorkingAddr = (XLNX_COMPONENT_ADDRESS_TYPE)((ContextPtr->ComponentBaseAddress) + Offset);
ret_val = XLNX_Environment_Wrapper_Write32_WithMask(ContextPtr->UserEnvironment.Device_IO.Write32WithMask, ContextPtr->UserContextPtr, WorkingAddr, Value, Mask);
return ret_val;
}
XLNX_ERROR_CODE XLNX_COMP_BCAM_GetCompBcamBaseKeyData24Reg(XLNX_COMP_BCAM_CONTEXT_TYPE* ContextPtr, uint32_t* ValuePtr)
{
XLNX_ERROR_CODE ret_val = XLNX_OK;
uint32_t Offset;
XLNX_COMPONENT_ADDRESS_TYPE WorkingAddr;
Offset = (COMP_BCAM_BASE_KEY_DATA_24_REG_OFFSET);
WorkingAddr = (XLNX_COMPONENT_ADDRESS_TYPE)((ContextPtr->ComponentBaseAddress) + Offset);
ret_val = XLNX_Environment_Wrapper_Read32(ContextPtr->UserEnvironment.Device_IO.Read32, ContextPtr->UserContextPtr, ValuePtr, WorkingAddr);
return ret_val;
}
XLNX_ERROR_CODE XLNX_COMP_BCAM_SetCompBcamBaseKeyData25KeyData25(XLNX_COMP_BCAM_CONTEXT_TYPE* ContextPtr, uint32_t KeyData25)
{
XLNX_ERROR_CODE ret_val = XLNX_OK;
uint32_t Offset, Mask, Shift, Buffer;
XLNX_COMPONENT_ADDRESS_TYPE WorkingAddr;
Offset = (COMP_BCAM_BASE_KEY_DATA_25_REG_OFFSET);
Mask = COMP_BCAM_BASE_KEY_DATA_25_KEY_DATA_25_MASK;
Shift = COMP_BCAM_BASE_KEY_DATA_25_KEY_DATA_25_SHIFT;
WorkingAddr = (XLNX_COMPONENT_ADDRESS_TYPE)((ContextPtr->ComponentBaseAddress) + Offset);
Buffer = (KeyData25 << Shift);
ret_val = XLNX_Environment_Wrapper_Write32_WithMask(ContextPtr->UserEnvironment.Device_IO.Write32WithMask, ContextPtr->UserContextPtr, WorkingAddr, Buffer, Mask);
return ret_val;
}
void XLNX_COMP_BCAM_BuildCompBcamBaseKeyData25KeyData25(uint32_t* MaskPtr, uint32_t* ValPtr, uint32_t KeyData25)
{
*MaskPtr |= COMP_BCAM_BASE_KEY_DATA_25_KEY_DATA_25_MASK;
*ValPtr |= (KeyData25 << COMP_BCAM_BASE_KEY_DATA_25_KEY_DATA_25_SHIFT);
}
XLNX_ERROR_CODE XLNX_COMP_BCAM_GetCompBcamBaseKeyData25KeyData25(XLNX_COMP_BCAM_CONTEXT_TYPE* ContextPtr, uint32_t* KeyData25Ptr)
{
XLNX_ERROR_CODE ret_val = XLNX_OK;
uint32_t Offset, Mask, Shift, Buffer;
XLNX_COMPONENT_ADDRESS_TYPE WorkingAddr;
Offset = (COMP_BCAM_BASE_KEY_DATA_25_REG_OFFSET);
Mask = COMP_BCAM_BASE_KEY_DATA_25_KEY_DATA_25_MASK;
Shift = COMP_BCAM_BASE_KEY_DATA_25_KEY_DATA_25_SHIFT;
WorkingAddr = (XLNX_COMPONENT_ADDRESS_TYPE)((ContextPtr->ComponentBaseAddress) + Offset);
ret_val = XLNX_Environment_Wrapper_Read32(ContextPtr->UserEnvironment.Device_IO.Read32, ContextPtr->UserContextPtr, &Buffer, WorkingAddr);
if (XLNX_OK == ret_val)
{
*KeyData25Ptr = ((Buffer & Mask) >> Shift);
}
return ret_val;
}
XLNX_ERROR_CODE XLNX_COMP_BCAM_SetCompBcamBaseKeyData25Reg(XLNX_COMP_BCAM_CONTEXT_TYPE* ContextPtr, uint32_t Mask, uint32_t Value)
{
XLNX_ERROR_CODE ret_val = XLNX_OK;
uint32_t Offset;
XLNX_COMPONENT_ADDRESS_TYPE WorkingAddr;
Offset = (COMP_BCAM_BASE_KEY_DATA_25_REG_OFFSET);
WorkingAddr = (XLNX_COMPONENT_ADDRESS_TYPE)((ContextPtr->ComponentBaseAddress) + Offset);
ret_val = XLNX_Environment_Wrapper_Write32_WithMask(ContextPtr->UserEnvironment.Device_IO.Write32WithMask, ContextPtr->UserContextPtr, WorkingAddr, Value, Mask);
return ret_val;
}
XLNX_ERROR_CODE XLNX_COMP_BCAM_GetCompBcamBaseKeyData25Reg(XLNX_COMP_BCAM_CONTEXT_TYPE* ContextPtr, uint32_t* ValuePtr)
{
XLNX_ERROR_CODE ret_val = XLNX_OK;
uint32_t Offset;
XLNX_COMPONENT_ADDRESS_TYPE WorkingAddr;
Offset = (COMP_BCAM_BASE_KEY_DATA_25_REG_OFFSET);
WorkingAddr = (XLNX_COMPONENT_ADDRESS_TYPE)((ContextPtr->ComponentBaseAddress) + Offset);
ret_val = XLNX_Environment_Wrapper_Read32(ContextPtr->UserEnvironment.Device_IO.Read32, ContextPtr->UserContextPtr, ValuePtr, WorkingAddr);
return ret_val;
}
XLNX_ERROR_CODE XLNX_COMP_BCAM_SetCompBcamBaseKeyData26KeyData26(XLNX_COMP_BCAM_CONTEXT_TYPE* ContextPtr, uint32_t KeyData26)
{
XLNX_ERROR_CODE ret_val = XLNX_OK;
uint32_t Offset, Mask, Shift, Buffer;
XLNX_COMPONENT_ADDRESS_TYPE WorkingAddr;
Offset = (COMP_BCAM_BASE_KEY_DATA_26_REG_OFFSET);
Mask = COMP_BCAM_BASE_KEY_DATA_26_KEY_DATA_26_MASK;
Shift = COMP_BCAM_BASE_KEY_DATA_26_KEY_DATA_26_SHIFT;
WorkingAddr = (XLNX_COMPONENT_ADDRESS_TYPE)((ContextPtr->ComponentBaseAddress) + Offset);
Buffer = (KeyData26 << Shift);
ret_val = XLNX_Environment_Wrapper_Write32_WithMask(ContextPtr->UserEnvironment.Device_IO.Write32WithMask, ContextPtr->UserContextPtr, WorkingAddr, Buffer, Mask);
return ret_val;
}
void XLNX_COMP_BCAM_BuildCompBcamBaseKeyData26KeyData26(uint32_t* MaskPtr, uint32_t* ValPtr, uint32_t KeyData26)
{
*MaskPtr |= COMP_BCAM_BASE_KEY_DATA_26_KEY_DATA_26_MASK;
*ValPtr |= (KeyData26 << COMP_BCAM_BASE_KEY_DATA_26_KEY_DATA_26_SHIFT);
}
XLNX_ERROR_CODE XLNX_COMP_BCAM_GetCompBcamBaseKeyData26KeyData26(XLNX_COMP_BCAM_CONTEXT_TYPE* ContextPtr, uint32_t* KeyData26Ptr)
{
XLNX_ERROR_CODE ret_val = XLNX_OK;
uint32_t Offset, Mask, Shift, Buffer;
XLNX_COMPONENT_ADDRESS_TYPE WorkingAddr;
Offset = (COMP_BCAM_BASE_KEY_DATA_26_REG_OFFSET);
Mask = COMP_BCAM_BASE_KEY_DATA_26_KEY_DATA_26_MASK;
Shift = COMP_BCAM_BASE_KEY_DATA_26_KEY_DATA_26_SHIFT;
WorkingAddr = (XLNX_COMPONENT_ADDRESS_TYPE)((ContextPtr->ComponentBaseAddress) + Offset);
ret_val = XLNX_Environment_Wrapper_Read32(ContextPtr->UserEnvironment.Device_IO.Read32, ContextPtr->UserContextPtr, &Buffer, WorkingAddr);
if (XLNX_OK == ret_val)
{
*KeyData26Ptr = ((Buffer & Mask) >> Shift);
}
return ret_val;
}
XLNX_ERROR_CODE XLNX_COMP_BCAM_SetCompBcamBaseKeyData26Reg(XLNX_COMP_BCAM_CONTEXT_TYPE* ContextPtr, uint32_t Mask, uint32_t Value)
{
XLNX_ERROR_CODE ret_val = XLNX_OK;
uint32_t Offset;
XLNX_COMPONENT_ADDRESS_TYPE WorkingAddr;
Offset = (COMP_BCAM_BASE_KEY_DATA_26_REG_OFFSET);
WorkingAddr = (XLNX_COMPONENT_ADDRESS_TYPE)((ContextPtr->ComponentBaseAddress) + Offset);
ret_val = XLNX_Environment_Wrapper_Write32_WithMask(ContextPtr->UserEnvironment.Device_IO.Write32WithMask, ContextPtr->UserContextPtr, WorkingAddr, Value, Mask);
return ret_val;
}
XLNX_ERROR_CODE XLNX_COMP_BCAM_GetCompBcamBaseKeyData26Reg(XLNX_COMP_BCAM_CONTEXT_TYPE* ContextPtr, uint32_t* ValuePtr)
{
XLNX_ERROR_CODE ret_val = XLNX_OK;
uint32_t Offset;
XLNX_COMPONENT_ADDRESS_TYPE WorkingAddr;
Offset = (COMP_BCAM_BASE_KEY_DATA_26_REG_OFFSET);
WorkingAddr = (XLNX_COMPONENT_ADDRESS_TYPE)((ContextPtr->ComponentBaseAddress) + Offset);
ret_val = XLNX_Environment_Wrapper_Read32(ContextPtr->UserEnvironment.Device_IO.Read32, ContextPtr->UserContextPtr, ValuePtr, WorkingAddr);
return ret_val;
}
XLNX_ERROR_CODE XLNX_COMP_BCAM_SetCompBcamBaseKeyData27KeyData27(XLNX_COMP_BCAM_CONTEXT_TYPE* ContextPtr, uint32_t KeyData27)
{
XLNX_ERROR_CODE ret_val = XLNX_OK;
uint32_t Offset, Mask, Shift, Buffer;
XLNX_COMPONENT_ADDRESS_TYPE WorkingAddr;
Offset = (COMP_BCAM_BASE_KEY_DATA_27_REG_OFFSET);
Mask = COMP_BCAM_BASE_KEY_DATA_27_KEY_DATA_27_MASK;
Shift = COMP_BCAM_BASE_KEY_DATA_27_KEY_DATA_27_SHIFT;
WorkingAddr = (XLNX_COMPONENT_ADDRESS_TYPE)((ContextPtr->ComponentBaseAddress) + Offset);
Buffer = (KeyData27 << Shift);
ret_val = XLNX_Environment_Wrapper_Write32_WithMask(ContextPtr->UserEnvironment.Device_IO.Write32WithMask, ContextPtr->UserContextPtr, WorkingAddr, Buffer, Mask);
return ret_val;
}
void XLNX_COMP_BCAM_BuildCompBcamBaseKeyData27KeyData27(uint32_t* MaskPtr, uint32_t* ValPtr, uint32_t KeyData27)
{
*MaskPtr |= COMP_BCAM_BASE_KEY_DATA_27_KEY_DATA_27_MASK;
*ValPtr |= (KeyData27 << COMP_BCAM_BASE_KEY_DATA_27_KEY_DATA_27_SHIFT);
}
XLNX_ERROR_CODE XLNX_COMP_BCAM_GetCompBcamBaseKeyData27KeyData27(XLNX_COMP_BCAM_CONTEXT_TYPE* ContextPtr, uint32_t* KeyData27Ptr)
{
XLNX_ERROR_CODE ret_val = XLNX_OK;
uint32_t Offset, Mask, Shift, Buffer;
XLNX_COMPONENT_ADDRESS_TYPE WorkingAddr;
Offset = (COMP_BCAM_BASE_KEY_DATA_27_REG_OFFSET);
Mask = COMP_BCAM_BASE_KEY_DATA_27_KEY_DATA_27_MASK;
Shift = COMP_BCAM_BASE_KEY_DATA_27_KEY_DATA_27_SHIFT;
WorkingAddr = (XLNX_COMPONENT_ADDRESS_TYPE)((ContextPtr->ComponentBaseAddress) + Offset);
ret_val = XLNX_Environment_Wrapper_Read32(ContextPtr->UserEnvironment.Device_IO.Read32, ContextPtr->UserContextPtr, &Buffer, WorkingAddr);
if (XLNX_OK == ret_val)
{
*KeyData27Ptr = ((Buffer & Mask) >> Shift);
}
return ret_val;
}
XLNX_ERROR_CODE XLNX_COMP_BCAM_SetCompBcamBaseKeyData27Reg(XLNX_COMP_BCAM_CONTEXT_TYPE* ContextPtr, uint32_t Mask, uint32_t Value)
{
XLNX_ERROR_CODE ret_val = XLNX_OK;
uint32_t Offset;
XLNX_COMPONENT_ADDRESS_TYPE WorkingAddr;
Offset = (COMP_BCAM_BASE_KEY_DATA_27_REG_OFFSET);
WorkingAddr = (XLNX_COMPONENT_ADDRESS_TYPE)((ContextPtr->ComponentBaseAddress) + Offset);
ret_val = XLNX_Environment_Wrapper_Write32_WithMask(ContextPtr->UserEnvironment.Device_IO.Write32WithMask, ContextPtr->UserContextPtr, WorkingAddr, Value, Mask);
return ret_val;
}
XLNX_ERROR_CODE XLNX_COMP_BCAM_GetCompBcamBaseKeyData27Reg(XLNX_COMP_BCAM_CONTEXT_TYPE* ContextPtr, uint32_t* ValuePtr)
{
XLNX_ERROR_CODE ret_val = XLNX_OK;
uint32_t Offset;
XLNX_COMPONENT_ADDRESS_TYPE WorkingAddr;
Offset = (COMP_BCAM_BASE_KEY_DATA_27_REG_OFFSET);
WorkingAddr = (XLNX_COMPONENT_ADDRESS_TYPE)((ContextPtr->ComponentBaseAddress) + Offset);
ret_val = XLNX_Environment_Wrapper_Read32(ContextPtr->UserEnvironment.Device_IO.Read32, ContextPtr->UserContextPtr, ValuePtr, WorkingAddr);
return ret_val;
}
XLNX_ERROR_CODE XLNX_COMP_BCAM_SetCompBcamBaseKeyData28KeyData28(XLNX_COMP_BCAM_CONTEXT_TYPE* ContextPtr, uint32_t KeyData28)
{
XLNX_ERROR_CODE ret_val = XLNX_OK;
uint32_t Offset, Mask, Shift, Buffer;
XLNX_COMPONENT_ADDRESS_TYPE WorkingAddr;
Offset = (COMP_BCAM_BASE_KEY_DATA_28_REG_OFFSET);
Mask = COMP_BCAM_BASE_KEY_DATA_28_KEY_DATA_28_MASK;
Shift = COMP_BCAM_BASE_KEY_DATA_28_KEY_DATA_28_SHIFT;
WorkingAddr = (XLNX_COMPONENT_ADDRESS_TYPE)((ContextPtr->ComponentBaseAddress) + Offset);
Buffer = (KeyData28 << Shift);
ret_val = XLNX_Environment_Wrapper_Write32_WithMask(ContextPtr->UserEnvironment.Device_IO.Write32WithMask, ContextPtr->UserContextPtr, WorkingAddr, Buffer, Mask);
return ret_val;
}
void XLNX_COMP_BCAM_BuildCompBcamBaseKeyData28KeyData28(uint32_t* MaskPtr, uint32_t* ValPtr, uint32_t KeyData28)
{
*MaskPtr |= COMP_BCAM_BASE_KEY_DATA_28_KEY_DATA_28_MASK;
*ValPtr |= (KeyData28 << COMP_BCAM_BASE_KEY_DATA_28_KEY_DATA_28_SHIFT);
}
XLNX_ERROR_CODE XLNX_COMP_BCAM_GetCompBcamBaseKeyData28KeyData28(XLNX_COMP_BCAM_CONTEXT_TYPE* ContextPtr, uint32_t* KeyData28Ptr)
{
XLNX_ERROR_CODE ret_val = XLNX_OK;
uint32_t Offset, Mask, Shift, Buffer;
XLNX_COMPONENT_ADDRESS_TYPE WorkingAddr;
Offset = (COMP_BCAM_BASE_KEY_DATA_28_REG_OFFSET);
Mask = COMP_BCAM_BASE_KEY_DATA_28_KEY_DATA_28_MASK;
Shift = COMP_BCAM_BASE_KEY_DATA_28_KEY_DATA_28_SHIFT;
WorkingAddr = (XLNX_COMPONENT_ADDRESS_TYPE)((ContextPtr->ComponentBaseAddress) + Offset);
ret_val = XLNX_Environment_Wrapper_Read32(ContextPtr->UserEnvironment.Device_IO.Read32, ContextPtr->UserContextPtr, &Buffer, WorkingAddr);
if (XLNX_OK == ret_val)
{
*KeyData28Ptr = ((Buffer & Mask) >> Shift);
}
return ret_val;
}
XLNX_ERROR_CODE XLNX_COMP_BCAM_SetCompBcamBaseKeyData28Reg(XLNX_COMP_BCAM_CONTEXT_TYPE* ContextPtr, uint32_t Mask, uint32_t Value)
{
XLNX_ERROR_CODE ret_val = XLNX_OK;
uint32_t Offset;
XLNX_COMPONENT_ADDRESS_TYPE WorkingAddr;
Offset = (COMP_BCAM_BASE_KEY_DATA_28_REG_OFFSET);
WorkingAddr = (XLNX_COMPONENT_ADDRESS_TYPE)((ContextPtr->ComponentBaseAddress) + Offset);
ret_val = XLNX_Environment_Wrapper_Write32_WithMask(ContextPtr->UserEnvironment.Device_IO.Write32WithMask, ContextPtr->UserContextPtr, WorkingAddr, Value, Mask);
return ret_val;
}
XLNX_ERROR_CODE XLNX_COMP_BCAM_GetCompBcamBaseKeyData28Reg(XLNX_COMP_BCAM_CONTEXT_TYPE* ContextPtr, uint32_t* ValuePtr)
{
XLNX_ERROR_CODE ret_val = XLNX_OK;
uint32_t Offset;
XLNX_COMPONENT_ADDRESS_TYPE WorkingAddr;
Offset = (COMP_BCAM_BASE_KEY_DATA_28_REG_OFFSET);
WorkingAddr = (XLNX_COMPONENT_ADDRESS_TYPE)((ContextPtr->ComponentBaseAddress) + Offset);
ret_val = XLNX_Environment_Wrapper_Read32(ContextPtr->UserEnvironment.Device_IO.Read32, ContextPtr->UserContextPtr, ValuePtr, WorkingAddr);
return ret_val;
}
XLNX_ERROR_CODE XLNX_COMP_BCAM_SetCompBcamBaseKeyData29KeyData29(XLNX_COMP_BCAM_CONTEXT_TYPE* ContextPtr, uint32_t KeyData29)
{
XLNX_ERROR_CODE ret_val = XLNX_OK;
uint32_t Offset, Mask, Shift, Buffer;
XLNX_COMPONENT_ADDRESS_TYPE WorkingAddr;
Offset = (COMP_BCAM_BASE_KEY_DATA_29_REG_OFFSET);
Mask = COMP_BCAM_BASE_KEY_DATA_29_KEY_DATA_29_MASK;
Shift = COMP_BCAM_BASE_KEY_DATA_29_KEY_DATA_29_SHIFT;
WorkingAddr = (XLNX_COMPONENT_ADDRESS_TYPE)((ContextPtr->ComponentBaseAddress) + Offset);
Buffer = (KeyData29 << Shift);
ret_val = XLNX_Environment_Wrapper_Write32_WithMask(ContextPtr->UserEnvironment.Device_IO.Write32WithMask, ContextPtr->UserContextPtr, WorkingAddr, Buffer, Mask);
return ret_val;
}
void XLNX_COMP_BCAM_BuildCompBcamBaseKeyData29KeyData29(uint32_t* MaskPtr, uint32_t* ValPtr, uint32_t KeyData29)
{
*MaskPtr |= COMP_BCAM_BASE_KEY_DATA_29_KEY_DATA_29_MASK;
*ValPtr |= (KeyData29 << COMP_BCAM_BASE_KEY_DATA_29_KEY_DATA_29_SHIFT);
}
XLNX_ERROR_CODE XLNX_COMP_BCAM_GetCompBcamBaseKeyData29KeyData29(XLNX_COMP_BCAM_CONTEXT_TYPE* ContextPtr, uint32_t* KeyData29Ptr)
{
XLNX_ERROR_CODE ret_val = XLNX_OK;
uint32_t Offset, Mask, Shift, Buffer;
XLNX_COMPONENT_ADDRESS_TYPE WorkingAddr;
Offset = (COMP_BCAM_BASE_KEY_DATA_29_REG_OFFSET);
Mask = COMP_BCAM_BASE_KEY_DATA_29_KEY_DATA_29_MASK;
Shift = COMP_BCAM_BASE_KEY_DATA_29_KEY_DATA_29_SHIFT;
WorkingAddr = (XLNX_COMPONENT_ADDRESS_TYPE)((ContextPtr->ComponentBaseAddress) + Offset);
ret_val = XLNX_Environment_Wrapper_Read32(ContextPtr->UserEnvironment.Device_IO.Read32, ContextPtr->UserContextPtr, &Buffer, WorkingAddr);
if (XLNX_OK == ret_val)
{
*KeyData29Ptr = ((Buffer & Mask) >> Shift);
}
return ret_val;
}
XLNX_ERROR_CODE XLNX_COMP_BCAM_SetCompBcamBaseKeyData29Reg(XLNX_COMP_BCAM_CONTEXT_TYPE* ContextPtr, uint32_t Mask, uint32_t Value)
{
XLNX_ERROR_CODE ret_val = XLNX_OK;
uint32_t Offset;
XLNX_COMPONENT_ADDRESS_TYPE WorkingAddr;
Offset = (COMP_BCAM_BASE_KEY_DATA_29_REG_OFFSET);
WorkingAddr = (XLNX_COMPONENT_ADDRESS_TYPE)((ContextPtr->ComponentBaseAddress) + Offset);
ret_val = XLNX_Environment_Wrapper_Write32_WithMask(ContextPtr->UserEnvironment.Device_IO.Write32WithMask, ContextPtr->UserContextPtr, WorkingAddr, Value, Mask);
return ret_val;
}
XLNX_ERROR_CODE XLNX_COMP_BCAM_GetCompBcamBaseKeyData29Reg(XLNX_COMP_BCAM_CONTEXT_TYPE* ContextPtr, uint32_t* ValuePtr)
{
XLNX_ERROR_CODE ret_val = XLNX_OK;
uint32_t Offset;
XLNX_COMPONENT_ADDRESS_TYPE WorkingAddr;
Offset = (COMP_BCAM_BASE_KEY_DATA_29_REG_OFFSET);
WorkingAddr = (XLNX_COMPONENT_ADDRESS_TYPE)((ContextPtr->ComponentBaseAddress) + Offset);
ret_val = XLNX_Environment_Wrapper_Read32(ContextPtr->UserEnvironment.Device_IO.Read32, ContextPtr->UserContextPtr, ValuePtr, WorkingAddr);
return ret_val;
}
XLNX_ERROR_CODE XLNX_COMP_BCAM_SetCompBcamBaseKeyData30KeyData30(XLNX_COMP_BCAM_CONTEXT_TYPE* ContextPtr, uint32_t KeyData30)
{
XLNX_ERROR_CODE ret_val = XLNX_OK;
uint32_t Offset, Mask, Shift, Buffer;
XLNX_COMPONENT_ADDRESS_TYPE WorkingAddr;
Offset = (COMP_BCAM_BASE_KEY_DATA_30_REG_OFFSET);
Mask = COMP_BCAM_BASE_KEY_DATA_30_KEY_DATA_30_MASK;
Shift = COMP_BCAM_BASE_KEY_DATA_30_KEY_DATA_30_SHIFT;
WorkingAddr = (XLNX_COMPONENT_ADDRESS_TYPE)((ContextPtr->ComponentBaseAddress) + Offset);
Buffer = (KeyData30 << Shift);
ret_val = XLNX_Environment_Wrapper_Write32_WithMask(ContextPtr->UserEnvironment.Device_IO.Write32WithMask, ContextPtr->UserContextPtr, WorkingAddr, Buffer, Mask);
return ret_val;
}
void XLNX_COMP_BCAM_BuildCompBcamBaseKeyData30KeyData30(uint32_t* MaskPtr, uint32_t* ValPtr, uint32_t KeyData30)
{
*MaskPtr |= COMP_BCAM_BASE_KEY_DATA_30_KEY_DATA_30_MASK;
*ValPtr |= (KeyData30 << COMP_BCAM_BASE_KEY_DATA_30_KEY_DATA_30_SHIFT);
}
XLNX_ERROR_CODE XLNX_COMP_BCAM_GetCompBcamBaseKeyData30KeyData30(XLNX_COMP_BCAM_CONTEXT_TYPE* ContextPtr, uint32_t* KeyData30Ptr)
{
XLNX_ERROR_CODE ret_val = XLNX_OK;
uint32_t Offset, Mask, Shift, Buffer;
XLNX_COMPONENT_ADDRESS_TYPE WorkingAddr;
Offset = (COMP_BCAM_BASE_KEY_DATA_30_REG_OFFSET);
Mask = COMP_BCAM_BASE_KEY_DATA_30_KEY_DATA_30_MASK;
Shift = COMP_BCAM_BASE_KEY_DATA_30_KEY_DATA_30_SHIFT;
WorkingAddr = (XLNX_COMPONENT_ADDRESS_TYPE)((ContextPtr->ComponentBaseAddress) + Offset);
ret_val = XLNX_Environment_Wrapper_Read32(ContextPtr->UserEnvironment.Device_IO.Read32, ContextPtr->UserContextPtr, &Buffer, WorkingAddr);
if (XLNX_OK == ret_val)
{
*KeyData30Ptr = ((Buffer & Mask) >> Shift);
}
return ret_val;
}
XLNX_ERROR_CODE XLNX_COMP_BCAM_SetCompBcamBaseKeyData30Reg(XLNX_COMP_BCAM_CONTEXT_TYPE* ContextPtr, uint32_t Mask, uint32_t Value)
{
XLNX_ERROR_CODE ret_val = XLNX_OK;
uint32_t Offset;
XLNX_COMPONENT_ADDRESS_TYPE WorkingAddr;
Offset = (COMP_BCAM_BASE_KEY_DATA_30_REG_OFFSET);
WorkingAddr = (XLNX_COMPONENT_ADDRESS_TYPE)((ContextPtr->ComponentBaseAddress) + Offset);
ret_val = XLNX_Environment_Wrapper_Write32_WithMask(ContextPtr->UserEnvironment.Device_IO.Write32WithMask, ContextPtr->UserContextPtr, WorkingAddr, Value, Mask);
return ret_val;
}
XLNX_ERROR_CODE XLNX_COMP_BCAM_GetCompBcamBaseKeyData30Reg(XLNX_COMP_BCAM_CONTEXT_TYPE* ContextPtr, uint32_t* ValuePtr)
{
XLNX_ERROR_CODE ret_val = XLNX_OK;
uint32_t Offset;
XLNX_COMPONENT_ADDRESS_TYPE WorkingAddr;
Offset = (COMP_BCAM_BASE_KEY_DATA_30_REG_OFFSET);
WorkingAddr = (XLNX_COMPONENT_ADDRESS_TYPE)((ContextPtr->ComponentBaseAddress) + Offset);
ret_val = XLNX_Environment_Wrapper_Read32(ContextPtr->UserEnvironment.Device_IO.Read32, ContextPtr->UserContextPtr, ValuePtr, WorkingAddr);
return ret_val;
}
XLNX_ERROR_CODE XLNX_COMP_BCAM_SetCompBcamBaseKeyData31KeyData31(XLNX_COMP_BCAM_CONTEXT_TYPE* ContextPtr, uint32_t KeyData31)
{
XLNX_ERROR_CODE ret_val = XLNX_OK;
uint32_t Offset, Mask, Shift, Buffer;
XLNX_COMPONENT_ADDRESS_TYPE WorkingAddr;
Offset = (COMP_BCAM_BASE_KEY_DATA_31_REG_OFFSET);
Mask = COMP_BCAM_BASE_KEY_DATA_31_KEY_DATA_31_MASK;
Shift = COMP_BCAM_BASE_KEY_DATA_31_KEY_DATA_31_SHIFT;
WorkingAddr = (XLNX_COMPONENT_ADDRESS_TYPE)((ContextPtr->ComponentBaseAddress) + Offset);
Buffer = (KeyData31 << Shift);
ret_val = XLNX_Environment_Wrapper_Write32_WithMask(ContextPtr->UserEnvironment.Device_IO.Write32WithMask, ContextPtr->UserContextPtr, WorkingAddr, Buffer, Mask);
return ret_val;
}
void XLNX_COMP_BCAM_BuildCompBcamBaseKeyData31KeyData31(uint32_t* MaskPtr, uint32_t* ValPtr, uint32_t KeyData31)
{
*MaskPtr |= COMP_BCAM_BASE_KEY_DATA_31_KEY_DATA_31_MASK;
*ValPtr |= (KeyData31 << COMP_BCAM_BASE_KEY_DATA_31_KEY_DATA_31_SHIFT);
}
XLNX_ERROR_CODE XLNX_COMP_BCAM_GetCompBcamBaseKeyData31KeyData31(XLNX_COMP_BCAM_CONTEXT_TYPE* ContextPtr, uint32_t* KeyData31Ptr)
{
XLNX_ERROR_CODE ret_val = XLNX_OK;
uint32_t Offset, Mask, Shift, Buffer;
XLNX_COMPONENT_ADDRESS_TYPE WorkingAddr;
Offset = (COMP_BCAM_BASE_KEY_DATA_31_REG_OFFSET);
Mask = COMP_BCAM_BASE_KEY_DATA_31_KEY_DATA_31_MASK;
Shift = COMP_BCAM_BASE_KEY_DATA_31_KEY_DATA_31_SHIFT;
WorkingAddr = (XLNX_COMPONENT_ADDRESS_TYPE)((ContextPtr->ComponentBaseAddress) + Offset);
ret_val = XLNX_Environment_Wrapper_Read32(ContextPtr->UserEnvironment.Device_IO.Read32, ContextPtr->UserContextPtr, &Buffer, WorkingAddr);
if (XLNX_OK == ret_val)
{
*KeyData31Ptr = ((Buffer & Mask) >> Shift);
}
return ret_val;
}
XLNX_ERROR_CODE XLNX_COMP_BCAM_SetCompBcamBaseKeyData31Reg(XLNX_COMP_BCAM_CONTEXT_TYPE* ContextPtr, uint32_t Mask, uint32_t Value)
{
XLNX_ERROR_CODE ret_val = XLNX_OK;
uint32_t Offset;
XLNX_COMPONENT_ADDRESS_TYPE WorkingAddr;
Offset = (COMP_BCAM_BASE_KEY_DATA_31_REG_OFFSET);
WorkingAddr = (XLNX_COMPONENT_ADDRESS_TYPE)((ContextPtr->ComponentBaseAddress) + Offset);
ret_val = XLNX_Environment_Wrapper_Write32_WithMask(ContextPtr->UserEnvironment.Device_IO.Write32WithMask, ContextPtr->UserContextPtr, WorkingAddr, Value, Mask);
return ret_val;
}
XLNX_ERROR_CODE XLNX_COMP_BCAM_GetCompBcamBaseKeyData31Reg(XLNX_COMP_BCAM_CONTEXT_TYPE* ContextPtr, uint32_t* ValuePtr)
{
XLNX_ERROR_CODE ret_val = XLNX_OK;
uint32_t Offset;
XLNX_COMPONENT_ADDRESS_TYPE WorkingAddr;
Offset = (COMP_BCAM_BASE_KEY_DATA_31_REG_OFFSET);
WorkingAddr = (XLNX_COMPONENT_ADDRESS_TYPE)((ContextPtr->ComponentBaseAddress) + Offset);
ret_val = XLNX_Environment_Wrapper_Read32(ContextPtr->UserEnvironment.Device_IO.Read32, ContextPtr->UserContextPtr, ValuePtr, WorkingAddr);
return ret_val;
}
XLNX_ERROR_CODE XLNX_COMP_BCAM_SetCompBcamBaseResponseData00ResponseData00(XLNX_COMP_BCAM_CONTEXT_TYPE* ContextPtr, uint32_t ResponseData00)
{
XLNX_ERROR_CODE ret_val = XLNX_OK;
uint32_t Offset, Mask, Shift, Buffer;
XLNX_COMPONENT_ADDRESS_TYPE WorkingAddr;
Offset = (COMP_BCAM_BASE_RESPONSE_DATA_00_REG_OFFSET);
Mask = COMP_BCAM_BASE_RESPONSE_DATA_00_RESPONSE_DATA_00_MASK;
Shift = COMP_BCAM_BASE_RESPONSE_DATA_00_RESPONSE_DATA_00_SHIFT;
WorkingAddr = (XLNX_COMPONENT_ADDRESS_TYPE)((ContextPtr->ComponentBaseAddress) + Offset);
Buffer = (ResponseData00 << Shift);
ret_val = XLNX_Environment_Wrapper_Write32_WithMask(ContextPtr->UserEnvironment.Device_IO.Write32WithMask, ContextPtr->UserContextPtr, WorkingAddr, Buffer, Mask);
return ret_val;
}
XLNX_ERROR_CODE XLNX_COMP_BCAM_SetCompBcamData(const XLNX_COMP_BCAM_CONTEXT_TYPE* ContextPtr, uint32_t Offset, uint32_t ResponseData)
{
XLNX_ERROR_CODE ret_val = XLNX_OK;
uint32_t WorkingAddr;
WorkingAddr = ASSEMBLY_COMP_BCAM_OFFSET + Offset;
ret_val = XLNX_Environment_Wrapper_Write32(ContextPtr->UserEnvironment.Device_IO.Write32, ContextPtr->UserContextPtr, WorkingAddr, ResponseData);
return ret_val;
}
XLNX_ERROR_CODE XLNX_COMP_BCAM_GetCompBcamData(const XLNX_COMP_BCAM_CONTEXT_TYPE* ContextPtr, uint32_t Offset, uint32_t* ResponseDataPtr)
{
XLNX_ERROR_CODE ret_val = XLNX_OK;
uint32_t WorkingAddr;
WorkingAddr = ASSEMBLY_COMP_BCAM_OFFSET + Offset;
ContextPtr->UserEnvironment.Device_IO.Read32(ContextPtr->UserContextPtr, WorkingAddr, ResponseDataPtr);
return ret_val;
}
void XLNX_COMP_BCAM_BuildCompBcamBaseResponseData00ResponseData00(uint32_t* MaskPtr, uint32_t* ValPtr, uint32_t ResponseData00)
{
*MaskPtr |= COMP_BCAM_BASE_RESPONSE_DATA_00_RESPONSE_DATA_00_MASK;
*ValPtr |= (ResponseData00 << COMP_BCAM_BASE_RESPONSE_DATA_00_RESPONSE_DATA_00_SHIFT);
}
XLNX_ERROR_CODE XLNX_COMP_BCAM_GetCompBcamBaseResponseData00ResponseData00(XLNX_COMP_BCAM_CONTEXT_TYPE* ContextPtr, uint32_t* ResponseData00Ptr)
{
XLNX_ERROR_CODE ret_val = XLNX_OK;
uint32_t Offset, Mask, Shift, Buffer;
XLNX_COMPONENT_ADDRESS_TYPE WorkingAddr;
Offset = (COMP_BCAM_BASE_RESPONSE_DATA_00_REG_OFFSET);
Mask = COMP_BCAM_BASE_RESPONSE_DATA_00_RESPONSE_DATA_00_MASK;
Shift = COMP_BCAM_BASE_RESPONSE_DATA_00_RESPONSE_DATA_00_SHIFT;
WorkingAddr = (XLNX_COMPONENT_ADDRESS_TYPE)((ContextPtr->ComponentBaseAddress) + Offset);
ret_val = XLNX_Environment_Wrapper_Read32(ContextPtr->UserEnvironment.Device_IO.Read32, ContextPtr->UserContextPtr, &Buffer, WorkingAddr);
if (XLNX_OK == ret_val)
{
*ResponseData00Ptr = ((Buffer & Mask) >> Shift);
}
return ret_val;
}
XLNX_ERROR_CODE XLNX_COMP_BCAM_SetCompBcamBaseResponseData00Reg(XLNX_COMP_BCAM_CONTEXT_TYPE* ContextPtr, uint32_t Mask, uint32_t Value)
{
XLNX_ERROR_CODE ret_val = XLNX_OK;
uint32_t Offset;
XLNX_COMPONENT_ADDRESS_TYPE WorkingAddr;
Offset = (COMP_BCAM_BASE_RESPONSE_DATA_00_REG_OFFSET);
WorkingAddr = (XLNX_COMPONENT_ADDRESS_TYPE)((ContextPtr->ComponentBaseAddress) + Offset);
ret_val = XLNX_Environment_Wrapper_Write32_WithMask(ContextPtr->UserEnvironment.Device_IO.Write32WithMask, ContextPtr->UserContextPtr, WorkingAddr, Value, Mask);
return ret_val;
}
XLNX_ERROR_CODE XLNX_COMP_BCAM_GetCompBcamBaseResponseData00Reg(XLNX_COMP_BCAM_CONTEXT_TYPE* ContextPtr, uint32_t* ValuePtr)
{
XLNX_ERROR_CODE ret_val = XLNX_OK;
uint32_t Offset;
XLNX_COMPONENT_ADDRESS_TYPE WorkingAddr;
Offset = (COMP_BCAM_BASE_RESPONSE_DATA_00_REG_OFFSET);
WorkingAddr = (XLNX_COMPONENT_ADDRESS_TYPE)((ContextPtr->ComponentBaseAddress) + Offset);
ret_val = XLNX_Environment_Wrapper_Read32(ContextPtr->UserEnvironment.Device_IO.Read32, ContextPtr->UserContextPtr, ValuePtr, WorkingAddr);
return ret_val;
}
XLNX_ERROR_CODE XLNX_COMP_BCAM_SetCompBcamBaseResponseData01ResponseData01(XLNX_COMP_BCAM_CONTEXT_TYPE* ContextPtr, uint32_t ResponseData01)
{
XLNX_ERROR_CODE ret_val = XLNX_OK;
uint32_t Offset, Mask, Shift, Buffer;
XLNX_COMPONENT_ADDRESS_TYPE WorkingAddr;
Offset = (COMP_BCAM_BASE_RESPONSE_DATA_01_REG_OFFSET);
Mask = COMP_BCAM_BASE_RESPONSE_DATA_01_RESPONSE_DATA_01_MASK;
Shift = COMP_BCAM_BASE_RESPONSE_DATA_01_RESPONSE_DATA_01_SHIFT;
WorkingAddr = (XLNX_COMPONENT_ADDRESS_TYPE)((ContextPtr->ComponentBaseAddress) + Offset);
Buffer = (ResponseData01 << Shift);
ret_val = XLNX_Environment_Wrapper_Write32_WithMask(ContextPtr->UserEnvironment.Device_IO.Write32WithMask, ContextPtr->UserContextPtr, WorkingAddr, Buffer, Mask);
return ret_val;
}
void XLNX_COMP_BCAM_BuildCompBcamBaseResponseData01ResponseData01(uint32_t* MaskPtr, uint32_t* ValPtr, uint32_t ResponseData01)
{
*MaskPtr |= COMP_BCAM_BASE_RESPONSE_DATA_01_RESPONSE_DATA_01_MASK;
*ValPtr |= (ResponseData01 << COMP_BCAM_BASE_RESPONSE_DATA_01_RESPONSE_DATA_01_SHIFT);
}
XLNX_ERROR_CODE XLNX_COMP_BCAM_GetCompBcamBaseResponseData01ResponseData01(XLNX_COMP_BCAM_CONTEXT_TYPE* ContextPtr, uint32_t* ResponseData01Ptr)
{
XLNX_ERROR_CODE ret_val = XLNX_OK;
uint32_t Offset, Mask, Shift, Buffer;
XLNX_COMPONENT_ADDRESS_TYPE WorkingAddr;
Offset = (COMP_BCAM_BASE_RESPONSE_DATA_01_REG_OFFSET);
Mask = COMP_BCAM_BASE_RESPONSE_DATA_01_RESPONSE_DATA_01_MASK;
Shift = COMP_BCAM_BASE_RESPONSE_DATA_01_RESPONSE_DATA_01_SHIFT;
WorkingAddr = (XLNX_COMPONENT_ADDRESS_TYPE)((ContextPtr->ComponentBaseAddress) + Offset);
ret_val = XLNX_Environment_Wrapper_Read32(ContextPtr->UserEnvironment.Device_IO.Read32, ContextPtr->UserContextPtr, &Buffer, WorkingAddr);
if (XLNX_OK == ret_val)
{
*ResponseData01Ptr = ((Buffer & Mask) >> Shift);
}
return ret_val;
}
XLNX_ERROR_CODE XLNX_COMP_BCAM_SetCompBcamBaseResponseData01Reg(XLNX_COMP_BCAM_CONTEXT_TYPE* ContextPtr, uint32_t Mask, uint32_t Value)
{
XLNX_ERROR_CODE ret_val = XLNX_OK;
uint32_t Offset;
XLNX_COMPONENT_ADDRESS_TYPE WorkingAddr;
Offset = (COMP_BCAM_BASE_RESPONSE_DATA_01_REG_OFFSET);
WorkingAddr = (XLNX_COMPONENT_ADDRESS_TYPE)((ContextPtr->ComponentBaseAddress) + Offset);
ret_val = XLNX_Environment_Wrapper_Write32_WithMask(ContextPtr->UserEnvironment.Device_IO.Write32WithMask, ContextPtr->UserContextPtr, WorkingAddr, Value, Mask);
return ret_val;
}
XLNX_ERROR_CODE XLNX_COMP_BCAM_GetCompBcamBaseResponseData01Reg(XLNX_COMP_BCAM_CONTEXT_TYPE* ContextPtr, uint32_t* ValuePtr)
{
XLNX_ERROR_CODE ret_val = XLNX_OK;
uint32_t Offset;
XLNX_COMPONENT_ADDRESS_TYPE WorkingAddr;
Offset = (COMP_BCAM_BASE_RESPONSE_DATA_01_REG_OFFSET);
WorkingAddr = (XLNX_COMPONENT_ADDRESS_TYPE)((ContextPtr->ComponentBaseAddress) + Offset);
ret_val = XLNX_Environment_Wrapper_Read32(ContextPtr->UserEnvironment.Device_IO.Read32, ContextPtr->UserContextPtr, ValuePtr, WorkingAddr);
return ret_val;
}
XLNX_ERROR_CODE XLNX_COMP_BCAM_SetCompBcamBaseResponseData02ResponseData02(XLNX_COMP_BCAM_CONTEXT_TYPE* ContextPtr, uint32_t ResponseData02)
{
XLNX_ERROR_CODE ret_val = XLNX_OK;
uint32_t Offset, Mask, Shift, Buffer;
XLNX_COMPONENT_ADDRESS_TYPE WorkingAddr;
Offset = (COMP_BCAM_BASE_RESPONSE_DATA_02_REG_OFFSET);
Mask = COMP_BCAM_BASE_RESPONSE_DATA_02_RESPONSE_DATA_02_MASK;
Shift = COMP_BCAM_BASE_RESPONSE_DATA_02_RESPONSE_DATA_02_SHIFT;
WorkingAddr = (XLNX_COMPONENT_ADDRESS_TYPE)((ContextPtr->ComponentBaseAddress) + Offset);
Buffer = (ResponseData02 << Shift);
ret_val = XLNX_Environment_Wrapper_Write32_WithMask(ContextPtr->UserEnvironment.Device_IO.Write32WithMask, ContextPtr->UserContextPtr, WorkingAddr, Buffer, Mask);
return ret_val;
}
void XLNX_COMP_BCAM_BuildCompBcamBaseResponseData02ResponseData02(uint32_t* MaskPtr, uint32_t* ValPtr, uint32_t ResponseData02)
{
*MaskPtr |= COMP_BCAM_BASE_RESPONSE_DATA_02_RESPONSE_DATA_02_MASK;
*ValPtr |= (ResponseData02 << COMP_BCAM_BASE_RESPONSE_DATA_02_RESPONSE_DATA_02_SHIFT);
}
XLNX_ERROR_CODE XLNX_COMP_BCAM_GetCompBcamBaseResponseData02ResponseData02(XLNX_COMP_BCAM_CONTEXT_TYPE* ContextPtr, uint32_t* ResponseData02Ptr)
{
XLNX_ERROR_CODE ret_val = XLNX_OK;
uint32_t Offset, Mask, Shift, Buffer;
XLNX_COMPONENT_ADDRESS_TYPE WorkingAddr;
Offset = (COMP_BCAM_BASE_RESPONSE_DATA_02_REG_OFFSET);
Mask = COMP_BCAM_BASE_RESPONSE_DATA_02_RESPONSE_DATA_02_MASK;
Shift = COMP_BCAM_BASE_RESPONSE_DATA_02_RESPONSE_DATA_02_SHIFT;
WorkingAddr = (XLNX_COMPONENT_ADDRESS_TYPE)((ContextPtr->ComponentBaseAddress) + Offset);
ret_val = XLNX_Environment_Wrapper_Read32(ContextPtr->UserEnvironment.Device_IO.Read32, ContextPtr->UserContextPtr, &Buffer, WorkingAddr);
if (XLNX_OK == ret_val)
{
*ResponseData02Ptr = ((Buffer & Mask) >> Shift);
}
return ret_val;
}
XLNX_ERROR_CODE XLNX_COMP_BCAM_SetCompBcamBaseResponseData02Reg(XLNX_COMP_BCAM_CONTEXT_TYPE* ContextPtr, uint32_t Mask, uint32_t Value)
{
XLNX_ERROR_CODE ret_val = XLNX_OK;
uint32_t Offset;
XLNX_COMPONENT_ADDRESS_TYPE WorkingAddr;
Offset = (COMP_BCAM_BASE_RESPONSE_DATA_02_REG_OFFSET);
WorkingAddr = (XLNX_COMPONENT_ADDRESS_TYPE)((ContextPtr->ComponentBaseAddress) + Offset);
ret_val = XLNX_Environment_Wrapper_Write32_WithMask(ContextPtr->UserEnvironment.Device_IO.Write32WithMask, ContextPtr->UserContextPtr, WorkingAddr, Value, Mask);
return ret_val;
}
XLNX_ERROR_CODE XLNX_COMP_BCAM_GetCompBcamBaseResponseData02Reg(XLNX_COMP_BCAM_CONTEXT_TYPE* ContextPtr, uint32_t* ValuePtr)
{
XLNX_ERROR_CODE ret_val = XLNX_OK;
uint32_t Offset;
XLNX_COMPONENT_ADDRESS_TYPE WorkingAddr;
Offset = (COMP_BCAM_BASE_RESPONSE_DATA_02_REG_OFFSET);
WorkingAddr = (XLNX_COMPONENT_ADDRESS_TYPE)((ContextPtr->ComponentBaseAddress) + Offset);
ret_val = XLNX_Environment_Wrapper_Read32(ContextPtr->UserEnvironment.Device_IO.Read32, ContextPtr->UserContextPtr, ValuePtr, WorkingAddr);
return ret_val;
}
XLNX_ERROR_CODE XLNX_COMP_BCAM_SetCompBcamBaseResponseData03ResponseData03(XLNX_COMP_BCAM_CONTEXT_TYPE* ContextPtr, uint32_t ResponseData03)
{
XLNX_ERROR_CODE ret_val = XLNX_OK;
uint32_t Offset, Mask, Shift, Buffer;
XLNX_COMPONENT_ADDRESS_TYPE WorkingAddr;
Offset = (COMP_BCAM_BASE_RESPONSE_DATA_03_REG_OFFSET);
Mask = COMP_BCAM_BASE_RESPONSE_DATA_03_RESPONSE_DATA_03_MASK;
Shift = COMP_BCAM_BASE_RESPONSE_DATA_03_RESPONSE_DATA_03_SHIFT;
WorkingAddr = (XLNX_COMPONENT_ADDRESS_TYPE)((ContextPtr->ComponentBaseAddress) + Offset);
Buffer = (ResponseData03 << Shift);
ret_val = XLNX_Environment_Wrapper_Write32_WithMask(ContextPtr->UserEnvironment.Device_IO.Write32WithMask, ContextPtr->UserContextPtr, WorkingAddr, Buffer, Mask);
return ret_val;
}
void XLNX_COMP_BCAM_BuildCompBcamBaseResponseData03ResponseData03(uint32_t* MaskPtr, uint32_t* ValPtr, uint32_t ResponseData03)
{
*MaskPtr |= COMP_BCAM_BASE_RESPONSE_DATA_03_RESPONSE_DATA_03_MASK;
*ValPtr |= (ResponseData03 << COMP_BCAM_BASE_RESPONSE_DATA_03_RESPONSE_DATA_03_SHIFT);
}
XLNX_ERROR_CODE XLNX_COMP_BCAM_GetCompBcamBaseResponseData03ResponseData03(XLNX_COMP_BCAM_CONTEXT_TYPE* ContextPtr, uint32_t* ResponseData03Ptr)
{
XLNX_ERROR_CODE ret_val = XLNX_OK;
uint32_t Offset, Mask, Shift, Buffer;
XLNX_COMPONENT_ADDRESS_TYPE WorkingAddr;
Offset = (COMP_BCAM_BASE_RESPONSE_DATA_03_REG_OFFSET);
Mask = COMP_BCAM_BASE_RESPONSE_DATA_03_RESPONSE_DATA_03_MASK;
Shift = COMP_BCAM_BASE_RESPONSE_DATA_03_RESPONSE_DATA_03_SHIFT;
WorkingAddr = (XLNX_COMPONENT_ADDRESS_TYPE)((ContextPtr->ComponentBaseAddress) + Offset);
ret_val = XLNX_Environment_Wrapper_Read32(ContextPtr->UserEnvironment.Device_IO.Read32, ContextPtr->UserContextPtr, &Buffer, WorkingAddr);
if (XLNX_OK == ret_val)
{
*ResponseData03Ptr = ((Buffer & Mask) >> Shift);
}
return ret_val;
}
XLNX_ERROR_CODE XLNX_COMP_BCAM_SetCompBcamBaseResponseData03Reg(XLNX_COMP_BCAM_CONTEXT_TYPE* ContextPtr, uint32_t Mask, uint32_t Value)
{
XLNX_ERROR_CODE ret_val = XLNX_OK;
uint32_t Offset;
XLNX_COMPONENT_ADDRESS_TYPE WorkingAddr;
Offset = (COMP_BCAM_BASE_RESPONSE_DATA_03_REG_OFFSET);
WorkingAddr = (XLNX_COMPONENT_ADDRESS_TYPE)((ContextPtr->ComponentBaseAddress) + Offset);
ret_val = XLNX_Environment_Wrapper_Write32_WithMask(ContextPtr->UserEnvironment.Device_IO.Write32WithMask, ContextPtr->UserContextPtr, WorkingAddr, Value, Mask);
return ret_val;
}
XLNX_ERROR_CODE XLNX_COMP_BCAM_GetCompBcamBaseResponseData03Reg(XLNX_COMP_BCAM_CONTEXT_TYPE* ContextPtr, uint32_t* ValuePtr)
{
XLNX_ERROR_CODE ret_val = XLNX_OK;
uint32_t Offset;
XLNX_COMPONENT_ADDRESS_TYPE WorkingAddr;
Offset = (COMP_BCAM_BASE_RESPONSE_DATA_03_REG_OFFSET);
WorkingAddr = (XLNX_COMPONENT_ADDRESS_TYPE)((ContextPtr->ComponentBaseAddress) + Offset);
ret_val = XLNX_Environment_Wrapper_Read32(ContextPtr->UserEnvironment.Device_IO.Read32, ContextPtr->UserContextPtr, ValuePtr, WorkingAddr);
return ret_val;
}
XLNX_ERROR_CODE XLNX_COMP_BCAM_SetCompBcamBaseResponseData04ResponseData04(XLNX_COMP_BCAM_CONTEXT_TYPE* ContextPtr, uint32_t ResponseData04)
{
XLNX_ERROR_CODE ret_val = XLNX_OK;
uint32_t Offset, Mask, Shift, Buffer;
XLNX_COMPONENT_ADDRESS_TYPE WorkingAddr;
Offset = (COMP_BCAM_BASE_RESPONSE_DATA_04_REG_OFFSET);
Mask = COMP_BCAM_BASE_RESPONSE_DATA_04_RESPONSE_DATA_04_MASK;
Shift = COMP_BCAM_BASE_RESPONSE_DATA_04_RESPONSE_DATA_04_SHIFT;
WorkingAddr = (XLNX_COMPONENT_ADDRESS_TYPE)((ContextPtr->ComponentBaseAddress) + Offset);
Buffer = (ResponseData04 << Shift);
ret_val = XLNX_Environment_Wrapper_Write32_WithMask(ContextPtr->UserEnvironment.Device_IO.Write32WithMask, ContextPtr->UserContextPtr, WorkingAddr, Buffer, Mask);
return ret_val;
}
void XLNX_COMP_BCAM_BuildCompBcamBaseResponseData04ResponseData04(uint32_t* MaskPtr, uint32_t* ValPtr, uint32_t ResponseData04)
{
*MaskPtr |= COMP_BCAM_BASE_RESPONSE_DATA_04_RESPONSE_DATA_04_MASK;
*ValPtr |= (ResponseData04 << COMP_BCAM_BASE_RESPONSE_DATA_04_RESPONSE_DATA_04_SHIFT);
}
XLNX_ERROR_CODE XLNX_COMP_BCAM_GetCompBcamBaseResponseData04ResponseData04(XLNX_COMP_BCAM_CONTEXT_TYPE* ContextPtr, uint32_t* ResponseData04Ptr)
{
XLNX_ERROR_CODE ret_val = XLNX_OK;
uint32_t Offset, Mask, Shift, Buffer;
XLNX_COMPONENT_ADDRESS_TYPE WorkingAddr;
Offset = (COMP_BCAM_BASE_RESPONSE_DATA_04_REG_OFFSET);
Mask = COMP_BCAM_BASE_RESPONSE_DATA_04_RESPONSE_DATA_04_MASK;
Shift = COMP_BCAM_BASE_RESPONSE_DATA_04_RESPONSE_DATA_04_SHIFT;
WorkingAddr = (XLNX_COMPONENT_ADDRESS_TYPE)((ContextPtr->ComponentBaseAddress) + Offset);
ret_val = XLNX_Environment_Wrapper_Read32(ContextPtr->UserEnvironment.Device_IO.Read32, ContextPtr->UserContextPtr, &Buffer, WorkingAddr);
if (XLNX_OK == ret_val)
{
*ResponseData04Ptr = ((Buffer & Mask) >> Shift);
}
return ret_val;
}
XLNX_ERROR_CODE XLNX_COMP_BCAM_SetCompBcamBaseResponseData04Reg(XLNX_COMP_BCAM_CONTEXT_TYPE* ContextPtr, uint32_t Mask, uint32_t Value)
{
XLNX_ERROR_CODE ret_val = XLNX_OK;
uint32_t Offset;
XLNX_COMPONENT_ADDRESS_TYPE WorkingAddr;
Offset = (COMP_BCAM_BASE_RESPONSE_DATA_04_REG_OFFSET);
WorkingAddr = (XLNX_COMPONENT_ADDRESS_TYPE)((ContextPtr->ComponentBaseAddress) + Offset);
ret_val = XLNX_Environment_Wrapper_Write32_WithMask(ContextPtr->UserEnvironment.Device_IO.Write32WithMask, ContextPtr->UserContextPtr, WorkingAddr, Value, Mask);
return ret_val;
}
XLNX_ERROR_CODE XLNX_COMP_BCAM_GetCompBcamBaseResponseData04Reg(XLNX_COMP_BCAM_CONTEXT_TYPE* ContextPtr, uint32_t* ValuePtr)
{
XLNX_ERROR_CODE ret_val = XLNX_OK;
uint32_t Offset;
XLNX_COMPONENT_ADDRESS_TYPE WorkingAddr;
Offset = (COMP_BCAM_BASE_RESPONSE_DATA_04_REG_OFFSET);
WorkingAddr = (XLNX_COMPONENT_ADDRESS_TYPE)((ContextPtr->ComponentBaseAddress) + Offset);
ret_val = XLNX_Environment_Wrapper_Read32(ContextPtr->UserEnvironment.Device_IO.Read32, ContextPtr->UserContextPtr, ValuePtr, WorkingAddr);
return ret_val;
}
XLNX_ERROR_CODE XLNX_COMP_BCAM_SetCompBcamBaseResponseData05ResponseData05(XLNX_COMP_BCAM_CONTEXT_TYPE* ContextPtr, uint32_t ResponseData05)
{
XLNX_ERROR_CODE ret_val = XLNX_OK;
uint32_t Offset, Mask, Shift, Buffer;
XLNX_COMPONENT_ADDRESS_TYPE WorkingAddr;
Offset = (COMP_BCAM_BASE_RESPONSE_DATA_05_REG_OFFSET);
Mask = COMP_BCAM_BASE_RESPONSE_DATA_05_RESPONSE_DATA_05_MASK;
Shift = COMP_BCAM_BASE_RESPONSE_DATA_05_RESPONSE_DATA_05_SHIFT;
WorkingAddr = (XLNX_COMPONENT_ADDRESS_TYPE)((ContextPtr->ComponentBaseAddress) + Offset);
Buffer = (ResponseData05 << Shift);
ret_val = XLNX_Environment_Wrapper_Write32_WithMask(ContextPtr->UserEnvironment.Device_IO.Write32WithMask, ContextPtr->UserContextPtr, WorkingAddr, Buffer, Mask);
return ret_val;
}
void XLNX_COMP_BCAM_BuildCompBcamBaseResponseData05ResponseData05(uint32_t* MaskPtr, uint32_t* ValPtr, uint32_t ResponseData05)
{
*MaskPtr |= COMP_BCAM_BASE_RESPONSE_DATA_05_RESPONSE_DATA_05_MASK;
*ValPtr |= (ResponseData05 << COMP_BCAM_BASE_RESPONSE_DATA_05_RESPONSE_DATA_05_SHIFT);
}
XLNX_ERROR_CODE XLNX_COMP_BCAM_GetCompBcamBaseResponseData05ResponseData05(XLNX_COMP_BCAM_CONTEXT_TYPE* ContextPtr, uint32_t* ResponseData05Ptr)
{
XLNX_ERROR_CODE ret_val = XLNX_OK;
uint32_t Offset, Mask, Shift, Buffer;
XLNX_COMPONENT_ADDRESS_TYPE WorkingAddr;
Offset = (COMP_BCAM_BASE_RESPONSE_DATA_05_REG_OFFSET);
Mask = COMP_BCAM_BASE_RESPONSE_DATA_05_RESPONSE_DATA_05_MASK;
Shift = COMP_BCAM_BASE_RESPONSE_DATA_05_RESPONSE_DATA_05_SHIFT;
WorkingAddr = (XLNX_COMPONENT_ADDRESS_TYPE)((ContextPtr->ComponentBaseAddress) + Offset);
ret_val = XLNX_Environment_Wrapper_Read32(ContextPtr->UserEnvironment.Device_IO.Read32, ContextPtr->UserContextPtr, &Buffer, WorkingAddr);
if (XLNX_OK == ret_val)
{
*ResponseData05Ptr = ((Buffer & Mask) >> Shift);
}
return ret_val;
}
XLNX_ERROR_CODE XLNX_COMP_BCAM_SetCompBcamBaseResponseData05Reg(XLNX_COMP_BCAM_CONTEXT_TYPE* ContextPtr, uint32_t Mask, uint32_t Value)
{
XLNX_ERROR_CODE ret_val = XLNX_OK;
uint32_t Offset;
XLNX_COMPONENT_ADDRESS_TYPE WorkingAddr;
Offset = (COMP_BCAM_BASE_RESPONSE_DATA_05_REG_OFFSET);
WorkingAddr = (XLNX_COMPONENT_ADDRESS_TYPE)((ContextPtr->ComponentBaseAddress) + Offset);
ret_val = XLNX_Environment_Wrapper_Write32_WithMask(ContextPtr->UserEnvironment.Device_IO.Write32WithMask, ContextPtr->UserContextPtr, WorkingAddr, Value, Mask);
return ret_val;
}
XLNX_ERROR_CODE XLNX_COMP_BCAM_GetCompBcamBaseResponseData05Reg(XLNX_COMP_BCAM_CONTEXT_TYPE* ContextPtr, uint32_t* ValuePtr)
{
XLNX_ERROR_CODE ret_val = XLNX_OK;
uint32_t Offset;
XLNX_COMPONENT_ADDRESS_TYPE WorkingAddr;
Offset = (COMP_BCAM_BASE_RESPONSE_DATA_05_REG_OFFSET);
WorkingAddr = (XLNX_COMPONENT_ADDRESS_TYPE)((ContextPtr->ComponentBaseAddress) + Offset);
ret_val = XLNX_Environment_Wrapper_Read32(ContextPtr->UserEnvironment.Device_IO.Read32, ContextPtr->UserContextPtr, ValuePtr, WorkingAddr);
return ret_val;
}
XLNX_ERROR_CODE XLNX_COMP_BCAM_SetCompBcamBaseResponseData06ResponseData06(XLNX_COMP_BCAM_CONTEXT_TYPE* ContextPtr, uint32_t ResponseData06)
{
XLNX_ERROR_CODE ret_val = XLNX_OK;
uint32_t Offset, Mask, Shift, Buffer;
XLNX_COMPONENT_ADDRESS_TYPE WorkingAddr;
Offset = (COMP_BCAM_BASE_RESPONSE_DATA_06_REG_OFFSET);
Mask = COMP_BCAM_BASE_RESPONSE_DATA_06_RESPONSE_DATA_06_MASK;
Shift = COMP_BCAM_BASE_RESPONSE_DATA_06_RESPONSE_DATA_06_SHIFT;
WorkingAddr = (XLNX_COMPONENT_ADDRESS_TYPE)((ContextPtr->ComponentBaseAddress) + Offset);
Buffer = (ResponseData06 << Shift);
ret_val = XLNX_Environment_Wrapper_Write32_WithMask(ContextPtr->UserEnvironment.Device_IO.Write32WithMask, ContextPtr->UserContextPtr, WorkingAddr, Buffer, Mask);
return ret_val;
}
void XLNX_COMP_BCAM_BuildCompBcamBaseResponseData06ResponseData06(uint32_t* MaskPtr, uint32_t* ValPtr, uint32_t ResponseData06)
{
*MaskPtr |= COMP_BCAM_BASE_RESPONSE_DATA_06_RESPONSE_DATA_06_MASK;
*ValPtr |= (ResponseData06 << COMP_BCAM_BASE_RESPONSE_DATA_06_RESPONSE_DATA_06_SHIFT);
}
XLNX_ERROR_CODE XLNX_COMP_BCAM_GetCompBcamBaseResponseData06ResponseData06(XLNX_COMP_BCAM_CONTEXT_TYPE* ContextPtr, uint32_t* ResponseData06Ptr)
{
XLNX_ERROR_CODE ret_val = XLNX_OK;
uint32_t Offset, Mask, Shift, Buffer;
XLNX_COMPONENT_ADDRESS_TYPE WorkingAddr;
Offset = (COMP_BCAM_BASE_RESPONSE_DATA_06_REG_OFFSET);
Mask = COMP_BCAM_BASE_RESPONSE_DATA_06_RESPONSE_DATA_06_MASK;
Shift = COMP_BCAM_BASE_RESPONSE_DATA_06_RESPONSE_DATA_06_SHIFT;
WorkingAddr = (XLNX_COMPONENT_ADDRESS_TYPE)((ContextPtr->ComponentBaseAddress) + Offset);
ret_val = XLNX_Environment_Wrapper_Read32(ContextPtr->UserEnvironment.Device_IO.Read32, ContextPtr->UserContextPtr, &Buffer, WorkingAddr);
if (XLNX_OK == ret_val)
{
*ResponseData06Ptr = ((Buffer & Mask) >> Shift);
}
return ret_val;
}
XLNX_ERROR_CODE XLNX_COMP_BCAM_SetCompBcamBaseResponseData06Reg(XLNX_COMP_BCAM_CONTEXT_TYPE* ContextPtr, uint32_t Mask, uint32_t Value)
{
XLNX_ERROR_CODE ret_val = XLNX_OK;
uint32_t Offset;
XLNX_COMPONENT_ADDRESS_TYPE WorkingAddr;
Offset = (COMP_BCAM_BASE_RESPONSE_DATA_06_REG_OFFSET);
WorkingAddr = (XLNX_COMPONENT_ADDRESS_TYPE)((ContextPtr->ComponentBaseAddress) + Offset);
ret_val = XLNX_Environment_Wrapper_Write32_WithMask(ContextPtr->UserEnvironment.Device_IO.Write32WithMask, ContextPtr->UserContextPtr, WorkingAddr, Value, Mask);
return ret_val;
}
XLNX_ERROR_CODE XLNX_COMP_BCAM_GetCompBcamBaseResponseData06Reg(XLNX_COMP_BCAM_CONTEXT_TYPE* ContextPtr, uint32_t* ValuePtr)
{
XLNX_ERROR_CODE ret_val = XLNX_OK;
uint32_t Offset;
XLNX_COMPONENT_ADDRESS_TYPE WorkingAddr;
Offset = (COMP_BCAM_BASE_RESPONSE_DATA_06_REG_OFFSET);
WorkingAddr = (XLNX_COMPONENT_ADDRESS_TYPE)((ContextPtr->ComponentBaseAddress) + Offset);
ret_val = XLNX_Environment_Wrapper_Read32(ContextPtr->UserEnvironment.Device_IO.Read32, ContextPtr->UserContextPtr, ValuePtr, WorkingAddr);
return ret_val;
}
XLNX_ERROR_CODE XLNX_COMP_BCAM_SetCompBcamBaseResponseData07ResponseData07(XLNX_COMP_BCAM_CONTEXT_TYPE* ContextPtr, uint32_t ResponseData07)
{
XLNX_ERROR_CODE ret_val = XLNX_OK;
uint32_t Offset, Mask, Shift, Buffer;
XLNX_COMPONENT_ADDRESS_TYPE WorkingAddr;
Offset = (COMP_BCAM_BASE_RESPONSE_DATA_07_REG_OFFSET);
Mask = COMP_BCAM_BASE_RESPONSE_DATA_07_RESPONSE_DATA_07_MASK;
Shift = COMP_BCAM_BASE_RESPONSE_DATA_07_RESPONSE_DATA_07_SHIFT;
WorkingAddr = (XLNX_COMPONENT_ADDRESS_TYPE)((ContextPtr->ComponentBaseAddress) + Offset);
Buffer = (ResponseData07 << Shift);
ret_val = XLNX_Environment_Wrapper_Write32_WithMask(ContextPtr->UserEnvironment.Device_IO.Write32WithMask, ContextPtr->UserContextPtr, WorkingAddr, Buffer, Mask);
return ret_val;
}
void XLNX_COMP_BCAM_BuildCompBcamBaseResponseData07ResponseData07(uint32_t* MaskPtr, uint32_t* ValPtr, uint32_t ResponseData07)
{
*MaskPtr |= COMP_BCAM_BASE_RESPONSE_DATA_07_RESPONSE_DATA_07_MASK;
*ValPtr |= (ResponseData07 << COMP_BCAM_BASE_RESPONSE_DATA_07_RESPONSE_DATA_07_SHIFT);
}
XLNX_ERROR_CODE XLNX_COMP_BCAM_GetCompBcamBaseResponseData07ResponseData07(XLNX_COMP_BCAM_CONTEXT_TYPE* ContextPtr, uint32_t* ResponseData07Ptr)
{
XLNX_ERROR_CODE ret_val = XLNX_OK;
uint32_t Offset, Mask, Shift, Buffer;
XLNX_COMPONENT_ADDRESS_TYPE WorkingAddr;
Offset = (COMP_BCAM_BASE_RESPONSE_DATA_07_REG_OFFSET);
Mask = COMP_BCAM_BASE_RESPONSE_DATA_07_RESPONSE_DATA_07_MASK;
Shift = COMP_BCAM_BASE_RESPONSE_DATA_07_RESPONSE_DATA_07_SHIFT;
WorkingAddr = (XLNX_COMPONENT_ADDRESS_TYPE)((ContextPtr->ComponentBaseAddress) + Offset);
ret_val = XLNX_Environment_Wrapper_Read32(ContextPtr->UserEnvironment.Device_IO.Read32, ContextPtr->UserContextPtr, &Buffer, WorkingAddr);
if (XLNX_OK == ret_val)
{
*ResponseData07Ptr = ((Buffer & Mask) >> Shift);
}
return ret_val;
}
XLNX_ERROR_CODE XLNX_COMP_BCAM_SetCompBcamBaseResponseData07Reg(XLNX_COMP_BCAM_CONTEXT_TYPE* ContextPtr, uint32_t Mask, uint32_t Value)
{
XLNX_ERROR_CODE ret_val = XLNX_OK;
uint32_t Offset;
XLNX_COMPONENT_ADDRESS_TYPE WorkingAddr;
Offset = (COMP_BCAM_BASE_RESPONSE_DATA_07_REG_OFFSET);
WorkingAddr = (XLNX_COMPONENT_ADDRESS_TYPE)((ContextPtr->ComponentBaseAddress) + Offset);
ret_val = XLNX_Environment_Wrapper_Write32_WithMask(ContextPtr->UserEnvironment.Device_IO.Write32WithMask, ContextPtr->UserContextPtr, WorkingAddr, Value, Mask);
return ret_val;
}
XLNX_ERROR_CODE XLNX_COMP_BCAM_GetCompBcamBaseResponseData07Reg(XLNX_COMP_BCAM_CONTEXT_TYPE* ContextPtr, uint32_t* ValuePtr)
{
XLNX_ERROR_CODE ret_val = XLNX_OK;
uint32_t Offset;
XLNX_COMPONENT_ADDRESS_TYPE WorkingAddr;
Offset = (COMP_BCAM_BASE_RESPONSE_DATA_07_REG_OFFSET);
WorkingAddr = (XLNX_COMPONENT_ADDRESS_TYPE)((ContextPtr->ComponentBaseAddress) + Offset);
ret_val = XLNX_Environment_Wrapper_Read32(ContextPtr->UserEnvironment.Device_IO.Read32, ContextPtr->UserContextPtr, ValuePtr, WorkingAddr);
return ret_val;
}
XLNX_ERROR_CODE XLNX_COMP_BCAM_SetCompBcamBaseResponseData08ResponseData08(XLNX_COMP_BCAM_CONTEXT_TYPE* ContextPtr, uint32_t ResponseData08)
{
XLNX_ERROR_CODE ret_val = XLNX_OK;
uint32_t Offset, Mask, Shift, Buffer;
XLNX_COMPONENT_ADDRESS_TYPE WorkingAddr;
Offset = (COMP_BCAM_BASE_RESPONSE_DATA_08_REG_OFFSET);
Mask = COMP_BCAM_BASE_RESPONSE_DATA_08_RESPONSE_DATA_08_MASK;
Shift = COMP_BCAM_BASE_RESPONSE_DATA_08_RESPONSE_DATA_08_SHIFT;
WorkingAddr = (XLNX_COMPONENT_ADDRESS_TYPE)((ContextPtr->ComponentBaseAddress) + Offset);
Buffer = (ResponseData08 << Shift);
ret_val = XLNX_Environment_Wrapper_Write32_WithMask(ContextPtr->UserEnvironment.Device_IO.Write32WithMask, ContextPtr->UserContextPtr, WorkingAddr, Buffer, Mask);
return ret_val;
}
void XLNX_COMP_BCAM_BuildCompBcamBaseResponseData08ResponseData08(uint32_t* MaskPtr, uint32_t* ValPtr, uint32_t ResponseData08)
{
*MaskPtr |= COMP_BCAM_BASE_RESPONSE_DATA_08_RESPONSE_DATA_08_MASK;
*ValPtr |= (ResponseData08 << COMP_BCAM_BASE_RESPONSE_DATA_08_RESPONSE_DATA_08_SHIFT);
}
XLNX_ERROR_CODE XLNX_COMP_BCAM_GetCompBcamBaseResponseData08ResponseData08(XLNX_COMP_BCAM_CONTEXT_TYPE* ContextPtr, uint32_t* ResponseData08Ptr)
{
XLNX_ERROR_CODE ret_val = XLNX_OK;
uint32_t Offset, Mask, Shift, Buffer;
XLNX_COMPONENT_ADDRESS_TYPE WorkingAddr;
Offset = (COMP_BCAM_BASE_RESPONSE_DATA_08_REG_OFFSET);
Mask = COMP_BCAM_BASE_RESPONSE_DATA_08_RESPONSE_DATA_08_MASK;
Shift = COMP_BCAM_BASE_RESPONSE_DATA_08_RESPONSE_DATA_08_SHIFT;
WorkingAddr = (XLNX_COMPONENT_ADDRESS_TYPE)((ContextPtr->ComponentBaseAddress) + Offset);
ret_val = XLNX_Environment_Wrapper_Read32(ContextPtr->UserEnvironment.Device_IO.Read32, ContextPtr->UserContextPtr, &Buffer, WorkingAddr);
if (XLNX_OK == ret_val)
{
*ResponseData08Ptr = ((Buffer & Mask) >> Shift);
}
return ret_val;
}
XLNX_ERROR_CODE XLNX_COMP_BCAM_SetCompBcamBaseResponseData08Reg(XLNX_COMP_BCAM_CONTEXT_TYPE* ContextPtr, uint32_t Mask, uint32_t Value)
{
XLNX_ERROR_CODE ret_val = XLNX_OK;
uint32_t Offset;
XLNX_COMPONENT_ADDRESS_TYPE WorkingAddr;
Offset = (COMP_BCAM_BASE_RESPONSE_DATA_08_REG_OFFSET);
WorkingAddr = (XLNX_COMPONENT_ADDRESS_TYPE)((ContextPtr->ComponentBaseAddress) + Offset);
ret_val = XLNX_Environment_Wrapper_Write32_WithMask(ContextPtr->UserEnvironment.Device_IO.Write32WithMask, ContextPtr->UserContextPtr, WorkingAddr, Value, Mask);
return ret_val;
}
XLNX_ERROR_CODE XLNX_COMP_BCAM_GetCompBcamBaseResponseData08Reg(XLNX_COMP_BCAM_CONTEXT_TYPE* ContextPtr, uint32_t* ValuePtr)
{
XLNX_ERROR_CODE ret_val = XLNX_OK;
uint32_t Offset;
XLNX_COMPONENT_ADDRESS_TYPE WorkingAddr;
Offset = (COMP_BCAM_BASE_RESPONSE_DATA_08_REG_OFFSET);
WorkingAddr = (XLNX_COMPONENT_ADDRESS_TYPE)((ContextPtr->ComponentBaseAddress) + Offset);
ret_val = XLNX_Environment_Wrapper_Read32(ContextPtr->UserEnvironment.Device_IO.Read32, ContextPtr->UserContextPtr, ValuePtr, WorkingAddr);
return ret_val;
}
XLNX_ERROR_CODE XLNX_COMP_BCAM_SetCompBcamBaseResponseData09ResponseData09(XLNX_COMP_BCAM_CONTEXT_TYPE* ContextPtr, uint32_t ResponseData09)
{
XLNX_ERROR_CODE ret_val = XLNX_OK;
uint32_t Offset, Mask, Shift, Buffer;
XLNX_COMPONENT_ADDRESS_TYPE WorkingAddr;
Offset = (COMP_BCAM_BASE_RESPONSE_DATA_09_REG_OFFSET);
Mask = COMP_BCAM_BASE_RESPONSE_DATA_09_RESPONSE_DATA_09_MASK;
Shift = COMP_BCAM_BASE_RESPONSE_DATA_09_RESPONSE_DATA_09_SHIFT;
WorkingAddr = (XLNX_COMPONENT_ADDRESS_TYPE)((ContextPtr->ComponentBaseAddress) + Offset);
Buffer = (ResponseData09 << Shift);
ret_val = XLNX_Environment_Wrapper_Write32_WithMask(ContextPtr->UserEnvironment.Device_IO.Write32WithMask, ContextPtr->UserContextPtr, WorkingAddr, Buffer, Mask);
return ret_val;
}
void XLNX_COMP_BCAM_BuildCompBcamBaseResponseData09ResponseData09(uint32_t* MaskPtr, uint32_t* ValPtr, uint32_t ResponseData09)
{
*MaskPtr |= COMP_BCAM_BASE_RESPONSE_DATA_09_RESPONSE_DATA_09_MASK;
*ValPtr |= (ResponseData09 << COMP_BCAM_BASE_RESPONSE_DATA_09_RESPONSE_DATA_09_SHIFT);
}
XLNX_ERROR_CODE XLNX_COMP_BCAM_GetCompBcamBaseResponseData09ResponseData09(XLNX_COMP_BCAM_CONTEXT_TYPE* ContextPtr, uint32_t* ResponseData09Ptr)
{
XLNX_ERROR_CODE ret_val = XLNX_OK;
uint32_t Offset, Mask, Shift, Buffer;
XLNX_COMPONENT_ADDRESS_TYPE WorkingAddr;
Offset = (COMP_BCAM_BASE_RESPONSE_DATA_09_REG_OFFSET);
Mask = COMP_BCAM_BASE_RESPONSE_DATA_09_RESPONSE_DATA_09_MASK;
Shift = COMP_BCAM_BASE_RESPONSE_DATA_09_RESPONSE_DATA_09_SHIFT;
WorkingAddr = (XLNX_COMPONENT_ADDRESS_TYPE)((ContextPtr->ComponentBaseAddress) + Offset);
ret_val = XLNX_Environment_Wrapper_Read32(ContextPtr->UserEnvironment.Device_IO.Read32, ContextPtr->UserContextPtr, &Buffer, WorkingAddr);
if (XLNX_OK == ret_val)
{
*ResponseData09Ptr = ((Buffer & Mask) >> Shift);
}
return ret_val;
}
XLNX_ERROR_CODE XLNX_COMP_BCAM_SetCompBcamBaseResponseData09Reg(XLNX_COMP_BCAM_CONTEXT_TYPE* ContextPtr, uint32_t Mask, uint32_t Value)
{
XLNX_ERROR_CODE ret_val = XLNX_OK;
uint32_t Offset;
XLNX_COMPONENT_ADDRESS_TYPE WorkingAddr;
Offset = (COMP_BCAM_BASE_RESPONSE_DATA_09_REG_OFFSET);
WorkingAddr = (XLNX_COMPONENT_ADDRESS_TYPE)((ContextPtr->ComponentBaseAddress) + Offset);
ret_val = XLNX_Environment_Wrapper_Write32_WithMask(ContextPtr->UserEnvironment.Device_IO.Write32WithMask, ContextPtr->UserContextPtr, WorkingAddr, Value, Mask);
return ret_val;
}
XLNX_ERROR_CODE XLNX_COMP_BCAM_GetCompBcamBaseResponseData09Reg(XLNX_COMP_BCAM_CONTEXT_TYPE* ContextPtr, uint32_t* ValuePtr)
{
XLNX_ERROR_CODE ret_val = XLNX_OK;
uint32_t Offset;
XLNX_COMPONENT_ADDRESS_TYPE WorkingAddr;
Offset = (COMP_BCAM_BASE_RESPONSE_DATA_09_REG_OFFSET);
WorkingAddr = (XLNX_COMPONENT_ADDRESS_TYPE)((ContextPtr->ComponentBaseAddress) + Offset);
ret_val = XLNX_Environment_Wrapper_Read32(ContextPtr->UserEnvironment.Device_IO.Read32, ContextPtr->UserContextPtr, ValuePtr, WorkingAddr);
return ret_val;
}
XLNX_ERROR_CODE XLNX_COMP_BCAM_SetCompBcamBaseResponseData10ResponseData10(XLNX_COMP_BCAM_CONTEXT_TYPE* ContextPtr, uint32_t ResponseData10)
{
XLNX_ERROR_CODE ret_val = XLNX_OK;
uint32_t Offset, Mask, Shift, Buffer;
XLNX_COMPONENT_ADDRESS_TYPE WorkingAddr;
Offset = (COMP_BCAM_BASE_RESPONSE_DATA_10_REG_OFFSET);
Mask = COMP_BCAM_BASE_RESPONSE_DATA_10_RESPONSE_DATA_10_MASK;
Shift = COMP_BCAM_BASE_RESPONSE_DATA_10_RESPONSE_DATA_10_SHIFT;
WorkingAddr = (XLNX_COMPONENT_ADDRESS_TYPE)((ContextPtr->ComponentBaseAddress) + Offset);
Buffer = (ResponseData10 << Shift);
ret_val = XLNX_Environment_Wrapper_Write32_WithMask(ContextPtr->UserEnvironment.Device_IO.Write32WithMask, ContextPtr->UserContextPtr, WorkingAddr, Buffer, Mask);
return ret_val;
}
void XLNX_COMP_BCAM_BuildCompBcamBaseResponseData10ResponseData10(uint32_t* MaskPtr, uint32_t* ValPtr, uint32_t ResponseData10)
{
*MaskPtr |= COMP_BCAM_BASE_RESPONSE_DATA_10_RESPONSE_DATA_10_MASK;
*ValPtr |= (ResponseData10 << COMP_BCAM_BASE_RESPONSE_DATA_10_RESPONSE_DATA_10_SHIFT);
}
XLNX_ERROR_CODE XLNX_COMP_BCAM_GetCompBcamBaseResponseData10ResponseData10(XLNX_COMP_BCAM_CONTEXT_TYPE* ContextPtr, uint32_t* ResponseData10Ptr)
{
XLNX_ERROR_CODE ret_val = XLNX_OK;
uint32_t Offset, Mask, Shift, Buffer;
XLNX_COMPONENT_ADDRESS_TYPE WorkingAddr;
Offset = (COMP_BCAM_BASE_RESPONSE_DATA_10_REG_OFFSET);
Mask = COMP_BCAM_BASE_RESPONSE_DATA_10_RESPONSE_DATA_10_MASK;
Shift = COMP_BCAM_BASE_RESPONSE_DATA_10_RESPONSE_DATA_10_SHIFT;
WorkingAddr = (XLNX_COMPONENT_ADDRESS_TYPE)((ContextPtr->ComponentBaseAddress) + Offset);
ret_val = XLNX_Environment_Wrapper_Read32(ContextPtr->UserEnvironment.Device_IO.Read32, ContextPtr->UserContextPtr, &Buffer, WorkingAddr);
if (XLNX_OK == ret_val)
{
*ResponseData10Ptr = ((Buffer & Mask) >> Shift);
}
return ret_val;
}
XLNX_ERROR_CODE XLNX_COMP_BCAM_SetCompBcamBaseResponseData10Reg(XLNX_COMP_BCAM_CONTEXT_TYPE* ContextPtr, uint32_t Mask, uint32_t Value)
{
XLNX_ERROR_CODE ret_val = XLNX_OK;
uint32_t Offset;
XLNX_COMPONENT_ADDRESS_TYPE WorkingAddr;
Offset = (COMP_BCAM_BASE_RESPONSE_DATA_10_REG_OFFSET);
WorkingAddr = (XLNX_COMPONENT_ADDRESS_TYPE)((ContextPtr->ComponentBaseAddress) + Offset);
ret_val = XLNX_Environment_Wrapper_Write32_WithMask(ContextPtr->UserEnvironment.Device_IO.Write32WithMask, ContextPtr->UserContextPtr, WorkingAddr, Value, Mask);
return ret_val;
}
XLNX_ERROR_CODE XLNX_COMP_BCAM_GetCompBcamBaseResponseData10Reg(XLNX_COMP_BCAM_CONTEXT_TYPE* ContextPtr, uint32_t* ValuePtr)
{
XLNX_ERROR_CODE ret_val = XLNX_OK;
uint32_t Offset;
XLNX_COMPONENT_ADDRESS_TYPE WorkingAddr;
Offset = (COMP_BCAM_BASE_RESPONSE_DATA_10_REG_OFFSET);
WorkingAddr = (XLNX_COMPONENT_ADDRESS_TYPE)((ContextPtr->ComponentBaseAddress) + Offset);
ret_val = XLNX_Environment_Wrapper_Read32(ContextPtr->UserEnvironment.Device_IO.Read32, ContextPtr->UserContextPtr, ValuePtr, WorkingAddr);
return ret_val;
}
XLNX_ERROR_CODE XLNX_COMP_BCAM_SetCompBcamBaseResponseData11ResponseData11(XLNX_COMP_BCAM_CONTEXT_TYPE* ContextPtr, uint32_t ResponseData11)
{
XLNX_ERROR_CODE ret_val = XLNX_OK;
uint32_t Offset, Mask, Shift, Buffer;
XLNX_COMPONENT_ADDRESS_TYPE WorkingAddr;
Offset = (COMP_BCAM_BASE_RESPONSE_DATA_11_REG_OFFSET);
Mask = COMP_BCAM_BASE_RESPONSE_DATA_11_RESPONSE_DATA_11_MASK;
Shift = COMP_BCAM_BASE_RESPONSE_DATA_11_RESPONSE_DATA_11_SHIFT;
WorkingAddr = (XLNX_COMPONENT_ADDRESS_TYPE)((ContextPtr->ComponentBaseAddress) + Offset);
Buffer = (ResponseData11 << Shift);
ret_val = XLNX_Environment_Wrapper_Write32_WithMask(ContextPtr->UserEnvironment.Device_IO.Write32WithMask, ContextPtr->UserContextPtr, WorkingAddr, Buffer, Mask);
return ret_val;
}
void XLNX_COMP_BCAM_BuildCompBcamBaseResponseData11ResponseData11(uint32_t* MaskPtr, uint32_t* ValPtr, uint32_t ResponseData11)
{
*MaskPtr |= COMP_BCAM_BASE_RESPONSE_DATA_11_RESPONSE_DATA_11_MASK;
*ValPtr |= (ResponseData11 << COMP_BCAM_BASE_RESPONSE_DATA_11_RESPONSE_DATA_11_SHIFT);
}
XLNX_ERROR_CODE XLNX_COMP_BCAM_GetCompBcamBaseResponseData11ResponseData11(XLNX_COMP_BCAM_CONTEXT_TYPE* ContextPtr, uint32_t* ResponseData11Ptr)
{
XLNX_ERROR_CODE ret_val = XLNX_OK;
uint32_t Offset, Mask, Shift, Buffer;
XLNX_COMPONENT_ADDRESS_TYPE WorkingAddr;
Offset = (COMP_BCAM_BASE_RESPONSE_DATA_11_REG_OFFSET);
Mask = COMP_BCAM_BASE_RESPONSE_DATA_11_RESPONSE_DATA_11_MASK;
Shift = COMP_BCAM_BASE_RESPONSE_DATA_11_RESPONSE_DATA_11_SHIFT;
WorkingAddr = (XLNX_COMPONENT_ADDRESS_TYPE)((ContextPtr->ComponentBaseAddress) + Offset);
ret_val = XLNX_Environment_Wrapper_Read32(ContextPtr->UserEnvironment.Device_IO.Read32, ContextPtr->UserContextPtr, &Buffer, WorkingAddr);
if (XLNX_OK == ret_val)
{
*ResponseData11Ptr = ((Buffer & Mask) >> Shift);
}
return ret_val;
}
XLNX_ERROR_CODE XLNX_COMP_BCAM_SetCompBcamBaseResponseData11Reg(XLNX_COMP_BCAM_CONTEXT_TYPE* ContextPtr, uint32_t Mask, uint32_t Value)
{
XLNX_ERROR_CODE ret_val = XLNX_OK;
uint32_t Offset;
XLNX_COMPONENT_ADDRESS_TYPE WorkingAddr;
Offset = (COMP_BCAM_BASE_RESPONSE_DATA_11_REG_OFFSET);
WorkingAddr = (XLNX_COMPONENT_ADDRESS_TYPE)((ContextPtr->ComponentBaseAddress) + Offset);
ret_val = XLNX_Environment_Wrapper_Write32_WithMask(ContextPtr->UserEnvironment.Device_IO.Write32WithMask, ContextPtr->UserContextPtr, WorkingAddr, Value, Mask);
return ret_val;
}
XLNX_ERROR_CODE XLNX_COMP_BCAM_GetCompBcamBaseResponseData11Reg(XLNX_COMP_BCAM_CONTEXT_TYPE* ContextPtr, uint32_t* ValuePtr)
{
XLNX_ERROR_CODE ret_val = XLNX_OK;
uint32_t Offset;
XLNX_COMPONENT_ADDRESS_TYPE WorkingAddr;
Offset = (COMP_BCAM_BASE_RESPONSE_DATA_11_REG_OFFSET);
WorkingAddr = (XLNX_COMPONENT_ADDRESS_TYPE)((ContextPtr->ComponentBaseAddress) + Offset);
ret_val = XLNX_Environment_Wrapper_Read32(ContextPtr->UserEnvironment.Device_IO.Read32, ContextPtr->UserContextPtr, ValuePtr, WorkingAddr);
return ret_val;
}
XLNX_ERROR_CODE XLNX_COMP_BCAM_SetCompBcamBaseResponseData12ResponseData12(XLNX_COMP_BCAM_CONTEXT_TYPE* ContextPtr, uint32_t ResponseData12)
{
XLNX_ERROR_CODE ret_val = XLNX_OK;
uint32_t Offset, Mask, Shift, Buffer;
XLNX_COMPONENT_ADDRESS_TYPE WorkingAddr;
Offset = (COMP_BCAM_BASE_RESPONSE_DATA_12_REG_OFFSET);
Mask = COMP_BCAM_BASE_RESPONSE_DATA_12_RESPONSE_DATA_12_MASK;
Shift = COMP_BCAM_BASE_RESPONSE_DATA_12_RESPONSE_DATA_12_SHIFT;
WorkingAddr = (XLNX_COMPONENT_ADDRESS_TYPE)((ContextPtr->ComponentBaseAddress) + Offset);
Buffer = (ResponseData12 << Shift);
ret_val = XLNX_Environment_Wrapper_Write32_WithMask(ContextPtr->UserEnvironment.Device_IO.Write32WithMask, ContextPtr->UserContextPtr, WorkingAddr, Buffer, Mask);
return ret_val;
}
void XLNX_COMP_BCAM_BuildCompBcamBaseResponseData12ResponseData12(uint32_t* MaskPtr, uint32_t* ValPtr, uint32_t ResponseData12)
{
*MaskPtr |= COMP_BCAM_BASE_RESPONSE_DATA_12_RESPONSE_DATA_12_MASK;
*ValPtr |= (ResponseData12 << COMP_BCAM_BASE_RESPONSE_DATA_12_RESPONSE_DATA_12_SHIFT);
}
XLNX_ERROR_CODE XLNX_COMP_BCAM_GetCompBcamBaseResponseData12ResponseData12(XLNX_COMP_BCAM_CONTEXT_TYPE* ContextPtr, uint32_t* ResponseData12Ptr)
{
XLNX_ERROR_CODE ret_val = XLNX_OK;
uint32_t Offset, Mask, Shift, Buffer;
XLNX_COMPONENT_ADDRESS_TYPE WorkingAddr;
Offset = (COMP_BCAM_BASE_RESPONSE_DATA_12_REG_OFFSET);
Mask = COMP_BCAM_BASE_RESPONSE_DATA_12_RESPONSE_DATA_12_MASK;
Shift = COMP_BCAM_BASE_RESPONSE_DATA_12_RESPONSE_DATA_12_SHIFT;
WorkingAddr = (XLNX_COMPONENT_ADDRESS_TYPE)((ContextPtr->ComponentBaseAddress) + Offset);
ret_val = XLNX_Environment_Wrapper_Read32(ContextPtr->UserEnvironment.Device_IO.Read32, ContextPtr->UserContextPtr, &Buffer, WorkingAddr);
if (XLNX_OK == ret_val)
{
*ResponseData12Ptr = ((Buffer & Mask) >> Shift);
}
return ret_val;
}
XLNX_ERROR_CODE XLNX_COMP_BCAM_SetCompBcamBaseResponseData12Reg(XLNX_COMP_BCAM_CONTEXT_TYPE* ContextPtr, uint32_t Mask, uint32_t Value)
{
XLNX_ERROR_CODE ret_val = XLNX_OK;
uint32_t Offset;
XLNX_COMPONENT_ADDRESS_TYPE WorkingAddr;
Offset = (COMP_BCAM_BASE_RESPONSE_DATA_12_REG_OFFSET);
WorkingAddr = (XLNX_COMPONENT_ADDRESS_TYPE)((ContextPtr->ComponentBaseAddress) + Offset);
ret_val = XLNX_Environment_Wrapper_Write32_WithMask(ContextPtr->UserEnvironment.Device_IO.Write32WithMask, ContextPtr->UserContextPtr, WorkingAddr, Value, Mask);
return ret_val;
}
XLNX_ERROR_CODE XLNX_COMP_BCAM_GetCompBcamBaseResponseData12Reg(XLNX_COMP_BCAM_CONTEXT_TYPE* ContextPtr, uint32_t* ValuePtr)
{
XLNX_ERROR_CODE ret_val = XLNX_OK;
uint32_t Offset;
XLNX_COMPONENT_ADDRESS_TYPE WorkingAddr;
Offset = (COMP_BCAM_BASE_RESPONSE_DATA_12_REG_OFFSET);
WorkingAddr = (XLNX_COMPONENT_ADDRESS_TYPE)((ContextPtr->ComponentBaseAddress) + Offset);
ret_val = XLNX_Environment_Wrapper_Read32(ContextPtr->UserEnvironment.Device_IO.Read32, ContextPtr->UserContextPtr, ValuePtr, WorkingAddr);
return ret_val;
}
XLNX_ERROR_CODE XLNX_COMP_BCAM_SetCompBcamBaseResponseData13ResponseData13(XLNX_COMP_BCAM_CONTEXT_TYPE* ContextPtr, uint32_t ResponseData13)
{
XLNX_ERROR_CODE ret_val = XLNX_OK;
uint32_t Offset, Mask, Shift, Buffer;
XLNX_COMPONENT_ADDRESS_TYPE WorkingAddr;
Offset = (COMP_BCAM_BASE_RESPONSE_DATA_13_REG_OFFSET);
Mask = COMP_BCAM_BASE_RESPONSE_DATA_13_RESPONSE_DATA_13_MASK;
Shift = COMP_BCAM_BASE_RESPONSE_DATA_13_RESPONSE_DATA_13_SHIFT;
WorkingAddr = (XLNX_COMPONENT_ADDRESS_TYPE)((ContextPtr->ComponentBaseAddress) + Offset);
Buffer = (ResponseData13 << Shift);
ret_val = XLNX_Environment_Wrapper_Write32_WithMask(ContextPtr->UserEnvironment.Device_IO.Write32WithMask, ContextPtr->UserContextPtr, WorkingAddr, Buffer, Mask);
return ret_val;
}
void XLNX_COMP_BCAM_BuildCompBcamBaseResponseData13ResponseData13(uint32_t* MaskPtr, uint32_t* ValPtr, uint32_t ResponseData13)
{
*MaskPtr |= COMP_BCAM_BASE_RESPONSE_DATA_13_RESPONSE_DATA_13_MASK;
*ValPtr |= (ResponseData13 << COMP_BCAM_BASE_RESPONSE_DATA_13_RESPONSE_DATA_13_SHIFT);
}
XLNX_ERROR_CODE XLNX_COMP_BCAM_GetCompBcamBaseResponseData13ResponseData13(XLNX_COMP_BCAM_CONTEXT_TYPE* ContextPtr, uint32_t* ResponseData13Ptr)
{
XLNX_ERROR_CODE ret_val = XLNX_OK;
uint32_t Offset, Mask, Shift, Buffer;
XLNX_COMPONENT_ADDRESS_TYPE WorkingAddr;
Offset = (COMP_BCAM_BASE_RESPONSE_DATA_13_REG_OFFSET);
Mask = COMP_BCAM_BASE_RESPONSE_DATA_13_RESPONSE_DATA_13_MASK;
Shift = COMP_BCAM_BASE_RESPONSE_DATA_13_RESPONSE_DATA_13_SHIFT;
WorkingAddr = (XLNX_COMPONENT_ADDRESS_TYPE)((ContextPtr->ComponentBaseAddress) + Offset);
ret_val = XLNX_Environment_Wrapper_Read32(ContextPtr->UserEnvironment.Device_IO.Read32, ContextPtr->UserContextPtr, &Buffer, WorkingAddr);
if (XLNX_OK == ret_val)
{
*ResponseData13Ptr = ((Buffer & Mask) >> Shift);
}
return ret_val;
}
XLNX_ERROR_CODE XLNX_COMP_BCAM_SetCompBcamBaseResponseData13Reg(XLNX_COMP_BCAM_CONTEXT_TYPE* ContextPtr, uint32_t Mask, uint32_t Value)
{
XLNX_ERROR_CODE ret_val = XLNX_OK;
uint32_t Offset;
XLNX_COMPONENT_ADDRESS_TYPE WorkingAddr;
Offset = (COMP_BCAM_BASE_RESPONSE_DATA_13_REG_OFFSET);
WorkingAddr = (XLNX_COMPONENT_ADDRESS_TYPE)((ContextPtr->ComponentBaseAddress) + Offset);
ret_val = XLNX_Environment_Wrapper_Write32_WithMask(ContextPtr->UserEnvironment.Device_IO.Write32WithMask, ContextPtr->UserContextPtr, WorkingAddr, Value, Mask);
return ret_val;
}
XLNX_ERROR_CODE XLNX_COMP_BCAM_GetCompBcamBaseResponseData13Reg(XLNX_COMP_BCAM_CONTEXT_TYPE* ContextPtr, uint32_t* ValuePtr)
{
XLNX_ERROR_CODE ret_val = XLNX_OK;
uint32_t Offset;
XLNX_COMPONENT_ADDRESS_TYPE WorkingAddr;
Offset = (COMP_BCAM_BASE_RESPONSE_DATA_13_REG_OFFSET);
WorkingAddr = (XLNX_COMPONENT_ADDRESS_TYPE)((ContextPtr->ComponentBaseAddress) + Offset);
ret_val = XLNX_Environment_Wrapper_Read32(ContextPtr->UserEnvironment.Device_IO.Read32, ContextPtr->UserContextPtr, ValuePtr, WorkingAddr);
return ret_val;
}
XLNX_ERROR_CODE XLNX_COMP_BCAM_SetCompBcamBaseResponseData14ResponseData14(XLNX_COMP_BCAM_CONTEXT_TYPE* ContextPtr, uint32_t ResponseData14)
{
XLNX_ERROR_CODE ret_val = XLNX_OK;
uint32_t Offset, Mask, Shift, Buffer;
XLNX_COMPONENT_ADDRESS_TYPE WorkingAddr;
Offset = (COMP_BCAM_BASE_RESPONSE_DATA_14_REG_OFFSET);
Mask = COMP_BCAM_BASE_RESPONSE_DATA_14_RESPONSE_DATA_14_MASK;
Shift = COMP_BCAM_BASE_RESPONSE_DATA_14_RESPONSE_DATA_14_SHIFT;
WorkingAddr = (XLNX_COMPONENT_ADDRESS_TYPE)((ContextPtr->ComponentBaseAddress) + Offset);
Buffer = (ResponseData14 << Shift);
ret_val = XLNX_Environment_Wrapper_Write32_WithMask(ContextPtr->UserEnvironment.Device_IO.Write32WithMask, ContextPtr->UserContextPtr, WorkingAddr, Buffer, Mask);
return ret_val;
}
void XLNX_COMP_BCAM_BuildCompBcamBaseResponseData14ResponseData14(uint32_t* MaskPtr, uint32_t* ValPtr, uint32_t ResponseData14)
{
*MaskPtr |= COMP_BCAM_BASE_RESPONSE_DATA_14_RESPONSE_DATA_14_MASK;
*ValPtr |= (ResponseData14 << COMP_BCAM_BASE_RESPONSE_DATA_14_RESPONSE_DATA_14_SHIFT);
}
XLNX_ERROR_CODE XLNX_COMP_BCAM_GetCompBcamBaseResponseData14ResponseData14(XLNX_COMP_BCAM_CONTEXT_TYPE* ContextPtr, uint32_t* ResponseData14Ptr)
{
XLNX_ERROR_CODE ret_val = XLNX_OK;
uint32_t Offset, Mask, Shift, Buffer;
XLNX_COMPONENT_ADDRESS_TYPE WorkingAddr;
Offset = (COMP_BCAM_BASE_RESPONSE_DATA_14_REG_OFFSET);
Mask = COMP_BCAM_BASE_RESPONSE_DATA_14_RESPONSE_DATA_14_MASK;
Shift = COMP_BCAM_BASE_RESPONSE_DATA_14_RESPONSE_DATA_14_SHIFT;
WorkingAddr = (XLNX_COMPONENT_ADDRESS_TYPE)((ContextPtr->ComponentBaseAddress) + Offset);
ret_val = XLNX_Environment_Wrapper_Read32(ContextPtr->UserEnvironment.Device_IO.Read32, ContextPtr->UserContextPtr, &Buffer, WorkingAddr);
if (XLNX_OK == ret_val)
{
*ResponseData14Ptr = ((Buffer & Mask) >> Shift);
}
return ret_val;
}
XLNX_ERROR_CODE XLNX_COMP_BCAM_SetCompBcamBaseResponseData14Reg(XLNX_COMP_BCAM_CONTEXT_TYPE* ContextPtr, uint32_t Mask, uint32_t Value)
{
XLNX_ERROR_CODE ret_val = XLNX_OK;
uint32_t Offset;
XLNX_COMPONENT_ADDRESS_TYPE WorkingAddr;
Offset = (COMP_BCAM_BASE_RESPONSE_DATA_14_REG_OFFSET);
WorkingAddr = (XLNX_COMPONENT_ADDRESS_TYPE)((ContextPtr->ComponentBaseAddress) + Offset);
ret_val = XLNX_Environment_Wrapper_Write32_WithMask(ContextPtr->UserEnvironment.Device_IO.Write32WithMask, ContextPtr->UserContextPtr, WorkingAddr, Value, Mask);
return ret_val;
}
XLNX_ERROR_CODE XLNX_COMP_BCAM_GetCompBcamBaseResponseData14Reg(XLNX_COMP_BCAM_CONTEXT_TYPE* ContextPtr, uint32_t* ValuePtr)
{
XLNX_ERROR_CODE ret_val = XLNX_OK;
uint32_t Offset;
XLNX_COMPONENT_ADDRESS_TYPE WorkingAddr;
Offset = (COMP_BCAM_BASE_RESPONSE_DATA_14_REG_OFFSET);
WorkingAddr = (XLNX_COMPONENT_ADDRESS_TYPE)((ContextPtr->ComponentBaseAddress) + Offset);
ret_val = XLNX_Environment_Wrapper_Read32(ContextPtr->UserEnvironment.Device_IO.Read32, ContextPtr->UserContextPtr, ValuePtr, WorkingAddr);
return ret_val;
}
XLNX_ERROR_CODE XLNX_COMP_BCAM_SetCompBcamBaseResponseData15ResponseData15(XLNX_COMP_BCAM_CONTEXT_TYPE* ContextPtr, uint32_t ResponseData15)
{
XLNX_ERROR_CODE ret_val = XLNX_OK;
uint32_t Offset, Mask, Shift, Buffer;
XLNX_COMPONENT_ADDRESS_TYPE WorkingAddr;
Offset = (COMP_BCAM_BASE_RESPONSE_DATA_15_REG_OFFSET);
Mask = COMP_BCAM_BASE_RESPONSE_DATA_15_RESPONSE_DATA_15_MASK;
Shift = COMP_BCAM_BASE_RESPONSE_DATA_15_RESPONSE_DATA_15_SHIFT;
WorkingAddr = (XLNX_COMPONENT_ADDRESS_TYPE)((ContextPtr->ComponentBaseAddress) + Offset);
Buffer = (ResponseData15 << Shift);
ret_val = XLNX_Environment_Wrapper_Write32_WithMask(ContextPtr->UserEnvironment.Device_IO.Write32WithMask, ContextPtr->UserContextPtr, WorkingAddr, Buffer, Mask);
return ret_val;
}
void XLNX_COMP_BCAM_BuildCompBcamBaseResponseData15ResponseData15(uint32_t* MaskPtr, uint32_t* ValPtr, uint32_t ResponseData15)
{
*MaskPtr |= COMP_BCAM_BASE_RESPONSE_DATA_15_RESPONSE_DATA_15_MASK;
*ValPtr |= (ResponseData15 << COMP_BCAM_BASE_RESPONSE_DATA_15_RESPONSE_DATA_15_SHIFT);
}
XLNX_ERROR_CODE XLNX_COMP_BCAM_GetCompBcamBaseResponseData15ResponseData15(XLNX_COMP_BCAM_CONTEXT_TYPE* ContextPtr, uint32_t* ResponseData15Ptr)
{
XLNX_ERROR_CODE ret_val = XLNX_OK;
uint32_t Offset, Mask, Shift, Buffer;
XLNX_COMPONENT_ADDRESS_TYPE WorkingAddr;
Offset = (COMP_BCAM_BASE_RESPONSE_DATA_15_REG_OFFSET);
Mask = COMP_BCAM_BASE_RESPONSE_DATA_15_RESPONSE_DATA_15_MASK;
Shift = COMP_BCAM_BASE_RESPONSE_DATA_15_RESPONSE_DATA_15_SHIFT;
WorkingAddr = (XLNX_COMPONENT_ADDRESS_TYPE)((ContextPtr->ComponentBaseAddress) + Offset);
ret_val = XLNX_Environment_Wrapper_Read32(ContextPtr->UserEnvironment.Device_IO.Read32, ContextPtr->UserContextPtr, &Buffer, WorkingAddr);
if (XLNX_OK == ret_val)
{
*ResponseData15Ptr = ((Buffer & Mask) >> Shift);
}
return ret_val;
}
XLNX_ERROR_CODE XLNX_COMP_BCAM_SetCompBcamBaseResponseData15Reg(XLNX_COMP_BCAM_CONTEXT_TYPE* ContextPtr, uint32_t Mask, uint32_t Value)
{
XLNX_ERROR_CODE ret_val = XLNX_OK;
uint32_t Offset;
XLNX_COMPONENT_ADDRESS_TYPE WorkingAddr;
Offset = (COMP_BCAM_BASE_RESPONSE_DATA_15_REG_OFFSET);
WorkingAddr = (XLNX_COMPONENT_ADDRESS_TYPE)((ContextPtr->ComponentBaseAddress) + Offset);
ret_val = XLNX_Environment_Wrapper_Write32_WithMask(ContextPtr->UserEnvironment.Device_IO.Write32WithMask, ContextPtr->UserContextPtr, WorkingAddr, Value, Mask);
return ret_val;
}
XLNX_ERROR_CODE XLNX_COMP_BCAM_GetCompBcamBaseResponseData15Reg(XLNX_COMP_BCAM_CONTEXT_TYPE* ContextPtr, uint32_t* ValuePtr)
{
XLNX_ERROR_CODE ret_val = XLNX_OK;
uint32_t Offset;
XLNX_COMPONENT_ADDRESS_TYPE WorkingAddr;
Offset = (COMP_BCAM_BASE_RESPONSE_DATA_15_REG_OFFSET);
WorkingAddr = (XLNX_COMPONENT_ADDRESS_TYPE)((ContextPtr->ComponentBaseAddress) + Offset);
ret_val = XLNX_Environment_Wrapper_Read32(ContextPtr->UserEnvironment.Device_IO.Read32, ContextPtr->UserContextPtr, ValuePtr, WorkingAddr);
return ret_val;
}
XLNX_ERROR_CODE XLNX_COMP_BCAM_SetCompBcamBaseResponseData16ResponseData16(XLNX_COMP_BCAM_CONTEXT_TYPE* ContextPtr, uint32_t ResponseData16)
{
XLNX_ERROR_CODE ret_val = XLNX_OK;
uint32_t Offset, Mask, Shift, Buffer;
XLNX_COMPONENT_ADDRESS_TYPE WorkingAddr;
Offset = (COMP_BCAM_BASE_RESPONSE_DATA_16_REG_OFFSET);
Mask = COMP_BCAM_BASE_RESPONSE_DATA_16_RESPONSE_DATA_16_MASK;
Shift = COMP_BCAM_BASE_RESPONSE_DATA_16_RESPONSE_DATA_16_SHIFT;
WorkingAddr = (XLNX_COMPONENT_ADDRESS_TYPE)((ContextPtr->ComponentBaseAddress) + Offset);
Buffer = (ResponseData16 << Shift);
ret_val = XLNX_Environment_Wrapper_Write32_WithMask(ContextPtr->UserEnvironment.Device_IO.Write32WithMask, ContextPtr->UserContextPtr, WorkingAddr, Buffer, Mask);
return ret_val;
}
void XLNX_COMP_BCAM_BuildCompBcamBaseResponseData16ResponseData16(uint32_t* MaskPtr, uint32_t* ValPtr, uint32_t ResponseData16)
{
*MaskPtr |= COMP_BCAM_BASE_RESPONSE_DATA_16_RESPONSE_DATA_16_MASK;
*ValPtr |= (ResponseData16 << COMP_BCAM_BASE_RESPONSE_DATA_16_RESPONSE_DATA_16_SHIFT);
}
XLNX_ERROR_CODE XLNX_COMP_BCAM_GetCompBcamBaseResponseData16ResponseData16(XLNX_COMP_BCAM_CONTEXT_TYPE* ContextPtr, uint32_t* ResponseData16Ptr)
{
XLNX_ERROR_CODE ret_val = XLNX_OK;
uint32_t Offset, Mask, Shift, Buffer;
XLNX_COMPONENT_ADDRESS_TYPE WorkingAddr;
Offset = (COMP_BCAM_BASE_RESPONSE_DATA_16_REG_OFFSET);
Mask = COMP_BCAM_BASE_RESPONSE_DATA_16_RESPONSE_DATA_16_MASK;
Shift = COMP_BCAM_BASE_RESPONSE_DATA_16_RESPONSE_DATA_16_SHIFT;
WorkingAddr = (XLNX_COMPONENT_ADDRESS_TYPE)((ContextPtr->ComponentBaseAddress) + Offset);
ret_val = XLNX_Environment_Wrapper_Read32(ContextPtr->UserEnvironment.Device_IO.Read32, ContextPtr->UserContextPtr, &Buffer, WorkingAddr);
if (XLNX_OK == ret_val)
{
*ResponseData16Ptr = ((Buffer & Mask) >> Shift);
}
return ret_val;
}
XLNX_ERROR_CODE XLNX_COMP_BCAM_SetCompBcamBaseResponseData16Reg(XLNX_COMP_BCAM_CONTEXT_TYPE* ContextPtr, uint32_t Mask, uint32_t Value)
{
XLNX_ERROR_CODE ret_val = XLNX_OK;
uint32_t Offset;
XLNX_COMPONENT_ADDRESS_TYPE WorkingAddr;
Offset = (COMP_BCAM_BASE_RESPONSE_DATA_16_REG_OFFSET);
WorkingAddr = (XLNX_COMPONENT_ADDRESS_TYPE)((ContextPtr->ComponentBaseAddress) + Offset);
ret_val = XLNX_Environment_Wrapper_Write32_WithMask(ContextPtr->UserEnvironment.Device_IO.Write32WithMask, ContextPtr->UserContextPtr, WorkingAddr, Value, Mask);
return ret_val;
}
XLNX_ERROR_CODE XLNX_COMP_BCAM_GetCompBcamBaseResponseData16Reg(XLNX_COMP_BCAM_CONTEXT_TYPE* ContextPtr, uint32_t* ValuePtr)
{
XLNX_ERROR_CODE ret_val = XLNX_OK;
uint32_t Offset;
XLNX_COMPONENT_ADDRESS_TYPE WorkingAddr;
Offset = (COMP_BCAM_BASE_RESPONSE_DATA_16_REG_OFFSET);
WorkingAddr = (XLNX_COMPONENT_ADDRESS_TYPE)((ContextPtr->ComponentBaseAddress) + Offset);
ret_val = XLNX_Environment_Wrapper_Read32(ContextPtr->UserEnvironment.Device_IO.Read32, ContextPtr->UserContextPtr, ValuePtr, WorkingAddr);
return ret_val;
}
XLNX_ERROR_CODE XLNX_COMP_BCAM_SetCompBcamBaseResponseData17ResponseData17(XLNX_COMP_BCAM_CONTEXT_TYPE* ContextPtr, uint32_t ResponseData17)
{
XLNX_ERROR_CODE ret_val = XLNX_OK;
uint32_t Offset, Mask, Shift, Buffer;
XLNX_COMPONENT_ADDRESS_TYPE WorkingAddr;
Offset = (COMP_BCAM_BASE_RESPONSE_DATA_17_REG_OFFSET);
Mask = COMP_BCAM_BASE_RESPONSE_DATA_17_RESPONSE_DATA_17_MASK;
Shift = COMP_BCAM_BASE_RESPONSE_DATA_17_RESPONSE_DATA_17_SHIFT;
WorkingAddr = (XLNX_COMPONENT_ADDRESS_TYPE)((ContextPtr->ComponentBaseAddress) + Offset);
Buffer = (ResponseData17 << Shift);
ret_val = XLNX_Environment_Wrapper_Write32_WithMask(ContextPtr->UserEnvironment.Device_IO.Write32WithMask, ContextPtr->UserContextPtr, WorkingAddr, Buffer, Mask);
return ret_val;
}
void XLNX_COMP_BCAM_BuildCompBcamBaseResponseData17ResponseData17(uint32_t* MaskPtr, uint32_t* ValPtr, uint32_t ResponseData17)
{
*MaskPtr |= COMP_BCAM_BASE_RESPONSE_DATA_17_RESPONSE_DATA_17_MASK;
*ValPtr |= (ResponseData17 << COMP_BCAM_BASE_RESPONSE_DATA_17_RESPONSE_DATA_17_SHIFT);
}
XLNX_ERROR_CODE XLNX_COMP_BCAM_GetCompBcamBaseResponseData17ResponseData17(XLNX_COMP_BCAM_CONTEXT_TYPE* ContextPtr, uint32_t* ResponseData17Ptr)
{
XLNX_ERROR_CODE ret_val = XLNX_OK;
uint32_t Offset, Mask, Shift, Buffer;
XLNX_COMPONENT_ADDRESS_TYPE WorkingAddr;
Offset = (COMP_BCAM_BASE_RESPONSE_DATA_17_REG_OFFSET);
Mask = COMP_BCAM_BASE_RESPONSE_DATA_17_RESPONSE_DATA_17_MASK;
Shift = COMP_BCAM_BASE_RESPONSE_DATA_17_RESPONSE_DATA_17_SHIFT;
WorkingAddr = (XLNX_COMPONENT_ADDRESS_TYPE)((ContextPtr->ComponentBaseAddress) + Offset);
ret_val = XLNX_Environment_Wrapper_Read32(ContextPtr->UserEnvironment.Device_IO.Read32, ContextPtr->UserContextPtr, &Buffer, WorkingAddr);
if (XLNX_OK == ret_val)
{
*ResponseData17Ptr = ((Buffer & Mask) >> Shift);
}
return ret_val;
}
XLNX_ERROR_CODE XLNX_COMP_BCAM_SetCompBcamBaseResponseData17Reg(XLNX_COMP_BCAM_CONTEXT_TYPE* ContextPtr, uint32_t Mask, uint32_t Value)
{
XLNX_ERROR_CODE ret_val = XLNX_OK;
uint32_t Offset;
XLNX_COMPONENT_ADDRESS_TYPE WorkingAddr;
Offset = (COMP_BCAM_BASE_RESPONSE_DATA_17_REG_OFFSET);
WorkingAddr = (XLNX_COMPONENT_ADDRESS_TYPE)((ContextPtr->ComponentBaseAddress) + Offset);
ret_val = XLNX_Environment_Wrapper_Write32_WithMask(ContextPtr->UserEnvironment.Device_IO.Write32WithMask, ContextPtr->UserContextPtr, WorkingAddr, Value, Mask);
return ret_val;
}
XLNX_ERROR_CODE XLNX_COMP_BCAM_GetCompBcamBaseResponseData17Reg(XLNX_COMP_BCAM_CONTEXT_TYPE* ContextPtr, uint32_t* ValuePtr)
{
XLNX_ERROR_CODE ret_val = XLNX_OK;
uint32_t Offset;
XLNX_COMPONENT_ADDRESS_TYPE WorkingAddr;
Offset = (COMP_BCAM_BASE_RESPONSE_DATA_17_REG_OFFSET);
WorkingAddr = (XLNX_COMPONENT_ADDRESS_TYPE)((ContextPtr->ComponentBaseAddress) + Offset);
ret_val = XLNX_Environment_Wrapper_Read32(ContextPtr->UserEnvironment.Device_IO.Read32, ContextPtr->UserContextPtr, ValuePtr, WorkingAddr);
return ret_val;
}
XLNX_ERROR_CODE XLNX_COMP_BCAM_SetCompBcamBaseResponseData18ResponseData18(XLNX_COMP_BCAM_CONTEXT_TYPE* ContextPtr, uint32_t ResponseData18)
{
XLNX_ERROR_CODE ret_val = XLNX_OK;
uint32_t Offset, Mask, Shift, Buffer;
XLNX_COMPONENT_ADDRESS_TYPE WorkingAddr;
Offset = (COMP_BCAM_BASE_RESPONSE_DATA_18_REG_OFFSET);
Mask = COMP_BCAM_BASE_RESPONSE_DATA_18_RESPONSE_DATA_18_MASK;
Shift = COMP_BCAM_BASE_RESPONSE_DATA_18_RESPONSE_DATA_18_SHIFT;
WorkingAddr = (XLNX_COMPONENT_ADDRESS_TYPE)((ContextPtr->ComponentBaseAddress) + Offset);
Buffer = (ResponseData18 << Shift);
ret_val = XLNX_Environment_Wrapper_Write32_WithMask(ContextPtr->UserEnvironment.Device_IO.Write32WithMask, ContextPtr->UserContextPtr, WorkingAddr, Buffer, Mask);
return ret_val;
}
void XLNX_COMP_BCAM_BuildCompBcamBaseResponseData18ResponseData18(uint32_t* MaskPtr, uint32_t* ValPtr, uint32_t ResponseData18)
{
*MaskPtr |= COMP_BCAM_BASE_RESPONSE_DATA_18_RESPONSE_DATA_18_MASK;
*ValPtr |= (ResponseData18 << COMP_BCAM_BASE_RESPONSE_DATA_18_RESPONSE_DATA_18_SHIFT);
}
XLNX_ERROR_CODE XLNX_COMP_BCAM_GetCompBcamBaseResponseData18ResponseData18(XLNX_COMP_BCAM_CONTEXT_TYPE* ContextPtr, uint32_t* ResponseData18Ptr)
{
XLNX_ERROR_CODE ret_val = XLNX_OK;
uint32_t Offset, Mask, Shift, Buffer;
XLNX_COMPONENT_ADDRESS_TYPE WorkingAddr;
Offset = (COMP_BCAM_BASE_RESPONSE_DATA_18_REG_OFFSET);
Mask = COMP_BCAM_BASE_RESPONSE_DATA_18_RESPONSE_DATA_18_MASK;
Shift = COMP_BCAM_BASE_RESPONSE_DATA_18_RESPONSE_DATA_18_SHIFT;
WorkingAddr = (XLNX_COMPONENT_ADDRESS_TYPE)((ContextPtr->ComponentBaseAddress) + Offset);
ret_val = XLNX_Environment_Wrapper_Read32(ContextPtr->UserEnvironment.Device_IO.Read32, ContextPtr->UserContextPtr, &Buffer, WorkingAddr);
if (XLNX_OK == ret_val)
{
*ResponseData18Ptr = ((Buffer & Mask) >> Shift);
}
return ret_val;
}
XLNX_ERROR_CODE XLNX_COMP_BCAM_SetCompBcamBaseResponseData18Reg(XLNX_COMP_BCAM_CONTEXT_TYPE* ContextPtr, uint32_t Mask, uint32_t Value)
{
XLNX_ERROR_CODE ret_val = XLNX_OK;
uint32_t Offset;
XLNX_COMPONENT_ADDRESS_TYPE WorkingAddr;
Offset = (COMP_BCAM_BASE_RESPONSE_DATA_18_REG_OFFSET);
WorkingAddr = (XLNX_COMPONENT_ADDRESS_TYPE)((ContextPtr->ComponentBaseAddress) + Offset);
ret_val = XLNX_Environment_Wrapper_Write32_WithMask(ContextPtr->UserEnvironment.Device_IO.Write32WithMask, ContextPtr->UserContextPtr, WorkingAddr, Value, Mask);
return ret_val;
}
XLNX_ERROR_CODE XLNX_COMP_BCAM_GetCompBcamBaseResponseData18Reg(XLNX_COMP_BCAM_CONTEXT_TYPE* ContextPtr, uint32_t* ValuePtr)
{
XLNX_ERROR_CODE ret_val = XLNX_OK;
uint32_t Offset;
XLNX_COMPONENT_ADDRESS_TYPE WorkingAddr;
Offset = (COMP_BCAM_BASE_RESPONSE_DATA_18_REG_OFFSET);
WorkingAddr = (XLNX_COMPONENT_ADDRESS_TYPE)((ContextPtr->ComponentBaseAddress) + Offset);
ret_val = XLNX_Environment_Wrapper_Read32(ContextPtr->UserEnvironment.Device_IO.Read32, ContextPtr->UserContextPtr, ValuePtr, WorkingAddr);
return ret_val;
}
XLNX_ERROR_CODE XLNX_COMP_BCAM_SetCompBcamBaseResponseData19ResponseData19(XLNX_COMP_BCAM_CONTEXT_TYPE* ContextPtr, uint32_t ResponseData19)
{
XLNX_ERROR_CODE ret_val = XLNX_OK;
uint32_t Offset, Mask, Shift, Buffer;
XLNX_COMPONENT_ADDRESS_TYPE WorkingAddr;
Offset = (COMP_BCAM_BASE_RESPONSE_DATA_19_REG_OFFSET);
Mask = COMP_BCAM_BASE_RESPONSE_DATA_19_RESPONSE_DATA_19_MASK;
Shift = COMP_BCAM_BASE_RESPONSE_DATA_19_RESPONSE_DATA_19_SHIFT;
WorkingAddr = (XLNX_COMPONENT_ADDRESS_TYPE)((ContextPtr->ComponentBaseAddress) + Offset);
Buffer = (ResponseData19 << Shift);
ret_val = XLNX_Environment_Wrapper_Write32_WithMask(ContextPtr->UserEnvironment.Device_IO.Write32WithMask, ContextPtr->UserContextPtr, WorkingAddr, Buffer, Mask);
return ret_val;
}
void XLNX_COMP_BCAM_BuildCompBcamBaseResponseData19ResponseData19(uint32_t* MaskPtr, uint32_t* ValPtr, uint32_t ResponseData19)
{
*MaskPtr |= COMP_BCAM_BASE_RESPONSE_DATA_19_RESPONSE_DATA_19_MASK;
*ValPtr |= (ResponseData19 << COMP_BCAM_BASE_RESPONSE_DATA_19_RESPONSE_DATA_19_SHIFT);
}
XLNX_ERROR_CODE XLNX_COMP_BCAM_GetCompBcamBaseResponseData19ResponseData19(XLNX_COMP_BCAM_CONTEXT_TYPE* ContextPtr, uint32_t* ResponseData19Ptr)
{
XLNX_ERROR_CODE ret_val = XLNX_OK;
uint32_t Offset, Mask, Shift, Buffer;
XLNX_COMPONENT_ADDRESS_TYPE WorkingAddr;
Offset = (COMP_BCAM_BASE_RESPONSE_DATA_19_REG_OFFSET);
Mask = COMP_BCAM_BASE_RESPONSE_DATA_19_RESPONSE_DATA_19_MASK;
Shift = COMP_BCAM_BASE_RESPONSE_DATA_19_RESPONSE_DATA_19_SHIFT;
WorkingAddr = (XLNX_COMPONENT_ADDRESS_TYPE)((ContextPtr->ComponentBaseAddress) + Offset);
ret_val = XLNX_Environment_Wrapper_Read32(ContextPtr->UserEnvironment.Device_IO.Read32, ContextPtr->UserContextPtr, &Buffer, WorkingAddr);
if (XLNX_OK == ret_val)
{
*ResponseData19Ptr = ((Buffer & Mask) >> Shift);
}
return ret_val;
}
XLNX_ERROR_CODE XLNX_COMP_BCAM_SetCompBcamBaseResponseData19Reg(XLNX_COMP_BCAM_CONTEXT_TYPE* ContextPtr, uint32_t Mask, uint32_t Value)
{
XLNX_ERROR_CODE ret_val = XLNX_OK;
uint32_t Offset;
XLNX_COMPONENT_ADDRESS_TYPE WorkingAddr;
Offset = (COMP_BCAM_BASE_RESPONSE_DATA_19_REG_OFFSET);
WorkingAddr = (XLNX_COMPONENT_ADDRESS_TYPE)((ContextPtr->ComponentBaseAddress) + Offset);
ret_val = XLNX_Environment_Wrapper_Write32_WithMask(ContextPtr->UserEnvironment.Device_IO.Write32WithMask, ContextPtr->UserContextPtr, WorkingAddr, Value, Mask);
return ret_val;
}
XLNX_ERROR_CODE XLNX_COMP_BCAM_GetCompBcamBaseResponseData19Reg(XLNX_COMP_BCAM_CONTEXT_TYPE* ContextPtr, uint32_t* ValuePtr)
{
XLNX_ERROR_CODE ret_val = XLNX_OK;
uint32_t Offset;
XLNX_COMPONENT_ADDRESS_TYPE WorkingAddr;
Offset = (COMP_BCAM_BASE_RESPONSE_DATA_19_REG_OFFSET);
WorkingAddr = (XLNX_COMPONENT_ADDRESS_TYPE)((ContextPtr->ComponentBaseAddress) + Offset);
ret_val = XLNX_Environment_Wrapper_Read32(ContextPtr->UserEnvironment.Device_IO.Read32, ContextPtr->UserContextPtr, ValuePtr, WorkingAddr);
return ret_val;
}
XLNX_ERROR_CODE XLNX_COMP_BCAM_SetCompBcamBaseResponseData20ResponseData20(XLNX_COMP_BCAM_CONTEXT_TYPE* ContextPtr, uint32_t ResponseData20)
{
XLNX_ERROR_CODE ret_val = XLNX_OK;
uint32_t Offset, Mask, Shift, Buffer;
XLNX_COMPONENT_ADDRESS_TYPE WorkingAddr;
Offset = (COMP_BCAM_BASE_RESPONSE_DATA_20_REG_OFFSET);
Mask = COMP_BCAM_BASE_RESPONSE_DATA_20_RESPONSE_DATA_20_MASK;
Shift = COMP_BCAM_BASE_RESPONSE_DATA_20_RESPONSE_DATA_20_SHIFT;
WorkingAddr = (XLNX_COMPONENT_ADDRESS_TYPE)((ContextPtr->ComponentBaseAddress) + Offset);
Buffer = (ResponseData20 << Shift);
ret_val = XLNX_Environment_Wrapper_Write32_WithMask(ContextPtr->UserEnvironment.Device_IO.Write32WithMask, ContextPtr->UserContextPtr, WorkingAddr, Buffer, Mask);
return ret_val;
}
void XLNX_COMP_BCAM_BuildCompBcamBaseResponseData20ResponseData20(uint32_t* MaskPtr, uint32_t* ValPtr, uint32_t ResponseData20)
{
*MaskPtr |= COMP_BCAM_BASE_RESPONSE_DATA_20_RESPONSE_DATA_20_MASK;
*ValPtr |= (ResponseData20 << COMP_BCAM_BASE_RESPONSE_DATA_20_RESPONSE_DATA_20_SHIFT);
}
XLNX_ERROR_CODE XLNX_COMP_BCAM_GetCompBcamBaseResponseData20ResponseData20(XLNX_COMP_BCAM_CONTEXT_TYPE* ContextPtr, uint32_t* ResponseData20Ptr)
{
XLNX_ERROR_CODE ret_val = XLNX_OK;
uint32_t Offset, Mask, Shift, Buffer;
XLNX_COMPONENT_ADDRESS_TYPE WorkingAddr;
Offset = (COMP_BCAM_BASE_RESPONSE_DATA_20_REG_OFFSET);
Mask = COMP_BCAM_BASE_RESPONSE_DATA_20_RESPONSE_DATA_20_MASK;
Shift = COMP_BCAM_BASE_RESPONSE_DATA_20_RESPONSE_DATA_20_SHIFT;
WorkingAddr = (XLNX_COMPONENT_ADDRESS_TYPE)((ContextPtr->ComponentBaseAddress) + Offset);
ret_val = XLNX_Environment_Wrapper_Read32(ContextPtr->UserEnvironment.Device_IO.Read32, ContextPtr->UserContextPtr, &Buffer, WorkingAddr);
if (XLNX_OK == ret_val)
{
*ResponseData20Ptr = ((Buffer & Mask) >> Shift);
}
return ret_val;
}
XLNX_ERROR_CODE XLNX_COMP_BCAM_SetCompBcamBaseResponseData20Reg(XLNX_COMP_BCAM_CONTEXT_TYPE* ContextPtr, uint32_t Mask, uint32_t Value)
{
XLNX_ERROR_CODE ret_val = XLNX_OK;
uint32_t Offset;
XLNX_COMPONENT_ADDRESS_TYPE WorkingAddr;
Offset = (COMP_BCAM_BASE_RESPONSE_DATA_20_REG_OFFSET);
WorkingAddr = (XLNX_COMPONENT_ADDRESS_TYPE)((ContextPtr->ComponentBaseAddress) + Offset);
ret_val = XLNX_Environment_Wrapper_Write32_WithMask(ContextPtr->UserEnvironment.Device_IO.Write32WithMask, ContextPtr->UserContextPtr, WorkingAddr, Value, Mask);
return ret_val;
}
XLNX_ERROR_CODE XLNX_COMP_BCAM_GetCompBcamBaseResponseData20Reg(XLNX_COMP_BCAM_CONTEXT_TYPE* ContextPtr, uint32_t* ValuePtr)
{
XLNX_ERROR_CODE ret_val = XLNX_OK;
uint32_t Offset;
XLNX_COMPONENT_ADDRESS_TYPE WorkingAddr;
Offset = (COMP_BCAM_BASE_RESPONSE_DATA_20_REG_OFFSET);
WorkingAddr = (XLNX_COMPONENT_ADDRESS_TYPE)((ContextPtr->ComponentBaseAddress) + Offset);
ret_val = XLNX_Environment_Wrapper_Read32(ContextPtr->UserEnvironment.Device_IO.Read32, ContextPtr->UserContextPtr, ValuePtr, WorkingAddr);
return ret_val;
}
XLNX_ERROR_CODE XLNX_COMP_BCAM_SetCompBcamBaseResponseData21ResponseData21(XLNX_COMP_BCAM_CONTEXT_TYPE* ContextPtr, uint32_t ResponseData21)
{
XLNX_ERROR_CODE ret_val = XLNX_OK;
uint32_t Offset, Mask, Shift, Buffer;
XLNX_COMPONENT_ADDRESS_TYPE WorkingAddr;
Offset = (COMP_BCAM_BASE_RESPONSE_DATA_21_REG_OFFSET);
Mask = COMP_BCAM_BASE_RESPONSE_DATA_21_RESPONSE_DATA_21_MASK;
Shift = COMP_BCAM_BASE_RESPONSE_DATA_21_RESPONSE_DATA_21_SHIFT;
WorkingAddr = (XLNX_COMPONENT_ADDRESS_TYPE)((ContextPtr->ComponentBaseAddress) + Offset);
Buffer = (ResponseData21 << Shift);
ret_val = XLNX_Environment_Wrapper_Write32_WithMask(ContextPtr->UserEnvironment.Device_IO.Write32WithMask, ContextPtr->UserContextPtr, WorkingAddr, Buffer, Mask);
return ret_val;
}
void XLNX_COMP_BCAM_BuildCompBcamBaseResponseData21ResponseData21(uint32_t* MaskPtr, uint32_t* ValPtr, uint32_t ResponseData21)
{
*MaskPtr |= COMP_BCAM_BASE_RESPONSE_DATA_21_RESPONSE_DATA_21_MASK;
*ValPtr |= (ResponseData21 << COMP_BCAM_BASE_RESPONSE_DATA_21_RESPONSE_DATA_21_SHIFT);
}
XLNX_ERROR_CODE XLNX_COMP_BCAM_GetCompBcamBaseResponseData21ResponseData21(XLNX_COMP_BCAM_CONTEXT_TYPE* ContextPtr, uint32_t* ResponseData21Ptr)
{
XLNX_ERROR_CODE ret_val = XLNX_OK;
uint32_t Offset, Mask, Shift, Buffer;
XLNX_COMPONENT_ADDRESS_TYPE WorkingAddr;
Offset = (COMP_BCAM_BASE_RESPONSE_DATA_21_REG_OFFSET);
Mask = COMP_BCAM_BASE_RESPONSE_DATA_21_RESPONSE_DATA_21_MASK;
Shift = COMP_BCAM_BASE_RESPONSE_DATA_21_RESPONSE_DATA_21_SHIFT;
WorkingAddr = (XLNX_COMPONENT_ADDRESS_TYPE)((ContextPtr->ComponentBaseAddress) + Offset);
ret_val = XLNX_Environment_Wrapper_Read32(ContextPtr->UserEnvironment.Device_IO.Read32, ContextPtr->UserContextPtr, &Buffer, WorkingAddr);
if (XLNX_OK == ret_val)
{
*ResponseData21Ptr = ((Buffer & Mask) >> Shift);
}
return ret_val;
}
XLNX_ERROR_CODE XLNX_COMP_BCAM_SetCompBcamBaseResponseData21Reg(XLNX_COMP_BCAM_CONTEXT_TYPE* ContextPtr, uint32_t Mask, uint32_t Value)
{
XLNX_ERROR_CODE ret_val = XLNX_OK;
uint32_t Offset;
XLNX_COMPONENT_ADDRESS_TYPE WorkingAddr;
Offset = (COMP_BCAM_BASE_RESPONSE_DATA_21_REG_OFFSET);
WorkingAddr = (XLNX_COMPONENT_ADDRESS_TYPE)((ContextPtr->ComponentBaseAddress) + Offset);
ret_val = XLNX_Environment_Wrapper_Write32_WithMask(ContextPtr->UserEnvironment.Device_IO.Write32WithMask, ContextPtr->UserContextPtr, WorkingAddr, Value, Mask);
return ret_val;
}
XLNX_ERROR_CODE XLNX_COMP_BCAM_GetCompBcamBaseResponseData21Reg(XLNX_COMP_BCAM_CONTEXT_TYPE* ContextPtr, uint32_t* ValuePtr)
{
XLNX_ERROR_CODE ret_val = XLNX_OK;
uint32_t Offset;
XLNX_COMPONENT_ADDRESS_TYPE WorkingAddr;
Offset = (COMP_BCAM_BASE_RESPONSE_DATA_21_REG_OFFSET);
WorkingAddr = (XLNX_COMPONENT_ADDRESS_TYPE)((ContextPtr->ComponentBaseAddress) + Offset);
ret_val = XLNX_Environment_Wrapper_Read32(ContextPtr->UserEnvironment.Device_IO.Read32, ContextPtr->UserContextPtr, ValuePtr, WorkingAddr);
return ret_val;
}
XLNX_ERROR_CODE XLNX_COMP_BCAM_SetCompBcamBaseResponseData22ResponseData22(XLNX_COMP_BCAM_CONTEXT_TYPE* ContextPtr, uint32_t ResponseData22)
{
XLNX_ERROR_CODE ret_val = XLNX_OK;
uint32_t Offset, Mask, Shift, Buffer;
XLNX_COMPONENT_ADDRESS_TYPE WorkingAddr;
Offset = (COMP_BCAM_BASE_RESPONSE_DATA_22_REG_OFFSET);
Mask = COMP_BCAM_BASE_RESPONSE_DATA_22_RESPONSE_DATA_22_MASK;
Shift = COMP_BCAM_BASE_RESPONSE_DATA_22_RESPONSE_DATA_22_SHIFT;
WorkingAddr = (XLNX_COMPONENT_ADDRESS_TYPE)((ContextPtr->ComponentBaseAddress) + Offset);
Buffer = (ResponseData22 << Shift);
ret_val = XLNX_Environment_Wrapper_Write32_WithMask(ContextPtr->UserEnvironment.Device_IO.Write32WithMask, ContextPtr->UserContextPtr, WorkingAddr, Buffer, Mask);
return ret_val;
}
void XLNX_COMP_BCAM_BuildCompBcamBaseResponseData22ResponseData22(uint32_t* MaskPtr, uint32_t* ValPtr, uint32_t ResponseData22)
{
*MaskPtr |= COMP_BCAM_BASE_RESPONSE_DATA_22_RESPONSE_DATA_22_MASK;
*ValPtr |= (ResponseData22 << COMP_BCAM_BASE_RESPONSE_DATA_22_RESPONSE_DATA_22_SHIFT);
}
XLNX_ERROR_CODE XLNX_COMP_BCAM_GetCompBcamBaseResponseData22ResponseData22(XLNX_COMP_BCAM_CONTEXT_TYPE* ContextPtr, uint32_t* ResponseData22Ptr)
{
XLNX_ERROR_CODE ret_val = XLNX_OK;
uint32_t Offset, Mask, Shift, Buffer;
XLNX_COMPONENT_ADDRESS_TYPE WorkingAddr;
Offset = (COMP_BCAM_BASE_RESPONSE_DATA_22_REG_OFFSET);
Mask = COMP_BCAM_BASE_RESPONSE_DATA_22_RESPONSE_DATA_22_MASK;
Shift = COMP_BCAM_BASE_RESPONSE_DATA_22_RESPONSE_DATA_22_SHIFT;
WorkingAddr = (XLNX_COMPONENT_ADDRESS_TYPE)((ContextPtr->ComponentBaseAddress) + Offset);
ret_val = XLNX_Environment_Wrapper_Read32(ContextPtr->UserEnvironment.Device_IO.Read32, ContextPtr->UserContextPtr, &Buffer, WorkingAddr);
if (XLNX_OK == ret_val)
{
*ResponseData22Ptr = ((Buffer & Mask) >> Shift);
}
return ret_val;
}
XLNX_ERROR_CODE XLNX_COMP_BCAM_SetCompBcamBaseResponseData22Reg(XLNX_COMP_BCAM_CONTEXT_TYPE* ContextPtr, uint32_t Mask, uint32_t Value)
{
XLNX_ERROR_CODE ret_val = XLNX_OK;
uint32_t Offset;
XLNX_COMPONENT_ADDRESS_TYPE WorkingAddr;
Offset = (COMP_BCAM_BASE_RESPONSE_DATA_22_REG_OFFSET);
WorkingAddr = (XLNX_COMPONENT_ADDRESS_TYPE)((ContextPtr->ComponentBaseAddress) + Offset);
ret_val = XLNX_Environment_Wrapper_Write32_WithMask(ContextPtr->UserEnvironment.Device_IO.Write32WithMask, ContextPtr->UserContextPtr, WorkingAddr, Value, Mask);
return ret_val;
}
XLNX_ERROR_CODE XLNX_COMP_BCAM_GetCompBcamBaseResponseData22Reg(XLNX_COMP_BCAM_CONTEXT_TYPE* ContextPtr, uint32_t* ValuePtr)
{
XLNX_ERROR_CODE ret_val = XLNX_OK;
uint32_t Offset;
XLNX_COMPONENT_ADDRESS_TYPE WorkingAddr;
Offset = (COMP_BCAM_BASE_RESPONSE_DATA_22_REG_OFFSET);
WorkingAddr = (XLNX_COMPONENT_ADDRESS_TYPE)((ContextPtr->ComponentBaseAddress) + Offset);
ret_val = XLNX_Environment_Wrapper_Read32(ContextPtr->UserEnvironment.Device_IO.Read32, ContextPtr->UserContextPtr, ValuePtr, WorkingAddr);
return ret_val;
}
XLNX_ERROR_CODE XLNX_COMP_BCAM_SetCompBcamBaseResponseData23ResponseData23(XLNX_COMP_BCAM_CONTEXT_TYPE* ContextPtr, uint32_t ResponseData23)
{
XLNX_ERROR_CODE ret_val = XLNX_OK;
uint32_t Offset, Mask, Shift, Buffer;
XLNX_COMPONENT_ADDRESS_TYPE WorkingAddr;
Offset = (COMP_BCAM_BASE_RESPONSE_DATA_23_REG_OFFSET);
Mask = COMP_BCAM_BASE_RESPONSE_DATA_23_RESPONSE_DATA_23_MASK;
Shift = COMP_BCAM_BASE_RESPONSE_DATA_23_RESPONSE_DATA_23_SHIFT;
WorkingAddr = (XLNX_COMPONENT_ADDRESS_TYPE)((ContextPtr->ComponentBaseAddress) + Offset);
Buffer = (ResponseData23 << Shift);
ret_val = XLNX_Environment_Wrapper_Write32_WithMask(ContextPtr->UserEnvironment.Device_IO.Write32WithMask, ContextPtr->UserContextPtr, WorkingAddr, Buffer, Mask);
return ret_val;
}
void XLNX_COMP_BCAM_BuildCompBcamBaseResponseData23ResponseData23(uint32_t* MaskPtr, uint32_t* ValPtr, uint32_t ResponseData23)
{
*MaskPtr |= COMP_BCAM_BASE_RESPONSE_DATA_23_RESPONSE_DATA_23_MASK;
*ValPtr |= (ResponseData23 << COMP_BCAM_BASE_RESPONSE_DATA_23_RESPONSE_DATA_23_SHIFT);
}
XLNX_ERROR_CODE XLNX_COMP_BCAM_GetCompBcamBaseResponseData23ResponseData23(XLNX_COMP_BCAM_CONTEXT_TYPE* ContextPtr, uint32_t* ResponseData23Ptr)
{
XLNX_ERROR_CODE ret_val = XLNX_OK;
uint32_t Offset, Mask, Shift, Buffer;
XLNX_COMPONENT_ADDRESS_TYPE WorkingAddr;
Offset = (COMP_BCAM_BASE_RESPONSE_DATA_23_REG_OFFSET);
Mask = COMP_BCAM_BASE_RESPONSE_DATA_23_RESPONSE_DATA_23_MASK;
Shift = COMP_BCAM_BASE_RESPONSE_DATA_23_RESPONSE_DATA_23_SHIFT;
WorkingAddr = (XLNX_COMPONENT_ADDRESS_TYPE)((ContextPtr->ComponentBaseAddress) + Offset);
ret_val = XLNX_Environment_Wrapper_Read32(ContextPtr->UserEnvironment.Device_IO.Read32, ContextPtr->UserContextPtr, &Buffer, WorkingAddr);
if (XLNX_OK == ret_val)
{
*ResponseData23Ptr = ((Buffer & Mask) >> Shift);
}
return ret_val;
}
XLNX_ERROR_CODE XLNX_COMP_BCAM_SetCompBcamBaseResponseData23Reg(XLNX_COMP_BCAM_CONTEXT_TYPE* ContextPtr, uint32_t Mask, uint32_t Value)
{
XLNX_ERROR_CODE ret_val = XLNX_OK;
uint32_t Offset;
XLNX_COMPONENT_ADDRESS_TYPE WorkingAddr;
Offset = (COMP_BCAM_BASE_RESPONSE_DATA_23_REG_OFFSET);
WorkingAddr = (XLNX_COMPONENT_ADDRESS_TYPE)((ContextPtr->ComponentBaseAddress) + Offset);
ret_val = XLNX_Environment_Wrapper_Write32_WithMask(ContextPtr->UserEnvironment.Device_IO.Write32WithMask, ContextPtr->UserContextPtr, WorkingAddr, Value, Mask);
return ret_val;
}
XLNX_ERROR_CODE XLNX_COMP_BCAM_GetCompBcamBaseResponseData23Reg(XLNX_COMP_BCAM_CONTEXT_TYPE* ContextPtr, uint32_t* ValuePtr)
{
XLNX_ERROR_CODE ret_val = XLNX_OK;
uint32_t Offset;
XLNX_COMPONENT_ADDRESS_TYPE WorkingAddr;
Offset = (COMP_BCAM_BASE_RESPONSE_DATA_23_REG_OFFSET);
WorkingAddr = (XLNX_COMPONENT_ADDRESS_TYPE)((ContextPtr->ComponentBaseAddress) + Offset);
ret_val = XLNX_Environment_Wrapper_Read32(ContextPtr->UserEnvironment.Device_IO.Read32, ContextPtr->UserContextPtr, ValuePtr, WorkingAddr);
return ret_val;
}
XLNX_ERROR_CODE XLNX_COMP_BCAM_SetCompBcamBaseResponseData24ResponseData24(XLNX_COMP_BCAM_CONTEXT_TYPE* ContextPtr, uint32_t ResponseData24)
{
XLNX_ERROR_CODE ret_val = XLNX_OK;
uint32_t Offset, Mask, Shift, Buffer;
XLNX_COMPONENT_ADDRESS_TYPE WorkingAddr;
Offset = (COMP_BCAM_BASE_RESPONSE_DATA_24_REG_OFFSET);
Mask = COMP_BCAM_BASE_RESPONSE_DATA_24_RESPONSE_DATA_24_MASK;
Shift = COMP_BCAM_BASE_RESPONSE_DATA_24_RESPONSE_DATA_24_SHIFT;
WorkingAddr = (XLNX_COMPONENT_ADDRESS_TYPE)((ContextPtr->ComponentBaseAddress) + Offset);
Buffer = (ResponseData24 << Shift);
ret_val = XLNX_Environment_Wrapper_Write32_WithMask(ContextPtr->UserEnvironment.Device_IO.Write32WithMask, ContextPtr->UserContextPtr, WorkingAddr, Buffer, Mask);
return ret_val;
}
void XLNX_COMP_BCAM_BuildCompBcamBaseResponseData24ResponseData24(uint32_t* MaskPtr, uint32_t* ValPtr, uint32_t ResponseData24)
{
*MaskPtr |= COMP_BCAM_BASE_RESPONSE_DATA_24_RESPONSE_DATA_24_MASK;
*ValPtr |= (ResponseData24 << COMP_BCAM_BASE_RESPONSE_DATA_24_RESPONSE_DATA_24_SHIFT);
}
XLNX_ERROR_CODE XLNX_COMP_BCAM_GetCompBcamBaseResponseData24ResponseData24(XLNX_COMP_BCAM_CONTEXT_TYPE* ContextPtr, uint32_t* ResponseData24Ptr)
{
XLNX_ERROR_CODE ret_val = XLNX_OK;
uint32_t Offset, Mask, Shift, Buffer;
XLNX_COMPONENT_ADDRESS_TYPE WorkingAddr;
Offset = (COMP_BCAM_BASE_RESPONSE_DATA_24_REG_OFFSET);
Mask = COMP_BCAM_BASE_RESPONSE_DATA_24_RESPONSE_DATA_24_MASK;
Shift = COMP_BCAM_BASE_RESPONSE_DATA_24_RESPONSE_DATA_24_SHIFT;
WorkingAddr = (XLNX_COMPONENT_ADDRESS_TYPE)((ContextPtr->ComponentBaseAddress) + Offset);
ret_val = XLNX_Environment_Wrapper_Read32(ContextPtr->UserEnvironment.Device_IO.Read32, ContextPtr->UserContextPtr, &Buffer, WorkingAddr);
if (XLNX_OK == ret_val)
{
*ResponseData24Ptr = ((Buffer & Mask) >> Shift);
}
return ret_val;
}
XLNX_ERROR_CODE XLNX_COMP_BCAM_SetCompBcamBaseResponseData24Reg(XLNX_COMP_BCAM_CONTEXT_TYPE* ContextPtr, uint32_t Mask, uint32_t Value)
{
XLNX_ERROR_CODE ret_val = XLNX_OK;
uint32_t Offset;
XLNX_COMPONENT_ADDRESS_TYPE WorkingAddr;
Offset = (COMP_BCAM_BASE_RESPONSE_DATA_24_REG_OFFSET);
WorkingAddr = (XLNX_COMPONENT_ADDRESS_TYPE)((ContextPtr->ComponentBaseAddress) + Offset);
ret_val = XLNX_Environment_Wrapper_Write32_WithMask(ContextPtr->UserEnvironment.Device_IO.Write32WithMask, ContextPtr->UserContextPtr, WorkingAddr, Value, Mask);
return ret_val;
}
XLNX_ERROR_CODE XLNX_COMP_BCAM_GetCompBcamBaseResponseData24Reg(XLNX_COMP_BCAM_CONTEXT_TYPE* ContextPtr, uint32_t* ValuePtr)
{
XLNX_ERROR_CODE ret_val = XLNX_OK;
uint32_t Offset;
XLNX_COMPONENT_ADDRESS_TYPE WorkingAddr;
Offset = (COMP_BCAM_BASE_RESPONSE_DATA_24_REG_OFFSET);
WorkingAddr = (XLNX_COMPONENT_ADDRESS_TYPE)((ContextPtr->ComponentBaseAddress) + Offset);
ret_val = XLNX_Environment_Wrapper_Read32(ContextPtr->UserEnvironment.Device_IO.Read32, ContextPtr->UserContextPtr, ValuePtr, WorkingAddr);
return ret_val;
}
XLNX_ERROR_CODE XLNX_COMP_BCAM_SetCompBcamBaseResponseData25ResponseData25(XLNX_COMP_BCAM_CONTEXT_TYPE* ContextPtr, uint32_t ResponseData25)
{
XLNX_ERROR_CODE ret_val = XLNX_OK;
uint32_t Offset, Mask, Shift, Buffer;
XLNX_COMPONENT_ADDRESS_TYPE WorkingAddr;
Offset = (COMP_BCAM_BASE_RESPONSE_DATA_25_REG_OFFSET);
Mask = COMP_BCAM_BASE_RESPONSE_DATA_25_RESPONSE_DATA_25_MASK;
Shift = COMP_BCAM_BASE_RESPONSE_DATA_25_RESPONSE_DATA_25_SHIFT;
WorkingAddr = (XLNX_COMPONENT_ADDRESS_TYPE)((ContextPtr->ComponentBaseAddress) + Offset);
Buffer = (ResponseData25 << Shift);
ret_val = XLNX_Environment_Wrapper_Write32_WithMask(ContextPtr->UserEnvironment.Device_IO.Write32WithMask, ContextPtr->UserContextPtr, WorkingAddr, Buffer, Mask);
return ret_val;
}
void XLNX_COMP_BCAM_BuildCompBcamBaseResponseData25ResponseData25(uint32_t* MaskPtr, uint32_t* ValPtr, uint32_t ResponseData25)
{
*MaskPtr |= COMP_BCAM_BASE_RESPONSE_DATA_25_RESPONSE_DATA_25_MASK;
*ValPtr |= (ResponseData25 << COMP_BCAM_BASE_RESPONSE_DATA_25_RESPONSE_DATA_25_SHIFT);
}
XLNX_ERROR_CODE XLNX_COMP_BCAM_GetCompBcamBaseResponseData25ResponseData25(XLNX_COMP_BCAM_CONTEXT_TYPE* ContextPtr, uint32_t* ResponseData25Ptr)
{
XLNX_ERROR_CODE ret_val = XLNX_OK;
uint32_t Offset, Mask, Shift, Buffer;
XLNX_COMPONENT_ADDRESS_TYPE WorkingAddr;
Offset = (COMP_BCAM_BASE_RESPONSE_DATA_25_REG_OFFSET);
Mask = COMP_BCAM_BASE_RESPONSE_DATA_25_RESPONSE_DATA_25_MASK;
Shift = COMP_BCAM_BASE_RESPONSE_DATA_25_RESPONSE_DATA_25_SHIFT;
WorkingAddr = (XLNX_COMPONENT_ADDRESS_TYPE)((ContextPtr->ComponentBaseAddress) + Offset);
ret_val = XLNX_Environment_Wrapper_Read32(ContextPtr->UserEnvironment.Device_IO.Read32, ContextPtr->UserContextPtr, &Buffer, WorkingAddr);
if (XLNX_OK == ret_val)
{
*ResponseData25Ptr = ((Buffer & Mask) >> Shift);
}
return ret_val;
}
XLNX_ERROR_CODE XLNX_COMP_BCAM_SetCompBcamBaseResponseData25Reg(XLNX_COMP_BCAM_CONTEXT_TYPE* ContextPtr, uint32_t Mask, uint32_t Value)
{
XLNX_ERROR_CODE ret_val = XLNX_OK;
uint32_t Offset;
XLNX_COMPONENT_ADDRESS_TYPE WorkingAddr;
Offset = (COMP_BCAM_BASE_RESPONSE_DATA_25_REG_OFFSET);
WorkingAddr = (XLNX_COMPONENT_ADDRESS_TYPE)((ContextPtr->ComponentBaseAddress) + Offset);
ret_val = XLNX_Environment_Wrapper_Write32_WithMask(ContextPtr->UserEnvironment.Device_IO.Write32WithMask, ContextPtr->UserContextPtr, WorkingAddr, Value, Mask);
return ret_val;
}
XLNX_ERROR_CODE XLNX_COMP_BCAM_GetCompBcamBaseResponseData25Reg(XLNX_COMP_BCAM_CONTEXT_TYPE* ContextPtr, uint32_t* ValuePtr)
{
XLNX_ERROR_CODE ret_val = XLNX_OK;
uint32_t Offset;
XLNX_COMPONENT_ADDRESS_TYPE WorkingAddr;
Offset = (COMP_BCAM_BASE_RESPONSE_DATA_25_REG_OFFSET);
WorkingAddr = (XLNX_COMPONENT_ADDRESS_TYPE)((ContextPtr->ComponentBaseAddress) + Offset);
ret_val = XLNX_Environment_Wrapper_Read32(ContextPtr->UserEnvironment.Device_IO.Read32, ContextPtr->UserContextPtr, ValuePtr, WorkingAddr);
return ret_val;
}
XLNX_ERROR_CODE XLNX_COMP_BCAM_SetCompBcamBaseResponseData26ResponseData26(XLNX_COMP_BCAM_CONTEXT_TYPE* ContextPtr, uint32_t ResponseData26)
{
XLNX_ERROR_CODE ret_val = XLNX_OK;
uint32_t Offset, Mask, Shift, Buffer;
XLNX_COMPONENT_ADDRESS_TYPE WorkingAddr;
Offset = (COMP_BCAM_BASE_RESPONSE_DATA_26_REG_OFFSET);
Mask = COMP_BCAM_BASE_RESPONSE_DATA_26_RESPONSE_DATA_26_MASK;
Shift = COMP_BCAM_BASE_RESPONSE_DATA_26_RESPONSE_DATA_26_SHIFT;
WorkingAddr = (XLNX_COMPONENT_ADDRESS_TYPE)((ContextPtr->ComponentBaseAddress) + Offset);
Buffer = (ResponseData26 << Shift);
ret_val = XLNX_Environment_Wrapper_Write32_WithMask(ContextPtr->UserEnvironment.Device_IO.Write32WithMask, ContextPtr->UserContextPtr, WorkingAddr, Buffer, Mask);
return ret_val;
}
void XLNX_COMP_BCAM_BuildCompBcamBaseResponseData26ResponseData26(uint32_t* MaskPtr, uint32_t* ValPtr, uint32_t ResponseData26)
{
*MaskPtr |= COMP_BCAM_BASE_RESPONSE_DATA_26_RESPONSE_DATA_26_MASK;
*ValPtr |= (ResponseData26 << COMP_BCAM_BASE_RESPONSE_DATA_26_RESPONSE_DATA_26_SHIFT);
}
XLNX_ERROR_CODE XLNX_COMP_BCAM_GetCompBcamBaseResponseData26ResponseData26(XLNX_COMP_BCAM_CONTEXT_TYPE* ContextPtr, uint32_t* ResponseData26Ptr)
{
XLNX_ERROR_CODE ret_val = XLNX_OK;
uint32_t Offset, Mask, Shift, Buffer;
XLNX_COMPONENT_ADDRESS_TYPE WorkingAddr;
Offset = (COMP_BCAM_BASE_RESPONSE_DATA_26_REG_OFFSET);
Mask = COMP_BCAM_BASE_RESPONSE_DATA_26_RESPONSE_DATA_26_MASK;
Shift = COMP_BCAM_BASE_RESPONSE_DATA_26_RESPONSE_DATA_26_SHIFT;
WorkingAddr = (XLNX_COMPONENT_ADDRESS_TYPE)((ContextPtr->ComponentBaseAddress) + Offset);
ret_val = XLNX_Environment_Wrapper_Read32(ContextPtr->UserEnvironment.Device_IO.Read32, ContextPtr->UserContextPtr, &Buffer, WorkingAddr);
if (XLNX_OK == ret_val)
{
*ResponseData26Ptr = ((Buffer & Mask) >> Shift);
}
return ret_val;
}
XLNX_ERROR_CODE XLNX_COMP_BCAM_SetCompBcamBaseResponseData26Reg(XLNX_COMP_BCAM_CONTEXT_TYPE* ContextPtr, uint32_t Mask, uint32_t Value)
{
XLNX_ERROR_CODE ret_val = XLNX_OK;
uint32_t Offset;
XLNX_COMPONENT_ADDRESS_TYPE WorkingAddr;
Offset = (COMP_BCAM_BASE_RESPONSE_DATA_26_REG_OFFSET);
WorkingAddr = (XLNX_COMPONENT_ADDRESS_TYPE)((ContextPtr->ComponentBaseAddress) + Offset);
ret_val = XLNX_Environment_Wrapper_Write32_WithMask(ContextPtr->UserEnvironment.Device_IO.Write32WithMask, ContextPtr->UserContextPtr, WorkingAddr, Value, Mask);
return ret_val;
}
XLNX_ERROR_CODE XLNX_COMP_BCAM_GetCompBcamBaseResponseData26Reg(XLNX_COMP_BCAM_CONTEXT_TYPE* ContextPtr, uint32_t* ValuePtr)
{
XLNX_ERROR_CODE ret_val = XLNX_OK;
uint32_t Offset;
XLNX_COMPONENT_ADDRESS_TYPE WorkingAddr;
Offset = (COMP_BCAM_BASE_RESPONSE_DATA_26_REG_OFFSET);
WorkingAddr = (XLNX_COMPONENT_ADDRESS_TYPE)((ContextPtr->ComponentBaseAddress) + Offset);
ret_val = XLNX_Environment_Wrapper_Read32(ContextPtr->UserEnvironment.Device_IO.Read32, ContextPtr->UserContextPtr, ValuePtr, WorkingAddr);
return ret_val;
}
XLNX_ERROR_CODE XLNX_COMP_BCAM_SetCompBcamBaseResponseData27ResponseData27(XLNX_COMP_BCAM_CONTEXT_TYPE* ContextPtr, uint32_t ResponseData27)
{
XLNX_ERROR_CODE ret_val = XLNX_OK;
uint32_t Offset, Mask, Shift, Buffer;
XLNX_COMPONENT_ADDRESS_TYPE WorkingAddr;
Offset = (COMP_BCAM_BASE_RESPONSE_DATA_27_REG_OFFSET);
Mask = COMP_BCAM_BASE_RESPONSE_DATA_27_RESPONSE_DATA_27_MASK;
Shift = COMP_BCAM_BASE_RESPONSE_DATA_27_RESPONSE_DATA_27_SHIFT;
WorkingAddr = (XLNX_COMPONENT_ADDRESS_TYPE)((ContextPtr->ComponentBaseAddress) + Offset);
Buffer = (ResponseData27 << Shift);
ret_val = XLNX_Environment_Wrapper_Write32_WithMask(ContextPtr->UserEnvironment.Device_IO.Write32WithMask, ContextPtr->UserContextPtr, WorkingAddr, Buffer, Mask);
return ret_val;
}
void XLNX_COMP_BCAM_BuildCompBcamBaseResponseData27ResponseData27(uint32_t* MaskPtr, uint32_t* ValPtr, uint32_t ResponseData27)
{
*MaskPtr |= COMP_BCAM_BASE_RESPONSE_DATA_27_RESPONSE_DATA_27_MASK;
*ValPtr |= (ResponseData27 << COMP_BCAM_BASE_RESPONSE_DATA_27_RESPONSE_DATA_27_SHIFT);
}
XLNX_ERROR_CODE XLNX_COMP_BCAM_GetCompBcamBaseResponseData27ResponseData27(XLNX_COMP_BCAM_CONTEXT_TYPE* ContextPtr, uint32_t* ResponseData27Ptr)
{
XLNX_ERROR_CODE ret_val = XLNX_OK;
uint32_t Offset, Mask, Shift, Buffer;
XLNX_COMPONENT_ADDRESS_TYPE WorkingAddr;
Offset = (COMP_BCAM_BASE_RESPONSE_DATA_27_REG_OFFSET);
Mask = COMP_BCAM_BASE_RESPONSE_DATA_27_RESPONSE_DATA_27_MASK;
Shift = COMP_BCAM_BASE_RESPONSE_DATA_27_RESPONSE_DATA_27_SHIFT;
WorkingAddr = (XLNX_COMPONENT_ADDRESS_TYPE)((ContextPtr->ComponentBaseAddress) + Offset);
ret_val = XLNX_Environment_Wrapper_Read32(ContextPtr->UserEnvironment.Device_IO.Read32, ContextPtr->UserContextPtr, &Buffer, WorkingAddr);
if (XLNX_OK == ret_val)
{
*ResponseData27Ptr = ((Buffer & Mask) >> Shift);
}
return ret_val;
}
XLNX_ERROR_CODE XLNX_COMP_BCAM_SetCompBcamBaseResponseData27Reg(XLNX_COMP_BCAM_CONTEXT_TYPE* ContextPtr, uint32_t Mask, uint32_t Value)
{
XLNX_ERROR_CODE ret_val = XLNX_OK;
uint32_t Offset;
XLNX_COMPONENT_ADDRESS_TYPE WorkingAddr;
Offset = (COMP_BCAM_BASE_RESPONSE_DATA_27_REG_OFFSET);
WorkingAddr = (XLNX_COMPONENT_ADDRESS_TYPE)((ContextPtr->ComponentBaseAddress) + Offset);
ret_val = XLNX_Environment_Wrapper_Write32_WithMask(ContextPtr->UserEnvironment.Device_IO.Write32WithMask, ContextPtr->UserContextPtr, WorkingAddr, Value, Mask);
return ret_val;
}
XLNX_ERROR_CODE XLNX_COMP_BCAM_GetCompBcamBaseResponseData27Reg(XLNX_COMP_BCAM_CONTEXT_TYPE* ContextPtr, uint32_t* ValuePtr)
{
XLNX_ERROR_CODE ret_val = XLNX_OK;
uint32_t Offset;
XLNX_COMPONENT_ADDRESS_TYPE WorkingAddr;
Offset = (COMP_BCAM_BASE_RESPONSE_DATA_27_REG_OFFSET);
WorkingAddr = (XLNX_COMPONENT_ADDRESS_TYPE)((ContextPtr->ComponentBaseAddress) + Offset);
ret_val = XLNX_Environment_Wrapper_Read32(ContextPtr->UserEnvironment.Device_IO.Read32, ContextPtr->UserContextPtr, ValuePtr, WorkingAddr);
return ret_val;
}
XLNX_ERROR_CODE XLNX_COMP_BCAM_SetCompBcamBaseResponseData28ResponseData28(XLNX_COMP_BCAM_CONTEXT_TYPE* ContextPtr, uint32_t ResponseData28)
{
XLNX_ERROR_CODE ret_val = XLNX_OK;
uint32_t Offset, Mask, Shift, Buffer;
XLNX_COMPONENT_ADDRESS_TYPE WorkingAddr;
Offset = (COMP_BCAM_BASE_RESPONSE_DATA_28_REG_OFFSET);
Mask = COMP_BCAM_BASE_RESPONSE_DATA_28_RESPONSE_DATA_28_MASK;
Shift = COMP_BCAM_BASE_RESPONSE_DATA_28_RESPONSE_DATA_28_SHIFT;
WorkingAddr = (XLNX_COMPONENT_ADDRESS_TYPE)((ContextPtr->ComponentBaseAddress) + Offset);
Buffer = (ResponseData28 << Shift);
ret_val = XLNX_Environment_Wrapper_Write32_WithMask(ContextPtr->UserEnvironment.Device_IO.Write32WithMask, ContextPtr->UserContextPtr, WorkingAddr, Buffer, Mask);
return ret_val;
}
void XLNX_COMP_BCAM_BuildCompBcamBaseResponseData28ResponseData28(uint32_t* MaskPtr, uint32_t* ValPtr, uint32_t ResponseData28)
{
*MaskPtr |= COMP_BCAM_BASE_RESPONSE_DATA_28_RESPONSE_DATA_28_MASK;
*ValPtr |= (ResponseData28 << COMP_BCAM_BASE_RESPONSE_DATA_28_RESPONSE_DATA_28_SHIFT);
}
XLNX_ERROR_CODE XLNX_COMP_BCAM_GetCompBcamBaseResponseData28ResponseData28(XLNX_COMP_BCAM_CONTEXT_TYPE* ContextPtr, uint32_t* ResponseData28Ptr)
{
XLNX_ERROR_CODE ret_val = XLNX_OK;
uint32_t Offset, Mask, Shift, Buffer;
XLNX_COMPONENT_ADDRESS_TYPE WorkingAddr;
Offset = (COMP_BCAM_BASE_RESPONSE_DATA_28_REG_OFFSET);
Mask = COMP_BCAM_BASE_RESPONSE_DATA_28_RESPONSE_DATA_28_MASK;
Shift = COMP_BCAM_BASE_RESPONSE_DATA_28_RESPONSE_DATA_28_SHIFT;
WorkingAddr = (XLNX_COMPONENT_ADDRESS_TYPE)((ContextPtr->ComponentBaseAddress) + Offset);
ret_val = XLNX_Environment_Wrapper_Read32(ContextPtr->UserEnvironment.Device_IO.Read32, ContextPtr->UserContextPtr, &Buffer, WorkingAddr);
if (XLNX_OK == ret_val)
{
*ResponseData28Ptr = ((Buffer & Mask) >> Shift);
}
return ret_val;
}
XLNX_ERROR_CODE XLNX_COMP_BCAM_SetCompBcamBaseResponseData28Reg(XLNX_COMP_BCAM_CONTEXT_TYPE* ContextPtr, uint32_t Mask, uint32_t Value)
{
XLNX_ERROR_CODE ret_val = XLNX_OK;
uint32_t Offset;
XLNX_COMPONENT_ADDRESS_TYPE WorkingAddr;
Offset = (COMP_BCAM_BASE_RESPONSE_DATA_28_REG_OFFSET);
WorkingAddr = (XLNX_COMPONENT_ADDRESS_TYPE)((ContextPtr->ComponentBaseAddress) + Offset);
ret_val = XLNX_Environment_Wrapper_Write32_WithMask(ContextPtr->UserEnvironment.Device_IO.Write32WithMask, ContextPtr->UserContextPtr, WorkingAddr, Value, Mask);
return ret_val;
}
XLNX_ERROR_CODE XLNX_COMP_BCAM_GetCompBcamBaseResponseData28Reg(XLNX_COMP_BCAM_CONTEXT_TYPE* ContextPtr, uint32_t* ValuePtr)
{
XLNX_ERROR_CODE ret_val = XLNX_OK;
uint32_t Offset;
XLNX_COMPONENT_ADDRESS_TYPE WorkingAddr;
Offset = (COMP_BCAM_BASE_RESPONSE_DATA_28_REG_OFFSET);
WorkingAddr = (XLNX_COMPONENT_ADDRESS_TYPE)((ContextPtr->ComponentBaseAddress) + Offset);
ret_val = XLNX_Environment_Wrapper_Read32(ContextPtr->UserEnvironment.Device_IO.Read32, ContextPtr->UserContextPtr, ValuePtr, WorkingAddr);
return ret_val;
}
XLNX_ERROR_CODE XLNX_COMP_BCAM_SetCompBcamBaseResponseData29ResponseData29(XLNX_COMP_BCAM_CONTEXT_TYPE* ContextPtr, uint32_t ResponseData29)
{
XLNX_ERROR_CODE ret_val = XLNX_OK;
uint32_t Offset, Mask, Shift, Buffer;
XLNX_COMPONENT_ADDRESS_TYPE WorkingAddr;
Offset = (COMP_BCAM_BASE_RESPONSE_DATA_29_REG_OFFSET);
Mask = COMP_BCAM_BASE_RESPONSE_DATA_29_RESPONSE_DATA_29_MASK;
Shift = COMP_BCAM_BASE_RESPONSE_DATA_29_RESPONSE_DATA_29_SHIFT;
WorkingAddr = (XLNX_COMPONENT_ADDRESS_TYPE)((ContextPtr->ComponentBaseAddress) + Offset);
Buffer = (ResponseData29 << Shift);
ret_val = XLNX_Environment_Wrapper_Write32_WithMask(ContextPtr->UserEnvironment.Device_IO.Write32WithMask, ContextPtr->UserContextPtr, WorkingAddr, Buffer, Mask);
return ret_val;
}
void XLNX_COMP_BCAM_BuildCompBcamBaseResponseData29ResponseData29(uint32_t* MaskPtr, uint32_t* ValPtr, uint32_t ResponseData29)
{
*MaskPtr |= COMP_BCAM_BASE_RESPONSE_DATA_29_RESPONSE_DATA_29_MASK;
*ValPtr |= (ResponseData29 << COMP_BCAM_BASE_RESPONSE_DATA_29_RESPONSE_DATA_29_SHIFT);
}
XLNX_ERROR_CODE XLNX_COMP_BCAM_GetCompBcamBaseResponseData29ResponseData29(XLNX_COMP_BCAM_CONTEXT_TYPE* ContextPtr, uint32_t* ResponseData29Ptr)
{
XLNX_ERROR_CODE ret_val = XLNX_OK;
uint32_t Offset, Mask, Shift, Buffer;
XLNX_COMPONENT_ADDRESS_TYPE WorkingAddr;
Offset = (COMP_BCAM_BASE_RESPONSE_DATA_29_REG_OFFSET);
Mask = COMP_BCAM_BASE_RESPONSE_DATA_29_RESPONSE_DATA_29_MASK;
Shift = COMP_BCAM_BASE_RESPONSE_DATA_29_RESPONSE_DATA_29_SHIFT;
WorkingAddr = (XLNX_COMPONENT_ADDRESS_TYPE)((ContextPtr->ComponentBaseAddress) + Offset);
ret_val = XLNX_Environment_Wrapper_Read32(ContextPtr->UserEnvironment.Device_IO.Read32, ContextPtr->UserContextPtr, &Buffer, WorkingAddr);
if (XLNX_OK == ret_val)
{
*ResponseData29Ptr = ((Buffer & Mask) >> Shift);
}
return ret_val;
}
XLNX_ERROR_CODE XLNX_COMP_BCAM_SetCompBcamBaseResponseData29Reg(XLNX_COMP_BCAM_CONTEXT_TYPE* ContextPtr, uint32_t Mask, uint32_t Value)
{
XLNX_ERROR_CODE ret_val = XLNX_OK;
uint32_t Offset;
XLNX_COMPONENT_ADDRESS_TYPE WorkingAddr;
Offset = (COMP_BCAM_BASE_RESPONSE_DATA_29_REG_OFFSET);
WorkingAddr = (XLNX_COMPONENT_ADDRESS_TYPE)((ContextPtr->ComponentBaseAddress) + Offset);
ret_val = XLNX_Environment_Wrapper_Write32_WithMask(ContextPtr->UserEnvironment.Device_IO.Write32WithMask, ContextPtr->UserContextPtr, WorkingAddr, Value, Mask);
return ret_val;
}
XLNX_ERROR_CODE XLNX_COMP_BCAM_GetCompBcamBaseResponseData29Reg(XLNX_COMP_BCAM_CONTEXT_TYPE* ContextPtr, uint32_t* ValuePtr)
{
XLNX_ERROR_CODE ret_val = XLNX_OK;
uint32_t Offset;
XLNX_COMPONENT_ADDRESS_TYPE WorkingAddr;
Offset = (COMP_BCAM_BASE_RESPONSE_DATA_29_REG_OFFSET);
WorkingAddr = (XLNX_COMPONENT_ADDRESS_TYPE)((ContextPtr->ComponentBaseAddress) + Offset);
ret_val = XLNX_Environment_Wrapper_Read32(ContextPtr->UserEnvironment.Device_IO.Read32, ContextPtr->UserContextPtr, ValuePtr, WorkingAddr);
return ret_val;
}
XLNX_ERROR_CODE XLNX_COMP_BCAM_SetCompBcamBaseResponseData30ResponseData30(XLNX_COMP_BCAM_CONTEXT_TYPE* ContextPtr, uint32_t ResponseData30)
{
XLNX_ERROR_CODE ret_val = XLNX_OK;
uint32_t Offset, Mask, Shift, Buffer;
XLNX_COMPONENT_ADDRESS_TYPE WorkingAddr;
Offset = (COMP_BCAM_BASE_RESPONSE_DATA_30_REG_OFFSET);
Mask = COMP_BCAM_BASE_RESPONSE_DATA_30_RESPONSE_DATA_30_MASK;
Shift = COMP_BCAM_BASE_RESPONSE_DATA_30_RESPONSE_DATA_30_SHIFT;
WorkingAddr = (XLNX_COMPONENT_ADDRESS_TYPE)((ContextPtr->ComponentBaseAddress) + Offset);
Buffer = (ResponseData30 << Shift);
ret_val = XLNX_Environment_Wrapper_Write32_WithMask(ContextPtr->UserEnvironment.Device_IO.Write32WithMask, ContextPtr->UserContextPtr, WorkingAddr, Buffer, Mask);
return ret_val;
}
void XLNX_COMP_BCAM_BuildCompBcamBaseResponseData30ResponseData30(uint32_t* MaskPtr, uint32_t* ValPtr, uint32_t ResponseData30)
{
*MaskPtr |= COMP_BCAM_BASE_RESPONSE_DATA_30_RESPONSE_DATA_30_MASK;
*ValPtr |= (ResponseData30 << COMP_BCAM_BASE_RESPONSE_DATA_30_RESPONSE_DATA_30_SHIFT);
}
XLNX_ERROR_CODE XLNX_COMP_BCAM_GetCompBcamBaseResponseData30ResponseData30(XLNX_COMP_BCAM_CONTEXT_TYPE* ContextPtr, uint32_t* ResponseData30Ptr)
{
XLNX_ERROR_CODE ret_val = XLNX_OK;
uint32_t Offset, Mask, Shift, Buffer;
XLNX_COMPONENT_ADDRESS_TYPE WorkingAddr;
Offset = (COMP_BCAM_BASE_RESPONSE_DATA_30_REG_OFFSET);
Mask = COMP_BCAM_BASE_RESPONSE_DATA_30_RESPONSE_DATA_30_MASK;
Shift = COMP_BCAM_BASE_RESPONSE_DATA_30_RESPONSE_DATA_30_SHIFT;
WorkingAddr = (XLNX_COMPONENT_ADDRESS_TYPE)((ContextPtr->ComponentBaseAddress) + Offset);
ret_val = XLNX_Environment_Wrapper_Read32(ContextPtr->UserEnvironment.Device_IO.Read32, ContextPtr->UserContextPtr, &Buffer, WorkingAddr);
if (XLNX_OK == ret_val)
{
*ResponseData30Ptr = ((Buffer & Mask) >> Shift);
}
return ret_val;
}
XLNX_ERROR_CODE XLNX_COMP_BCAM_SetCompBcamBaseResponseData30Reg(XLNX_COMP_BCAM_CONTEXT_TYPE* ContextPtr, uint32_t Mask, uint32_t Value)
{
XLNX_ERROR_CODE ret_val = XLNX_OK;
uint32_t Offset;
XLNX_COMPONENT_ADDRESS_TYPE WorkingAddr;
Offset = (COMP_BCAM_BASE_RESPONSE_DATA_30_REG_OFFSET);
WorkingAddr = (XLNX_COMPONENT_ADDRESS_TYPE)((ContextPtr->ComponentBaseAddress) + Offset);
ret_val = XLNX_Environment_Wrapper_Write32_WithMask(ContextPtr->UserEnvironment.Device_IO.Write32WithMask, ContextPtr->UserContextPtr, WorkingAddr, Value, Mask);
return ret_val;
}
XLNX_ERROR_CODE XLNX_COMP_BCAM_GetCompBcamBaseResponseData30Reg(XLNX_COMP_BCAM_CONTEXT_TYPE* ContextPtr, uint32_t* ValuePtr)
{
XLNX_ERROR_CODE ret_val = XLNX_OK;
uint32_t Offset;
XLNX_COMPONENT_ADDRESS_TYPE WorkingAddr;
Offset = (COMP_BCAM_BASE_RESPONSE_DATA_30_REG_OFFSET);
WorkingAddr = (XLNX_COMPONENT_ADDRESS_TYPE)((ContextPtr->ComponentBaseAddress) + Offset);
ret_val = XLNX_Environment_Wrapper_Read32(ContextPtr->UserEnvironment.Device_IO.Read32, ContextPtr->UserContextPtr, ValuePtr, WorkingAddr);
return ret_val;
}
XLNX_ERROR_CODE XLNX_COMP_BCAM_SetCompBcamBaseResponseData31ResponseData31(XLNX_COMP_BCAM_CONTEXT_TYPE* ContextPtr, uint32_t ResponseData31)
{
XLNX_ERROR_CODE ret_val = XLNX_OK;
uint32_t Offset, Mask, Shift, Buffer;
XLNX_COMPONENT_ADDRESS_TYPE WorkingAddr;
Offset = (COMP_BCAM_BASE_RESPONSE_DATA_31_REG_OFFSET);
Mask = COMP_BCAM_BASE_RESPONSE_DATA_31_RESPONSE_DATA_31_MASK;
Shift = COMP_BCAM_BASE_RESPONSE_DATA_31_RESPONSE_DATA_31_SHIFT;
WorkingAddr = (XLNX_COMPONENT_ADDRESS_TYPE)((ContextPtr->ComponentBaseAddress) + Offset);
Buffer = (ResponseData31 << Shift);
ret_val = XLNX_Environment_Wrapper_Write32_WithMask(ContextPtr->UserEnvironment.Device_IO.Write32WithMask, ContextPtr->UserContextPtr, WorkingAddr, Buffer, Mask);
return ret_val;
}
void XLNX_COMP_BCAM_BuildCompBcamBaseResponseData31ResponseData31(uint32_t* MaskPtr, uint32_t* ValPtr, uint32_t ResponseData31)
{
*MaskPtr |= COMP_BCAM_BASE_RESPONSE_DATA_31_RESPONSE_DATA_31_MASK;
*ValPtr |= (ResponseData31 << COMP_BCAM_BASE_RESPONSE_DATA_31_RESPONSE_DATA_31_SHIFT);
}
XLNX_ERROR_CODE XLNX_COMP_BCAM_GetCompBcamBaseResponseData31ResponseData31(XLNX_COMP_BCAM_CONTEXT_TYPE* ContextPtr, uint32_t* ResponseData31Ptr)
{
XLNX_ERROR_CODE ret_val = XLNX_OK;
uint32_t Offset, Mask, Shift, Buffer;
XLNX_COMPONENT_ADDRESS_TYPE WorkingAddr;
Offset = (COMP_BCAM_BASE_RESPONSE_DATA_31_REG_OFFSET);
Mask = COMP_BCAM_BASE_RESPONSE_DATA_31_RESPONSE_DATA_31_MASK;
Shift = COMP_BCAM_BASE_RESPONSE_DATA_31_RESPONSE_DATA_31_SHIFT;
WorkingAddr = (XLNX_COMPONENT_ADDRESS_TYPE)((ContextPtr->ComponentBaseAddress) + Offset);
ret_val = XLNX_Environment_Wrapper_Read32(ContextPtr->UserEnvironment.Device_IO.Read32, ContextPtr->UserContextPtr, &Buffer, WorkingAddr);
if (XLNX_OK == ret_val)
{
*ResponseData31Ptr = ((Buffer & Mask) >> Shift);
}
return ret_val;
}
XLNX_ERROR_CODE XLNX_COMP_BCAM_SetCompBcamBaseResponseData31Reg(XLNX_COMP_BCAM_CONTEXT_TYPE* ContextPtr, uint32_t Mask, uint32_t Value)
{
XLNX_ERROR_CODE ret_val = XLNX_OK;
uint32_t Offset;
XLNX_COMPONENT_ADDRESS_TYPE WorkingAddr;
Offset = (COMP_BCAM_BASE_RESPONSE_DATA_31_REG_OFFSET);
WorkingAddr = (XLNX_COMPONENT_ADDRESS_TYPE)((ContextPtr->ComponentBaseAddress) + Offset);
ret_val = XLNX_Environment_Wrapper_Write32_WithMask(ContextPtr->UserEnvironment.Device_IO.Write32WithMask, ContextPtr->UserContextPtr, WorkingAddr, Value, Mask);
return ret_val;
}
XLNX_ERROR_CODE XLNX_COMP_BCAM_GetCompBcamBaseResponseData31Reg(XLNX_COMP_BCAM_CONTEXT_TYPE* ContextPtr, uint32_t* ValuePtr)
{
XLNX_ERROR_CODE ret_val = XLNX_OK;
uint32_t Offset;
XLNX_COMPONENT_ADDRESS_TYPE WorkingAddr;
Offset = (COMP_BCAM_BASE_RESPONSE_DATA_31_REG_OFFSET);
WorkingAddr = (XLNX_COMPONENT_ADDRESS_TYPE)((ContextPtr->ComponentBaseAddress) + Offset);
ret_val = XLNX_Environment_Wrapper_Read32(ContextPtr->UserEnvironment.Device_IO.Read32, ContextPtr->UserContextPtr, ValuePtr, WorkingAddr);
return ret_val;
}
XLNX_ERROR_CODE XLNX_COMP_BCAM_SetBcsBaseModeMode(XLNX_COMP_BCAM_CONTEXT_TYPE* ContextPtr, uint32_t Mode)
{
XLNX_ERROR_CODE ret_val = XLNX_OK;
uint32_t Offset, Mask, Shift, Buffer;
XLNX_COMPONENT_ADDRESS_TYPE WorkingAddr;
Offset = (BCS_BASE_MODE_REG_OFFSET);
Mask = BCS_BASE_MODE_MODE_MASK;
Shift = BCS_BASE_MODE_MODE_SHIFT;
WorkingAddr = (XLNX_COMPONENT_ADDRESS_TYPE)((ContextPtr->ComponentBaseAddress) + Offset);
Buffer = (Mode << Shift);
ret_val = XLNX_Environment_Wrapper_Write32_WithMask(ContextPtr->UserEnvironment.Device_IO.Write32WithMask, ContextPtr->UserContextPtr, WorkingAddr, Buffer, Mask);
return ret_val;
}
void XLNX_COMP_BCAM_BuildBcsBaseModeMode(uint32_t* MaskPtr, uint32_t* ValPtr, uint32_t Mode)
{
*MaskPtr |= BCS_BASE_MODE_MODE_MASK;
*ValPtr |= (Mode << BCS_BASE_MODE_MODE_SHIFT);
}
XLNX_ERROR_CODE XLNX_COMP_BCAM_GetBcsBaseModeMode(XLNX_COMP_BCAM_CONTEXT_TYPE* ContextPtr, uint32_t* ModePtr)
{
XLNX_ERROR_CODE ret_val = XLNX_OK;
uint32_t Offset, Mask, Shift, Buffer;
XLNX_COMPONENT_ADDRESS_TYPE WorkingAddr;
Offset = (BCS_BASE_MODE_REG_OFFSET);
Mask = BCS_BASE_MODE_MODE_MASK;
Shift = BCS_BASE_MODE_MODE_SHIFT;
WorkingAddr = (XLNX_COMPONENT_ADDRESS_TYPE)((ContextPtr->ComponentBaseAddress) + Offset);
ret_val = XLNX_Environment_Wrapper_Read32(ContextPtr->UserEnvironment.Device_IO.Read32, ContextPtr->UserContextPtr, &Buffer, WorkingAddr);
if (XLNX_OK == ret_val)
{
*ModePtr = ((Buffer & Mask) >> Shift);
}
return ret_val;
}
XLNX_ERROR_CODE XLNX_COMP_BCAM_SetBcsBaseModeReg(XLNX_COMP_BCAM_CONTEXT_TYPE* ContextPtr, uint32_t Mask, uint32_t Value)
{
XLNX_ERROR_CODE ret_val = XLNX_OK;
uint32_t Offset;
XLNX_COMPONENT_ADDRESS_TYPE WorkingAddr;
Offset = (BCS_BASE_MODE_REG_OFFSET);
WorkingAddr = (XLNX_COMPONENT_ADDRESS_TYPE)((ContextPtr->ComponentBaseAddress) + Offset);
ret_val = XLNX_Environment_Wrapper_Write32_WithMask(ContextPtr->UserEnvironment.Device_IO.Write32WithMask, ContextPtr->UserContextPtr, WorkingAddr, Value, Mask);
return ret_val;
}
XLNX_ERROR_CODE XLNX_COMP_BCAM_GetBcsBaseModeReg(XLNX_COMP_BCAM_CONTEXT_TYPE* ContextPtr, uint32_t* ValuePtr)
{
XLNX_ERROR_CODE ret_val = XLNX_OK;
uint32_t Offset;
XLNX_COMPONENT_ADDRESS_TYPE WorkingAddr;
Offset = (BCS_BASE_MODE_REG_OFFSET);
WorkingAddr = (XLNX_COMPONENT_ADDRESS_TYPE)((ContextPtr->ComponentBaseAddress) + Offset);
ret_val = XLNX_Environment_Wrapper_Read32(ContextPtr->UserEnvironment.Device_IO.Read32, ContextPtr->UserContextPtr, ValuePtr, WorkingAddr);
return ret_val;
}
XLNX_ERROR_CODE XLNX_COMP_BCAM_GetBcsBaseCrfSbiterrCountCrfSbiterrCount(XLNX_COMP_BCAM_CONTEXT_TYPE* ContextPtr, uint32_t* CrfSbiterrCountPtr)
{
XLNX_ERROR_CODE ret_val = XLNX_OK;
uint32_t Offset, Mask, Shift, Buffer;
XLNX_COMPONENT_ADDRESS_TYPE WorkingAddr;
Offset = (BCS_BASE_CRF_SBITERR_COUNT_REG_OFFSET);
Mask = BCS_BASE_CRF_SBITERR_COUNT_CRF_SBITERR_COUNT_MASK;
Shift = BCS_BASE_CRF_SBITERR_COUNT_CRF_SBITERR_COUNT_SHIFT;
WorkingAddr = (XLNX_COMPONENT_ADDRESS_TYPE)((ContextPtr->ComponentBaseAddress) + Offset);
ret_val = XLNX_Environment_Wrapper_Read32(ContextPtr->UserEnvironment.Device_IO.Read32, ContextPtr->UserContextPtr, &Buffer, WorkingAddr);
if (XLNX_OK == ret_val)
{
*CrfSbiterrCountPtr = ((Buffer & Mask) >> Shift);
}
return ret_val;
}
XLNX_ERROR_CODE XLNX_COMP_BCAM_GetBcsBaseCrfSbiterrCountReg(XLNX_COMP_BCAM_CONTEXT_TYPE* ContextPtr, uint32_t* ValuePtr)
{
XLNX_ERROR_CODE ret_val = XLNX_OK;
uint32_t Offset;
XLNX_COMPONENT_ADDRESS_TYPE WorkingAddr;
Offset = (BCS_BASE_CRF_SBITERR_COUNT_REG_OFFSET);
WorkingAddr = (XLNX_COMPONENT_ADDRESS_TYPE)((ContextPtr->ComponentBaseAddress) + Offset);
ret_val = XLNX_Environment_Wrapper_Read32(ContextPtr->UserEnvironment.Device_IO.Read32, ContextPtr->UserContextPtr, ValuePtr, WorkingAddr);
return ret_val;
}
XLNX_ERROR_CODE XLNX_COMP_BCAM_GetBcsBaseCrfDbiterrCountCrfDbiterrCount(XLNX_COMP_BCAM_CONTEXT_TYPE* ContextPtr, uint32_t* CrfDbiterrCountPtr)
{
XLNX_ERROR_CODE ret_val = XLNX_OK;
uint32_t Offset, Mask, Shift, Buffer;
XLNX_COMPONENT_ADDRESS_TYPE WorkingAddr;
Offset = (BCS_BASE_CRF_DBITERR_COUNT_REG_OFFSET);
Mask = BCS_BASE_CRF_DBITERR_COUNT_CRF_DBITERR_COUNT_MASK;
Shift = BCS_BASE_CRF_DBITERR_COUNT_CRF_DBITERR_COUNT_SHIFT;
WorkingAddr = (XLNX_COMPONENT_ADDRESS_TYPE)((ContextPtr->ComponentBaseAddress) + Offset);
ret_val = XLNX_Environment_Wrapper_Read32(ContextPtr->UserEnvironment.Device_IO.Read32, ContextPtr->UserContextPtr, &Buffer, WorkingAddr);
if (XLNX_OK == ret_val)
{
*CrfDbiterrCountPtr = ((Buffer & Mask) >> Shift);
}
return ret_val;
}
XLNX_ERROR_CODE XLNX_COMP_BCAM_GetBcsBaseCrfDbiterrCountReg(XLNX_COMP_BCAM_CONTEXT_TYPE* ContextPtr, uint32_t* ValuePtr)
{
XLNX_ERROR_CODE ret_val = XLNX_OK;
uint32_t Offset;
XLNX_COMPONENT_ADDRESS_TYPE WorkingAddr;
Offset = (BCS_BASE_CRF_DBITERR_COUNT_REG_OFFSET);
WorkingAddr = (XLNX_COMPONENT_ADDRESS_TYPE)((ContextPtr->ComponentBaseAddress) + Offset);
ret_val = XLNX_Environment_Wrapper_Read32(ContextPtr->UserEnvironment.Device_IO.Read32, ContextPtr->UserContextPtr, ValuePtr, WorkingAddr);
return ret_val;
}
XLNX_ERROR_CODE XLNX_COMP_BCAM_GetBcsBaseRroSbiterrCountRroSbiterrCount(XLNX_COMP_BCAM_CONTEXT_TYPE* ContextPtr, uint32_t* RroSbiterrCountPtr)
{
XLNX_ERROR_CODE ret_val = XLNX_OK;
uint32_t Offset, Mask, Shift, Buffer;
XLNX_COMPONENT_ADDRESS_TYPE WorkingAddr;
Offset = (BCS_BASE_RRO_SBITERR_COUNT_REG_OFFSET);
Mask = BCS_BASE_RRO_SBITERR_COUNT_RRO_SBITERR_COUNT_MASK;
Shift = BCS_BASE_RRO_SBITERR_COUNT_RRO_SBITERR_COUNT_SHIFT;
WorkingAddr = (XLNX_COMPONENT_ADDRESS_TYPE)((ContextPtr->ComponentBaseAddress) + Offset);
ret_val = XLNX_Environment_Wrapper_Read32(ContextPtr->UserEnvironment.Device_IO.Read32, ContextPtr->UserContextPtr, &Buffer, WorkingAddr);
if (XLNX_OK == ret_val)
{
*RroSbiterrCountPtr = ((Buffer & Mask) >> Shift);
}
return ret_val;
}
XLNX_ERROR_CODE XLNX_COMP_BCAM_GetBcsBaseRroSbiterrCountReg(XLNX_COMP_BCAM_CONTEXT_TYPE* ContextPtr, uint32_t* ValuePtr)
{
XLNX_ERROR_CODE ret_val = XLNX_OK;
uint32_t Offset;
XLNX_COMPONENT_ADDRESS_TYPE WorkingAddr;
Offset = (BCS_BASE_RRO_SBITERR_COUNT_REG_OFFSET);
WorkingAddr = (XLNX_COMPONENT_ADDRESS_TYPE)((ContextPtr->ComponentBaseAddress) + Offset);
ret_val = XLNX_Environment_Wrapper_Read32(ContextPtr->UserEnvironment.Device_IO.Read32, ContextPtr->UserContextPtr, ValuePtr, WorkingAddr);
return ret_val;
}
XLNX_ERROR_CODE XLNX_Environment_Wrapper_Read32(XLNX_ENVIRONMENT_READ32_TYPE Read32, XLNX_USER_CONTEXT_TYPE pUserContext, uint32_t * pDestinationBuffer, XLNX_COMPONENT_ADDRESS_TYPE SourceAddress)
{
XLNX_ERROR_CODE Result = XLNX_ERR_ENVIRONMENT;
if (Read32 != NULL)
{
(*Read32)(pUserContext, SourceAddress, pDestinationBuffer);
Result = XLNX_OK;
}
return Result;
}
XLNX_ERROR_CODE XLNX_Environment_Wrapper_BlockRead32(XLNX_ENVIRONMENT_BLOCK_READ32_TYPE BlockRead32, XLNX_USER_CONTEXT_TYPE pUserContext, uint32_t * pDestinationBuffer, XLNX_COMPONENT_ADDRESS_TYPE SourceAddress, uint32_t WordsToRead)
{
XLNX_ERROR_CODE Result = XLNX_ERR_ENVIRONMENT;
if (BlockRead32 != NULL)
{
(*BlockRead32)(pUserContext, SourceAddress, pDestinationBuffer, WordsToRead);
Result = XLNX_OK;
}
return Result;
}
XLNX_ERROR_CODE XLNX_Environment_Wrapper_Write32(XLNX_ENVIRONMENT_WRITE32_TYPE Write32, XLNX_USER_CONTEXT_TYPE pUserContext, XLNX_COMPONENT_ADDRESS_TYPE DestinationAddress, uint32_t Value)
{
XLNX_ERROR_CODE Result = XLNX_ERR_ENVIRONMENT;
if (Write32 != NULL)
{
(*Write32)(pUserContext, DestinationAddress, Value);
Result = XLNX_OK;
}
return Result;
}
XLNX_ERROR_CODE XLNX_Environment_Wrapper_Write32_WithMask(XLNX_ENVIRONMENT_WRITE32_WITH_MASK_TYPE Write32_WithMask, XLNX_USER_CONTEXT_TYPE pUserContext, XLNX_COMPONENT_ADDRESS_TYPE DestinationAddress, uint32_t Value, uint32_t Mask)
{
XLNX_ERROR_CODE Result = XLNX_ERR_ENVIRONMENT;
if (Write32_WithMask != NULL)
{
(*Write32_WithMask)(pUserContext, (uint32_t)DestinationAddress, Value, Mask);
Result = XLNX_OK;
}
return Result;
}
#define SHIFT32BIT 32
#define MAX_CAM_REG_COUNT 100000
typedef struct {
uint32_t count; 
uint32_t timestamp; 
}XLNX_COMP_BCAM_COUNT;
typedef struct {
uint32_t num_passes; 
XLNX_COMP_BCAM_COUNT num_inserts; 
XLNX_COMP_BCAM_COUNT num_updates; 
XLNX_COMP_BCAM_COUNT num_deletes; 
XLNX_COMP_BCAM_COUNT num_lookups; 
XLNX_COMP_BCAM_COUNT hit_count;
XLNX_COMP_BCAM_COUNT ext_event_count;
XLNX_COMP_BCAM_COUNT li_req_ws_count;
XLNX_COMP_BCAM_COUNT get_by_key; 
uint32_t sbiterr_count; 
uint32_t dbiterr_count; 
uint32_t last_det_num_passes; 
uint32_t max_det_num_passes; 
uint64_t total_num_passes; 
}XLNX_COMP_BCAM_STATS;
struct comp_cam_a1aaat {
cam_config_t *conf;
aaaaaaaaaaaaaaaa1aaaaaaaaaaaaaaaabaaaaaaaaaaaaaaaaaaaaaaaaaaaa3aaat default_response;
uint32_t max_num_entries; 
uint32_t num_entries_count; 
uint32_t cam_full; 
XLNX_COMP_BCAM_CONTEXT_TYPE io;
uint32_t option_flags;
uint32_t poll_count;
XLNX_COMP_BCAM_STATS stats;
};
static uint32_t comp_cam_a1bbbbbbbbbbbbbbbbbb3aaaaaaaaaaaaaaaabaaaaaaaaaaaaaaaaaaaaaaaaaaaa4aaaresp(const comp_cam_a1aaat* client, const aaaaaaaaaaaaaaaa1aaaaaaaaaaaaaaaabaaaaaaaaaaaaaaaaaaaaaaaaaaaa3aaat* response, uint32_t resp_size);
static uint32_t comp_cam_a1aaaaaaaaaaaaaaaabaaaaaaaaaaaa3aaaaaaaaaaaaaaaabaaaaaaaaaaaaaaaaaaaaaaaaaaaa3aaaresp(const comp_cam_a1aaat* client, aaaaaaaaaaaaaaaa1aaaaaaaaaaaaaaaabaaaaaaaaaaaaaaaaaaaaaaaaaaaa3aaat* response, uint32_t resp_bit_width);
static uint32_t comp_cam_a1bbbbbbbbbbbbbbbbbb3aaaaaaaaaaaaaaaabaaaaaaaaaaaaaaaaaaaaaaaaaaaa4aaaaaaaaaaaaaaaabaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaa4aaa(const comp_cam_a1aaat* client, const aaaaaaaaaaaaa1aaat* key, uint32_t key_size);
static uint32_t comp_cam_a1aaapollstatus(comp_cam_a1aaat* client);
static uint32_t comp_bcam_clear_cam(comp_cam_a1aaat* client);
static uint32_t comp_bcam_api_initialize(comp_cam_a1aaat* client, const cam_config_t* cam_conf);
static int comp_bcam_a1aaaread_config(const comp_cam_a1aaat* client, cam_config_t* hw_config);
static uint32_t comp_cam_a1aaaaaaaaaaaaaaaabaaaaaaaaaaaa3aaaindirect_width(const comp_cam_a1aaat* client, uint32_t* ValuePtr);
static uint32_t comp_cam_a1aaaaaaaaaaaaaaaabaaaaaaaaaaaa3aaaindirect_respwidth(const comp_cam_a1aaat* client, uint32_t* ValuePtr);
static uint32_t comp_cam_a1aaaaaaaaaaaaaaaabaaaaaaaaaaaa3aaaindirect_prio(const comp_cam_a1aaat* client, uint32_t* ValuePtr);
static uint32_t comp_cam_a1aaaaaaaaaaaaaaaabaaaaaaaaaaaa3aaaindirect_numunits(const comp_cam_a1aaat* client, uint32_t* ValuePtr);
static uint32_t comp_cam_a1aaaaaaaaaaaaaaaabaaaaaaaaaaaa3aaaindirect_numtimeslots(const comp_cam_a1aaat* client, uint32_t* ValuePtr);
static uint32_t comp_cam_a1aaaaaaaaaaaaaaaabaaaaaaaaaaaa3aaaindirect_kmdata(const comp_cam_a1aaat* client, uint32_t* ValuePtr);
static uint32_t comp_cam_a1aaaaaaaaaaaaaaaabaaaaaaaaaaaa3aaaindirect_kmaddr(const comp_cam_a1aaat* client, uint32_t* ValuePtr);
static uint32_t comp_cam_a1aaaaaaaaaaaaaaaabaaaaaaaaaaaa3aaaindirect_mode(const comp_cam_a1aaat* client, uint32_t* ValuePtr);
static int comp_bcam_a1aaaaaaaaaaaaaaaabaaaaaaaaaaaa3aaacompbcamstats(comp_cam_a1aaat* client);
static int comp_bcam_a1aaaaaaaaaaaaaaaabaaaaaaaaaaaa3aaacompbcaminsertcount(XLNX_COMP_BCAM_CONTEXT_TYPE* ContextPtr, XLNX_COMP_BCAM_COUNT* countPtr);
static int comp_bcam_a1aaaaaaaaaaaaaaaabaaaaaaaaaaaa3aaacompbcamupdatecount(XLNX_COMP_BCAM_CONTEXT_TYPE* ContextPtr, XLNX_COMP_BCAM_COUNT* countPtr);
static int comp_bcam_a1aaaaaaaaaaaaaaaabaaaaaaaaaaaa3aaacompbcamdeletecount(XLNX_COMP_BCAM_CONTEXT_TYPE* ContextPtr, XLNX_COMP_BCAM_COUNT* countPtr);
static int comp_bcam_a1aaaaaaaaaaaaaaaabaaaaaaaaaaaa3aaacompbcamgetbykeycount(XLNX_COMP_BCAM_CONTEXT_TYPE* ContextPtr, XLNX_COMP_BCAM_COUNT* countPtr);
static int comp_bcam_a1aaaaaaaaaaaaaaaabaaaaaaaaaaaa3aaacompbcambaselookupcount(XLNX_COMP_BCAM_CONTEXT_TYPE* ContextPtr, XLNX_COMP_BCAM_COUNT* countPtr);
static int comp_bcam_a1aaaaaaaaaaaaaaaabaaaaaaaaaaaa3aaacompbcambasehitcount(XLNX_COMP_BCAM_CONTEXT_TYPE* ContextPtr, XLNX_COMP_BCAM_COUNT* countPtr);
static int comp_bcam_a1aaaaaaaaaaaaaaaabaaaaaaaaaaaa3aaacompbcambaseexteventcount(XLNX_COMP_BCAM_CONTEXT_TYPE* ContextPtr, XLNX_COMP_BCAM_COUNT* countPtr);
static int comp_bcam_a1aaaaaaaaaaaaaaaabaaaaaaaaaaaa3aaacompbcambaselireqwscount(XLNX_COMP_BCAM_CONTEXT_TYPE* ContextPtr, XLNX_COMP_BCAM_COUNT* countPtr);
static int comp_bcam_a1aaaaaaaaaaaaaaaabaaaaaaaaaaaa3aaacompbcambasetotalnumpassescount(XLNX_COMP_BCAM_CONTEXT_TYPE* ContextPtr, uint64_t* countPtr);
static int comp_bcam_a1aaaaaaaaaaaaaaaabaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaa3aaastats(comp_cam_a1aaat* client);
static inline void comp_bcam_get_the_count(uint32_t hi_count, uint32_t lo_count, uint64_t* countPtr);
int comp_bcam_a1bbbbbbbbbbbbbbbbbbbbbbbbbbbbbbbbbbbbbbb3aaaeate(cam_arg_t *cam_conf_arg, cam_instance_type_t cam_instance_type, comp_cam_a1aaat **client)
{
cam_config_t *cam_conf;
uint32_t rc = XLNX_OK;
uint32_t debug_flags;
bool err;
char sub_str[500];
char message[500];
if ((cam_conf_arg == NULL) || (client == NULL))
{
return (XLNX_ERR_NULL_PTR);
}
comp_cam_a1aaat *new_client = cam_conf_arg->malloc_function(sizeof(comp_cam_a1aaat));
if (new_client == NULL)
{
return CAM_ERROR_MALLOC_FAILED;
}
rc = cam_config_create(cam_conf_arg, cam_instance_type, &cam_conf);
if (rc != XLNX_OK)
{
cam_free_func free_function = cam_conf_arg->free_function;
free_function(new_client);
return rc;
}
new_client->conf = cam_conf;
rc = comp_bcam_api_initialize(new_client, cam_conf);
if (rc != XLNX_OK)
{
cam_free_func free_function = cam_conf_arg->free_function;
free_function(new_client);
return rc;
}
debug_flags = new_client->conf->arg.debug_flags;
if (debug_flags & CAM_DEBUG_VERIFY_CONFIG)
{
cam_config_t hw_conf;
rc = comp_bcam_a1aaaread_config(new_client, &hw_conf);
if (rc != XLNX_OK)
{
return rc;
}
err = cam_conf->key_width != hw_conf.key_width;
if (err || (debug_flags & CAM_DEBUG_VERBOSE_VERIFY))
{
           sprintf(sub_str, "CAM_DEBUG_CONFIG  key width = %0d (expected %0d)",
hw_conf.key_width, cam_conf->key_width);
           sprintf(message, "%-70s%s", sub_str, err ? "FAIL" : "OK");
if (err)
{
rc = CAM_ERROR_CONFIGURATION;
comp_bcam_a1aaaaaaaaaaaaaaaabaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaa3aaaaaaaaaaaaaaaabaaaaaaaaaaaaaaaaaaaaaaaaaaaa4aaaerror(new_client, message);
}
else
{
comp_bcam_a1aaaaaaaaaaaaaaaabaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaa3aaaaaaaaaaaaaaaabaaaaaaaaaaaaaaaaaaaaaaaaaaaa4aaainfo(new_client, message);
}
}
err = cam_conf->prio_width != hw_conf.prio_width;
if (err || (debug_flags & CAM_DEBUG_VERBOSE_VERIFY))
{
           sprintf(sub_str, "CAM_DEBUG_CONFIG  prio width = %0d (expected %0d)",
hw_conf.prio_width, cam_conf->prio_width);
           sprintf(message, "%-70s%s", sub_str, err ? "FAIL" : "OK");
if (err)
{
rc = CAM_ERROR_CONFIGURATION;
comp_bcam_a1aaaaaaaaaaaaaaaabaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaa3aaaaaaaaaaaaaaaabaaaaaaaaaaaaaaaaaaaaaaaaaaaa4aaaerror(new_client, message);
}
else
{
comp_bcam_a1aaaaaaaaaaaaaaaabaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaa3aaaaaaaaaaaaaaaabaaaaaaaaaaaaaaaaaaaaaaaaaaaa4aaainfo(new_client, message);
}
}
err = cam_conf->arg.response_width != hw_conf.arg.response_width;
if (err || (debug_flags & CAM_DEBUG_VERBOSE_VERIFY))
{
           sprintf(sub_str, "CAM_DEBUG_CONFIG  response width = %0d (expected %0d)",
hw_conf.arg.response_width, cam_conf->arg.response_width);
           sprintf(message, "%-70s%s", sub_str, err ? "FAIL" : "OK");
if (err)
{
rc = CAM_ERROR_CONFIGURATION;
comp_bcam_a1aaaaaaaaaaaaaaaabaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaa3aaaaaaaaaaaaaaaabaaaaaaaaaaaaaaaaaaaaaaaaaaaa4aaaerror(new_client, message);
}
else
{
comp_bcam_a1aaaaaaaaaaaaaaaabaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaa3aaaaaaaaaaaaaaaabaaaaaaaaaaaaaaaaaaaaaaaaaaaa4aaainfo(new_client, message);
}
}
err = cam_conf->num_units != hw_conf.num_units;
if (err || (debug_flags & CAM_DEBUG_VERBOSE_VERIFY))
{
           sprintf(sub_str, "CAM_DEBUG_CONFIG  number of logical units = %0d (expected %0d)",
hw_conf.num_units, cam_conf->num_units);
           sprintf(message, "%-70s%s", sub_str, err ? "FAIL" : "OK");
if (err)
{
rc = CAM_ERROR_CONFIGURATION;
comp_bcam_a1aaaaaaaaaaaaaaaabaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaa3aaaaaaaaaaaaaaaabaaaaaaaaaaaaaaaaaaaaaaaaaaaa4aaaerror(new_client, message);
}
else
{
comp_bcam_a1aaaaaaaaaaaaaaaabaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaa3aaaaaaaaaaaaaaaabaaaaaaaaaaaaaaaaaaaaaaaaaaaa4aaainfo(new_client, message);
}
}
err = cam_conf->num_slots != hw_conf.num_slots;
if (err || (debug_flags & CAM_DEBUG_VERBOSE_VERIFY))
{
           sprintf(sub_str, "CAM_DEBUG_CONFIG  number of time slots = %0d (expected %0d)",
hw_conf.num_slots, cam_conf->num_slots);
           sprintf(message, "%-70s%s", sub_str, err ? "FAIL" : "OK");
if (err)
{
rc = CAM_ERROR_CONFIGURATION;
comp_bcam_a1aaaaaaaaaaaaaaaabaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaa3aaaaaaaaaaaaaaaabaaaaaaaaaaaaaaaaaaaaaaaaaaaa4aaaerror(new_client, message);
}
else
{
comp_bcam_a1aaaaaaaaaaaaaaaabaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaa3aaaaaaaaaaaaaaaabaaaaaaaaaaaaaaaaaaaaaaaaaaaa4aaainfo(new_client, message);
}
}
err = cam_conf->num_lists != hw_conf.num_lists;
if (err || (debug_flags & CAM_DEBUG_VERBOSE_VERIFY))
{
           sprintf(sub_str, "CAM_DEBUG_CONFIG  RAM addresses (logical) = %0d (expected %0d)",
hw_conf.num_lists, cam_conf->num_lists);
           sprintf(message, "%-70s%s", sub_str, err ? "FAIL" : "OK");
if (err)
{
rc = CAM_ERROR_CONFIGURATION;
comp_bcam_a1aaaaaaaaaaaaaaaabaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaa3aaaaaaaaaaaaaaaabaaaaaaaaaaaaaaaaaaaaaaaaaaaa4aaaerror(new_client, message);
}
else
{
comp_bcam_a1aaaaaaaaaaaaaaaabaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaa3aaaaaaaaaaaaaaaabaaaaaaaaaaaaaaaaaaaaaaaaaaaa4aaainfo(new_client, message);
}
}
err = cam_conf->list_length != hw_conf.list_length;
if (err || (debug_flags & CAM_DEBUG_VERBOSE_VERIFY))
{
           sprintf(sub_str, "CAM_DEBUG_CONFIG  RAM data width = %0d (expected %0d)",
hw_conf.list_length, cam_conf->list_length);
           sprintf(message, "%-70s%s", sub_str, err ? "FAIL" : "OK");
if (err)
{
rc = CAM_ERROR_CONFIGURATION;
comp_bcam_a1aaaaaaaaaaaaaaaabaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaa3aaaaaaaaaaaaaaaabaaaaaaaaaaaaaaaaaaaaaaaaaaaa4aaaerror(new_client, message);
}
else
{
comp_bcam_a1aaaaaaaaaaaaaaaabaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaa3aaaaaaaaaaaaaaaabaaaaaaaaaaaaaaaaaaaaaaaaaaaa4aaainfo(new_client, message);
}
}
}
if (!(debug_flags & CAM_DEBUG_SKIP_MEM_INIT))
{
rc = comp_bcam_clear_cam(new_client); 
       sprintf(sub_str, "Clear comp bcam memory ");
       sprintf(message, "%-70s%s", sub_str, rc ? "FAIL" : "OK");
if (rc != XLNX_OK) 
{ 
comp_bcam_a1aaaaaaaaaaaaaaaabaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaa3aaaaaaaaaaaaaaaabaaaaaaaaaaaaaaaaaaaaaaaaaaaa4aaaerror(new_client, message);
cam_free_func free_function = cam_conf_arg->free_function;
free_function(new_client); 
return rc;
}
else
{
comp_bcam_a1aaaaaaaaaaaaaaaabaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaa3aaaaaaaaaaaaaaaabaaaaaaaaaaaaaaaaaaaaaaaaaaaa4aaainfo(new_client, message);
} 
}
*client = (void*)new_client;
return rc;
}
int comp_bcam_a1aaaaaaaaaaaaaaaabaaaaaaaaaaaaaaaaaaaaaaaaa3aaa(comp_cam_a1aaat *client)
{
int rc = 0;
if (client == NULL)
{
return 0 ;
}
if (comp_bcam_a1aaaaaaaaaaaaaaaabaaaaaaaaaaaa3aaaaaaaaaaaaaaaabaaaaaaaaaaaaaaaaaaaaaaaaaaaa3bbbbbbbbbbbbbbbbbbbbbbbbbbbbbbbbbbbbb3aaaaaaaaaaaaaaaabaaaaaaaaaaaaaaaaaaaaaaaaaaaa4aaaflags(client) & CAM_DEBUG_STATS)
{
rc = comp_bcam_a1aaaaaaaaaaaaaaaabaaaaaaaaaaaa3aaacompbcamstats(client);
if (rc == XLNX_OK)
{
comp_bcam_a1aaaaaaaaaaaaaaaabaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaa3aaastats(client);
}
else
{
char message[100];
           sprintf(message, "%s fail", __func__);
comp_bcam_a1aaaaaaaaaaaaaaaabaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaa3aaaaaaaaaaaaaaaabaaaaaaaaaaaaaaaaaaaaaaaaaaaa4aaainfo(client, message);
}
}
cam_free_func free_function = comp_bcam_a1aaaaaaaaaaaaaaaabaaaaaaaaaaaa3aaaaaaaaaaaaaaaabaaaaaaaaaaaaaaaaaaaaaaaaaaaa3aaaaaaaaaaaaaabaaaaaaaaaaaa4aaaaaaaaaaaaaaaabaaaaaaaaaaaaaaaaaaaaaaaaaaaa4aaaaaaaaaaaaaaaabaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaa4aaa(client);
free_function(client);
return rc;
}
int comp_bcam_a1bbbbbbbbbbbbbbbbbbbb3aaaaaaaaaaaaaaaabaaaaaaaaaaaaaaaaaaaaaaaaaaaa4aaaaaaaaaaaaaaaabaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaa4aaa(comp_cam_a1aaat *client, const aaaaaaaaaaaaa1aaat *key, const aaaaaaaaaaaaaaaa1aaaaaaaaaaaaaaaabaaaaaaaaaaaaaaaaaaaaaaaaaaaa3aaat *response, uint32_t key_bit_width, uint32_t resp_bit_width)
{
uint32_t Ret = XLNX_OK;
Ret = comp_cam_a1bbbbbbbbbbbbbbbbbb3aaaaaaaaaaaaaaaabaaaaaaaaaaaaaaaaaaaaaaaaaaaa4aaaaaaaaaaaaaaaabaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaa4aaa(client, key, key_bit_width);
if (Ret == XLNX_OK)
{
Ret = comp_cam_a1bbbbbbbbbbbbbbbbbb3aaaaaaaaaaaaaaaabaaaaaaaaaaaaaaaaaaaaaaaaaaaa4aaaresp(client, response, resp_bit_width);
}
if (Ret == XLNX_OK)
{
Ret = XLNX_COMP_BCAM_SetCompBcamBaseOperationReg(&(client->io), (uint32_t)CAM_OPERATION_UPDATE);
}
if (Ret == XLNX_OK)
{
Ret = comp_cam_a1aaapollstatus(client);
}
return(Ret);
}
int comp_bcam_a1aaaaaaaaaaaaaaabaaaaaaaaaaaaaaaaaaa3aaaaaaaaaaaaaaaabaaaaaaaaaaaaaaaaaaaaaaaaaaaa3aaaaaaaaaaaaaaaabaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaa3aaa(comp_cam_a1aaat *client, const aaaaaaaaaaaaa1aaat *key, const aaaaaaaaaaaaaaaa1aaaaaaaaaaaaaaaabaaaaaaaaaaaaaaaaaaaaaaaaaaaa3aaat *response, uint32_t key_bit_width, uint32_t resp_bit_width)
{
uint32_t Ret = XLNX_OK;
if (client->cam_full)
{
return(CAM_ERROR_FULL);
}
if (Ret == XLNX_OK)
{
Ret = comp_cam_a1bbbbbbbbbbbbbbbbbb3aaaaaaaaaaaaaaaabaaaaaaaaaaaaaaaaaaaaaaaaaaaa4aaaaaaaaaaaaaaaabaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaa4aaa(client, key, key_bit_width);
}
if (Ret == XLNX_OK)
{
Ret = comp_cam_a1bbbbbbbbbbbbbbbbbb3aaaaaaaaaaaaaaaabaaaaaaaaaaaaaaaaaaaaaaaaaaaa4aaaresp(client, response, resp_bit_width);
}
if (Ret == XLNX_OK)
{
Ret = XLNX_COMP_BCAM_SetCompBcamBaseOperationReg(&(client->io), (uint32_t) CAM_OPERATION_INSERT);
}
if (Ret == XLNX_OK)
{
Ret = comp_cam_a1aaapollstatus(client);
}
if (Ret == XLNX_OK)
{
client->num_entries_count++;
if (client->num_entries_count == client->max_num_entries)
{
client->cam_full = 1;
}
}
else
{
if (Ret == CAM_ERROR_FULL)
{
client->num_entries_count++;
client->cam_full = 1;
}
}
return(Ret);
}
int comp_bcam_a1aaaaaaaaaaaaaaaabaaaaaaaaaaaaaaaaaaa3aaaaaaaaaaaaaaaabaaaaaaaaaaaaaaaaaaaaaaaaaaaa3aaaaaaaaaaaaaaaabaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaa3aaa(comp_cam_a1aaat *client, const aaaaaaaaaaaaa1aaat *key, uint32_t key_bit_width)
{
uint32_t Ret = XLNX_OK;
Ret = comp_cam_a1bbbbbbbbbbbbbbbbbb3aaaaaaaaaaaaaaaabaaaaaaaaaaaaaaaaaaaaaaaaaaaa4aaaaaaaaaaaaaaaabaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaa4aaa(client, key, key_bit_width);
if (Ret == XLNX_OK)
{
Ret = XLNX_COMP_BCAM_SetCompBcamBaseOperationReg(&(client->io), (uint32_t) CAM_OPERATION_DELETE);
}
if (Ret == XLNX_OK)
{
Ret = comp_cam_a1aaapollstatus(client);
}
if (Ret == XLNX_OK)
{
client->num_entries_count--;
if (client->cam_full)
{
client->cam_full = 0;
}
}
return(Ret);
}
int comp_bcam_a1aaaaaaaaaaaaaaaabaaaaaaaaaaaa3aaaaaaaaaaaaaaaabaaaaaaaaaaaaaaaaaaaaaaaaaaaa3aaaby_key(comp_cam_a1aaat *client, const aaaaaaaaaaaaa1aaat *key, aaaaaaaaaaaaaaaa1aaaaaaaaaaaaaaaabaaaaaaaaaaaaaaaaaaaaaaaaaaaa3aaat *response, const uint16_t key_bit_width, const uint16_t resp_bit_width)
{
uint32_t Ret = XLNX_OK;
Ret = comp_cam_a1bbbbbbbbbbbbbbbbbb3aaaaaaaaaaaaaaaabaaaaaaaaaaaaaaaaaaaaaaaaaaaa4aaaaaaaaaaaaaaaabaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaa4aaa(client, key, key_bit_width);
if (Ret == XLNX_OK)
{
Ret = XLNX_COMP_BCAM_SetCompBcamBaseOperationReg(&(client->io), (uint32_t) CAM_OPERATION_GETBYKEY);
}
if (Ret == XLNX_OK)
{
Ret = comp_cam_a1aaapollstatus(client);
}
if (Ret == XLNX_OK)
{
comp_cam_a1aaaaaaaaaaaaaaaabaaaaaaaaaaaa3aaaaaaaaaaaaaaaabaaaaaaaaaaaaaaaaaaaaaaaaaaaa3aaaresp(client, response, resp_bit_width);
}
return(Ret);
}
uint32_t comp_bcam_a1aaaaaaaaaaaaaaaabaaaaaaaaaaaa3aaaaaaaaaaaaaaaabaaaaaaaaaaaaaaaaaaaaaaaaaaaa3aaaaaaaaaaaaaaabaaaaaaaaaaaaaaaa4aaaaaaaaaaaaaaaabaaaaaaaaaaaaaaaaaaaaaaaaaaaa4aaaaaaaaaaaaabaaaaaaaaaaaaaaaaa5aaas(const comp_cam_a1aaat *client)
{
return cam_config_get_num_lists(client->conf);
}
uint32_t comp_bcam_a1aaaaaaaaaaaaaaaabaaaaaaaaaaaa3aaaaaaaaaaaaaaaabaaaaaaaaaaaaaaaaaaaaaaaaaaaa3aaacurrent_num_entries(const comp_cam_a1aaat *client)
{
return client->num_entries_count;
}
uint16_t comp_bcam_a1aaaaaaaaaaaaaaaabaaaaaaaaaaaa3aaaaaaaaaaaaaaaabaaaaaaaaaaaaaaaaaaaaaaaaaaaa3aaaaaaaaaaaaaaaabaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaa3aaaaaaaaaaaaaaaabaaaaaaaaaaaaaaaaaaaaaaaaaaaa4aaawidth(const comp_cam_a1aaat *client)
{
return cam_config_get_key_width(client->conf);
}
cam_free_func comp_bcam_a1aaaaaaaaaaaaaaaabaaaaaaaaaaaa3aaaaaaaaaaaaaaaabaaaaaaaaaaaaaaaaaaaaaaaaaaaa3aaaaaaaaaaaaaabaaaaaaaaaaaa4aaaaaaaaaaaaaaaabaaaaaaaaaaaaaaaaaaaaaaaaaaaa4aaaaaaaaaaaaaaaabaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaa4aaa(const comp_cam_a1aaat* client)
{
return(client->conf->arg.free_function);
}
cam_malloc_func comp_bcam_a1aaaaaaaaaaaaaaaabaaaaaaaaaaaa3aaaaaaaaaaaaaaaabaaaaaaaaaaaaaaaaaaaaaaaaaaaa3aaamalloc_function(const comp_cam_a1aaat* client)
{
return(client->conf->arg.malloc_function);
}
cam_calloc_func comp_bcam_a1aaaaaaaaaaaaaaaabaaaaaaaaaaaa3aaaaaaaaaaaaaaaabaaaaaaaaaaaaaaaaaaaaaaaaaaaa3aaacalloc_function(const comp_cam_a1aaat* client)
{
return(client->conf->arg.calloc_function);
}
void comp_bcam_a1aaaaaaaaaaaaaaaabaaaaaaaaaaaa3aaaaaaaaaaaaaaaabaaaaaaaaaaaaaaaaaaaaaaaaaaaa3aaawidths(const comp_cam_a1aaat *client, uint16_t *key_width,
uint16_t *response_width)
{
*key_width = comp_bcam_a1aaaaaaaaaaaaaaaabaaaaaaaaaaaa3aaaaaaaaaaaaaaaabaaaaaaaaaaaaaaaaaaaaaaaaaaaa3aaaaaaaaaaaaaaaabaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaa3aaaaaaaaaaaaaaaabaaaaaaaaaaaaaaaaaaaaaaaaaaaa4aaawidth(client);
*response_width = comp_bcam_a1aaaaaaaaaaaaaaaabaaaaaaaaaaaa3aaaaaaaaaaaaaaaabaaaaaaaaaaaaaaaaaaaaaaaaaaaa3aaaaaaaaaaaaaaaabaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaa3aaaaaaaaaaaaaaaabaaaaaaaaaaaaaaaaaaaaaaaaaaaa4aaawidth(client);
}
uint32_t comp_bcam_a1aaaaaaaaaaaaaaaabaaaaaaaaaaaa3aaaaaaaaaaaaaaaabaaaaaaaaaaaaaaaaaaaaaaaaaaaa3aaaaaaaaaaaaaaabaaaaaaaaaaaaaaaa4aaaaaaaaaaaaaaaabaaaaaaaaaaaaaaaaaaaaaaaaaaaa4aaaaaaaaaaaabaaaaaaaaaaaaaaaaa5aaas(const comp_cam_a1aaat *client)
{ 
return 0;
}
uint16_t comp_bcam_a1aaaaaaaaaaaaaaaabaaaaaaaaaaaa3aaaaaaaaaaaaaaaabaaaaaaaaaaaaaaaaaaaaaaaaaaaa3aaaaaaaaaaaaaaaabaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaa3aaaaaaaaaaaaaaaabaaaaaaaaaaaaaaaaaaaaaaaaaaaa4aaawidth(const comp_cam_a1aaat *client)
{
return cam_config_get_response_width(client->conf);
}
void comp_bcam_a1bbbbbbbbbbbbbbbbbb3aaaaaaaaaaaaaaaabaaaaaaaaaaaaaaaaaaaaaaaaaaaa4bbbbbbbbbbbbbbbbbbbbbbbbbbbbbbbbbbbbb4aaaaaaaaaaaaaaaabaaaaaaaaaaaaaaaaaaaaaaaaaaaa5aaaflags(const comp_cam_a1aaat *client, uint32_t debug_flags)
{
client->conf->arg.debug_flags = debug_flags;
}
uint32_t comp_bcam_a1aaaaaaaaaaaaaaaabaaaaaaaaaaaa3aaaaaaaaaaaaaaaabaaaaaaaaaaaaaaaaaaaaaaaaaaaa3bbbbbbbbbbbbbbbbbbbbbbbbbbbbbbbbbbbbb3aaaaaaaaaaaaaaaabaaaaaaaaaaaaaaaaaaaaaaaaaaaa4aaaflags(const comp_cam_a1aaat *client)
{
return client->conf->arg.debug_flags;
}
uint32_t comp_bcam_a1aaaaaaaaaaaaaaaabaaaaaaaaaaaa3aaaaaaaaaaaaaaaabaaaaaaaaaaaaaaaaaaaaaaaaaaaa3aaaaaaaaaaaaaaabaaaaaaaaaaaaaaaa4aaaaaaaaaaaaaaaabaaaaaaaaaaaaaaaaaaaaaaaaaaaa4aaaaaaaaaaaaaaaabaaaaaaaaaaaaaaaaaaaaa5aaa(const comp_cam_a1aaat *client)
{
assert(client != NULL);
return cam_config_get_num_entries(client->conf);
}
void comp_bcam_a1aaaaaaaaaaaaaaaabaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaa3aaaaaaaaaaaaaaaabaaaaaaaaaaaaaaaaaaaaaaaaaaaa4aaaerror(const comp_cam_a1aaat *client, char *message)
{
client->conf->arg.error_print_function(client->conf->ctx, message);
}
void comp_bcam_a1aaaaaaaaaaaaaaaabaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaa3aaaaaaaaaaaaaaaabaaaaaaaaaaaaaaaaaaaaaaaaaaaa4aaainfo(const comp_cam_a1aaat *client, char *message)
{
client->conf->arg.info_print_function(client->conf->ctx, message);
}
static uint32_t comp_bcam_api_initialize(comp_cam_a1aaat *client, const cam_config_t *cam_conf)
{
XLNX_ERROR_CODE Result = XLNX_OK;
if ((client == NULL) || (cam_conf == NULL))
{
return (XLNX_ERR_ENVIRONMENT);
}
const cam_arg_t *cam_conf_arg = &(cam_conf->arg);
client->io.ComponentBaseAddress = ASSEMBLY_COMP_BCAM_OFFSET; 
client->io.UserContextPtr = cam_conf->ctx;
client->max_num_entries = cam_conf_arg->num_entries;
client->io.UserEnvironment.Device_IO.Write32WithMask = NULL;
client->num_entries_count = 0;
client->cam_full = 0;
client->poll_count = 0;
client->option_flags = 0;
if ((cam_conf_arg->hw_read_function == NULL) || (cam_conf_arg->hw_write_function == NULL))
{
client->io.UserEnvironment.Device_IO.Read32 = NULL;
client->io.UserEnvironment.Device_IO.Write32 = NULL;
Result = XLNX_ERR_ENVIRONMENT;
}
else
{
client->io.UserEnvironment.Device_IO.Read32 = cam_conf_arg->hw_read_function;
client->io.UserEnvironment.Device_IO.Write32 = cam_conf_arg->hw_write_function;
}
return Result;
}
static uint32_t comp_bcam_clear_cam(comp_cam_a1aaat* client)
{
uint32_t ret = XLNX_OK;
uint32_t count = 0;
uint32_t cam_clear_val = 1;
ret = XLNX_COMP_BCAM_SetCompBcamData(&(client->io), COMP_BCAM_BASE_CAM_CLEAR_REG_OFFSET, COMP_BCAM_BASE_CAM_CLEAR_REG_NUM);
if (ret == XLNX_OK)
{
do
{
XLNX_COMP_BCAM_GetCompBcamBaseCamClearCamClear(&(client->io), &cam_clear_val);
if (cam_clear_val == 0)
{
ret = XLNX_OK;
break;
}
count++;
}
while (count <= MAX_CAM_REG_COUNT);
}
if (count >= MAX_CAM_REG_COUNT)
{
ret = CAM_ERROR_ENVIRONMENT;
}
return ret;
}
static uint32_t comp_cam_a1bbbbbbbbbbbbbbbbbb3aaaaaaaaaaaaaaaabaaaaaaaaaaaaaaaaaaaaaaaaaaaa4aaaresp(const comp_cam_a1aaat *client, const aaaaaaaaaaaaaaaa1aaaaaaaaaaaaaaaabaaaaaaaaaaaaaaaaaaaaaaaaaaaa3aaat *response, uint32_t resp_bit_width)
{
uint32_t Ret = XLNX_OK;
uint32_t offset;
uint32_t num_words = resp_bit_width / NUM_BITS_IN_DWORD;
const uint32_t remaining_bits = resp_bit_width - (num_words * NUM_BITS_IN_DWORD);
if (remaining_bits >= 1)
{
num_words++;
}
for (uint32_t count = 0; count < num_words; count++)
{
offset = COMP_BCAM_BASE_RESPONSE_DATA_00_REG_OFFSET + (count * NUM_BYTES_IN_DWORD);
Ret = XLNX_COMP_BCAM_SetCompBcamData(&(client->io), offset, response->word[count]);
if (Ret != XLNX_OK)
{
return (Ret);
}
}
return Ret;
}
static uint32_t comp_cam_a1aaaaaaaaaaaaaaaabaaaaaaaaaaaa3aaaaaaaaaaaaaaaabaaaaaaaaaaaaaaaaaaaaaaaaaaaa3aaaresp(const comp_cam_a1aaat *client, aaaaaaaaaaaaaaaa1aaaaaaaaaaaaaaaabaaaaaaaaaaaaaaaaaaaaaaaaaaaa3aaat *response, uint32_t resp_bit_width)
{
uint32_t Ret = XLNX_OK;
uint32_t offset;
uint32_t num_words = resp_bit_width / NUM_BITS_IN_DWORD;
const uint32_t remaining_bits = resp_bit_width - (num_words * NUM_BITS_IN_DWORD);
if (remaining_bits >= 1)
{
num_words++;
}
for (uint32_t count = 0; count < num_words; count++)
{
offset = COMP_BCAM_BASE_RESPONSE_DATA_00_REG_OFFSET + (count * NUM_BYTES_IN_DWORD);
Ret = XLNX_COMP_BCAM_GetCompBcamData(&(client->io), offset, &(response->word[count]));
if (Ret != XLNX_OK)
{
return (Ret);
}
}
return Ret;
}
static uint32_t comp_cam_a1bbbbbbbbbbbbbbbbbb3aaaaaaaaaaaaaaaabaaaaaaaaaaaaaaaaaaaaaaaaaaaa4aaaaaaaaaaaaaaaabaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaa4aaa(const comp_cam_a1aaat *client, const aaaaaaaaaaaaa1aaat *key, uint32_t key_bit_width)
{
uint32_t count; 
uint32_t offset;
uint32_t Ret = XLNX_OK;
uint32_t num_words = key_bit_width / NUM_BITS_IN_DWORD;
const uint32_t remaining_bits = key_bit_width - (num_words * NUM_BITS_IN_DWORD);
if (remaining_bits >= 1)
{
num_words++;
}
for (count = 0; count < num_words; count++)
{
offset = COMP_BCAM_BASE_KEY_DATA_00_REG_OFFSET + (count * NUM_BYTES_IN_DWORD);
Ret = XLNX_COMP_BCAM_SetCompBcamData(&(client->io), offset, key->word[count]);
if (Ret != XLNX_OK)
{
return (Ret);
}
}
return Ret;
}
static uint32_t comp_cam_a1aaapollstatus(comp_cam_a1aaat *client)
{
uint32_t Ret = CAM_ERROR_ENVIRONMENT;
CAM_OPERATION_STATUS_ENUM Status = CAM_OPERATION_STATUS_FSMBUSY;
#ifdef NOPOLLING
Ret = XLNX_COMP_BCAM_GetCompBcamBaseStatusStatus(&(client->io), ( uint32_t*) & Status);
if (Ret != XLNX_OK)
{
Ret = CAM_ERROR_ENVIRONMENT;
}
#else 
uint32_t Count = 0;
do
{
Ret = XLNX_COMP_BCAM_GetCompBcamBaseStatusStatus(&(client->io), ( uint32_t*) &Status);
Count++;
if ((Count == 300000) || (Ret != XLNX_OK))
{
Ret = CAM_ERROR_ENVIRONMENT_POLLED_OUT;
break;
}
}
while (Status == CAM_OPERATION_STATUS_FSMBUSY);
if (Count > 1)
{
client->poll_count += Count;
}
#endif 
if (Ret == XLNX_OK)
{
switch (Status)
{
case CAM_OPERATION_STATUS_CAMFULL:
Ret = CAM_ERROR_FULL;
break;
case CAM_OPERATION_STATUS_KEYNOTFOUND:
Ret = CAM_ERROR_KEY_NOT_FOUND;
break;
case CAM_OPERATION_STATUS_DUPLICATEKEY:
Ret = CAM_ERROR_DUPLICATE_FOUND;
break;
case CAM_OPERATION_STATUS_SUCCESS:
Ret = XLNX_OK;
break;
default: 
Ret = CAM_ERROR_ENVIRONMENT;
break;
}
}
return Ret;
}
static int comp_bcam_a1aaaread_config(const comp_cam_a1aaat *client, cam_config_t *hw_config)
{
uint32_t data = 0;
comp_cam_a1aaaaaaaaaaaaaaaabaaaaaaaaaaaa3aaaindirect_width(client, &data);
hw_config->key_width = data;
comp_cam_a1aaaaaaaaaaaaaaaabaaaaaaaaaaaa3aaaindirect_prio(client, &data);
hw_config->prio_width = data;
comp_cam_a1aaaaaaaaaaaaaaaabaaaaaaaaaaaa3aaaindirect_respwidth(client, &data);
hw_config->arg.response_width = data;
comp_cam_a1aaaaaaaaaaaaaaaabaaaaaaaaaaaa3aaaindirect_numtimeslots(client, &data);
hw_config->num_slots = data;
comp_cam_a1aaaaaaaaaaaaaaaabaaaaaaaaaaaa3aaaindirect_numunits(client, &data);
hw_config->num_units = data * hw_config->num_slots;
comp_cam_a1aaaaaaaaaaaaaaaabaaaaaaaaaaaa3aaaindirect_kmdata(client, &data);
hw_config->list_length = data;
comp_cam_a1aaaaaaaaaaaaaaaabaaaaaaaaaaaa3aaaindirect_kmaddr(client, &data);
if (hw_config->num_slots != 0)
{
hw_config->num_lists = data / (hw_config->num_slots);
}
else
{
hw_config->num_lists = 0;
}
comp_cam_a1aaaaaaaaaaaaaaaabaaaaaaaaaaaa3aaaindirect_mode(client, &data);
hw_config->instance_type = data & COMP_BCAM_BASE_MODE_MODE_MASK;
return 0;
}
static uint32_t comp_cam_a1aaaaaaaaaaaaaaaabaaaaaaaaaaaa3aaaindirect_width(const comp_cam_a1aaat *client, uint32_t* ValuePtr)
{
uint32_t Ret = XLNX_OK;
XLNX_COMP_BCAM_SetCompBcamBaseIndirectAddrReg(&(client->io), INDIRECT_ADDR_KEY_WIDTH);
XLNX_COMP_BCAM_GetCompBcamBaseIndirectRdData00Reg(&(client->io), ValuePtr);
return Ret;
}
static uint32_t comp_cam_a1aaaaaaaaaaaaaaaabaaaaaaaaaaaa3aaaindirect_prio(const comp_cam_a1aaat *client, uint32_t* ValuePtr)
{
uint32_t Ret = XLNX_OK;
XLNX_COMP_BCAM_SetCompBcamBaseIndirectAddrReg(&(client->io), INDIRECT_ADDR_PRIO);
XLNX_COMP_BCAM_GetCompBcamBaseIndirectRdData00Reg(&(client->io), ValuePtr);
return Ret;
}
static uint32_t comp_cam_a1aaaaaaaaaaaaaaaabaaaaaaaaaaaa3aaaindirect_respwidth(const comp_cam_a1aaat *client, uint32_t* ValuePtr)
{
uint32_t Ret = XLNX_OK;
XLNX_COMP_BCAM_SetCompBcamBaseIndirectAddrReg(&(client->io), INDIRECT_ADDR_RESP_WIDTH);
XLNX_COMP_BCAM_GetCompBcamBaseIndirectRdData00Reg(&(client->io), ValuePtr);
return Ret;
}
static uint32_t comp_cam_a1aaaaaaaaaaaaaaaabaaaaaaaaaaaa3aaaindirect_numtimeslots(const comp_cam_a1aaat *client, uint32_t* ValuePtr)
{
uint32_t Ret = XLNX_OK;
XLNX_COMP_BCAM_SetCompBcamBaseIndirectAddrReg(&(client->io), INDIRECT_ADDR_TIME_SLOTS);
XLNX_COMP_BCAM_GetCompBcamBaseIndirectRdData00Reg(&(client->io), ValuePtr);
return Ret;
}
static uint32_t comp_cam_a1aaaaaaaaaaaaaaaabaaaaaaaaaaaa3aaaindirect_numunits(const comp_cam_a1aaat *client, uint32_t* ValuePtr)
{
uint32_t Ret = XLNX_OK;
XLNX_COMP_BCAM_SetCompBcamBaseIndirectAddrReg(&(client->io), INDIRECT_ADDR_UNITS);
XLNX_COMP_BCAM_GetCompBcamBaseIndirectRdData00Reg(&(client->io), ValuePtr);
return Ret;
}
static uint32_t comp_cam_a1aaaaaaaaaaaaaaaabaaaaaaaaaaaa3aaaindirect_kmdata(const comp_cam_a1aaat *client, uint32_t* ValuePtr)
{
uint32_t Ret = XLNX_OK;
XLNX_COMP_BCAM_SetCompBcamBaseIndirectAddrReg(&(client->io), INDIRECT_ADDR_aaaa1aaaDATA);
XLNX_COMP_BCAM_GetCompBcamBaseIndirectRdData00Reg(&(client->io), ValuePtr);
return Ret;
}
static uint32_t comp_cam_a1aaaaaaaaaaaaaaaabaaaaaaaaaaaa3aaaindirect_kmaddr(const comp_cam_a1aaat *client, uint32_t* ValuePtr)
{
uint32_t Ret = XLNX_OK;
XLNX_COMP_BCAM_SetCompBcamBaseIndirectAddrReg(&(client->io), INDIRECT_ADDR_aaaa1bbbbbbbbbbbbbbbbbbbbbbbbbbbbbbbb3aaaR);
XLNX_COMP_BCAM_GetCompBcamBaseIndirectRdData00Reg(&(client->io), ValuePtr);
return Ret;
}
static uint32_t comp_cam_a1aaaaaaaaaaaaaaaabaaaaaaaaaaaa3aaaindirect_mode(const comp_cam_a1aaat *client, uint32_t* ValuePtr)
{
uint32_t Ret = XLNX_OK;
XLNX_COMP_BCAM_SetCompBcamBaseIndirectAddrReg(&(client->io), INDIRECT_ADDR_MODE);
XLNX_COMP_BCAM_GetCompBcamBaseIndirectRdData00Reg(&(client->io), ValuePtr);
return Ret;
}
static int comp_bcam_a1aaaaaaaaaaaaaaaabaaaaaaaaaaaa3aaacompbcamstats(comp_cam_a1aaat* client)
{
int rc;
rc = XLNX_COMP_BCAM_GetCompBcamBaseNumberPassesNumberPasses(&(client->io), &(client->stats.num_passes));
if (rc == XLNX_OK)
{
rc = comp_bcam_a1aaaaaaaaaaaaaaaabaaaaaaaaaaaa3aaacompbcaminsertcount(&(client->io), &(client->stats.num_inserts));
}
if (rc == XLNX_OK)
{
rc = comp_bcam_a1aaaaaaaaaaaaaaaabaaaaaaaaaaaa3aaacompbcamupdatecount(&(client->io), &(client->stats.num_updates));
}
if (rc == XLNX_OK)
{
rc = comp_bcam_a1aaaaaaaaaaaaaaaabaaaaaaaaaaaa3aaacompbcamdeletecount(&(client->io), &(client->stats.num_deletes));
}
if (rc == XLNX_OK)
{
rc = comp_bcam_a1aaaaaaaaaaaaaaaabaaaaaaaaaaaa3aaacompbcamgetbykeycount(&(client->io), &(client->stats.get_by_key));
}
if (rc == XLNX_OK)
{
rc = comp_bcam_a1aaaaaaaaaaaaaaaabaaaaaaaaaaaa3aaacompbcambaselookupcount(&(client->io), &(client->stats.num_lookups));
}
if (rc == XLNX_OK)
{
rc = comp_bcam_a1aaaaaaaaaaaaaaaabaaaaaaaaaaaa3aaacompbcambasehitcount(&(client->io), &(client->stats.hit_count));
}
if (rc == XLNX_OK)
{
rc = XLNX_COMP_BCAM_GetCompBcamBaseSbiterrCountReg(&(client->io), &(client->stats.sbiterr_count));
}
if (rc == XLNX_OK)
{
rc = XLNX_COMP_BCAM_GetCompBcamBaseDbiterrCountReg(&(client->io), &(client->stats.dbiterr_count));
}
if (rc == XLNX_OK)
{
rc = comp_bcam_a1aaaaaaaaaaaaaaaabaaaaaaaaaaaa3aaacompbcambaseexteventcount(&(client->io), &(client->stats.ext_event_count));
}
if (rc == XLNX_OK)
{
rc = comp_bcam_a1aaaaaaaaaaaaaaaabaaaaaaaaaaaa3aaacompbcambaselireqwscount(&(client->io), &(client->stats.li_req_ws_count));
}
if (rc == XLNX_OK)
{
rc = XLNX_COMP_BCAM_SetCompBcamBaseFreezeCountersOperationReg(&(client->io), ( uint32_t) 1);
}
if (rc == XLNX_OK)
{
rc = comp_bcam_a1aaaaaaaaaaaaaaaabaaaaaaaaaaaa3aaacompbcambasetotalnumpassescount(&(client->io), &(client->stats.total_num_passes));
}
if (rc == XLNX_OK)
{
rc = XLNX_COMP_BCAM_GetCompBcamBaseLastDetNumPassesLastDetNumPasses(&(client->io), &(client->stats.last_det_num_passes));
}
if (rc == XLNX_OK)
{
rc = XLNX_COMP_BCAM_GetCompBcamBaseMaxDetNumPassesMaxDetNumPasses(&(client->io), &(client->stats.max_det_num_passes));
}
if (rc == XLNX_OK)
{
XLNX_COMP_BCAM_SetCompBcamBaseFreezeCountersOperationReg(&(client->io), ( uint32_t) 0);
}
return rc;
}
static int comp_bcam_a1aaaaaaaaaaaaaaaabaaaaaaaaaaaa3aaacompbcaminsertcount(XLNX_COMP_BCAM_CONTEXT_TYPE* ContextPtr, XLNX_COMP_BCAM_COUNT* countPtr)
{
uint32_t rc = 0;
rc = XLNX_COMP_BCAM_GetCompBcamBaseInsertCountInsertCount(ContextPtr, &(countPtr->count));
if (rc == XLNX_OK)
{
rc = XLNX_COMP_BCAM_GetCompBcamBaseInsertCountTimerCount(ContextPtr, &(countPtr->timestamp));
}
return rc;
}
static int comp_bcam_a1aaaaaaaaaaaaaaaabaaaaaaaaaaaa3aaacompbcamupdatecount(XLNX_COMP_BCAM_CONTEXT_TYPE* ContextPtr, XLNX_COMP_BCAM_COUNT* countPtr)
{
uint32_t rc = 0;
rc = XLNX_COMP_BCAM_GetCompBcamBaseUpdateCountUpdateCount(ContextPtr, &(countPtr->count));
if (rc == XLNX_OK)
{
rc = XLNX_COMP_BCAM_GetCompBcamBaseUpdateCountTimerCount(ContextPtr, &(countPtr->timestamp));
}
return rc;
}
static int comp_bcam_a1aaaaaaaaaaaaaaaabaaaaaaaaaaaa3aaacompbcamdeletecount(XLNX_COMP_BCAM_CONTEXT_TYPE* ContextPtr, XLNX_COMP_BCAM_COUNT* countPtr)
{
uint32_t rc = 0;
rc = XLNX_COMP_BCAM_GetCompBcamBaseDeleteCountDeleteCount(ContextPtr, &(countPtr->count));
if (rc == XLNX_OK)
{
rc = XLNX_COMP_BCAM_GetCompBcamBaseDeleteCountTimerCount(ContextPtr, &(countPtr->timestamp));
}
return rc;
}
static int comp_bcam_a1aaaaaaaaaaaaaaaabaaaaaaaaaaaa3aaacompbcamgetbykeycount(XLNX_COMP_BCAM_CONTEXT_TYPE* ContextPtr, XLNX_COMP_BCAM_COUNT* countPtr)
{
uint32_t rc = 0;
rc = XLNX_COMP_BCAM_GetCompBcamBaseGetbykeyCountGetbykeyCount(ContextPtr, &(countPtr->count));
if (rc == XLNX_OK)
{
rc = XLNX_COMP_BCAM_GetCompBcamBaseGetbykeyCountTimerCount(ContextPtr, &(countPtr->timestamp));
}
return rc;
}
static int comp_bcam_a1aaaaaaaaaaaaaaaabaaaaaaaaaaaa3aaacompbcambaselookupcount(XLNX_COMP_BCAM_CONTEXT_TYPE* ContextPtr, XLNX_COMP_BCAM_COUNT* countPtr)
{
uint32_t rc = 0;
rc = XLNX_COMP_BCAM_GetCompBcamBaseLookupCountLookupCount(ContextPtr, &(countPtr->count));
if (rc == XLNX_OK)
{
rc = XLNX_COMP_BCAM_GetCompBcamBaseLookupCountTimerCount(ContextPtr, &(countPtr->timestamp));
}
return rc;
}
static int comp_bcam_a1aaaaaaaaaaaaaaaabaaaaaaaaaaaa3aaacompbcambasehitcount(XLNX_COMP_BCAM_CONTEXT_TYPE* ContextPtr, XLNX_COMP_BCAM_COUNT* countPtr)
{
uint32_t rc = 0;
rc = XLNX_COMP_BCAM_GetCompBcamBaseHitCountHitCount(ContextPtr, &(countPtr->count));
if (rc == XLNX_OK)
{
rc = XLNX_COMP_BCAM_GetCompBcamBaseHitCountTimerCount(ContextPtr, &(countPtr->timestamp));
}
return rc;
}
static int comp_bcam_a1aaaaaaaaaaaaaaaabaaaaaaaaaaaa3aaacompbcambaseexteventcount(XLNX_COMP_BCAM_CONTEXT_TYPE* ContextPtr, XLNX_COMP_BCAM_COUNT* countPtr)
{
uint32_t rc = 0;
rc = XLNX_COMP_BCAM_GetCompBcamBaseExtEventCountExtEventCount(ContextPtr, &(countPtr->count));
if (rc == XLNX_OK)
{
rc = XLNX_COMP_BCAM_GetCompBcamBaseExtEventCountTimerCount(ContextPtr, &(countPtr->timestamp));
}
return rc;
}
static int comp_bcam_a1aaaaaaaaaaaaaaaabaaaaaaaaaaaa3aaacompbcambaselireqwscount(XLNX_COMP_BCAM_CONTEXT_TYPE* ContextPtr, XLNX_COMP_BCAM_COUNT* countPtr)
{
uint32_t rc = 0;
rc = XLNX_COMP_BCAM_GetCompBcamBaseLiReqWsCountLiReqWsCount(ContextPtr, &(countPtr->count));
if (rc == XLNX_OK)
{
rc = XLNX_COMP_BCAM_GetCompBcamBaseLiReqWsCountTimerCount(ContextPtr, &(countPtr->timestamp));
}
return rc;
}
static int comp_bcam_a1aaaaaaaaaaaaaaaabaaaaaaaaaaaa3aaacompbcambasetotalnumpassescount(XLNX_COMP_BCAM_CONTEXT_TYPE* ContextPtr, uint64_t* countPtr)
{
uint32_t rc = 0, hi_count, lo_count;
rc = XLNX_COMP_BCAM_GetCompBcamBaseTotalNumPassesHiReg(ContextPtr, &hi_count);
if (rc == XLNX_OK)
{
rc = XLNX_COMP_BCAM_GetCompBcamBaseTotalNumPassesLoReg(ContextPtr, &lo_count);
}
if (rc == XLNX_OK)
{
comp_bcam_get_the_count(hi_count, lo_count, countPtr);
}
return rc;
}
static inline void comp_bcam_get_the_count(uint32_t hi_count, uint32_t lo_count, uint64_t* countPtr)
{
*countPtr = (( uint64_t) hi_count << SHIFT32BIT) + ( uint64_t) lo_count;
}
static int comp_bcam_a1aaaaaaaaaaaaaaaabaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaa3aaastats(comp_cam_a1aaat* client)
{ 
char message[100]; 
   sprintf(message, "comp bcam stats ");
comp_bcam_a1aaaaaaaaaaaaaaaabaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaa3aaaaaaaaaaaaaaaabaaaaaaaaaaaaaaaaaaaaaaaaaaaa4aaainfo(client, message); 
   sprintf(message, "num_inserts  count = %" PRIu32  " timestamp = %" PRIu32  "", client->stats.num_inserts.count, client->stats.num_inserts.timestamp);
comp_bcam_a1aaaaaaaaaaaaaaaabaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaa3aaaaaaaaaaaaaaaabaaaaaaaaaaaaaaaaaaaaaaaaaaaa4aaainfo(client, message);
   sprintf(message, "num_updates count = %" PRIu32  " timestamp = %" PRIu32  "", client->stats.num_updates.count, client->stats.num_updates.timestamp);
comp_bcam_a1aaaaaaaaaaaaaaaabaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaa3aaaaaaaaaaaaaaaabaaaaaaaaaaaaaaaaaaaaaaaaaaaa4aaainfo(client, message);
   sprintf(message, "num_deletes count = %" PRIu32  " timestamp = %" PRIu32  "", client->stats.num_deletes.count, client->stats.num_deletes.timestamp);
comp_bcam_a1aaaaaaaaaaaaaaaabaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaa3aaaaaaaaaaaaaaaabaaaaaaaaaaaaaaaaaaaaaaaaaaaa4aaainfo(client, message);
   sprintf(message, "num_lookups count = %" PRIu32  " timestamp = %" PRIu32  "", client->stats.num_lookups.count, client->stats.num_lookups.timestamp);
comp_bcam_a1aaaaaaaaaaaaaaaabaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaa3aaaaaaaaaaaaaaaabaaaaaaaaaaaaaaaaaaaaaaaaaaaa4aaainfo(client, message);
   sprintf(message, "hit_count count = %" PRIu32  " timestamp = %" PRIu32  "", client->stats.hit_count.count, client->stats.hit_count.timestamp);
comp_bcam_a1aaaaaaaaaaaaaaaabaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaa3aaaaaaaaaaaaaaaabaaaaaaaaaaaaaaaaaaaaaaaaaaaa4aaainfo(client, message);
   sprintf(message, "ext_event_count count = %" PRIu32  " timestamp = %" PRIu32  "", client->stats.ext_event_count.count, client->stats.ext_event_count.timestamp);
comp_bcam_a1aaaaaaaaaaaaaaaabaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaa3aaaaaaaaaaaaaaaabaaaaaaaaaaaaaaaaaaaaaaaaaaaa4aaainfo(client, message);
   sprintf(message, "li_req_ws_count count = %" PRIu32  " timestamp = %" PRIu32  "", client->stats.li_req_ws_count.count, client->stats.li_req_ws_count.timestamp);
comp_bcam_a1aaaaaaaaaaaaaaaabaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaa3aaaaaaaaaaaaaaaabaaaaaaaaaaaaaaaaaaaaaaaaaaaa4aaainfo(client, message);
   sprintf(message, "get_by_key count = %" PRIu32  " timestamp = %" PRIu32  "", client->stats.get_by_key.count, client->stats.get_by_key.timestamp);
comp_bcam_a1aaaaaaaaaaaaaaaabaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaa3aaaaaaaaaaaaaaaabaaaaaaaaaaaaaaaaaaaaaaaaaaaa4aaainfo(client, message);
   sprintf(message, "sbiterr_count count = %" PRIu32  "", client->stats.sbiterr_count);
comp_bcam_a1aaaaaaaaaaaaaaaabaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaa3aaaaaaaaaaaaaaaabaaaaaaaaaaaaaaaaaaaaaaaaaaaa4aaainfo(client, message);
   sprintf(message, "dbiterr_count count = %" PRIu32  "", client->stats.dbiterr_count);
comp_bcam_a1aaaaaaaaaaaaaaaabaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaa3aaaaaaaaaaaaaaaabaaaaaaaaaaaaaaaaaaaaaaaaaaaa4aaainfo(client, message);
   sprintf(message, "last_det_num_passes count = %" PRIu32  "", client->stats.last_det_num_passes);
comp_bcam_a1aaaaaaaaaaaaaaaabaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaa3aaaaaaaaaaaaaaaabaaaaaaaaaaaaaaaaaaaaaaaaaaaa4aaainfo(client, message);
   sprintf(message, "max_det_num_passes count = %" PRIu32  "", client->stats.max_det_num_passes);
comp_bcam_a1aaaaaaaaaaaaaaaabaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaa3aaaaaaaaaaaaaaaabaaaaaaaaaaaaaaaaaaaaaaaaaaaa4aaainfo(client, message);
   sprintf(message, "total_num_passes count =  %" PRIu64  "", client->stats.total_num_passes);
comp_bcam_a1aaaaaaaaaaaaaaaabaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaa3aaaaaaaaaaaaaaaabaaaaaaaaaaaaaaaaaaaaaaaaaaaa4aaainfo(client, message);
return 0;
}
#ifndef XOR0_H
#define XOR0_H
#define XOR0(INST) {\
INST[1][0] = INST[0][1] ^ INST[0][14] ^ INST[0][31];\
INST[1][1] = INST[0][14] ^ INST[0][112];\
INST[1][2] = INST[0][112] ^ INST[0][31];\
INST[1][3] = INST[0][31] ^ INST[0][137];\
INST[1][4] = INST[0][137] ^ INST[0][86];\
INST[1][5] = INST[0][86] ^ INST[0][100];\
INST[1][6] = INST[0][100] ^ INST[0][109];\
INST[1][7] = INST[0][109] ^ INST[0][103];\
INST[1][8] = INST[0][103] ^ INST[0][84];\
INST[1][9] = INST[0][84] ^ INST[0][42];\
INST[1][10] = INST[0][42] ^ INST[0][131];\
INST[1][11] = INST[0][131] ^ INST[0][141];\
INST[1][12] = INST[0][141] ^ INST[0][16];\
INST[1][13] = INST[0][16] ^ INST[0][2];\
INST[1][14] = INST[0][2] ^ INST[0][89];\
INST[1][15] = INST[0][89] ^ INST[0][76];\
INST[1][16] = INST[0][76] ^ INST[0][69];\
INST[1][17] = INST[0][69] ^ INST[0][101];\
INST[1][18] = INST[0][101] ^ INST[0][46];\
INST[1][19] = INST[0][46] ^ INST[0][126];\
INST[1][20] = INST[0][126] ^ INST[0][33];\
INST[1][21] = INST[0][33] ^ INST[0][110];\
INST[1][22] = INST[0][110] ^ INST[0][25];\
INST[1][23] = INST[0][25] ^ INST[0][133];\
INST[1][24] = INST[0][133] ^ INST[0][93];\
INST[1][25] = INST[0][93] ^ INST[0][117];\
INST[1][26] = INST[0][117] ^ INST[0][91];\
INST[1][27] = INST[0][91] ^ INST[0][50];\
INST[1][28] = INST[0][50] ^ INST[0][5];\
INST[1][29] = INST[0][5] ^ INST[0][71];\
INST[1][30] = INST[0][71] ^ INST[0][61];\
INST[1][31] = INST[0][61] ^ INST[0][95];\
INST[1][32] = INST[0][95] ^ INST[0][124];\
INST[1][33] = INST[0][124] ^ INST[0][102];\
INST[1][34] = INST[0][102] ^ INST[0][3];\
INST[1][35] = INST[0][3] ^ INST[0][29];\
INST[1][36] = INST[0][29] ^ INST[0][116];\
INST[1][37] = INST[0][116] ^ INST[0][162];\
INST[1][38] = INST[0][162] ^ INST[0][44];\
INST[1][39] = INST[0][44] ^ INST[0][70];\
INST[1][40] = INST[0][70] ^ INST[0][35];\
INST[1][41] = INST[0][35] ^ INST[0][159];\
INST[1][42] = INST[0][159] ^ INST[0][129];\
INST[1][43] = INST[0][129] ^ INST[0][57];\
INST[1][44] = INST[0][57] ^ INST[0][127];\
INST[1][45] = INST[0][127] ^ INST[0][24];\
INST[1][46] = INST[0][24] ^ INST[0][132];\
INST[1][47] = INST[0][132] ^ INST[0][58];\
INST[1][48] = INST[0][58] ^ INST[0][62];\
INST[1][49] = INST[0][62] ^ INST[0][147];\
INST[1][50] = INST[0][147] ^ INST[0][149];\
INST[1][51] = INST[0][149] ^ INST[0][99];\
INST[1][52] = INST[0][99] ^ INST[0][138];\
INST[1][53] = INST[0][138] ^ INST[0][64];\
INST[1][54] = INST[0][64] ^ INST[0][0];\
INST[1][55] = INST[0][0] ^ INST[0][96];\
INST[1][56] = INST[0][96] ^ INST[0][163];\
INST[1][57] = INST[0][163] ^ INST[0][6];\
INST[1][58] = INST[0][6] ^ INST[0][155];\
INST[1][59] = INST[0][155] ^ INST[0][136];\
INST[1][60] = INST[0][136] ^ INST[0][144];\
INST[1][61] = INST[0][144] ^ INST[0][40];\
INST[1][62] = INST[0][40] ^ INST[0][11];\
INST[1][63] = INST[0][11] ^ INST[0][152];\
INST[1][64] = INST[0][152] ^ INST[0][39];\
INST[1][65] = INST[0][39] ^ INST[0][13];\
INST[1][66] = INST[0][13] ^ INST[0][140];\
INST[1][67] = INST[0][140] ^ INST[0][75];\
INST[1][68] = INST[0][75] ^ INST[0][139];\
INST[1][69] = INST[0][139] ^ INST[0][142];\
INST[1][70] = INST[0][142] ^ INST[0][111];\
INST[1][71] = INST[0][111] ^ INST[0][167];\
INST[1][72] = INST[0][167] ^ INST[0][122];\
INST[1][73] = INST[0][122] ^ INST[0][87];\
INST[1][74] = INST[0][87] ^ INST[0][156];\
INST[1][75] = INST[0][156] ^ INST[0][37];\
INST[1][76] = INST[0][37] ^ INST[0][114];\
INST[1][77] = INST[0][114] ^ INST[0][107];\
INST[1][78] = INST[0][107] ^ INST[0][97];\
INST[1][79] = INST[0][97] ^ INST[0][74];\
INST[1][80] = INST[0][74] ^ INST[0][165];\
INST[1][81] = INST[0][165] ^ INST[0][145];\
INST[1][82] = INST[0][145] ^ INST[0][78];\
INST[1][83] = INST[0][78] ^ INST[0][34];\
INST[1][84] = INST[0][34] ^ INST[0][65];\
INST[1][85] = INST[0][65] ^ INST[0][83];\
INST[1][86] = INST[0][83] ^ INST[0][166];\
INST[1][87] = INST[0][166] ^ INST[0][7];\
INST[1][88] = INST[0][7] ^ INST[0][72];\
INST[1][89] = INST[0][72] ^ INST[0][134];\
INST[1][90] = INST[0][134] ^ INST[0][43];\
INST[1][91] = INST[0][43] ^ INST[0][118];\
INST[1][92] = INST[0][118] ^ INST[0][15];\
INST[1][93] = INST[0][15] ^ INST[0][146];\
INST[1][94] = INST[0][146] ^ INST[0][23];\
INST[1][95] = INST[0][23] ^ INST[0][4];\
INST[1][96] = INST[0][4] ^ INST[0][9];\
INST[1][97] = INST[0][9] ^ INST[0][121];\
INST[1][98] = INST[0][121] ^ INST[0][108];\
INST[1][99] = INST[0][108] ^ INST[0][130];\
INST[1][100] = INST[0][130] ^ INST[0][135];\
INST[1][101] = INST[0][135] ^ INST[0][68];\
INST[1][102] = INST[0][68] ^ INST[0][32];\
INST[1][103] = INST[0][32] ^ INST[0][88];\
INST[1][104] = INST[0][88] ^ INST[0][157];\
INST[1][105] = INST[0][157] ^ INST[0][80];\
INST[1][106] = INST[0][80] ^ INST[0][38];\
INST[1][107] = INST[0][38] ^ INST[0][164];\
INST[1][108] = INST[0][164] ^ INST[0][98];\
INST[1][109] = INST[0][98] ^ INST[0][18];\
INST[1][110] = INST[0][18] ^ INST[0][53];\
INST[1][111] = INST[0][53] ^ INST[0][20];\
INST[1][112] = INST[0][20] ^ INST[0][151];\
INST[1][113] = INST[0][151] ^ INST[0][41];\
INST[1][114] = INST[0][41] ^ INST[0][82];\
INST[1][115] = INST[0][82] ^ INST[0][63];\
INST[1][116] = INST[0][63] ^ INST[0][161];\
INST[1][117] = INST[0][161] ^ INST[0][94];\
INST[1][118] = INST[0][94] ^ INST[0][26];\
INST[1][119] = INST[0][26] ^ INST[0][10];\
INST[1][120] = INST[0][10] ^ INST[0][104];\
INST[1][121] = INST[0][104] ^ INST[0][115];\
INST[1][122] = INST[0][115] ^ INST[0][54];\
INST[1][123] = INST[0][54] ^ INST[0][56];\
INST[1][124] = INST[0][56] ^ INST[0][105];\
INST[1][125] = INST[0][105] ^ INST[0][22];\
INST[1][126] = INST[0][22] ^ INST[0][30];\
INST[1][127] = INST[0][30] ^ INST[0][119];\
INST[1][128] = INST[0][119] ^ INST[0][73];\
INST[1][129] = INST[0][73] ^ INST[0][150];\
INST[1][130] = INST[0][150] ^ INST[0][66];\
INST[1][131] = INST[0][66] ^ INST[0][128];\
INST[1][132] = INST[0][128] ^ INST[0][77];\
INST[1][133] = INST[0][77] ^ INST[0][125];\
INST[1][134] = INST[0][125] ^ INST[0][79];\
INST[1][135] = INST[0][79] ^ INST[0][85];\
INST[1][136] = INST[0][85] ^ INST[0][123];\
INST[1][137] = INST[0][123] ^ INST[0][19];\
INST[1][138] = INST[0][19] ^ INST[0][148];\
INST[1][139] = INST[0][148] ^ INST[0][143];\
INST[1][140] = INST[0][143] ^ INST[0][67];\
INST[1][141] = INST[0][67] ^ INST[0][59];\
INST[1][142] = INST[0][59] ^ INST[0][106];\
INST[1][143] = INST[0][106] ^ INST[0][92];\
INST[1][144] = INST[0][92] ^ INST[0][120];\
INST[1][145] = INST[0][120] ^ INST[0][154];\
INST[1][146] = INST[0][154] ^ INST[0][28];\
INST[1][147] = INST[0][28] ^ INST[0][55];\
INST[1][148] = INST[0][55] ^ INST[0][90];\
INST[1][149] = INST[0][90] ^ INST[0][81];\
INST[1][150] = INST[0][81] ^ INST[0][12];\
INST[1][151] = INST[0][12] ^ INST[0][45];\
INST[1][152] = INST[0][45] ^ INST[0][52];\
INST[1][153] = INST[0][52] ^ INST[0][60];\
INST[1][154] = INST[0][60] ^ INST[0][160];\
INST[1][155] = INST[0][160] ^ INST[0][158];\
INST[1][156] = INST[0][158] ^ INST[0][113];\
INST[1][157] = INST[0][113] ^ INST[0][17];\
INST[1][158] = INST[0][17] ^ INST[0][153];\
INST[1][159] = INST[0][153] ^ INST[0][36];\
INST[1][160] = INST[0][36] ^ INST[0][21];\
INST[1][161] = INST[0][21] ^ INST[0][49];\
INST[1][162] = INST[0][49] ^ INST[0][51];\
INST[1][163] = INST[0][51] ^ INST[0][27];\
INST[1][164] = INST[0][27] ^ INST[0][8];\
INST[1][165] = INST[0][8] ^ INST[0][47];\
INST[1][166] = INST[0][47] ^ INST[0][48];\
INST[1][167] = INST[0][48] ^ INST[0][1];\
}
#endif
#ifndef XOR1_H
#define XOR1_H
#define XOR1(INST) {\
INST[0][0] = INST[1][106] ^ INST[1][32] ^ INST[1][73];\
INST[0][1] = INST[1][32] ^ INST[1][5];\
INST[0][2] = INST[1][5] ^ INST[1][73];\
INST[0][3] = INST[1][73] ^ INST[1][123];\
INST[0][4] = INST[1][123] ^ INST[1][63];\
INST[0][5] = INST[1][63] ^ INST[1][36];\
INST[0][6] = INST[1][36] ^ INST[1][125];\
INST[0][7] = INST[1][125] ^ INST[1][35];\
INST[0][8] = INST[1][35] ^ INST[1][167];\
INST[0][9] = INST[1][167] ^ INST[1][117];\
INST[0][10] = INST[1][117] ^ INST[1][137];\
INST[0][11] = INST[1][137] ^ INST[1][48];\
INST[0][12] = INST[1][48] ^ INST[1][2];\
INST[0][13] = INST[1][2] ^ INST[1][24];\
INST[0][14] = INST[1][24] ^ INST[1][135];\
INST[0][15] = INST[1][135] ^ INST[1][152];\
INST[0][16] = INST[1][152] ^ INST[1][74];\
INST[0][17] = INST[1][74] ^ INST[1][147];\
INST[0][18] = INST[1][147] ^ INST[1][38];\
INST[0][19] = INST[1][38] ^ INST[1][139];\
INST[0][20] = INST[1][139] ^ INST[1][21];\
INST[0][21] = INST[1][21] ^ INST[1][52];\
INST[0][22] = INST[1][52] ^ INST[1][44];\
INST[0][23] = INST[1][44] ^ INST[1][102];\
INST[0][24] = INST[1][102] ^ INST[1][87];\
INST[0][25] = INST[1][87] ^ INST[1][114];\
INST[0][26] = INST[1][114] ^ INST[1][93];\
INST[0][27] = INST[1][93] ^ INST[1][105];\
INST[0][28] = INST[1][105] ^ INST[1][66];\
INST[0][29] = INST[1][66] ^ INST[1][146];\
INST[0][30] = INST[1][146] ^ INST[1][17];\
INST[0][31] = INST[1][17] ^ INST[1][77];\
INST[0][32] = INST[1][77] ^ INST[1][165];\
INST[0][33] = INST[1][165] ^ INST[1][142];\
INST[0][34] = INST[1][142] ^ INST[1][109];\
INST[0][35] = INST[1][109] ^ INST[1][157];\
INST[0][36] = INST[1][157] ^ INST[1][94];\
INST[0][37] = INST[1][94] ^ INST[1][60];\
INST[0][38] = INST[1][60] ^ INST[1][31];\
INST[0][39] = INST[1][31] ^ INST[1][161];\
INST[0][40] = INST[1][161] ^ INST[1][127];\
INST[0][41] = INST[1][127] ^ INST[1][86];\
INST[0][42] = INST[1][86] ^ INST[1][79];\
INST[0][43] = INST[1][79] ^ INST[1][37];\
INST[0][44] = INST[1][37] ^ INST[1][88];\
INST[0][45] = INST[1][88] ^ INST[1][26];\
INST[0][46] = INST[1][26] ^ INST[1][148];\
INST[0][47] = INST[1][148] ^ INST[1][129];\
INST[0][48] = INST[1][129] ^ INST[1][11];\
INST[0][49] = INST[1][11] ^ INST[1][150];\
INST[0][50] = INST[1][150] ^ INST[1][104];\
INST[0][51] = INST[1][104] ^ INST[1][99];\
INST[0][52] = INST[1][99] ^ INST[1][13];\
INST[0][53] = INST[1][13] ^ INST[1][78];\
INST[0][54] = INST[1][78] ^ INST[1][50];\
INST[0][55] = INST[1][50] ^ INST[1][72];\
INST[0][56] = INST[1][72] ^ INST[1][3];\
INST[0][57] = INST[1][3] ^ INST[1][47];\
INST[0][58] = INST[1][47] ^ INST[1][144];\
INST[0][59] = INST[1][144] ^ INST[1][64];\
INST[0][60] = INST[1][64] ^ INST[1][62];\
INST[0][61] = INST[1][62] ^ INST[1][163];\
INST[0][62] = INST[1][163] ^ INST[1][61];\
INST[0][63] = INST[1][61] ^ INST[1][56];\
INST[0][64] = INST[1][56] ^ INST[1][65];\
INST[0][65] = INST[1][65] ^ INST[1][59];\
INST[0][66] = INST[1][59] ^ INST[1][97];\
INST[0][67] = INST[1][97] ^ INST[1][128];\
INST[0][68] = INST[1][128] ^ INST[1][95];\
INST[0][69] = INST[1][95] ^ INST[1][70];\
INST[0][70] = INST[1][70] ^ INST[1][113];\
INST[0][71] = INST[1][113] ^ INST[1][98];\
INST[0][72] = INST[1][98] ^ INST[1][6];\
INST[0][73] = INST[1][6] ^ INST[1][141];\
INST[0][74] = INST[1][141] ^ INST[1][89];\
INST[0][75] = INST[1][89] ^ INST[1][156];\
INST[0][76] = INST[1][156] ^ INST[1][76];\
INST[0][77] = INST[1][76] ^ INST[1][84];\
INST[0][78] = INST[1][84] ^ INST[1][69];\
INST[0][79] = INST[1][69] ^ INST[1][75];\
INST[0][80] = INST[1][75] ^ INST[1][29];\
INST[0][81] = INST[1][29] ^ INST[1][162];\
INST[0][82] = INST[1][162] ^ INST[1][0];\
INST[0][83] = INST[1][0] ^ INST[1][85];\
INST[0][84] = INST[1][85] ^ INST[1][7];\
INST[0][85] = INST[1][7] ^ INST[1][136];\
INST[0][86] = INST[1][136] ^ INST[1][16];\
INST[0][87] = INST[1][16] ^ INST[1][51];\
INST[0][88] = INST[1][51] ^ INST[1][122];\
INST[0][89] = INST[1][122] ^ INST[1][92];\
INST[0][90] = INST[1][92] ^ INST[1][153];\
INST[0][91] = INST[1][153] ^ INST[1][124];\
INST[0][92] = INST[1][124] ^ INST[1][9];\
INST[0][93] = INST[1][9] ^ INST[1][8];\
INST[0][94] = INST[1][8] ^ INST[1][10];\
INST[0][95] = INST[1][10] ^ INST[1][96];\
INST[0][96] = INST[1][96] ^ INST[1][138];\
INST[0][97] = INST[1][138] ^ INST[1][166];\
INST[0][98] = INST[1][166] ^ INST[1][159];\
INST[0][99] = INST[1][159] ^ INST[1][118];\
INST[0][100] = INST[1][118] ^ INST[1][115];\
INST[0][101] = INST[1][115] ^ INST[1][160];\
INST[0][102] = INST[1][160] ^ INST[1][34];\
INST[0][103] = INST[1][34] ^ INST[1][28];\
INST[0][104] = INST[1][28] ^ INST[1][131];\
INST[0][105] = INST[1][131] ^ INST[1][145];\
INST[0][106] = INST[1][145] ^ INST[1][140];\
INST[0][107] = INST[1][140] ^ INST[1][71];\
INST[0][108] = INST[1][71] ^ INST[1][68];\
INST[0][109] = INST[1][68] ^ INST[1][158];\
INST[0][110] = INST[1][158] ^ INST[1][121];\
INST[0][111] = INST[1][121] ^ INST[1][90];\
INST[0][112] = INST[1][90] ^ INST[1][46];\
INST[0][113] = INST[1][46] ^ INST[1][81];\
INST[0][114] = INST[1][81] ^ INST[1][110];\
INST[0][115] = INST[1][110] ^ INST[1][33];\
INST[0][116] = INST[1][33] ^ INST[1][82];\
INST[0][117] = INST[1][82] ^ INST[1][58];\
INST[0][118] = INST[1][58] ^ INST[1][120];\
INST[0][119] = INST[1][120] ^ INST[1][112];\
INST[0][120] = INST[1][112] ^ INST[1][15];\
INST[0][121] = INST[1][15] ^ INST[1][23];\
INST[0][122] = INST[1][23] ^ INST[1][100];\
INST[0][123] = INST[1][100] ^ INST[1][103];\
INST[0][124] = INST[1][103] ^ INST[1][22];\
INST[0][125] = INST[1][22] ^ INST[1][155];\
INST[0][126] = INST[1][155] ^ INST[1][164];\
INST[0][127] = INST[1][164] ^ INST[1][132];\
INST[0][128] = INST[1][132] ^ INST[1][83];\
INST[0][129] = INST[1][83] ^ INST[1][108];\
INST[0][130] = INST[1][108] ^ INST[1][43];\
INST[0][131] = INST[1][43] ^ INST[1][80];\
INST[0][132] = INST[1][80] ^ INST[1][154];\
INST[0][133] = INST[1][154] ^ INST[1][107];\
INST[0][134] = INST[1][107] ^ INST[1][126];\
INST[0][135] = INST[1][126] ^ INST[1][133];\
INST[0][136] = INST[1][133] ^ INST[1][40];\
INST[0][137] = INST[1][40] ^ INST[1][45];\
INST[0][138] = INST[1][45] ^ INST[1][18];\
INST[0][139] = INST[1][18] ^ INST[1][130];\
INST[0][140] = INST[1][130] ^ INST[1][41];\
INST[0][141] = INST[1][41] ^ INST[1][39];\
INST[0][142] = INST[1][39] ^ INST[1][12];\
INST[0][143] = INST[1][12] ^ INST[1][25];\
INST[0][144] = INST[1][25] ^ INST[1][101];\
INST[0][145] = INST[1][101] ^ INST[1][19];\
INST[0][146] = INST[1][19] ^ INST[1][143];\
INST[0][147] = INST[1][143] ^ INST[1][14];\
INST[0][148] = INST[1][14] ^ INST[1][4];\
INST[0][149] = INST[1][4] ^ INST[1][134];\
INST[0][150] = INST[1][134] ^ INST[1][116];\
INST[0][151] = INST[1][116] ^ INST[1][67];\
INST[0][152] = INST[1][67] ^ INST[1][42];\
INST[0][153] = INST[1][42] ^ INST[1][57];\
INST[0][154] = INST[1][57] ^ INST[1][55];\
INST[0][155] = INST[1][55] ^ INST[1][149];\
INST[0][156] = INST[1][149] ^ INST[1][30];\
INST[0][157] = INST[1][30] ^ INST[1][53];\
INST[0][158] = INST[1][53] ^ INST[1][119];\
INST[0][159] = INST[1][119] ^ INST[1][20];\
INST[0][160] = INST[1][20] ^ INST[1][151];\
INST[0][161] = INST[1][151] ^ INST[1][1];\
INST[0][162] = INST[1][1] ^ INST[1][27];\
INST[0][163] = INST[1][27] ^ INST[1][91];\
INST[0][164] = INST[1][91] ^ INST[1][111];\
INST[0][165] = INST[1][111] ^ INST[1][49];\
INST[0][166] = INST[1][49] ^ INST[1][54];\
INST[0][167] = INST[1][54] ^ INST[1][106];\
}
#endif
#ifndef XOR2_H
#define XOR2_H
#define XOR2(INST) {\
INST[1][0] = INST[0][33] ^ INST[0][165] ^ INST[0][119];\
INST[1][1] = INST[0][165] ^ INST[0][77];\
INST[1][2] = INST[0][77] ^ INST[0][119];\
INST[1][3] = INST[0][119] ^ INST[0][111];\
INST[1][4] = INST[0][111] ^ INST[0][42];\
INST[1][5] = INST[0][42] ^ INST[0][139];\
INST[1][6] = INST[0][139] ^ INST[0][57];\
INST[1][7] = INST[0][57] ^ INST[0][20];\
INST[1][8] = INST[0][20] ^ INST[0][133];\
INST[1][9] = INST[0][133] ^ INST[0][154];\
INST[1][10] = INST[0][154] ^ INST[0][94];\
INST[1][11] = INST[0][94] ^ INST[0][81];\
INST[1][12] = INST[0][81] ^ INST[0][80];\
INST[1][13] = INST[0][80] ^ INST[0][62];\
INST[1][14] = INST[0][62] ^ INST[0][67];\
INST[1][15] = INST[0][67] ^ INST[0][157];\
INST[1][16] = INST[0][157] ^ INST[0][6];\
INST[1][17] = INST[0][6] ^ INST[0][44];\
INST[1][18] = INST[0][44] ^ INST[0][88];\
INST[1][19] = INST[0][88] ^ INST[0][74];\
INST[1][20] = INST[0][74] ^ INST[0][89];\
INST[1][21] = INST[0][89] ^ INST[0][72];\
INST[1][22] = INST[0][72] ^ INST[0][136];\
INST[1][23] = INST[0][136] ^ INST[0][53];\
INST[1][24] = INST[0][53] ^ INST[0][91];\
INST[1][25] = INST[0][91] ^ INST[0][130];\
INST[1][26] = INST[0][130] ^ INST[0][24];\
INST[1][27] = INST[0][24] ^ INST[0][117];\
INST[1][28] = INST[0][117] ^ INST[0][56];\
INST[1][29] = INST[0][56] ^ INST[0][76];\
INST[1][30] = INST[0][76] ^ INST[0][120];\
INST[1][31] = INST[0][120] ^ INST[0][84];\
INST[1][32] = INST[0][84] ^ INST[0][118];\
INST[1][33] = INST[0][118] ^ INST[0][54];\
INST[1][34] = INST[0][54] ^ INST[0][66];\
INST[1][35] = INST[0][66] ^ INST[0][51];\
INST[1][36] = INST[0][51] ^ INST[0][61];\
INST[1][37] = INST[0][61] ^ INST[0][55];\
INST[1][38] = INST[0][55] ^ INST[0][34];\
INST[1][39] = INST[0][34] ^ INST[0][129];\
INST[1][40] = INST[0][129] ^ INST[0][128];\
INST[1][41] = INST[0][128] ^ INST[0][1];\
INST[1][42] = INST[0][1] ^ INST[0][104];\
INST[1][43] = INST[0][104] ^ INST[0][22];\
INST[1][44] = INST[0][22] ^ INST[0][2];\
INST[1][45] = INST[0][2] ^ INST[0][71];\
INST[1][46] = INST[0][71] ^ INST[0][113];\
INST[1][47] = INST[0][113] ^ INST[0][87];\
INST[1][48] = INST[0][87] ^ INST[0][15];\
INST[1][49] = INST[0][15] ^ INST[0][110];\
INST[1][50] = INST[0][110] ^ INST[0][161];\
INST[1][51] = INST[0][161] ^ INST[0][90];\
INST[1][52] = INST[0][90] ^ INST[0][163];\
INST[1][53] = INST[0][163] ^ INST[0][26];\
INST[1][54] = INST[0][26] ^ INST[0][12];\
INST[1][55] = INST[0][12] ^ INST[0][142];\
INST[1][56] = INST[0][142] ^ INST[0][127];\
INST[1][57] = INST[0][127] ^ INST[0][45];\
INST[1][58] = INST[0][45] ^ INST[0][82];\
INST[1][59] = INST[0][82] ^ INST[0][112];\
INST[1][60] = INST[0][112] ^ INST[0][65];\
INST[1][61] = INST[0][65] ^ INST[0][92];\
INST[1][62] = INST[0][92] ^ INST[0][121];\
INST[1][63] = INST[0][121] ^ INST[0][11];\
INST[1][64] = INST[0][11] ^ INST[0][46];\
INST[1][65] = INST[0][46] ^ INST[0][85];\
INST[1][66] = INST[0][85] ^ INST[0][38];\
INST[1][67] = INST[0][38] ^ INST[0][50];\
INST[1][68] = INST[0][50] ^ INST[0][41];\
INST[1][69] = INST[0][41] ^ INST[0][78];\
INST[1][70] = INST[0][78] ^ INST[0][0];\
INST[1][71] = INST[0][0] ^ INST[0][100];\
INST[1][72] = INST[0][100] ^ INST[0][103];\
INST[1][73] = INST[0][103] ^ INST[0][4];\
INST[1][74] = INST[0][4] ^ INST[0][106];\
INST[1][75] = INST[0][106] ^ INST[0][107];\
INST[1][76] = INST[0][107] ^ INST[0][125];\
INST[1][77] = INST[0][125] ^ INST[0][14];\
INST[1][78] = INST[0][14] ^ INST[0][123];\
INST[1][79] = INST[0][123] ^ INST[0][52];\
INST[1][80] = INST[0][52] ^ INST[0][59];\
INST[1][81] = INST[0][59] ^ INST[0][108];\
INST[1][82] = INST[0][108] ^ INST[0][147];\
INST[1][83] = INST[0][147] ^ INST[0][105];\
INST[1][84] = INST[0][105] ^ INST[0][153];\
INST[1][85] = INST[0][153] ^ INST[0][18];\
INST[1][86] = INST[0][18] ^ INST[0][160];\
INST[1][87] = INST[0][160] ^ INST[0][109];\
INST[1][88] = INST[0][109] ^ INST[0][135];\
INST[1][89] = INST[0][135] ^ INST[0][68];\
INST[1][90] = INST[0][68] ^ INST[0][73];\
INST[1][91] = INST[0][73] ^ INST[0][36];\
INST[1][92] = INST[0][36] ^ INST[0][17];\
INST[1][93] = INST[0][17] ^ INST[0][138];\
INST[1][94] = INST[0][138] ^ INST[0][152];\
INST[1][95] = INST[0][152] ^ INST[0][27];\
INST[1][96] = INST[0][27] ^ INST[0][37];\
INST[1][97] = INST[0][37] ^ INST[0][97];\
INST[1][98] = INST[0][97] ^ INST[0][155];\
INST[1][99] = INST[0][155] ^ INST[0][95];\
INST[1][100] = INST[0][95] ^ INST[0][101];\
INST[1][101] = INST[0][101] ^ INST[0][124];\
INST[1][102] = INST[0][124] ^ INST[0][167];\
INST[1][103] = INST[0][167] ^ INST[0][23];\
INST[1][104] = INST[0][23] ^ INST[0][39];\
INST[1][105] = INST[0][39] ^ INST[0][131];\
INST[1][106] = INST[0][131] ^ INST[0][35];\
INST[1][107] = INST[0][35] ^ INST[0][144];\
INST[1][108] = INST[0][144] ^ INST[0][9];\
INST[1][109] = INST[0][9] ^ INST[0][60];\
INST[1][110] = INST[0][60] ^ INST[0][93];\
INST[1][111] = INST[0][93] ^ INST[0][49];\
INST[1][112] = INST[0][49] ^ INST[0][32];\
INST[1][113] = INST[0][32] ^ INST[0][151];\
INST[1][114] = INST[0][151] ^ INST[0][3];\
INST[1][115] = INST[0][3] ^ INST[0][43];\
INST[1][116] = INST[0][43] ^ INST[0][64];\
INST[1][117] = INST[0][64] ^ INST[0][102];\
INST[1][118] = INST[0][102] ^ INST[0][149];\
INST[1][119] = INST[0][149] ^ INST[0][140];\
INST[1][120] = INST[0][140] ^ INST[0][126];\
INST[1][121] = INST[0][126] ^ INST[0][115];\
INST[1][122] = INST[0][115] ^ INST[0][99];\
INST[1][123] = INST[0][99] ^ INST[0][83];\
INST[1][124] = INST[0][83] ^ INST[0][146];\
INST[1][125] = INST[0][146] ^ INST[0][69];\
INST[1][126] = INST[0][69] ^ INST[0][137];\
INST[1][127] = INST[0][137] ^ INST[0][145];\
INST[1][128] = INST[0][145] ^ INST[0][116];\
INST[1][129] = INST[0][116] ^ INST[0][29];\
INST[1][130] = INST[0][29] ^ INST[0][122];\
INST[1][131] = INST[0][122] ^ INST[0][25];\
INST[1][132] = INST[0][25] ^ INST[0][162];\
INST[1][133] = INST[0][162] ^ INST[0][28];\
INST[1][134] = INST[0][28] ^ INST[0][16];\
INST[1][135] = INST[0][16] ^ INST[0][98];\
INST[1][136] = INST[0][98] ^ INST[0][164];\
INST[1][137] = INST[0][164] ^ INST[0][70];\
INST[1][138] = INST[0][70] ^ INST[0][5];\
INST[1][139] = INST[0][5] ^ INST[0][48];\
INST[1][140] = INST[0][48] ^ INST[0][58];\
INST[1][141] = INST[0][58] ^ INST[0][141];\
INST[1][142] = INST[0][141] ^ INST[0][21];\
INST[1][143] = INST[0][21] ^ INST[0][30];\
INST[1][144] = INST[0][30] ^ INST[0][47];\
INST[1][145] = INST[0][47] ^ INST[0][19];\
INST[1][146] = INST[0][19] ^ INST[0][96];\
INST[1][147] = INST[0][96] ^ INST[0][143];\
INST[1][148] = INST[0][143] ^ INST[0][150];\
INST[1][149] = INST[0][150] ^ INST[0][31];\
INST[1][150] = INST[0][31] ^ INST[0][40];\
INST[1][151] = INST[0][40] ^ INST[0][79];\
INST[1][152] = INST[0][79] ^ INST[0][156];\
INST[1][153] = INST[0][156] ^ INST[0][75];\
INST[1][154] = INST[0][75] ^ INST[0][132];\
INST[1][155] = INST[0][132] ^ INST[0][148];\
INST[1][156] = INST[0][148] ^ INST[0][10];\
INST[1][157] = INST[0][10] ^ INST[0][7];\
INST[1][158] = INST[0][7] ^ INST[0][8];\
INST[1][159] = INST[0][8] ^ INST[0][134];\
INST[1][160] = INST[0][134] ^ INST[0][159];\
INST[1][161] = INST[0][159] ^ INST[0][114];\
INST[1][162] = INST[0][114] ^ INST[0][86];\
INST[1][163] = INST[0][86] ^ INST[0][63];\
INST[1][164] = INST[0][63] ^ INST[0][166];\
INST[1][165] = INST[0][166] ^ INST[0][13];\
INST[1][166] = INST[0][13] ^ INST[0][158];\
INST[1][167] = INST[0][158] ^ INST[0][33];\
}
#endif
#ifndef XOR3_H
#define XOR3_H
#define XOR3(INST) {\
INST[0][0] = INST[1][22] ^ INST[1][106] ^ INST[1][121];\
INST[0][1] = INST[1][106] ^ INST[1][14];\
INST[0][2] = INST[1][14] ^ INST[1][121];\
INST[0][3] = INST[1][121] ^ INST[1][135];\
INST[0][4] = INST[1][135] ^ INST[1][125];\
INST[0][5] = INST[1][125] ^ INST[1][122];\
INST[0][6] = INST[1][122] ^ INST[1][43];\
INST[0][7] = INST[1][43] ^ INST[1][148];\
INST[0][8] = INST[1][148] ^ INST[1][95];\
INST[0][9] = INST[1][95] ^ INST[1][115];\
INST[0][10] = INST[1][115] ^ INST[1][2];\
INST[0][11] = INST[1][2] ^ INST[1][25];\
INST[0][12] = INST[1][25] ^ INST[1][109];\
INST[0][13] = INST[1][109] ^ INST[1][139];\
INST[0][14] = INST[1][139] ^ INST[1][66];\
INST[0][15] = INST[1][66] ^ INST[1][147];\
INST[0][16] = INST[1][147] ^ INST[1][105];\
INST[0][17] = INST[1][105] ^ INST[1][70];\
INST[0][18] = INST[1][70] ^ INST[1][167];\
INST[0][19] = INST[1][167] ^ INST[1][119];\
INST[0][20] = INST[1][119] ^ INST[1][68];\
INST[0][21] = INST[1][68] ^ INST[1][4];\
INST[0][22] = INST[1][4] ^ INST[1][32];\
INST[0][23] = INST[1][32] ^ INST[1][64];\
INST[0][24] = INST[1][64] ^ INST[1][134];\
INST[0][25] = INST[1][134] ^ INST[1][133];\
INST[0][26] = INST[1][133] ^ INST[1][124];\
INST[0][27] = INST[1][124] ^ INST[1][8];\
INST[0][28] = INST[1][8] ^ INST[1][15];\
INST[0][29] = INST[1][15] ^ INST[1][76];\
INST[0][30] = INST[1][76] ^ INST[1][30];\
INST[0][31] = INST[1][30] ^ INST[1][151];\
INST[0][32] = INST[1][151] ^ INST[1][144];\
INST[0][33] = INST[1][144] ^ INST[1][131];\
INST[0][34] = INST[1][131] ^ INST[1][54];\
INST[0][35] = INST[1][54] ^ INST[1][145];\
INST[0][36] = INST[1][145] ^ INST[1][61];\
INST[0][37] = INST[1][61] ^ INST[1][6];\
INST[0][38] = INST[1][6] ^ INST[1][129];\
INST[0][39] = INST[1][129] ^ INST[1][16];\
INST[0][40] = INST[1][16] ^ INST[1][50];\
INST[0][41] = INST[1][50] ^ INST[1][9];\
INST[0][42] = INST[1][9] ^ INST[1][123];\
INST[0][43] = INST[1][123] ^ INST[1][11];\
INST[0][44] = INST[1][11] ^ INST[1][87];\
INST[0][45] = INST[1][87] ^ INST[1][28];\
INST[0][46] = INST[1][28] ^ INST[1][96];\
INST[0][47] = INST[1][96] ^ INST[1][18];\
INST[0][48] = INST[1][18] ^ INST[1][19];\
INST[0][49] = INST[1][19] ^ INST[1][31];\
INST[0][50] = INST[1][31] ^ INST[1][157];\
INST[0][51] = INST[1][157] ^ INST[1][63];\
INST[0][52] = INST[1][63] ^ INST[1][160];\
INST[0][53] = INST[1][160] ^ INST[1][117];\
INST[0][54] = INST[1][117] ^ INST[1][60];\
INST[0][55] = INST[1][60] ^ INST[1][150];\
INST[0][56] = INST[1][150] ^ INST[1][86];\
INST[0][57] = INST[1][86] ^ INST[1][146];\
INST[0][58] = INST[1][146] ^ INST[1][156];\
INST[0][59] = INST[1][156] ^ INST[1][45];\
INST[0][60] = INST[1][45] ^ INST[1][69];\
INST[0][61] = INST[1][69] ^ INST[1][97];\
INST[0][62] = INST[1][97] ^ INST[1][130];\
INST[0][63] = INST[1][130] ^ INST[1][159];\
INST[0][64] = INST[1][159] ^ INST[1][10];\
INST[0][65] = INST[1][10] ^ INST[1][103];\
INST[0][66] = INST[1][103] ^ INST[1][7];\
INST[0][67] = INST[1][7] ^ INST[1][161];\
INST[0][68] = INST[1][161] ^ INST[1][53];\
INST[0][69] = INST[1][53] ^ INST[1][38];\
INST[0][70] = INST[1][38] ^ INST[1][137];\
INST[0][71] = INST[1][137] ^ INST[1][55];\
INST[0][72] = INST[1][55] ^ INST[1][138];\
INST[0][73] = INST[1][138] ^ INST[1][33];\
INST[0][74] = INST[1][33] ^ INST[1][82];\
INST[0][75] = INST[1][82] ^ INST[1][126];\
INST[0][76] = INST[1][126] ^ INST[1][104];\
INST[0][77] = INST[1][104] ^ INST[1][37];\
INST[0][78] = INST[1][37] ^ INST[1][62];\
INST[0][79] = INST[1][62] ^ INST[1][59];\
INST[0][80] = INST[1][59] ^ INST[1][99];\
INST[0][81] = INST[1][99] ^ INST[1][149];\
INST[0][82] = INST[1][149] ^ INST[1][35];\
INST[0][83] = INST[1][35] ^ INST[1][24];\
INST[0][84] = INST[1][24] ^ INST[1][52];\
INST[0][85] = INST[1][52] ^ INST[1][116];\
INST[0][86] = INST[1][116] ^ INST[1][73];\
INST[0][87] = INST[1][73] ^ INST[1][127];\
INST[0][88] = INST[1][127] ^ INST[1][80];\
INST[0][89] = INST[1][80] ^ INST[1][0];\
INST[0][90] = INST[1][0] ^ INST[1][17];\
INST[0][91] = INST[1][17] ^ INST[1][158];\
INST[0][92] = INST[1][158] ^ INST[1][40];\
INST[0][93] = INST[1][40] ^ INST[1][20];\
INST[0][94] = INST[1][20] ^ INST[1][136];\
INST[0][95] = INST[1][136] ^ INST[1][132];\
INST[0][96] = INST[1][132] ^ INST[1][12];\
INST[0][97] = INST[1][12] ^ INST[1][39];\
INST[0][98] = INST[1][39] ^ INST[1][101];\
INST[0][99] = INST[1][101] ^ INST[1][163];\
INST[0][100] = INST[1][163] ^ INST[1][47];\
INST[0][101] = INST[1][47] ^ INST[1][23];\
INST[0][102] = INST[1][23] ^ INST[1][67];\
INST[0][103] = INST[1][67] ^ INST[1][34];\
INST[0][104] = INST[1][34] ^ INST[1][21];\
INST[0][105] = INST[1][21] ^ INST[1][111];\
INST[0][106] = INST[1][111] ^ INST[1][3];\
INST[0][107] = INST[1][3] ^ INST[1][5];\
INST[0][108] = INST[1][5] ^ INST[1][93];\
INST[0][109] = INST[1][93] ^ INST[1][110];\
INST[0][110] = INST[1][110] ^ INST[1][51];\
INST[0][111] = INST[1][51] ^ INST[1][107];\
INST[0][112] = INST[1][107] ^ INST[1][44];\
INST[0][113] = INST[1][44] ^ INST[1][58];\
INST[0][114] = INST[1][58] ^ INST[1][153];\
INST[0][115] = INST[1][153] ^ INST[1][74];\
INST[0][116] = INST[1][74] ^ INST[1][140];\
INST[0][117] = INST[1][140] ^ INST[1][108];\
INST[0][118] = INST[1][108] ^ INST[1][85];\
INST[0][119] = INST[1][85] ^ INST[1][162];\
INST[0][120] = INST[1][162] ^ INST[1][100];\
INST[0][121] = INST[1][100] ^ INST[1][81];\
INST[0][122] = INST[1][81] ^ INST[1][113];\
INST[0][123] = INST[1][113] ^ INST[1][75];\
INST[0][124] = INST[1][75] ^ INST[1][90];\
INST[0][125] = INST[1][90] ^ INST[1][88];\
INST[0][126] = INST[1][88] ^ INST[1][49];\
INST[0][127] = INST[1][49] ^ INST[1][165];\
INST[0][128] = INST[1][165] ^ INST[1][46];\
INST[0][129] = INST[1][46] ^ INST[1][79];\
INST[0][130] = INST[1][79] ^ INST[1][143];\
INST[0][131] = INST[1][143] ^ INST[1][1];\
INST[0][132] = INST[1][1] ^ INST[1][56];\
INST[0][133] = INST[1][56] ^ INST[1][94];\
INST[0][134] = INST[1][94] ^ INST[1][13];\
INST[0][135] = INST[1][13] ^ INST[1][166];\
INST[0][136] = INST[1][166] ^ INST[1][155];\
INST[0][137] = INST[1][155] ^ INST[1][128];\
INST[0][138] = INST[1][128] ^ INST[1][27];\
INST[0][139] = INST[1][27] ^ INST[1][71];\
INST[0][140] = INST[1][71] ^ INST[1][142];\
INST[0][141] = INST[1][142] ^ INST[1][98];\
INST[0][142] = INST[1][98] ^ INST[1][84];\
INST[0][143] = INST[1][84] ^ INST[1][26];\
INST[0][144] = INST[1][26] ^ INST[1][114];\
INST[0][145] = INST[1][114] ^ INST[1][118];\
INST[0][146] = INST[1][118] ^ INST[1][112];\
INST[0][147] = INST[1][112] ^ INST[1][41];\
INST[0][148] = INST[1][41] ^ INST[1][42];\
INST[0][149] = INST[1][42] ^ INST[1][152];\
INST[0][150] = INST[1][152] ^ INST[1][141];\
INST[0][151] = INST[1][141] ^ INST[1][91];\
INST[0][152] = INST[1][91] ^ INST[1][48];\
INST[0][153] = INST[1][48] ^ INST[1][78];\
INST[0][154] = INST[1][78] ^ INST[1][120];\
INST[0][155] = INST[1][120] ^ INST[1][57];\
INST[0][156] = INST[1][57] ^ INST[1][72];\
INST[0][157] = INST[1][72] ^ INST[1][65];\
INST[0][158] = INST[1][65] ^ INST[1][77];\
INST[0][159] = INST[1][77] ^ INST[1][164];\
INST[0][160] = INST[1][164] ^ INST[1][83];\
INST[0][161] = INST[1][83] ^ INST[1][92];\
INST[0][162] = INST[1][92] ^ INST[1][36];\
INST[0][163] = INST[1][36] ^ INST[1][89];\
INST[0][164] = INST[1][89] ^ INST[1][102];\
INST[0][165] = INST[1][102] ^ INST[1][29];\
INST[0][166] = INST[1][29] ^ INST[1][154];\
INST[0][167] = INST[1][154] ^ INST[1][22];\
}
#endif
#ifndef SBOX4_H
#define SBOX4_H
#define SBOX4(INST) {\
uint8_t N0;\
uint8_t N1;\
uint8_t N2;\
uint8_t N3;\
uint8_t N4;\
uint8_t N5;\
uint8_t N6;\
uint8_t N7;\
uint8_t N8;\
uint8_t N9;\
uint8_t N10;\
uint8_t N11;\
uint8_t N12;\
uint8_t N13;\
N0 = ~INST[0][105];\
N1 = N0 & INST[0][79];\
N2 = N0 & INST[0][140];\
N3 = N1 | N2;\
N4 = INST[0][79] & INST[0][140];\
N5 = INST[0][105] & INST[0][79];\
N6 = ~INST[0][140];\
N7 = N6 & INST[0][105];\
N8 = N5 | N7;\
N9 = N6 & INST[0][79];\
N10 = N0 & INST[0][79];\
N11 = N0 & N6;\
N12 = N10 | N11;\
N13 = N6 & INST[0][79];\
INST[1][0]= N12 | N13;\
INST[1][1]= N8 | N9;\
INST[1][2]= N3 | N4;\
N0 = ~INST[0][76];\
N1 = N0 & INST[0][141];\
N2 = N0 & INST[0][157];\
N3 = N1 | N2;\
N4 = INST[0][141] & INST[0][157];\
N5 = INST[0][76] & INST[0][141];\
N6 = ~INST[0][157];\
N7 = N6 & INST[0][76];\
N8 = N5 | N7;\
N9 = N6 & INST[0][141];\
N10 = N0 & INST[0][141];\
N11 = N0 & N6;\
N12 = N10 | N11;\
N13 = N6 & INST[0][141];\
INST[1][3]= N12 | N13;\
INST[1][4]= N8 | N9;\
INST[1][5]= N3 | N4;\
N0 = ~INST[0][38];\
N1 = N0 & INST[0][135];\
N2 = N0 & INST[0][18];\
N3 = N1 | N2;\
N4 = INST[0][135] & INST[0][18];\
N5 = INST[0][38] & INST[0][135];\
N6 = ~INST[0][18];\
N7 = N6 & INST[0][38];\
N8 = N5 | N7;\
N9 = N6 & INST[0][135];\
N10 = N0 & INST[0][135];\
N11 = N0 & N6;\
N12 = N10 | N11;\
N13 = N6 & INST[0][135];\
INST[1][6]= N12 | N13;\
INST[1][7]= N8 | N9;\
INST[1][8]= N3 | N4;\
N0 = ~INST[0][161];\
N1 = N0 & INST[0][143];\
N2 = N0 & INST[0][28];\
N3 = N1 | N2;\
N4 = INST[0][143] & INST[0][28];\
N5 = INST[0][161] & INST[0][143];\
N6 = ~INST[0][28];\
N7 = N6 & INST[0][161];\
N8 = N5 | N7;\
N9 = N6 & INST[0][143];\
N10 = N0 & INST[0][143];\
N11 = N0 & N6;\
N12 = N10 | N11;\
N13 = N6 & INST[0][143];\
INST[1][9]= N12 | N13;\
INST[1][10]= N8 | N9;\
INST[1][11]= N3 | N4;\
N0 = ~INST[0][67];\
N1 = N0 & INST[0][117];\
N2 = N0 & INST[0][146];\
N3 = N1 | N2;\
N4 = INST[0][117] & INST[0][146];\
N5 = INST[0][67] & INST[0][117];\
N6 = ~INST[0][146];\
N7 = N6 & INST[0][67];\
N8 = N5 | N7;\
N9 = N6 & INST[0][117];\
N10 = N0 & INST[0][117];\
N11 = N0 & N6;\
N12 = N10 | N11;\
N13 = N6 & INST[0][117];\
INST[1][12]= N12 | N13;\
INST[1][13]= N8 | N9;\
INST[1][14]= N3 | N4;\
N0 = ~INST[0][13];\
N1 = N0 & INST[0][12];\
N2 = N0 & INST[0][113];\
N3 = N1 | N2;\
N4 = INST[0][12] & INST[0][113];\
N5 = INST[0][13] & INST[0][12];\
N6 = ~INST[0][113];\
N7 = N6 & INST[0][13];\
N8 = N5 | N7;\
N9 = N6 & INST[0][12];\
N10 = N0 & INST[0][12];\
N11 = N0 & N6;\
N12 = N10 | N11;\
N13 = N6 & INST[0][12];\
INST[1][15]= N12 | N13;\
INST[1][16]= N8 | N9;\
INST[1][17]= N3 | N4;\
N0 = ~INST[0][97];\
N1 = N0 & INST[0][54];\
N2 = N0 & INST[0][74];\
N3 = N1 | N2;\
N4 = INST[0][54] & INST[0][74];\
N5 = INST[0][97] & INST[0][54];\
N6 = ~INST[0][74];\
N7 = N6 & INST[0][97];\
N8 = N5 | N7;\
N9 = N6 & INST[0][54];\
N10 = N0 & INST[0][54];\
N11 = N0 & N6;\
N12 = N10 | N11;\
N13 = N6 & INST[0][54];\
INST[1][18]= N12 | N13;\
INST[1][19]= N8 | N9;\
INST[1][20]= N3 | N4;\
N0 = ~INST[0][92];\
N1 = N0 & INST[0][118];\
N2 = N0 & INST[0][107];\
N3 = N1 | N2;\
N4 = INST[0][118] & INST[0][107];\
N5 = INST[0][92] & INST[0][118];\
N6 = ~INST[0][107];\
N7 = N6 & INST[0][92];\
N8 = N5 | N7;\
N9 = N6 & INST[0][118];\
N10 = N0 & INST[0][118];\
N11 = N0 & N6;\
N12 = N10 | N11;\
N13 = N6 & INST[0][118];\
INST[1][21]= N12 | N13;\
INST[1][22]= N8 | N9;\
INST[1][23]= N3 | N4;\
N0 = ~INST[0][128];\
N1 = N0 & INST[0][160];\
N2 = N0 & INST[0][42];\
N3 = N1 | N2;\
N4 = INST[0][160] & INST[0][42];\
N5 = INST[0][128] & INST[0][160];\
N6 = ~INST[0][42];\
N7 = N6 & INST[0][128];\
N8 = N5 | N7;\
N9 = N6 & INST[0][160];\
N10 = N0 & INST[0][160];\
N11 = N0 & N6;\
N12 = N10 | N11;\
N13 = N6 & INST[0][160];\
INST[1][24]= N12 | N13;\
INST[1][25]= N8 | N9;\
INST[1][26]= N3 | N4;\
N0 = ~INST[0][19];\
N1 = N0 & INST[0][123];\
N2 = N0 & INST[0][108];\
N3 = N1 | N2;\
N4 = INST[0][123] & INST[0][108];\
N5 = INST[0][19] & INST[0][123];\
N6 = ~INST[0][108];\
N7 = N6 & INST[0][19];\
N8 = N5 | N7;\
N9 = N6 & INST[0][123];\
N10 = N0 & INST[0][123];\
N11 = N0 & N6;\
N12 = N10 | N11;\
N13 = N6 & INST[0][123];\
INST[1][27]= N12 | N13;\
INST[1][28]= N8 | N9;\
INST[1][29]= N3 | N4;\
N0 = ~INST[0][91];\
N1 = N0 & INST[0][115];\
N2 = N0 & INST[0][60];\
N3 = N1 | N2;\
N4 = INST[0][115] & INST[0][60];\
N5 = INST[0][91] & INST[0][115];\
N6 = ~INST[0][60];\
N7 = N6 & INST[0][91];\
N8 = N5 | N7;\
N9 = N6 & INST[0][115];\
N10 = N0 & INST[0][115];\
N11 = N0 & N6;\
N12 = N10 | N11;\
N13 = N6 & INST[0][115];\
INST[1][30]= N12 | N13;\
INST[1][31]= N8 | N9;\
INST[1][32]= N3 | N4;\
N0 = ~INST[0][69];\
N1 = N0 & INST[0][34];\
N2 = N0 & INST[0][129];\
N3 = N1 | N2;\
N4 = INST[0][34] & INST[0][129];\
N5 = INST[0][69] & INST[0][34];\
N6 = ~INST[0][129];\
N7 = N6 & INST[0][69];\
N8 = N5 | N7;\
N9 = N6 & INST[0][34];\
N10 = N0 & INST[0][34];\
N11 = N0 & N6;\
N12 = N10 | N11;\
N13 = N6 & INST[0][34];\
INST[1][33]= N12 | N13;\
INST[1][34]= N8 | N9;\
INST[1][35]= N3 | N4;\
N0 = ~INST[0][163];\
N1 = N0 & INST[0][83];\
N2 = N0 & INST[0][0];\
N3 = N1 | N2;\
N4 = INST[0][83] & INST[0][0];\
N5 = INST[0][163] & INST[0][83];\
N6 = ~INST[0][0];\
N7 = N6 & INST[0][163];\
N8 = N5 | N7;\
N9 = N6 & INST[0][83];\
N10 = N0 & INST[0][83];\
N11 = N0 & N6;\
N12 = N10 | N11;\
N13 = N6 & INST[0][83];\
INST[1][36]= N12 | N13;\
INST[1][37]= N8 | N9;\
INST[1][38]= N3 | N4;\
N0 = ~INST[0][159];\
N1 = N0 & INST[0][61];\
N2 = N0 & INST[0][52];\
N3 = N1 | N2;\
N4 = INST[0][61] & INST[0][52];\
N5 = INST[0][159] & INST[0][61];\
N6 = ~INST[0][52];\
N7 = N6 & INST[0][159];\
N8 = N5 | N7;\
N9 = N6 & INST[0][61];\
N10 = N0 & INST[0][61];\
N11 = N0 & N6;\
N12 = N10 | N11;\
N13 = N6 & INST[0][61];\
INST[1][39]= N12 | N13;\
INST[1][40]= N8 | N9;\
INST[1][41]= N3 | N4;\
N0 = ~INST[0][80];\
N1 = N0 & INST[0][48];\
N2 = N0 & INST[0][84];\
N3 = N1 | N2;\
N4 = INST[0][48] & INST[0][84];\
N5 = INST[0][80] & INST[0][48];\
N6 = ~INST[0][84];\
N7 = N6 & INST[0][80];\
N8 = N5 | N7;\
N9 = N6 & INST[0][48];\
N10 = N0 & INST[0][48];\
N11 = N0 & N6;\
N12 = N10 | N11;\
N13 = N6 & INST[0][48];\
INST[1][42]= N12 | N13;\
INST[1][43]= N8 | N9;\
INST[1][44]= N3 | N4;\
N0 = ~INST[0][134];\
N1 = N0 & INST[0][122];\
N2 = N0 & INST[0][130];\
N3 = N1 | N2;\
N4 = INST[0][122] & INST[0][130];\
N5 = INST[0][134] & INST[0][122];\
N6 = ~INST[0][130];\
N7 = N6 & INST[0][134];\
N8 = N5 | N7;\
N9 = N6 & INST[0][122];\
N10 = N0 & INST[0][122];\
N11 = N0 & N6;\
N12 = N10 | N11;\
N13 = N6 & INST[0][122];\
INST[1][45]= N12 | N13;\
INST[1][46]= N8 | N9;\
INST[1][47]= N3 | N4;\
N0 = ~INST[0][62];\
N1 = N0 & INST[0][27];\
N2 = N0 & INST[0][3];\
N3 = N1 | N2;\
N4 = INST[0][27] & INST[0][3];\
N5 = INST[0][62] & INST[0][27];\
N6 = ~INST[0][3];\
N7 = N6 & INST[0][62];\
N8 = N5 | N7;\
N9 = N6 & INST[0][27];\
N10 = N0 & INST[0][27];\
N11 = N0 & N6;\
N12 = N10 | N11;\
N13 = N6 & INST[0][27];\
INST[1][48]= N12 | N13;\
INST[1][49]= N8 | N9;\
INST[1][50]= N3 | N4;\
N0 = ~INST[0][46];\
N1 = N0 & INST[0][21];\
N2 = N0 & INST[0][154];\
N3 = N1 | N2;\
N4 = INST[0][21] & INST[0][154];\
N5 = INST[0][46] & INST[0][21];\
N6 = ~INST[0][154];\
N7 = N6 & INST[0][46];\
N8 = N5 | N7;\
N9 = N6 & INST[0][21];\
N10 = N0 & INST[0][21];\
N11 = N0 & N6;\
N12 = N10 | N11;\
N13 = N6 & INST[0][21];\
INST[1][51]= N12 | N13;\
INST[1][52]= N8 | N9;\
INST[1][53]= N3 | N4;\
N0 = ~INST[0][99];\
N1 = N0 & INST[0][29];\
N2 = N0 & INST[0][81];\
N3 = N1 | N2;\
N4 = INST[0][29] & INST[0][81];\
N5 = INST[0][99] & INST[0][29];\
N6 = ~INST[0][81];\
N7 = N6 & INST[0][99];\
N8 = N5 | N7;\
N9 = N6 & INST[0][29];\
N10 = N0 & INST[0][29];\
N11 = N0 & N6;\
N12 = N10 | N11;\
N13 = N6 & INST[0][29];\
INST[1][54]= N12 | N13;\
INST[1][55]= N8 | N9;\
INST[1][56]= N3 | N4;\
N0 = ~INST[0][26];\
N1 = N0 & INST[0][158];\
N2 = N0 & INST[0][132];\
N3 = N1 | N2;\
N4 = INST[0][158] & INST[0][132];\
N5 = INST[0][26] & INST[0][158];\
N6 = ~INST[0][132];\
N7 = N6 & INST[0][26];\
N8 = N5 | N7;\
N9 = N6 & INST[0][158];\
N10 = N0 & INST[0][158];\
N11 = N0 & N6;\
N12 = N10 | N11;\
N13 = N6 & INST[0][158];\
INST[1][57]= N12 | N13;\
INST[1][58]= N8 | N9;\
INST[1][59]= N3 | N4;\
N0 = ~INST[0][126];\
N1 = N0 & INST[0][152];\
N2 = N0 & INST[0][72];\
N3 = N1 | N2;\
N4 = INST[0][152] & INST[0][72];\
N5 = INST[0][126] & INST[0][152];\
N6 = ~INST[0][72];\
N7 = N6 & INST[0][126];\
N8 = N5 | N7;\
N9 = N6 & INST[0][152];\
N10 = N0 & INST[0][152];\
N11 = N0 & N6;\
N12 = N10 | N11;\
N13 = N6 & INST[0][152];\
INST[1][60]= N12 | N13;\
INST[1][61]= N8 | N9;\
INST[1][62]= N3 | N4;\
N0 = ~INST[0][166];\
N1 = N0 & INST[0][153];\
N2 = N0 & INST[0][11];\
N3 = N1 | N2;\
N4 = INST[0][153] & INST[0][11];\
N5 = INST[0][166] & INST[0][153];\
N6 = ~INST[0][11];\
N7 = N6 & INST[0][166];\
N8 = N5 | N7;\
N9 = N6 & INST[0][153];\
N10 = N0 & INST[0][153];\
N11 = N0 & N6;\
N12 = N10 | N11;\
N13 = N6 & INST[0][153];\
INST[1][63]= N12 | N13;\
INST[1][64]= N8 | N9;\
INST[1][65]= N3 | N4;\
N0 = ~INST[0][50];\
N1 = N0 & INST[0][2];\
N2 = N0 & INST[0][131];\
N3 = N1 | N2;\
N4 = INST[0][2] & INST[0][131];\
N5 = INST[0][50] & INST[0][2];\
N6 = ~INST[0][131];\
N7 = N6 & INST[0][50];\
N8 = N5 | N7;\
N9 = N6 & INST[0][2];\
N10 = N0 & INST[0][2];\
N11 = N0 & N6;\
N12 = N10 | N11;\
N13 = N6 & INST[0][2];\
INST[1][66]= N12 | N13;\
INST[1][67]= N8 | N9;\
INST[1][68]= N3 | N4;\
N0 = ~INST[0][95];\
N1 = N0 & INST[0][68];\
N2 = N0 & INST[0][145];\
N3 = N1 | N2;\
N4 = INST[0][68] & INST[0][145];\
N5 = INST[0][95] & INST[0][68];\
N6 = ~INST[0][145];\
N7 = N6 & INST[0][95];\
N8 = N5 | N7;\
N9 = N6 & INST[0][68];\
N10 = N0 & INST[0][68];\
N11 = N0 & N6;\
N12 = N10 | N11;\
N13 = N6 & INST[0][68];\
INST[1][69]= N12 | N13;\
INST[1][70]= N8 | N9;\
INST[1][71]= N3 | N4;\
N0 = ~INST[0][20];\
N1 = N0 & INST[0][149];\
N2 = N0 & INST[0][24];\
N3 = N1 | N2;\
N4 = INST[0][149] & INST[0][24];\
N5 = INST[0][20] & INST[0][149];\
N6 = ~INST[0][24];\
N7 = N6 & INST[0][20];\
N8 = N5 | N7;\
N9 = N6 & INST[0][149];\
N10 = N0 & INST[0][149];\
N11 = N0 & N6;\
N12 = N10 | N11;\
N13 = N6 & INST[0][149];\
INST[1][72]= N12 | N13;\
INST[1][73]= N8 | N9;\
INST[1][74]= N3 | N4;\
N0 = ~INST[0][1];\
N1 = N0 & INST[0][98];\
N2 = N0 & INST[0][23];\
N3 = N1 | N2;\
N4 = INST[0][98] & INST[0][23];\
N5 = INST[0][1] & INST[0][98];\
N6 = ~INST[0][23];\
N7 = N6 & INST[0][1];\
N8 = N5 | N7;\
N9 = N6 & INST[0][98];\
N10 = N0 & INST[0][98];\
N11 = N0 & N6;\
N12 = N10 | N11;\
N13 = N6 & INST[0][98];\
INST[1][75]= N12 | N13;\
INST[1][76]= N8 | N9;\
INST[1][77]= N3 | N4;\
N0 = ~INST[0][162];\
N1 = N0 & INST[0][106];\
N2 = N0 & INST[0][136];\
N3 = N1 | N2;\
N4 = INST[0][106] & INST[0][136];\
N5 = INST[0][162] & INST[0][106];\
N6 = ~INST[0][136];\
N7 = N6 & INST[0][162];\
N8 = N5 | N7;\
N9 = N6 & INST[0][106];\
N10 = N0 & INST[0][106];\
N11 = N0 & N6;\
N12 = N10 | N11;\
N13 = N6 & INST[0][106];\
INST[1][78]= N12 | N13;\
INST[1][79]= N8 | N9;\
INST[1][80]= N3 | N4;\
N0 = ~INST[0][65];\
N1 = N0 & INST[0][66];\
N2 = N0 & INST[0][47];\
N3 = N1 | N2;\
N4 = INST[0][66] & INST[0][47];\
N5 = INST[0][65] & INST[0][66];\
N6 = ~INST[0][47];\
N7 = N6 & INST[0][65];\
N8 = N5 | N7;\
N9 = N6 & INST[0][66];\
N10 = N0 & INST[0][66];\
N11 = N0 & N6;\
N12 = N10 | N11;\
N13 = N6 & INST[0][66];\
INST[1][81]= N12 | N13;\
INST[1][82]= N8 | N9;\
INST[1][83]= N3 | N4;\
N0 = ~INST[0][9];\
N1 = N0 & INST[0][4];\
N2 = N0 & INST[0][103];\
N3 = N1 | N2;\
N4 = INST[0][4] & INST[0][103];\
N5 = INST[0][9] & INST[0][4];\
N6 = ~INST[0][103];\
N7 = N6 & INST[0][9];\
N8 = N5 | N7;\
N9 = N6 & INST[0][4];\
N10 = N0 & INST[0][4];\
N11 = N0 & N6;\
N12 = N10 | N11;\
N13 = N6 & INST[0][4];\
INST[1][84]= N12 | N13;\
INST[1][85]= N8 | N9;\
INST[1][86]= N3 | N4;\
N0 = ~INST[0][109];\
N1 = N0 & INST[0][56];\
N2 = N0 & INST[0][124];\
N3 = N1 | N2;\
N4 = INST[0][56] & INST[0][124];\
N5 = INST[0][109] & INST[0][56];\
N6 = ~INST[0][124];\
N7 = N6 & INST[0][109];\
N8 = N5 | N7;\
N9 = N6 & INST[0][56];\
N10 = N0 & INST[0][56];\
N11 = N0 & N6;\
N12 = N10 | N11;\
N13 = N6 & INST[0][56];\
INST[1][87]= N12 | N13;\
INST[1][88]= N8 | N9;\
INST[1][89]= N3 | N4;\
N0 = ~INST[0][111];\
N1 = N0 & INST[0][150];\
N2 = N0 & INST[0][45];\
N3 = N1 | N2;\
N4 = INST[0][150] & INST[0][45];\
N5 = INST[0][111] & INST[0][150];\
N6 = ~INST[0][45];\
N7 = N6 & INST[0][111];\
N8 = N5 | N7;\
N9 = N6 & INST[0][150];\
N10 = N0 & INST[0][150];\
N11 = N0 & N6;\
N12 = N10 | N11;\
N13 = N6 & INST[0][150];\
INST[1][90]= N12 | N13;\
INST[1][91]= N8 | N9;\
INST[1][92]= N3 | N4;\
N0 = ~INST[0][16];\
N1 = N0 & INST[0][51];\
N2 = N0 & INST[0][85];\
N3 = N1 | N2;\
N4 = INST[0][51] & INST[0][85];\
N5 = INST[0][16] & INST[0][51];\
N6 = ~INST[0][85];\
N7 = N6 & INST[0][16];\
N8 = N5 | N7;\
N9 = N6 & INST[0][51];\
N10 = N0 & INST[0][51];\
N11 = N0 & N6;\
N12 = N10 | N11;\
N13 = N6 & INST[0][51];\
INST[1][93]= N12 | N13;\
INST[1][94]= N8 | N9;\
INST[1][95]= N3 | N4;\
N0 = ~INST[0][100];\
N1 = N0 & INST[0][59];\
N2 = N0 & INST[0][8];\
N3 = N1 | N2;\
N4 = INST[0][59] & INST[0][8];\
N5 = INST[0][100] & INST[0][59];\
N6 = ~INST[0][8];\
N7 = N6 & INST[0][100];\
N8 = N5 | N7;\
N9 = N6 & INST[0][59];\
N10 = N0 & INST[0][59];\
N11 = N0 & N6;\
N12 = N10 | N11;\
N13 = N6 & INST[0][59];\
INST[1][96]= N12 | N13;\
INST[1][97]= N8 | N9;\
INST[1][98]= N3 | N4;\
N0 = ~INST[0][17];\
N1 = N0 & INST[0][147];\
N2 = N0 & INST[0][89];\
N3 = N1 | N2;\
N4 = INST[0][147] & INST[0][89];\
N5 = INST[0][17] & INST[0][147];\
N6 = ~INST[0][89];\
N7 = N6 & INST[0][17];\
N8 = N5 | N7;\
N9 = N6 & INST[0][147];\
N10 = N0 & INST[0][147];\
N11 = N0 & N6;\
N12 = N10 | N11;\
N13 = N6 & INST[0][147];\
INST[1][99]= N12 | N13;\
INST[1][100]= N8 | N9;\
INST[1][101]= N3 | N4;\
N0 = ~INST[0][33];\
N1 = N0 & INST[0][63];\
N2 = N0 & INST[0][144];\
N3 = N1 | N2;\
N4 = INST[0][63] & INST[0][144];\
N5 = INST[0][33] & INST[0][63];\
N6 = ~INST[0][144];\
N7 = N6 & INST[0][33];\
N8 = N5 | N7;\
N9 = N6 & INST[0][63];\
N10 = N0 & INST[0][63];\
N11 = N0 & N6;\
N12 = N10 | N11;\
N13 = N6 & INST[0][63];\
INST[1][102]= N12 | N13;\
INST[1][103]= N8 | N9;\
INST[1][104]= N3 | N4;\
N0 = ~INST[0][125];\
N1 = N0 & INST[0][44];\
N2 = N0 & INST[0][35];\
N3 = N1 | N2;\
N4 = INST[0][44] & INST[0][35];\
N5 = INST[0][125] & INST[0][44];\
N6 = ~INST[0][35];\
N7 = N6 & INST[0][125];\
N8 = N5 | N7;\
N9 = N6 & INST[0][44];\
N10 = N0 & INST[0][44];\
N11 = N0 & N6;\
N12 = N10 | N11;\
N13 = N6 & INST[0][44];\
INST[1][105]= N12 | N13;\
INST[1][106]= N8 | N9;\
INST[1][107]= N3 | N4;\
N0 = ~INST[0][36];\
N1 = N0 & INST[0][53];\
N2 = N0 & INST[0][148];\
N3 = N1 | N2;\
N4 = INST[0][53] & INST[0][148];\
N5 = INST[0][36] & INST[0][53];\
N6 = ~INST[0][148];\
N7 = N6 & INST[0][36];\
N8 = N5 | N7;\
N9 = N6 & INST[0][53];\
N10 = N0 & INST[0][53];\
N11 = N0 & N6;\
N12 = N10 | N11;\
N13 = N6 & INST[0][53];\
INST[1][108]= N12 | N13;\
INST[1][109]= N8 | N9;\
INST[1][110]= N3 | N4;\
N0 = ~INST[0][139];\
N1 = N0 & INST[0][142];\
N2 = N0 & INST[0][14];\
N3 = N1 | N2;\
N4 = INST[0][142] & INST[0][14];\
N5 = INST[0][139] & INST[0][142];\
N6 = ~INST[0][14];\
N7 = N6 & INST[0][139];\
N8 = N5 | N7;\
N9 = N6 & INST[0][142];\
N10 = N0 & INST[0][142];\
N11 = N0 & N6;\
N12 = N10 | N11;\
N13 = N6 & INST[0][142];\
INST[1][111]= N12 | N13;\
INST[1][112]= N8 | N9;\
INST[1][113]= N3 | N4;\
N0 = ~INST[0][127];\
N1 = N0 & INST[0][41];\
N2 = N0 & INST[0][94];\
N3 = N1 | N2;\
N4 = INST[0][41] & INST[0][94];\
N5 = INST[0][127] & INST[0][41];\
N6 = ~INST[0][94];\
N7 = N6 & INST[0][127];\
N8 = N5 | N7;\
N9 = N6 & INST[0][41];\
N10 = N0 & INST[0][41];\
N11 = N0 & N6;\
N12 = N10 | N11;\
N13 = N6 & INST[0][41];\
INST[1][114]= N12 | N13;\
INST[1][115]= N8 | N9;\
INST[1][116]= N3 | N4;\
N0 = ~INST[0][6];\
N1 = N0 & INST[0][77];\
N2 = N0 & INST[0][7];\
N3 = N1 | N2;\
N4 = INST[0][77] & INST[0][7];\
N5 = INST[0][6] & INST[0][77];\
N6 = ~INST[0][7];\
N7 = N6 & INST[0][6];\
N8 = N5 | N7;\
N9 = N6 & INST[0][77];\
N10 = N0 & INST[0][77];\
N11 = N0 & N6;\
N12 = N10 | N11;\
N13 = N6 & INST[0][77];\
INST[1][117]= N12 | N13;\
INST[1][118]= N8 | N9;\
INST[1][119]= N3 | N4;\
N0 = ~INST[0][138];\
N1 = N0 & INST[0][39];\
N2 = N0 & INST[0][49];\
N3 = N1 | N2;\
N4 = INST[0][39] & INST[0][49];\
N5 = INST[0][138] & INST[0][39];\
N6 = ~INST[0][49];\
N7 = N6 & INST[0][138];\
N8 = N5 | N7;\
N9 = N6 & INST[0][39];\
N10 = N0 & INST[0][39];\
N11 = N0 & N6;\
N12 = N10 | N11;\
N13 = N6 & INST[0][39];\
INST[1][120]= N12 | N13;\
INST[1][121]= N8 | N9;\
INST[1][122]= N3 | N4;\
N0 = ~INST[0][155];\
N1 = N0 & INST[0][22];\
N2 = N0 & INST[0][88];\
N3 = N1 | N2;\
N4 = INST[0][22] & INST[0][88];\
N5 = INST[0][155] & INST[0][22];\
N6 = ~INST[0][88];\
N7 = N6 & INST[0][155];\
N8 = N5 | N7;\
N9 = N6 & INST[0][22];\
N10 = N0 & INST[0][22];\
N11 = N0 & N6;\
N12 = N10 | N11;\
N13 = N6 & INST[0][22];\
INST[1][123]= N12 | N13;\
INST[1][124]= N8 | N9;\
INST[1][125]= N3 | N4;\
N0 = ~INST[0][43];\
N1 = N0 & INST[0][102];\
N2 = N0 & INST[0][57];\
N3 = N1 | N2;\
N4 = INST[0][102] & INST[0][57];\
N5 = INST[0][43] & INST[0][102];\
N6 = ~INST[0][57];\
N7 = N6 & INST[0][43];\
N8 = N5 | N7;\
N9 = N6 & INST[0][102];\
N10 = N0 & INST[0][102];\
N11 = N0 & N6;\
N12 = N10 | N11;\
N13 = N6 & INST[0][102];\
INST[1][126]= N12 | N13;\
INST[1][127]= N8 | N9;\
INST[1][128]= N3 | N4;\
N0 = ~INST[0][37];\
N1 = N0 & INST[0][120];\
N2 = N0 & INST[0][96];\
N3 = N1 | N2;\
N4 = INST[0][120] & INST[0][96];\
N5 = INST[0][37] & INST[0][120];\
N6 = ~INST[0][96];\
N7 = N6 & INST[0][37];\
N8 = N5 | N7;\
N9 = N6 & INST[0][120];\
N10 = N0 & INST[0][120];\
N11 = N0 & N6;\
N12 = N10 | N11;\
N13 = N6 & INST[0][120];\
INST[1][129]= N12 | N13;\
INST[1][130]= N8 | N9;\
INST[1][131]= N3 | N4;\
N0 = ~INST[0][151];\
N1 = N0 & INST[0][93];\
N2 = N0 & INST[0][119];\
N3 = N1 | N2;\
N4 = INST[0][93] & INST[0][119];\
N5 = INST[0][151] & INST[0][93];\
N6 = ~INST[0][119];\
N7 = N6 & INST[0][151];\
N8 = N5 | N7;\
N9 = N6 & INST[0][93];\
N10 = N0 & INST[0][93];\
N11 = N0 & N6;\
N12 = N10 | N11;\
N13 = N6 & INST[0][93];\
INST[1][132]= N12 | N13;\
INST[1][133]= N8 | N9;\
INST[1][134]= N3 | N4;\
N0 = ~INST[0][30];\
N1 = N0 & INST[0][64];\
N2 = N0 & INST[0][32];\
N3 = N1 | N2;\
N4 = INST[0][64] & INST[0][32];\
N5 = INST[0][30] & INST[0][64];\
N6 = ~INST[0][32];\
N7 = N6 & INST[0][30];\
N8 = N5 | N7;\
N9 = N6 & INST[0][64];\
N10 = N0 & INST[0][64];\
N11 = N0 & N6;\
N12 = N10 | N11;\
N13 = N6 & INST[0][64];\
INST[1][135]= N12 | N13;\
INST[1][136]= N8 | N9;\
INST[1][137]= N3 | N4;\
N0 = ~INST[0][55];\
N1 = N0 & INST[0][78];\
N2 = N0 & INST[0][112];\
N3 = N1 | N2;\
N4 = INST[0][78] & INST[0][112];\
N5 = INST[0][55] & INST[0][78];\
N6 = ~INST[0][112];\
N7 = N6 & INST[0][55];\
N8 = N5 | N7;\
N9 = N6 & INST[0][78];\
N10 = N0 & INST[0][78];\
N11 = N0 & N6;\
N12 = N10 | N11;\
N13 = N6 & INST[0][78];\
INST[1][138]= N12 | N13;\
INST[1][139]= N8 | N9;\
INST[1][140]= N3 | N4;\
N0 = ~INST[0][104];\
N1 = N0 & INST[0][58];\
N2 = N0 & INST[0][15];\
N3 = N1 | N2;\
N4 = INST[0][58] & INST[0][15];\
N5 = INST[0][104] & INST[0][58];\
N6 = ~INST[0][15];\
N7 = N6 & INST[0][104];\
N8 = N5 | N7;\
N9 = N6 & INST[0][58];\
N10 = N0 & INST[0][58];\
N11 = N0 & N6;\
N12 = N10 | N11;\
N13 = N6 & INST[0][58];\
INST[1][141]= N12 | N13;\
INST[1][142]= N8 | N9;\
INST[1][143]= N3 | N4;\
N0 = ~INST[0][165];\
N1 = N0 & INST[0][82];\
N2 = N0 & INST[0][25];\
N3 = N1 | N2;\
N4 = INST[0][82] & INST[0][25];\
N5 = INST[0][165] & INST[0][82];\
N6 = ~INST[0][25];\
N7 = N6 & INST[0][165];\
N8 = N5 | N7;\
N9 = N6 & INST[0][82];\
N10 = N0 & INST[0][82];\
N11 = N0 & N6;\
N12 = N10 | N11;\
N13 = N6 & INST[0][82];\
INST[1][144]= N12 | N13;\
INST[1][145]= N8 | N9;\
INST[1][146]= N3 | N4;\
N0 = ~INST[0][167];\
N1 = N0 & INST[0][75];\
N2 = N0 & INST[0][101];\
N3 = N1 | N2;\
N4 = INST[0][75] & INST[0][101];\
N5 = INST[0][167] & INST[0][75];\
N6 = ~INST[0][101];\
N7 = N6 & INST[0][167];\
N8 = N5 | N7;\
N9 = N6 & INST[0][75];\
N10 = N0 & INST[0][75];\
N11 = N0 & N6;\
N12 = N10 | N11;\
N13 = N6 & INST[0][75];\
INST[1][147]= N12 | N13;\
INST[1][148]= N8 | N9;\
INST[1][149]= N3 | N4;\
N0 = ~INST[0][114];\
N1 = N0 & INST[0][73];\
N2 = N0 & INST[0][86];\
N3 = N1 | N2;\
N4 = INST[0][73] & INST[0][86];\
N5 = INST[0][114] & INST[0][73];\
N6 = ~INST[0][86];\
N7 = N6 & INST[0][114];\
N8 = N5 | N7;\
N9 = N6 & INST[0][73];\
N10 = N0 & INST[0][73];\
N11 = N0 & N6;\
N12 = N10 | N11;\
N13 = N6 & INST[0][73];\
INST[1][150]= N12 | N13;\
INST[1][151]= N8 | N9;\
INST[1][152]= N3 | N4;\
N0 = ~INST[0][133];\
N1 = N0 & INST[0][31];\
N2 = N0 & INST[0][156];\
N3 = N1 | N2;\
N4 = INST[0][31] & INST[0][156];\
N5 = INST[0][133] & INST[0][31];\
N6 = ~INST[0][156];\
N7 = N6 & INST[0][133];\
N8 = N5 | N7;\
N9 = N6 & INST[0][31];\
N10 = N0 & INST[0][31];\
N11 = N0 & N6;\
N12 = N10 | N11;\
N13 = N6 & INST[0][31];\
INST[1][153]= N12 | N13;\
INST[1][154]= N8 | N9;\
INST[1][155]= N3 | N4;\
N0 = ~INST[0][137];\
N1 = N0 & INST[0][87];\
N2 = N0 & INST[0][70];\
N3 = N1 | N2;\
N4 = INST[0][87] & INST[0][70];\
N5 = INST[0][137] & INST[0][87];\
N6 = ~INST[0][70];\
N7 = N6 & INST[0][137];\
N8 = N5 | N7;\
N9 = N6 & INST[0][87];\
N10 = N0 & INST[0][87];\
N11 = N0 & N6;\
N12 = N10 | N11;\
N13 = N6 & INST[0][87];\
INST[1][156]= N12 | N13;\
INST[1][157]= N8 | N9;\
INST[1][158]= N3 | N4;\
N0 = ~INST[0][5];\
N1 = N0 & INST[0][121];\
N2 = N0 & INST[0][71];\
N3 = N1 | N2;\
N4 = INST[0][121] & INST[0][71];\
N5 = INST[0][5] & INST[0][121];\
N6 = ~INST[0][71];\
N7 = N6 & INST[0][5];\
N8 = N5 | N7;\
N9 = N6 & INST[0][121];\
N10 = N0 & INST[0][121];\
N11 = N0 & N6;\
N12 = N10 | N11;\
N13 = N6 & INST[0][121];\
INST[1][159]= N12 | N13;\
INST[1][160]= N8 | N9;\
INST[1][161]= N3 | N4;\
N0 = ~INST[0][10];\
N1 = N0 & INST[0][116];\
N2 = N0 & INST[0][110];\
N3 = N1 | N2;\
N4 = INST[0][116] & INST[0][110];\
N5 = INST[0][10] & INST[0][116];\
N6 = ~INST[0][110];\
N7 = N6 & INST[0][10];\
N8 = N5 | N7;\
N9 = N6 & INST[0][116];\
N10 = N0 & INST[0][116];\
N11 = N0 & N6;\
N12 = N10 | N11;\
N13 = N6 & INST[0][116];\
INST[1][162]= N12 | N13;\
INST[1][163]= N8 | N9;\
INST[1][164]= N3 | N4;\
N0 = ~INST[0][164];\
N1 = N0 & INST[0][90];\
N2 = N0 & INST[0][40];\
N3 = N1 | N2;\
N4 = INST[0][90] & INST[0][40];\
N5 = INST[0][164] & INST[0][90];\
N6 = ~INST[0][40];\
N7 = N6 & INST[0][164];\
N8 = N5 | N7;\
N9 = N6 & INST[0][90];\
N10 = N0 & INST[0][90];\
N11 = N0 & N6;\
N12 = N10 | N11;\
N13 = N6 & INST[0][90];\
INST[1][165]= N12 | N13;\
INST[1][166]= N8 | N9;\
INST[1][167]= N3 | N4;\
}
#endif
#ifndef XOR5_H
#define XOR5_H
#define XOR5(INST) {\
INST[0][0] = INST[1][63] ^ INST[1][96] ^ INST[1][25];\
INST[0][1] = INST[1][96] ^ INST[1][153];\
INST[0][2] = INST[1][153] ^ INST[1][25];\
INST[0][3] = INST[1][25] ^ INST[1][12];\
INST[0][4] = INST[1][12] ^ INST[1][61];\
INST[0][5] = INST[1][61] ^ INST[1][5];\
INST[0][6] = INST[1][5] ^ INST[1][99];\
INST[0][7] = INST[1][99] ^ INST[1][137];\
INST[0][8] = INST[1][137] ^ INST[1][92];\
INST[0][9] = INST[1][92] ^ INST[1][23];\
INST[0][10] = INST[1][23] ^ INST[1][154];\
INST[0][11] = INST[1][154] ^ INST[1][33];\
INST[0][12] = INST[1][33] ^ INST[1][161];\
INST[0][13] = INST[1][161] ^ INST[1][55];\
INST[0][14] = INST[1][55] ^ INST[1][16];\
INST[0][15] = INST[1][16] ^ INST[1][64];\
INST[0][16] = INST[1][64] ^ INST[1][130];\
INST[0][17] = INST[1][130] ^ INST[1][110];\
INST[0][18] = INST[1][110] ^ INST[1][155];\
INST[0][19] = INST[1][155] ^ INST[1][21];\
INST[0][20] = INST[1][21] ^ INST[1][71];\
INST[0][21] = INST[1][71] ^ INST[1][60];\
INST[0][22] = INST[1][60] ^ INST[1][158];\
INST[0][23] = INST[1][158] ^ INST[1][116];\
INST[0][24] = INST[1][116] ^ INST[1][127];\
INST[0][25] = INST[1][127] ^ INST[1][3];\
INST[0][26] = INST[1][3] ^ INST[1][139];\
INST[0][27] = INST[1][139] ^ INST[1][54];\
INST[0][28] = INST[1][54] ^ INST[1][1];\
INST[0][29] = INST[1][1] ^ INST[1][84];\
INST[0][30] = INST[1][84] ^ INST[1][57];\
INST[0][31] = INST[1][57] ^ INST[1][90];\
INST[0][32] = INST[1][90] ^ INST[1][48];\
INST[0][33] = INST[1][48] ^ INST[1][149];\
INST[0][34] = INST[1][149] ^ INST[1][115];\
INST[0][35] = INST[1][115] ^ INST[1][7];\
INST[0][36] = INST[1][7] ^ INST[1][24];\
INST[0][37] = INST[1][24] ^ INST[1][70];\
INST[0][38] = INST[1][70] ^ INST[1][143];\
INST[0][39] = INST[1][143] ^ INST[1][74];\
INST[0][40] = INST[1][74] ^ INST[1][78];\
INST[0][41] = INST[1][78] ^ INST[1][135];\
INST[0][42] = INST[1][135] ^ INST[1][52];\
INST[0][43] = INST[1][52] ^ INST[1][4];\
INST[0][44] = INST[1][4] ^ INST[1][126];\
INST[0][45] = INST[1][126] ^ INST[1][91];\
INST[0][46] = INST[1][91] ^ INST[1][165];\
INST[0][47] = INST[1][165] ^ INST[1][40];\
INST[0][48] = INST[1][40] ^ INST[1][56];\
INST[0][49] = INST[1][56] ^ INST[1][68];\
INST[0][50] = INST[1][68] ^ INST[1][87];\
INST[0][51] = INST[1][87] ^ INST[1][2];\
INST[0][52] = INST[1][2] ^ INST[1][8];\
INST[0][53] = INST[1][8] ^ INST[1][141];\
INST[0][54] = INST[1][141] ^ INST[1][44];\
INST[0][55] = INST[1][44] ^ INST[1][34];\
INST[0][56] = INST[1][34] ^ INST[1][167];\
INST[0][57] = INST[1][167] ^ INST[1][27];\
INST[0][58] = INST[1][27] ^ INST[1][113];\
INST[0][59] = INST[1][113] ^ INST[1][29];\
INST[0][60] = INST[1][29] ^ INST[1][46];\
INST[0][61] = INST[1][46] ^ INST[1][41];\
INST[0][62] = INST[1][41] ^ INST[1][42];\
INST[0][63] = INST[1][42] ^ INST[1][142];\
INST[0][64] = INST[1][142] ^ INST[1][22];\
INST[0][65] = INST[1][22] ^ INST[1][160];\
INST[0][66] = INST[1][160] ^ INST[1][145];\
INST[0][67] = INST[1][145] ^ INST[1][85];\
INST[0][68] = INST[1][85] ^ INST[1][132];\
INST[0][69] = INST[1][132] ^ INST[1][103];\
INST[0][70] = INST[1][103] ^ INST[1][65];\
INST[0][71] = INST[1][65] ^ INST[1][133];\
INST[0][72] = INST[1][133] ^ INST[1][53];\
INST[0][73] = INST[1][53] ^ INST[1][134];\
INST[0][74] = INST[1][134] ^ INST[1][86];\
INST[0][75] = INST[1][86] ^ INST[1][151];\
INST[0][76] = INST[1][151] ^ INST[1][114];\
INST[0][77] = INST[1][114] ^ INST[1][0];\
INST[0][78] = INST[1][0] ^ INST[1][152];\
INST[0][79] = INST[1][152] ^ INST[1][147];\
INST[0][80] = INST[1][147] ^ INST[1][117];\
INST[0][81] = INST[1][117] ^ INST[1][97];\
INST[0][82] = INST[1][97] ^ INST[1][58];\
INST[0][83] = INST[1][58] ^ INST[1][95];\
INST[0][84] = INST[1][95] ^ INST[1][66];\
INST[0][85] = INST[1][66] ^ INST[1][35];\
INST[0][86] = INST[1][35] ^ INST[1][164];\
INST[0][87] = INST[1][164] ^ INST[1][77];\
INST[0][88] = INST[1][77] ^ INST[1][82];\
INST[0][89] = INST[1][82] ^ INST[1][32];\
INST[0][90] = INST[1][32] ^ INST[1][125];\
INST[0][91] = INST[1][125] ^ INST[1][36];\
INST[0][92] = INST[1][36] ^ INST[1][108];\
INST[0][93] = INST[1][108] ^ INST[1][10];\
INST[0][94] = INST[1][10] ^ INST[1][162];\
INST[0][95] = INST[1][162] ^ INST[1][112];\
INST[0][96] = INST[1][112] ^ INST[1][28];\
INST[0][97] = INST[1][28] ^ INST[1][159];\
INST[0][98] = INST[1][159] ^ INST[1][111];\
INST[0][99] = INST[1][111] ^ INST[1][59];\
INST[0][100] = INST[1][59] ^ INST[1][73];\
INST[0][101] = INST[1][73] ^ INST[1][109];\
INST[0][102] = INST[1][109] ^ INST[1][80];\
INST[0][103] = INST[1][80] ^ INST[1][128];\
INST[0][104] = INST[1][128] ^ INST[1][121];\
INST[0][105] = INST[1][121] ^ INST[1][50];\
INST[0][106] = INST[1][50] ^ INST[1][88];\
INST[0][107] = INST[1][88] ^ INST[1][148];\
INST[0][108] = INST[1][148] ^ INST[1][89];\
INST[0][109] = INST[1][89] ^ INST[1][94];\
INST[0][110] = INST[1][94] ^ INST[1][93];\
INST[0][111] = INST[1][93] ^ INST[1][136];\
INST[0][112] = INST[1][136] ^ INST[1][72];\
INST[0][113] = INST[1][72] ^ INST[1][39];\
INST[0][114] = INST[1][39] ^ INST[1][69];\
INST[0][115] = INST[1][69] ^ INST[1][18];\
INST[0][116] = INST[1][18] ^ INST[1][138];\
INST[0][117] = INST[1][138] ^ INST[1][156];\
INST[0][118] = INST[1][156] ^ INST[1][163];\
INST[0][119] = INST[1][163] ^ INST[1][76];\
INST[0][120] = INST[1][76] ^ INST[1][19];\
INST[0][121] = INST[1][19] ^ INST[1][98];\
INST[0][122] = INST[1][98] ^ INST[1][146];\
INST[0][123] = INST[1][146] ^ INST[1][11];\
INST[0][124] = INST[1][11] ^ INST[1][15];\
INST[0][125] = INST[1][15] ^ INST[1][107];\
INST[0][126] = INST[1][107] ^ INST[1][140];\
INST[0][127] = INST[1][140] ^ INST[1][6];\
INST[0][128] = INST[1][6] ^ INST[1][120];\
INST[0][129] = INST[1][120] ^ INST[1][129];\
INST[0][130] = INST[1][129] ^ INST[1][123];\
INST[0][131] = INST[1][123] ^ INST[1][166];\
INST[0][132] = INST[1][166] ^ INST[1][150];\
INST[0][133] = INST[1][150] ^ INST[1][14];\
INST[0][134] = INST[1][14] ^ INST[1][101];\
INST[0][135] = INST[1][101] ^ INST[1][157];\
INST[0][136] = INST[1][157] ^ INST[1][49];\
INST[0][137] = INST[1][49] ^ INST[1][37];\
INST[0][138] = INST[1][37] ^ INST[1][119];\
INST[0][139] = INST[1][119] ^ INST[1][13];\
INST[0][140] = INST[1][13] ^ INST[1][30];\
INST[0][141] = INST[1][30] ^ INST[1][100];\
INST[0][142] = INST[1][100] ^ INST[1][81];\
INST[0][143] = INST[1][81] ^ INST[1][17];\
INST[0][144] = INST[1][17] ^ INST[1][118];\
INST[0][145] = INST[1][118] ^ INST[1][45];\
INST[0][146] = INST[1][45] ^ INST[1][20];\
INST[0][147] = INST[1][20] ^ INST[1][47];\
INST[0][148] = INST[1][47] ^ INST[1][106];\
INST[0][149] = INST[1][106] ^ INST[1][102];\
INST[0][150] = INST[1][102] ^ INST[1][131];\
INST[0][151] = INST[1][131] ^ INST[1][38];\
INST[0][152] = INST[1][38] ^ INST[1][75];\
INST[0][153] = INST[1][75] ^ INST[1][104];\
INST[0][154] = INST[1][104] ^ INST[1][31];\
INST[0][155] = INST[1][31] ^ INST[1][43];\
INST[0][156] = INST[1][43] ^ INST[1][62];\
INST[0][157] = INST[1][62] ^ INST[1][105];\
INST[0][158] = INST[1][105] ^ INST[1][9];\
INST[0][159] = INST[1][9] ^ INST[1][79];\
INST[0][160] = INST[1][79] ^ INST[1][124];\
INST[0][161] = INST[1][124] ^ INST[1][51];\
INST[0][162] = INST[1][51] ^ INST[1][67];\
INST[0][163] = INST[1][67] ^ INST[1][144];\
INST[0][164] = INST[1][144] ^ INST[1][26];\
INST[0][165] = INST[1][26] ^ INST[1][83];\
INST[0][166] = INST[1][83] ^ INST[1][122];\
INST[0][167] = INST[1][122] ^ INST[1][63];\
}
#endif
#ifndef XOR6_H
#define XOR6_H
#define XOR6(INST) {\
INST[1][0] = INST[0][118] ^ INST[0][65] ^ INST[0][80];\
INST[1][1] = INST[0][65] ^ INST[0][5];\
INST[1][2] = INST[0][5] ^ INST[0][80];\
INST[1][3] = INST[0][80] ^ INST[0][22];\
INST[1][4] = INST[0][22] ^ INST[0][31];\
INST[1][5] = INST[0][31] ^ INST[0][34];\
INST[1][6] = INST[0][34] ^ INST[0][53];\
INST[1][7] = INST[0][53] ^ INST[0][13];\
INST[1][8] = INST[0][13] ^ INST[0][149];\
INST[1][9] = INST[0][149] ^ INST[0][152];\
INST[1][10] = INST[0][152] ^ INST[0][157];\
INST[1][11] = INST[0][157] ^ INST[0][141];\
INST[1][12] = INST[0][141] ^ INST[0][147];\
INST[1][13] = INST[0][147] ^ INST[0][129];\
INST[1][14] = INST[0][129] ^ INST[0][9];\
INST[1][15] = INST[0][9] ^ INST[0][93];\
INST[1][16] = INST[0][93] ^ INST[0][47];\
INST[1][17] = INST[0][47] ^ INST[0][71];\
INST[1][18] = INST[0][71] ^ INST[0][19];\
INST[1][19] = INST[0][19] ^ INST[0][114];\
INST[1][20] = INST[0][114] ^ INST[0][162];\
INST[1][21] = INST[0][162] ^ INST[0][134];\
INST[1][22] = INST[0][134] ^ INST[0][140];\
INST[1][23] = INST[0][140] ^ INST[0][12];\
INST[1][24] = INST[0][12] ^ INST[0][128];\
INST[1][25] = INST[0][128] ^ INST[0][69];\
INST[1][26] = INST[0][69] ^ INST[0][87];\
INST[1][27] = INST[0][87] ^ INST[0][70];\
INST[1][28] = INST[0][70] ^ INST[0][17];\
INST[1][29] = INST[0][17] ^ INST[0][166];\
INST[1][30] = INST[0][166] ^ INST[0][137];\
INST[1][31] = INST[0][137] ^ INST[0][83];\
INST[1][32] = INST[0][83] ^ INST[0][135];\
INST[1][33] = INST[0][135] ^ INST[0][86];\
INST[1][34] = INST[0][86] ^ INST[0][46];\
INST[1][35] = INST[0][46] ^ INST[0][126];\
INST[1][36] = INST[0][126] ^ INST[0][25];\
INST[1][37] = INST[0][25] ^ INST[0][143];\
INST[1][38] = INST[0][143] ^ INST[0][110];\
INST[1][39] = INST[0][110] ^ INST[0][148];\
INST[1][40] = INST[0][148] ^ INST[0][94];\
INST[1][41] = INST[0][94] ^ INST[0][120];\
INST[1][42] = INST[0][120] ^ INST[0][59];\
INST[1][43] = INST[0][59] ^ INST[0][58];\
INST[1][44] = INST[0][58] ^ INST[0][23];\
INST[1][45] = INST[0][23] ^ INST[0][151];\
INST[1][46] = INST[0][151] ^ INST[0][99];\
INST[1][47] = INST[0][99] ^ INST[0][18];\
INST[1][48] = INST[0][18] ^ INST[0][44];\
INST[1][49] = INST[0][44] ^ INST[0][78];\
INST[1][50] = INST[0][78] ^ INST[0][39];\
INST[1][51] = INST[0][39] ^ INST[0][165];\
INST[1][52] = INST[0][165] ^ INST[0][50];\
INST[1][53] = INST[0][50] ^ INST[0][48];\
INST[1][54] = INST[0][48] ^ INST[0][74];\
INST[1][55] = INST[0][74] ^ INST[0][32];\
INST[1][56] = INST[0][32] ^ INST[0][66];\
INST[1][57] = INST[0][66] ^ INST[0][3];\
INST[1][58] = INST[0][3] ^ INST[0][142];\
INST[1][59] = INST[0][142] ^ INST[0][68];\
INST[1][60] = INST[0][68] ^ INST[0][40];\
INST[1][61] = INST[0][40] ^ INST[0][103];\
INST[1][62] = INST[0][103] ^ INST[0][37];\
INST[1][63] = INST[0][37] ^ INST[0][67];\
INST[1][64] = INST[0][67] ^ INST[0][55];\
INST[1][65] = INST[0][55] ^ INST[0][20];\
INST[1][66] = INST[0][20] ^ INST[0][62];\
INST[1][67] = INST[0][62] ^ INST[0][2];\
INST[1][68] = INST[0][2] ^ INST[0][112];\
INST[1][69] = INST[0][112] ^ INST[0][98];\
INST[1][70] = INST[0][98] ^ INST[0][95];\
INST[1][71] = INST[0][95] ^ INST[0][82];\
INST[1][72] = INST[0][82] ^ INST[0][6];\
INST[1][73] = INST[0][6] ^ INST[0][105];\
INST[1][74] = INST[0][105] ^ INST[0][124];\
INST[1][75] = INST[0][124] ^ INST[0][15];\
INST[1][76] = INST[0][15] ^ INST[0][102];\
INST[1][77] = INST[0][102] ^ INST[0][21];\
INST[1][78] = INST[0][21] ^ INST[0][139];\
INST[1][79] = INST[0][139] ^ INST[0][111];\
INST[1][80] = INST[0][111] ^ INST[0][8];\
INST[1][81] = INST[0][8] ^ INST[0][92];\
INST[1][82] = INST[0][92] ^ INST[0][49];\
INST[1][83] = INST[0][49] ^ INST[0][52];\
INST[1][84] = INST[0][52] ^ INST[0][119];\
INST[1][85] = INST[0][119] ^ INST[0][35];\
INST[1][86] = INST[0][35] ^ INST[0][30];\
INST[1][87] = INST[0][30] ^ INST[0][89];\
INST[1][88] = INST[0][89] ^ INST[0][136];\
INST[1][89] = INST[0][136] ^ INST[0][28];\
INST[1][90] = INST[0][28] ^ INST[0][138];\
INST[1][91] = INST[0][138] ^ INST[0][131];\
INST[1][92] = INST[0][131] ^ INST[0][56];\
INST[1][93] = INST[0][56] ^ INST[0][26];\
INST[1][94] = INST[0][26] ^ INST[0][88];\
INST[1][95] = INST[0][88] ^ INST[0][90];\
INST[1][96] = INST[0][90] ^ INST[0][27];\
INST[1][97] = INST[0][27] ^ INST[0][51];\
INST[1][98] = INST[0][51] ^ INST[0][158];\
INST[1][99] = INST[0][158] ^ INST[0][117];\
INST[1][100] = INST[0][117] ^ INST[0][163];\
INST[1][101] = INST[0][163] ^ INST[0][4];\
INST[1][102] = INST[0][4] ^ INST[0][16];\
INST[1][103] = INST[0][16] ^ INST[0][29];\
INST[1][104] = INST[0][29] ^ INST[0][130];\
INST[1][105] = INST[0][130] ^ INST[0][75];\
INST[1][106] = INST[0][75] ^ INST[0][100];\
INST[1][107] = INST[0][100] ^ INST[0][125];\
INST[1][108] = INST[0][125] ^ INST[0][72];\
INST[1][109] = INST[0][72] ^ INST[0][81];\
INST[1][110] = INST[0][81] ^ INST[0][109];\
INST[1][111] = INST[0][109] ^ INST[0][122];\
INST[1][112] = INST[0][122] ^ INST[0][76];\
INST[1][113] = INST[0][76] ^ INST[0][73];\
INST[1][114] = INST[0][73] ^ INST[0][64];\
INST[1][115] = INST[0][64] ^ INST[0][41];\
INST[1][116] = INST[0][41] ^ INST[0][106];\
INST[1][117] = INST[0][106] ^ INST[0][14];\
INST[1][118] = INST[0][14] ^ INST[0][97];\
INST[1][119] = INST[0][97] ^ INST[0][38];\
INST[1][120] = INST[0][38] ^ INST[0][153];\
INST[1][121] = INST[0][153] ^ INST[0][24];\
INST[1][122] = INST[0][24] ^ INST[0][113];\
INST[1][123] = INST[0][113] ^ INST[0][42];\
INST[1][124] = INST[0][42] ^ INST[0][133];\
INST[1][125] = INST[0][133] ^ INST[0][96];\
INST[1][126] = INST[0][96] ^ INST[0][127];\
INST[1][127] = INST[0][127] ^ INST[0][91];\
INST[1][128] = INST[0][91] ^ INST[0][10];\
INST[1][129] = INST[0][10] ^ INST[0][121];\
INST[1][130] = INST[0][121] ^ INST[0][123];\
INST[1][131] = INST[0][123] ^ INST[0][154];\
INST[1][132] = INST[0][154] ^ INST[0][61];\
INST[1][133] = INST[0][61] ^ INST[0][161];\
INST[1][134] = INST[0][161] ^ INST[0][150];\
INST[1][135] = INST[0][150] ^ INST[0][160];\
INST[1][136] = INST[0][160] ^ INST[0][155];\
INST[1][137] = INST[0][155] ^ INST[0][101];\
INST[1][138] = INST[0][101] ^ INST[0][144];\
INST[1][139] = INST[0][144] ^ INST[0][104];\
INST[1][140] = INST[0][104] ^ INST[0][1];\
INST[1][141] = INST[0][1] ^ INST[0][115];\
INST[1][142] = INST[0][115] ^ INST[0][63];\
INST[1][143] = INST[0][63] ^ INST[0][45];\
INST[1][144] = INST[0][45] ^ INST[0][79];\
INST[1][145] = INST[0][79] ^ INST[0][107];\
INST[1][146] = INST[0][107] ^ INST[0][164];\
INST[1][147] = INST[0][164] ^ INST[0][156];\
INST[1][148] = INST[0][156] ^ INST[0][108];\
INST[1][149] = INST[0][108] ^ INST[0][36];\
INST[1][150] = INST[0][36] ^ INST[0][60];\
INST[1][151] = INST[0][60] ^ INST[0][77];\
INST[1][152] = INST[0][77] ^ INST[0][84];\
INST[1][153] = INST[0][84] ^ INST[0][159];\
INST[1][154] = INST[0][159] ^ INST[0][145];\
INST[1][155] = INST[0][145] ^ INST[0][167];\
INST[1][156] = INST[0][167] ^ INST[0][54];\
INST[1][157] = INST[0][54] ^ INST[0][132];\
INST[1][158] = INST[0][132] ^ INST[0][116];\
INST[1][159] = INST[0][116] ^ INST[0][85];\
INST[1][160] = INST[0][85] ^ INST[0][11];\
INST[1][161] = INST[0][11] ^ INST[0][7];\
INST[1][162] = INST[0][7] ^ INST[0][43];\
INST[1][163] = INST[0][43] ^ INST[0][57];\
INST[1][164] = INST[0][57] ^ INST[0][146];\
INST[1][165] = INST[0][146] ^ INST[0][0];\
INST[1][166] = INST[0][0] ^ INST[0][33];\
INST[1][167] = INST[0][33] ^ INST[0][118];\
}
#endif
#ifndef XOR7_H
#define XOR7_H
#define XOR7(INST) {\
INST[0][0] = INST[1][47] ^ INST[1][23] ^ INST[1][104];\
INST[0][1] = INST[1][23] ^ INST[1][35];\
INST[0][2] = INST[1][35] ^ INST[1][104];\
INST[0][3] = INST[1][104] ^ INST[1][146];\
INST[0][4] = INST[1][146] ^ INST[1][67];\
INST[0][5] = INST[1][67] ^ INST[1][129];\
INST[0][6] = INST[1][129] ^ INST[1][89];\
INST[0][7] = INST[1][89] ^ INST[1][159];\
INST[0][8] = INST[1][159] ^ INST[1][10];\
INST[0][9] = INST[1][10] ^ INST[1][24];\
INST[0][10] = INST[1][24] ^ INST[1][147];\
INST[0][11] = INST[1][147] ^ INST[1][137];\
INST[0][12] = INST[1][137] ^ INST[1][64];\
INST[0][13] = INST[1][64] ^ INST[1][143];\
INST[0][14] = INST[1][143] ^ INST[1][93];\
INST[0][15] = INST[1][93] ^ INST[1][158];\
INST[0][16] = INST[1][158] ^ INST[1][44];\
INST[0][17] = INST[1][44] ^ INST[1][128];\
INST[0][18] = INST[1][128] ^ INST[1][82];\
INST[0][19] = INST[1][82] ^ INST[1][37];\
INST[0][20] = INST[1][37] ^ INST[1][119];\
INST[0][21] = INST[1][119] ^ INST[1][66];\
INST[0][22] = INST[1][66] ^ INST[1][71];\
INST[0][23] = INST[1][71] ^ INST[1][27];\
INST[0][24] = INST[1][27] ^ INST[1][34];\
INST[0][25] = INST[1][34] ^ INST[1][121];\
INST[0][26] = INST[1][121] ^ INST[1][118];\
INST[0][27] = INST[1][118] ^ INST[1][98];\
INST[0][28] = INST[1][98] ^ INST[1][139];\
INST[0][29] = INST[1][139] ^ INST[1][111];\
INST[0][30] = INST[1][111] ^ INST[1][8];\
INST[0][31] = INST[1][8] ^ INST[1][5];\
INST[0][32] = INST[1][5] ^ INST[1][108];\
INST[0][33] = INST[1][108] ^ INST[1][14];\
INST[0][34] = INST[1][14] ^ INST[1][11];\
INST[0][35] = INST[1][11] ^ INST[1][124];\
INST[0][36] = INST[1][124] ^ INST[1][65];\
INST[0][37] = INST[1][65] ^ INST[1][21];\
INST[0][38] = INST[1][21] ^ INST[1][22];\
INST[0][39] = INST[1][22] ^ INST[1][100];\
INST[0][40] = INST[1][100] ^ INST[1][92];\
INST[0][41] = INST[1][92] ^ INST[1][50];\
INST[0][42] = INST[1][50] ^ INST[1][153];\
INST[0][43] = INST[1][153] ^ INST[1][79];\
INST[0][44] = INST[1][79] ^ INST[1][80];\
INST[0][45] = INST[1][80] ^ INST[1][150];\
INST[0][46] = INST[1][150] ^ INST[1][60];\
INST[0][47] = INST[1][60] ^ INST[1][133];\
INST[0][48] = INST[1][133] ^ INST[1][77];\
INST[0][49] = INST[1][77] ^ INST[1][20];\
INST[0][50] = INST[1][20] ^ INST[1][39];\
INST[0][51] = INST[1][39] ^ INST[1][13];\
INST[0][52] = INST[1][13] ^ INST[1][61];\
INST[0][53] = INST[1][61] ^ INST[1][154];\
INST[0][54] = INST[1][154] ^ INST[1][157];\
INST[0][55] = INST[1][157] ^ INST[1][106];\
INST[0][56] = INST[1][106] ^ INST[1][125];\
INST[0][57] = INST[1][125] ^ INST[1][18];\
INST[0][58] = INST[1][18] ^ INST[1][144];\
INST[0][59] = INST[1][144] ^ INST[1][7];\
INST[0][60] = INST[1][7] ^ INST[1][117];\
INST[0][61] = INST[1][117] ^ INST[1][102];\
INST[0][62] = INST[1][102] ^ INST[1][145];\
INST[0][63] = INST[1][145] ^ INST[1][84];\
INST[0][64] = INST[1][84] ^ INST[1][1];\
INST[0][65] = INST[1][1] ^ INST[1][3];\
INST[0][66] = INST[1][3] ^ INST[1][6];\
INST[0][67] = INST[1][6] ^ INST[1][134];\
INST[0][68] = INST[1][134] ^ INST[1][90];\
INST[0][69] = INST[1][90] ^ INST[1][105];\
INST[0][70] = INST[1][105] ^ INST[1][110];\
INST[0][71] = INST[1][110] ^ INST[1][51];\
INST[0][72] = INST[1][51] ^ INST[1][152];\
INST[0][73] = INST[1][152] ^ INST[1][156];\
INST[0][74] = INST[1][156] ^ INST[1][107];\
INST[0][75] = INST[1][107] ^ INST[1][33];\
INST[0][76] = INST[1][33] ^ INST[1][40];\
INST[0][77] = INST[1][40] ^ INST[1][70];\
INST[0][78] = INST[1][70] ^ INST[1][95];\
INST[0][79] = INST[1][95] ^ INST[1][120];\
INST[0][80] = INST[1][120] ^ INST[1][96];\
INST[0][81] = INST[1][96] ^ INST[1][160];\
INST[0][82] = INST[1][160] ^ INST[1][58];\
INST[0][83] = INST[1][58] ^ INST[1][17];\
INST[0][84] = INST[1][17] ^ INST[1][113];\
INST[0][85] = INST[1][113] ^ INST[1][15];\
INST[0][86] = INST[1][15] ^ INST[1][78];\
INST[0][87] = INST[1][78] ^ INST[1][88];\
INST[0][88] = INST[1][88] ^ INST[1][130];\
INST[0][89] = INST[1][130] ^ INST[1][38];\
INST[0][90] = INST[1][38] ^ INST[1][116];\
INST[0][91] = INST[1][116] ^ INST[1][101];\
INST[0][92] = INST[1][101] ^ INST[1][12];\
INST[0][93] = INST[1][12] ^ INST[1][16];\
INST[0][94] = INST[1][16] ^ INST[1][45];\
INST[0][95] = INST[1][45] ^ INST[1][122];\
INST[0][96] = INST[1][122] ^ INST[1][91];\
INST[0][97] = INST[1][91] ^ INST[1][115];\
INST[0][98] = INST[1][115] ^ INST[1][148];\
INST[0][99] = INST[1][148] ^ INST[1][52];\
INST[0][100] = INST[1][52] ^ INST[1][72];\
INST[0][101] = INST[1][72] ^ INST[1][114];\
INST[0][102] = INST[1][114] ^ INST[1][155];\
INST[0][103] = INST[1][155] ^ INST[1][32];\
INST[0][104] = INST[1][32] ^ INST[1][41];\
INST[0][105] = INST[1][41] ^ INST[1][48];\
INST[0][106] = INST[1][48] ^ INST[1][103];\
INST[0][107] = INST[1][103] ^ INST[1][166];\
INST[0][108] = INST[1][166] ^ INST[1][56];\
INST[0][109] = INST[1][56] ^ INST[1][76];\
INST[0][110] = INST[1][76] ^ INST[1][112];\
INST[0][111] = INST[1][112] ^ INST[1][81];\
INST[0][112] = INST[1][81] ^ INST[1][135];\
INST[0][113] = INST[1][135] ^ INST[1][55];\
INST[0][114] = INST[1][55] ^ INST[1][94];\
INST[0][115] = INST[1][94] ^ INST[1][109];\
INST[0][116] = INST[1][109] ^ INST[1][42];\
INST[0][117] = INST[1][42] ^ INST[1][167];\
INST[0][118] = INST[1][167] ^ INST[1][151];\
INST[0][119] = INST[1][151] ^ INST[1][75];\
INST[0][120] = INST[1][75] ^ INST[1][28];\
INST[0][121] = INST[1][28] ^ INST[1][132];\
INST[0][122] = INST[1][132] ^ INST[1][85];\
INST[0][123] = INST[1][85] ^ INST[1][131];\
INST[0][124] = INST[1][131] ^ INST[1][163];\
INST[0][125] = INST[1][163] ^ INST[1][53];\
INST[0][126] = INST[1][53] ^ INST[1][73];\
INST[0][127] = INST[1][73] ^ INST[1][161];\
INST[0][128] = INST[1][161] ^ INST[1][97];\
INST[0][129] = INST[1][97] ^ INST[1][162];\
INST[0][130] = INST[1][162] ^ INST[1][126];\
INST[0][131] = INST[1][126] ^ INST[1][54];\
INST[0][132] = INST[1][54] ^ INST[1][4];\
INST[0][133] = INST[1][4] ^ INST[1][36];\
INST[0][134] = INST[1][36] ^ INST[1][30];\
INST[0][135] = INST[1][30] ^ INST[1][99];\
INST[0][136] = INST[1][99] ^ INST[1][149];\
INST[0][137] = INST[1][149] ^ INST[1][164];\
INST[0][138] = INST[1][164] ^ INST[1][57];\
INST[0][139] = INST[1][57] ^ INST[1][49];\
INST[0][140] = INST[1][49] ^ INST[1][9];\
INST[0][141] = INST[1][9] ^ INST[1][127];\
INST[0][142] = INST[1][127] ^ INST[1][142];\
INST[0][143] = INST[1][142] ^ INST[1][136];\
INST[0][144] = INST[1][136] ^ INST[1][46];\
INST[0][145] = INST[1][46] ^ INST[1][62];\
INST[0][146] = INST[1][62] ^ INST[1][68];\
INST[0][147] = INST[1][68] ^ INST[1][0];\
INST[0][148] = INST[1][0] ^ INST[1][31];\
INST[0][149] = INST[1][31] ^ INST[1][19];\
INST[0][150] = INST[1][19] ^ INST[1][165];\
INST[0][151] = INST[1][165] ^ INST[1][26];\
INST[0][152] = INST[1][26] ^ INST[1][86];\
INST[0][153] = INST[1][86] ^ INST[1][87];\
INST[0][154] = INST[1][87] ^ INST[1][59];\
INST[0][155] = INST[1][59] ^ INST[1][69];\
INST[0][156] = INST[1][69] ^ INST[1][43];\
INST[0][157] = INST[1][43] ^ INST[1][25];\
INST[0][158] = INST[1][25] ^ INST[1][2];\
INST[0][159] = INST[1][2] ^ INST[1][123];\
INST[0][160] = INST[1][123] ^ INST[1][74];\
INST[0][161] = INST[1][74] ^ INST[1][63];\
INST[0][162] = INST[1][63] ^ INST[1][138];\
INST[0][163] = INST[1][138] ^ INST[1][83];\
INST[0][164] = INST[1][83] ^ INST[1][140];\
INST[0][165] = INST[1][140] ^ INST[1][141];\
INST[0][166] = INST[1][141] ^ INST[1][29];\
INST[0][167] = INST[1][29] ^ INST[1][47];\
}
#endif
#ifndef XOR8_H
#define XOR8_H
#define XOR8(INST) {\
INST[1][0] = INST[0][44] ^ INST[0][118] ^ INST[0][59];\
INST[1][1] = INST[0][118] ^ INST[0][134];\
INST[1][2] = INST[0][134] ^ INST[0][59];\
INST[1][3] = INST[0][59] ^ INST[0][139];\
INST[1][4] = INST[0][139] ^ INST[0][150];\
INST[1][5] = INST[0][150] ^ INST[0][51];\
INST[1][6] = INST[0][51] ^ INST[0][60];\
INST[1][7] = INST[0][60] ^ INST[0][132];\
INST[1][8] = INST[0][132] ^ INST[0][89];\
INST[1][9] = INST[0][89] ^ INST[0][166];\
INST[1][10] = INST[0][166] ^ INST[0][144];\
INST[1][11] = INST[0][144] ^ INST[0][75];\
INST[1][12] = INST[0][75] ^ INST[0][162];\
INST[1][13] = INST[0][162] ^ INST[0][115];\
INST[1][14] = INST[0][115] ^ INST[0][63];\
INST[1][15] = INST[0][63] ^ INST[0][68];\
INST[1][16] = INST[0][68] ^ INST[0][14];\
INST[1][17] = INST[0][14] ^ INST[0][143];\
INST[1][18] = INST[0][143] ^ INST[0][102];\
INST[1][19] = INST[0][102] ^ INST[0][126];\
INST[1][20] = INST[0][126] ^ INST[0][34];\
INST[1][21] = INST[0][34] ^ INST[0][153];\
INST[1][22] = INST[0][153] ^ INST[0][40];\
INST[1][23] = INST[0][40] ^ INST[0][24];\
INST[1][24] = INST[0][24] ^ INST[0][45];\
INST[1][25] = INST[0][45] ^ INST[0][27];\
INST[1][26] = INST[0][27] ^ INST[0][104];\
INST[1][27] = INST[0][104] ^ INST[0][131];\
INST[1][28] = INST[0][131] ^ INST[0][120];\
INST[1][29] = INST[0][120] ^ INST[0][72];\
INST[1][30] = INST[0][72] ^ INST[0][54];\
INST[1][31] = INST[0][54] ^ INST[0][0];\
INST[1][32] = INST[0][0] ^ INST[0][160];\
INST[1][33] = INST[0][160] ^ INST[0][112];\
INST[1][34] = INST[0][112] ^ INST[0][79];\
INST[1][35] = INST[0][79] ^ INST[0][64];\
INST[1][36] = INST[0][64] ^ INST[0][36];\
INST[1][37] = INST[0][36] ^ INST[0][77];\
INST[1][38] = INST[0][77] ^ INST[0][38];\
INST[1][39] = INST[0][38] ^ INST[0][127];\
INST[1][40] = INST[0][127] ^ INST[0][121];\
INST[1][41] = INST[0][121] ^ INST[0][17];\
INST[1][42] = INST[0][17] ^ INST[0][28];\
INST[1][43] = INST[0][28] ^ INST[0][52];\
INST[1][44] = INST[0][52] ^ INST[0][43];\
INST[1][45] = INST[0][43] ^ INST[0][86];\
INST[1][46] = INST[0][86] ^ INST[0][142];\
INST[1][47] = INST[0][142] ^ INST[0][37];\
INST[1][48] = INST[0][37] ^ INST[0][70];\
INST[1][49] = INST[0][70] ^ INST[0][99];\
INST[1][50] = INST[0][99] ^ INST[0][18];\
INST[1][51] = INST[0][18] ^ INST[0][113];\
INST[1][52] = INST[0][113] ^ INST[0][94];\
INST[1][53] = INST[0][94] ^ INST[0][154];\
INST[1][54] = INST[0][154] ^ INST[0][135];\
INST[1][55] = INST[0][135] ^ INST[0][88];\
INST[1][56] = INST[0][88] ^ INST[0][80];\
INST[1][57] = INST[0][80] ^ INST[0][141];\
INST[1][58] = INST[0][141] ^ INST[0][129];\
INST[1][59] = INST[0][129] ^ INST[0][33];\
INST[1][60] = INST[0][33] ^ INST[0][93];\
INST[1][61] = INST[0][93] ^ INST[0][108];\
INST[1][62] = INST[0][108] ^ INST[0][138];\
INST[1][63] = INST[0][138] ^ INST[0][65];\
INST[1][64] = INST[0][65] ^ INST[0][53];\
INST[1][65] = INST[0][53] ^ INST[0][26];\
INST[1][66] = INST[0][26] ^ INST[0][167];\
INST[1][67] = INST[0][167] ^ INST[0][107];\
INST[1][68] = INST[0][107] ^ INST[0][41];\
INST[1][69] = INST[0][41] ^ INST[0][159];\
INST[1][70] = INST[0][159] ^ INST[0][165];\
INST[1][71] = INST[0][165] ^ INST[0][62];\
INST[1][72] = INST[0][62] ^ INST[0][3];\
INST[1][73] = INST[0][3] ^ INST[0][39];\
INST[1][74] = INST[0][39] ^ INST[0][151];\
INST[1][75] = INST[0][151] ^ INST[0][74];\
INST[1][76] = INST[0][74] ^ INST[0][122];\
INST[1][77] = INST[0][122] ^ INST[0][146];\
INST[1][78] = INST[0][146] ^ INST[0][147];\
INST[1][79] = INST[0][147] ^ INST[0][55];\
INST[1][80] = INST[0][55] ^ INST[0][61];\
INST[1][81] = INST[0][61] ^ INST[0][42];\
INST[1][82] = INST[0][42] ^ INST[0][123];\
INST[1][83] = INST[0][123] ^ INST[0][8];\
INST[1][84] = INST[0][8] ^ INST[0][136];\
INST[1][85] = INST[0][136] ^ INST[0][109];\
INST[1][86] = INST[0][109] ^ INST[0][157];\
INST[1][87] = INST[0][157] ^ INST[0][13];\
INST[1][88] = INST[0][13] ^ INST[0][152];\
INST[1][89] = INST[0][152] ^ INST[0][49];\
INST[1][90] = INST[0][49] ^ INST[0][46];\
INST[1][91] = INST[0][46] ^ INST[0][98];\
INST[1][92] = INST[0][98] ^ INST[0][25];\
INST[1][93] = INST[0][25] ^ INST[0][84];\
INST[1][94] = INST[0][84] ^ INST[0][32];\
INST[1][95] = INST[0][32] ^ INST[0][95];\
INST[1][96] = INST[0][95] ^ INST[0][124];\
INST[1][97] = INST[0][124] ^ INST[0][5];\
INST[1][98] = INST[0][5] ^ INST[0][137];\
INST[1][99] = INST[0][137] ^ INST[0][58];\
INST[1][100] = INST[0][58] ^ INST[0][69];\
INST[1][101] = INST[0][69] ^ INST[0][103];\
INST[1][102] = INST[0][103] ^ INST[0][9];\
INST[1][103] = INST[0][9] ^ INST[0][117];\
INST[1][104] = INST[0][117] ^ INST[0][100];\
INST[1][105] = INST[0][100] ^ INST[0][76];\
INST[1][106] = INST[0][76] ^ INST[0][2];\
INST[1][107] = INST[0][2] ^ INST[0][22];\
INST[1][108] = INST[0][22] ^ INST[0][125];\
INST[1][109] = INST[0][125] ^ INST[0][105];\
INST[1][110] = INST[0][105] ^ INST[0][96];\
INST[1][111] = INST[0][96] ^ INST[0][133];\
INST[1][112] = INST[0][133] ^ INST[0][31];\
INST[1][113] = INST[0][31] ^ INST[0][81];\
INST[1][114] = INST[0][81] ^ INST[0][29];\
INST[1][115] = INST[0][29] ^ INST[0][156];\
INST[1][116] = INST[0][156] ^ INST[0][83];\
INST[1][117] = INST[0][83] ^ INST[0][4];\
INST[1][118] = INST[0][4] ^ INST[0][163];\
INST[1][119] = INST[0][163] ^ INST[0][19];\
INST[1][120] = INST[0][19] ^ INST[0][130];\
INST[1][121] = INST[0][130] ^ INST[0][10];\
INST[1][122] = INST[0][10] ^ INST[0][119];\
INST[1][123] = INST[0][119] ^ INST[0][11];\
INST[1][124] = INST[0][11] ^ INST[0][116];\
INST[1][125] = INST[0][116] ^ INST[0][7];\
INST[1][126] = INST[0][7] ^ INST[0][20];\
INST[1][127] = INST[0][20] ^ INST[0][73];\
INST[1][128] = INST[0][73] ^ INST[0][114];\
INST[1][129] = INST[0][114] ^ INST[0][85];\
INST[1][130] = INST[0][85] ^ INST[0][158];\
INST[1][131] = INST[0][158] ^ INST[0][92];\
INST[1][132] = INST[0][92] ^ INST[0][47];\
INST[1][133] = INST[0][47] ^ INST[0][71];\
INST[1][134] = INST[0][71] ^ INST[0][90];\
INST[1][135] = INST[0][90] ^ INST[0][128];\
INST[1][136] = INST[0][128] ^ INST[0][48];\
INST[1][137] = INST[0][48] ^ INST[0][140];\
INST[1][138] = INST[0][140] ^ INST[0][35];\
INST[1][139] = INST[0][35] ^ INST[0][155];\
INST[1][140] = INST[0][155] ^ INST[0][12];\
INST[1][141] = INST[0][12] ^ INST[0][23];\
INST[1][142] = INST[0][23] ^ INST[0][148];\
INST[1][143] = INST[0][148] ^ INST[0][82];\
INST[1][144] = INST[0][82] ^ INST[0][110];\
INST[1][145] = INST[0][110] ^ INST[0][78];\
INST[1][146] = INST[0][78] ^ INST[0][30];\
INST[1][147] = INST[0][30] ^ INST[0][97];\
INST[1][148] = INST[0][97] ^ INST[0][161];\
INST[1][149] = INST[0][161] ^ INST[0][145];\
INST[1][150] = INST[0][145] ^ INST[0][57];\
INST[1][151] = INST[0][57] ^ INST[0][21];\
INST[1][152] = INST[0][21] ^ INST[0][1];\
INST[1][153] = INST[0][1] ^ INST[0][67];\
INST[1][154] = INST[0][67] ^ INST[0][149];\
INST[1][155] = INST[0][149] ^ INST[0][111];\
INST[1][156] = INST[0][111] ^ INST[0][66];\
INST[1][157] = INST[0][66] ^ INST[0][6];\
INST[1][158] = INST[0][6] ^ INST[0][106];\
INST[1][159] = INST[0][106] ^ INST[0][91];\
INST[1][160] = INST[0][91] ^ INST[0][50];\
INST[1][161] = INST[0][50] ^ INST[0][87];\
INST[1][162] = INST[0][87] ^ INST[0][101];\
INST[1][163] = INST[0][101] ^ INST[0][16];\
INST[1][164] = INST[0][16] ^ INST[0][164];\
INST[1][165] = INST[0][164] ^ INST[0][15];\
INST[1][166] = INST[0][15] ^ INST[0][56];\
INST[1][167] = INST[0][56] ^ INST[0][44];\
}
#endif
#ifndef SBOX9_H
#define SBOX9_H
#define SBOX9(INST) {\
uint8_t N0;\
uint8_t N1;\
uint8_t N2;\
uint8_t N3;\
uint8_t N4;\
uint8_t N5;\
uint8_t N6;\
uint8_t N7;\
uint8_t N8;\
uint8_t N9;\
uint8_t N10;\
uint8_t N11;\
uint8_t N12;\
uint8_t N13;\
N0 = ~INST[1][131];\
N1 = N0 & INST[1][4];\
N2 = N0 & INST[1][39];\
N3 = N1 | N2;\
N4 = INST[1][4] & INST[1][39];\
N5 = INST[1][131] & INST[1][4];\
N6 = ~INST[1][39];\
N7 = N6 & INST[1][131];\
N8 = N5 | N7;\
N9 = N6 & INST[1][4];\
N10 = N0 & INST[1][4];\
N11 = N0 & N6;\
N12 = N10 | N11;\
N13 = N6 & INST[1][4];\
INST[0][0]= N12 | N13;\
INST[0][1]= N8 | N9;\
INST[0][2]= N3 | N4;\
N0 = ~INST[1][61];\
N1 = N0 & INST[1][151];\
N2 = N0 & INST[1][166];\
N3 = N1 | N2;\
N4 = INST[1][151] & INST[1][166];\
N5 = INST[1][61] & INST[1][151];\
N6 = ~INST[1][166];\
N7 = N6 & INST[1][61];\
N8 = N5 | N7;\
N9 = N6 & INST[1][151];\
N10 = N0 & INST[1][151];\
N11 = N0 & N6;\
N12 = N10 | N11;\
N13 = N6 & INST[1][151];\
INST[0][3]= N12 | N13;\
INST[0][4]= N8 | N9;\
INST[0][5]= N3 | N4;\
N0 = ~INST[1][89];\
N1 = N0 & INST[1][57];\
N2 = N0 & INST[1][98];\
N3 = N1 | N2;\
N4 = INST[1][57] & INST[1][98];\
N5 = INST[1][89] & INST[1][57];\
N6 = ~INST[1][98];\
N7 = N6 & INST[1][89];\
N8 = N5 | N7;\
N9 = N6 & INST[1][57];\
N10 = N0 & INST[1][57];\
N11 = N0 & N6;\
N12 = N10 | N11;\
N13 = N6 & INST[1][57];\
INST[0][6]= N12 | N13;\
INST[0][7]= N8 | N9;\
INST[0][8]= N3 | N4;\
N0 = ~INST[1][154];\
N1 = N0 & INST[1][155];\
N2 = N0 & INST[1][17];\
N3 = N1 | N2;\
N4 = INST[1][155] & INST[1][17];\
N5 = INST[1][154] & INST[1][155];\
N6 = ~INST[1][17];\
N7 = N6 & INST[1][154];\
N8 = N5 | N7;\
N9 = N6 & INST[1][155];\
N10 = N0 & INST[1][155];\
N11 = N0 & N6;\
N12 = N10 | N11;\
N13 = N6 & INST[1][155];\
INST[0][9]= N12 | N13;\
INST[0][10]= N8 | N9;\
INST[0][11]= N3 | N4;\
N0 = ~INST[1][21];\
N1 = N0 & INST[1][49];\
N2 = N0 & INST[1][73];\
N3 = N1 | N2;\
N4 = INST[1][49] & INST[1][73];\
N5 = INST[1][21] & INST[1][49];\
N6 = ~INST[1][73];\
N7 = N6 & INST[1][21];\
N8 = N5 | N7;\
N9 = N6 & INST[1][49];\
N10 = N0 & INST[1][49];\
N11 = N0 & N6;\
N12 = N10 | N11;\
N13 = N6 & INST[1][49];\
INST[0][12]= N12 | N13;\
INST[0][13]= N8 | N9;\
INST[0][14]= N3 | N4;\
N0 = ~INST[1][110];\
N1 = N0 & INST[1][91];\
N2 = N0 & INST[1][45];\
N3 = N1 | N2;\
N4 = INST[1][91] & INST[1][45];\
N5 = INST[1][110] & INST[1][91];\
N6 = ~INST[1][45];\
N7 = N6 & INST[1][110];\
N8 = N5 | N7;\
N9 = N6 & INST[1][91];\
N10 = N0 & INST[1][91];\
N11 = N0 & N6;\
N12 = N10 | N11;\
N13 = N6 & INST[1][91];\
INST[0][15]= N12 | N13;\
INST[0][16]= N8 | N9;\
INST[0][17]= N3 | N4;\
N0 = ~INST[1][60];\
N1 = N0 & INST[1][95];\
N2 = N0 & INST[1][113];\
N3 = N1 | N2;\
N4 = INST[1][95] & INST[1][113];\
N5 = INST[1][60] & INST[1][95];\
N6 = ~INST[1][113];\
N7 = N6 & INST[1][60];\
N8 = N5 | N7;\
N9 = N6 & INST[1][95];\
N10 = N0 & INST[1][95];\
N11 = N0 & N6;\
N12 = N10 | N11;\
N13 = N6 & INST[1][95];\
INST[0][18]= N12 | N13;\
INST[0][19]= N8 | N9;\
INST[0][20]= N3 | N4;\
N0 = ~INST[1][125];\
N1 = N0 & INST[1][75];\
N2 = N0 & INST[1][143];\
N3 = N1 | N2;\
N4 = INST[1][75] & INST[1][143];\
N5 = INST[1][125] & INST[1][75];\
N6 = ~INST[1][143];\
N7 = N6 & INST[1][125];\
N8 = N5 | N7;\
N9 = N6 & INST[1][75];\
N10 = N0 & INST[1][75];\
N11 = N0 & N6;\
N12 = N10 | N11;\
N13 = N6 & INST[1][75];\
INST[0][21]= N12 | N13;\
INST[0][22]= N8 | N9;\
INST[0][23]= N3 | N4;\
N0 = ~INST[1][28];\
N1 = N0 & INST[1][158];\
N2 = N0 & INST[1][100];\
N3 = N1 | N2;\
N4 = INST[1][158] & INST[1][100];\
N5 = INST[1][28] & INST[1][158];\
N6 = ~INST[1][100];\
N7 = N6 & INST[1][28];\
N8 = N5 | N7;\
N9 = N6 & INST[1][158];\
N10 = N0 & INST[1][158];\
N11 = N0 & N6;\
N12 = N10 | N11;\
N13 = N6 & INST[1][158];\
INST[0][24]= N12 | N13;\
INST[0][25]= N8 | N9;\
INST[0][26]= N3 | N4;\
N0 = ~INST[1][2];\
N1 = N0 & INST[1][34];\
N2 = N0 & INST[1][120];\
N3 = N1 | N2;\
N4 = INST[1][34] & INST[1][120];\
N5 = INST[1][2] & INST[1][34];\
N6 = ~INST[1][120];\
N7 = N6 & INST[1][2];\
N8 = N5 | N7;\
N9 = N6 & INST[1][34];\
N10 = N0 & INST[1][34];\
N11 = N0 & N6;\
N12 = N10 | N11;\
N13 = N6 & INST[1][34];\
INST[0][27]= N12 | N13;\
INST[0][28]= N8 | N9;\
INST[0][29]= N3 | N4;\
N0 = ~INST[1][5];\
N1 = N0 & INST[1][157];\
N2 = N0 & INST[1][52];\
N3 = N1 | N2;\
N4 = INST[1][157] & INST[1][52];\
N5 = INST[1][5] & INST[1][157];\
N6 = ~INST[1][52];\
N7 = N6 & INST[1][5];\
N8 = N5 | N7;\
N9 = N6 & INST[1][157];\
N10 = N0 & INST[1][157];\
N11 = N0 & N6;\
N12 = N10 | N11;\
N13 = N6 & INST[1][157];\
INST[0][30]= N12 | N13;\
INST[0][31]= N8 | N9;\
INST[0][32]= N3 | N4;\
N0 = ~INST[1][56];\
N1 = N0 & INST[1][99];\
N2 = N0 & INST[1][32];\
N3 = N1 | N2;\
N4 = INST[1][99] & INST[1][32];\
N5 = INST[1][56] & INST[1][99];\
N6 = ~INST[1][32];\
N7 = N6 & INST[1][56];\
N8 = N5 | N7;\
N9 = N6 & INST[1][99];\
N10 = N0 & INST[1][99];\
N11 = N0 & N6;\
N12 = N10 | N11;\
N13 = N6 & INST[1][99];\
INST[0][33]= N12 | N13;\
INST[0][34]= N8 | N9;\
INST[0][35]= N3 | N4;\
N0 = ~INST[1][106];\
N1 = N0 & INST[1][149];\
N2 = N0 & INST[1][26];\
N3 = N1 | N2;\
N4 = INST[1][149] & INST[1][26];\
N5 = INST[1][106] & INST[1][149];\
N6 = ~INST[1][26];\
N7 = N6 & INST[1][106];\
N8 = N5 | N7;\
N9 = N6 & INST[1][149];\
N10 = N0 & INST[1][149];\
N11 = N0 & N6;\
N12 = N10 | N11;\
N13 = N6 & INST[1][149];\
INST[0][36]= N12 | N13;\
INST[0][37]= N8 | N9;\
INST[0][38]= N3 | N4;\
N0 = ~INST[1][138];\
N1 = N0 & INST[1][62];\
N2 = N0 & INST[1][127];\
N3 = N1 | N2;\
N4 = INST[1][62] & INST[1][127];\
N5 = INST[1][138] & INST[1][62];\
N6 = ~INST[1][127];\
N7 = N6 & INST[1][138];\
N8 = N5 | N7;\
N9 = N6 & INST[1][62];\
N10 = N0 & INST[1][62];\
N11 = N0 & N6;\
N12 = N10 | N11;\
N13 = N6 & INST[1][62];\
INST[0][39]= N12 | N13;\
INST[0][40]= N8 | N9;\
INST[0][41]= N3 | N4;\
N0 = ~INST[1][80];\
N1 = N0 & INST[1][87];\
N2 = N0 & INST[1][47];\
N3 = N1 | N2;\
N4 = INST[1][87] & INST[1][47];\
N5 = INST[1][80] & INST[1][87];\
N6 = ~INST[1][47];\
N7 = N6 & INST[1][80];\
N8 = N5 | N7;\
N9 = N6 & INST[1][87];\
N10 = N0 & INST[1][87];\
N11 = N0 & N6;\
N12 = N10 | N11;\
N13 = N6 & INST[1][87];\
INST[0][42]= N12 | N13;\
INST[0][43]= N8 | N9;\
INST[0][44]= N3 | N4;\
N0 = ~INST[1][147];\
N1 = N0 & INST[1][11];\
N2 = N0 & INST[1][68];\
N3 = N1 | N2;\
N4 = INST[1][11] & INST[1][68];\
N5 = INST[1][147] & INST[1][11];\
N6 = ~INST[1][68];\
N7 = N6 & INST[1][147];\
N8 = N5 | N7;\
N9 = N6 & INST[1][11];\
N10 = N0 & INST[1][11];\
N11 = N0 & N6;\
N12 = N10 | N11;\
N13 = N6 & INST[1][11];\
INST[0][45]= N12 | N13;\
INST[0][46]= N8 | N9;\
INST[0][47]= N3 | N4;\
N0 = ~INST[1][55];\
N1 = N0 & INST[1][167];\
N2 = N0 & INST[1][83];\
N3 = N1 | N2;\
N4 = INST[1][167] & INST[1][83];\
N5 = INST[1][55] & INST[1][167];\
N6 = ~INST[1][83];\
N7 = N6 & INST[1][55];\
N8 = N5 | N7;\
N9 = N6 & INST[1][167];\
N10 = N0 & INST[1][167];\
N11 = N0 & N6;\
N12 = N10 | N11;\
N13 = N6 & INST[1][167];\
INST[0][48]= N12 | N13;\
INST[0][49]= N8 | N9;\
INST[0][50]= N3 | N4;\
N0 = ~INST[1][8];\
N1 = N0 & INST[1][132];\
N2 = N0 & INST[1][104];\
N3 = N1 | N2;\
N4 = INST[1][132] & INST[1][104];\
N5 = INST[1][8] & INST[1][132];\
N6 = ~INST[1][104];\
N7 = N6 & INST[1][8];\
N8 = N5 | N7;\
N9 = N6 & INST[1][132];\
N10 = N0 & INST[1][132];\
N11 = N0 & N6;\
N12 = N10 | N11;\
N13 = N6 & INST[1][132];\
INST[0][51]= N12 | N13;\
INST[0][52]= N8 | N9;\
INST[0][53]= N3 | N4;\
N0 = ~INST[1][148];\
N1 = N0 & INST[1][107];\
N2 = N0 & INST[1][109];\
N3 = N1 | N2;\
N4 = INST[1][107] & INST[1][109];\
N5 = INST[1][148] & INST[1][107];\
N6 = ~INST[1][109];\
N7 = N6 & INST[1][148];\
N8 = N5 | N7;\
N9 = N6 & INST[1][107];\
N10 = N0 & INST[1][107];\
N11 = N0 & N6;\
N12 = N10 | N11;\
N13 = N6 & INST[1][107];\
INST[0][54]= N12 | N13;\
INST[0][55]= N8 | N9;\
INST[0][56]= N3 | N4;\
}
#endif
#ifndef FUN_SEL_H
#define FUN_SEL_H
const uint8_t fun_sel[32][11] = {\
{25, 43, 15, 6, 36, 2, 28, 18, 34, 33, 35},\
{4, 10, 3, 8, 14, 39, 26, 19, 9, 22, 42},\
{32, 16, 23, 41, 31, 30, 29, 27, 17, 38, 20},\
{13, 0, 40, 7, 37, 12, 11, 1, 5, 21, 24},\
{9, 3, 5, 42, 8, 23, 30, 1, 6, 36, 31},\
{33, 39, 37, 35, 16, 7, 38, 4, 26, 25, 13},\
{21, 29, 2, 19, 18, 22, 10, 11, 40, 17, 12},\
{32, 15, 41, 24, 27, 0, 43, 14, 34, 20, 28},\
{21, 16, 15, 33, 19, 24, 23, 25, 6, 28, 11},\
{20, 12, 37, 9, 41, 18, 5, 22, 38, 42, 3},\
{27, 4, 32, 14, 30, 36, 2, 8, 35, 13, 43},\
{17, 0, 1, 39, 40, 31, 10, 29, 34, 7, 26},\
{34, 32, 42, 26, 33, 18, 37, 19, 30, 10, 21},\
{2, 38, 23, 29, 41, 24, 28, 12, 0, 16, 6},\
{5, 4, 35, 31, 8, 14, 27, 1, 20, 25, 36},\
{15, 13, 17, 7, 3, 9, 39, 40, 11, 22, 43},\
{28, 23, 21, 2, 29, 33, 7, 5, 25, 20, 27},\
{1, 32, 4, 22, 34, 16, 17, 14, 40, 31, 37},\
{6, 11, 10, 26, 18, 42, 36, 30, 0, 19, 8},\
{3, 24, 41, 35, 43, 13, 39, 12, 15, 9, 38},\
{5, 33, 3, 30, 17, 18, 11, 2, 10, 43, 19},\
{1, 20, 14, 16, 40, 31, 38, 23, 8, 28, 34},\
{7, 41, 35, 39, 36, 0, 22, 27, 12, 15, 9},\
{26, 25, 21, 6, 32, 4, 24, 13, 42, 37, 29},\
{26, 39, 11, 21, 8, 43, 9, 40, 17, 7, 1},\
{6, 24, 37, 33, 2, 42, 41, 20, 12, 25, 34},\
{10, 35, 19, 30, 28, 31, 4, 32, 5, 3, 22},\
{13, 18, 23, 15, 16, 0, 14, 36, 38, 27, 29},\
{6, 5, 3, 26, 12, 7, 28, 21, 14, 25, 36},\
{24, 8, 41, 30, 2, 9, 11, 42, 31, 13, 0},\
{35, 16, 43, 33, 22, 37, 27, 20, 23, 17, 18},\
{1, 38, 10, 19, 40, 4, 34, 32, 15, 39, 29},\
};
#endif
#define HASH_KEY_WIDTH 160
#define HASH_SEED_WIDTH 8
#define HASH_KEY_SIZE (HASH_KEY_WIDTH + HASH_SEED_WIDTH)
#define HASH_KEY_WORDS ((HASH_KEY_SIZE + 31) / 32) 
#define HASH_SLICES ((CAM_MAX_KEY_WIDTH + HASH_KEY_WIDTH - 1) / HASH_KEY_WIDTH)
#define CLOG2(N) (32 - __builtin_clz((uint32_t) ((N) - 1)))
struct hash_t {
uint32_t key[HASH_SLICES][HASH_KEY_WORDS];
uint8_t slices;
uint8_t bs[2][HASH_KEY_SIZE];
bool slice_calculated;
uint8_t log2_physical_lists;
uint8_t log2_physical_buckets;
};
size_t hash_size(void)
{
return sizeof(hash_t);
}
static void init_key(hash_t *hash, const aaaaaaaaaaaaa1aaat *key, uint16_t seed, uint16_t key_width,
uint32_t num_lists, uint8_t num_slots)
{
const uint8_t hash_slices = (key_width + HASH_KEY_WIDTH - 1) / HASH_KEY_WIDTH;
hash->slices = hash_slices;
for (int i = 0; i < key_width / HASH_KEY_WIDTH; i++) {
memcpy(&hash->key[i], &key->word[i * HASH_KEY_WIDTH / 32], HASH_KEY_WIDTH / 8);
hash->key[i][HASH_KEY_WORDS - 1] = seed & 0xff;
}
for (int i = key_width / HASH_KEY_WIDTH; i < hash_slices; i++) {
memset(&hash->key[i], 0, HASH_KEY_WIDTH / 8);
memcpy(&hash->key[i], &key->word[i * HASH_KEY_WIDTH / 32], (key_width - i * HASH_KEY_WIDTH + 7) / 8);
hash->key[i][HASH_KEY_WORDS - 1] = seed & 0xff;
}
hash->slice_calculated = false;
const uint32_t num_buckets = aaaaaa1aaaaaaaaaabaaaaaaaaaaa3aaaaaaaaaaaaaaaabaaaaaaaaaaaaaaaaaaaaaaaaaaaa3aaaaaaaaaaaaaaaabaaaaaaaaaaaaaaaaaaaaaaaaaaaaa3aaaaaaaaaaaaaaaabaaaaaaaaaaaaaaaaaaaaaaaaaaaa4aaaaaaaaaaaaabaaaaaaaaaaaaaaaaa5aaaaaaaaaaaaaaaabaaaaaaaaaaaaaaaaaaaaaaaaaaaa5aaaRATIO * num_lists;
const uint32_t physical_lists = num_slots * num_lists;
const uint32_t physical_buckets = num_slots * num_buckets;
hash->log2_physical_lists = CLOG2(physical_lists);
hash->log2_physical_buckets = CLOG2(physical_buckets);
}
void aaaaaaa1aaa(hash_t *hash, const aaaaaaaaaaaaa1aaat *key, const aaa1aaat *phm)
{
const uint16_t seed = aaa1aaaaaaaaaaaaaaaabaaaaaaaaaaaa3aaaaaaaaaaaaaaaabaaaaaaaaaaaaaaaaaaaaaaaaaaaa3aaaseed(phm);
const a1aaat *client = aaa1aaaaaaaaaaaaaaaabaaaaaaaaaaaa3aaaaaaaaaaaaaaaabaaaaaaaaaaaaaaaaaaaaaaaaaaaa3aaaclient(phm);
const uint16_t key_width = a1aaaaaaaaaaaaaaaabaaaaaaaaaaaa3aaaaaaaaaaaaaaaabaaaaaaaaaaaaaaaaaaaaaaaaaaaa3aaaaaaaaaaaaaaaabaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaa3aaaaaaaaaaaaaaaabaaaaaaaaaaaaaaaaaaaaaaaaaaaa4aaawidth(client);
const uint32_t num_lists = a1aaaaaaaaaaaaaaaabaaaaaaaaaaaa3aaaaaaaaaaaaaaaabaaaaaaaaaaaaaaaaaaaaaaaaaaaa3aaaaaaaaaaaaaaabaaaaaaaaaaaaaaaa4aaaaaaaaaaaaaaaabaaaaaaaaaaaaaaaaaaaaaaaaaaaa4aaaaaaaaaaaaabaaaaaaaaaaaaaaaaa5aaas(client);
const uint8_t num_slots = a1aaaaaaaaaaaaaaaabaaaaaaaaaaaa3aaaaaaaaaaaaaaaabaaaaaaaaaaaaaaaaaaaaaaaaaaaa3aaaaaaaaaaaaaaabaaaaaaaaaaaaaaaa4aaaaaaaaaaaaaaaabaaaaaaaaaaaaaaaaaaaaaaaaaaaa4bbbbbbbbbbbbbbbbbbbbbbbbbbbbbbbbbbbb4aaas(client);
init_key(hash, key, seed, key_width, num_lists, num_slots);
}
void calc_bit_slice(hash_t *hash, uint8_t slice)
{
const uint8_t sbox3x2[64] = { 9, 12, 15, 13, 10, 8, 11, 14, 33, 36, 39, 37, 34, 32, 35, 38, 57, 60, 63, 61, 58, 56,
59, 62, 41, 44, 47, 45, 42, 40, 43, 46, 17, 20, 23, 21, 18, 16, 19, 22, 1, 4, 7, 5, 2, 0, 3, 6, 25, 28, 31,
29, 26, 24, 27, 30, 49, 52, 55, 53, 50, 48, 51, 54 };
uint32_t *key = hash->key[slice];
uint16_t bit_counter = 0;
while (bit_counter < HASH_KEY_SIZE) {
const uint16_t word_pos = bit_counter / 32;
const uint16_t bit_pos = bit_counter - word_pos * 32;
uint8_t sbox_value;
if (bit_pos <= (32 - 6)) {
sbox_value = aaaaaaaa1aaaaaaaaaaaaaaaabaaaaaaaaaaaa3aaa(key[word_pos], bit_pos, 6);
} else {
assert(word_pos < 10);
const uint8_t sbox_value_lo = aaaaaaaa1aaaaaaaaaaaaaaaabaaaaaaaaaaaa3aaa(key[word_pos], bit_pos, 32 - bit_pos);
const uint8_t sbox_value_hi = aaaaaaaa1aaaaaaaaaaaaaaaabaaaaaaaaaaaa3aaa(key[word_pos + 1], 0, 6 - (32 - bit_pos));
sbox_value = (sbox_value_hi << (32 - bit_pos)) + sbox_value_lo;
assert(sbox_value < 64);
}
const uint8_t sbox_result = sbox3x2[sbox_value];
for (uint8_t j = 0; j < 6; j++) {
hash->bs[0][bit_counter + j] = (sbox_result >> (j)) & 1;
}
bit_counter = bit_counter + 6;
}
XOR0(hash->bs);
XOR1(hash->bs);
XOR2(hash->bs);
XOR3(hash->bs);
SBOX4(hash->bs);
XOR5(hash->bs);
XOR6(hash->bs);
XOR7(hash->bs);
XOR8(hash->bs);
SBOX9(hash->bs);
}
void calculate_bit_slice(hash_t *hash)
{
assert(!hash->slice_calculated);
uint8_t xor_hash[HASH_KEY_SIZE] = { 0 };
for (int slice = 0; slice < hash->slices; slice++) {
calc_bit_slice(hash, slice);
if (hash->slices == 1) {
break;
}
for (uint16_t i = 0; i < HASH_KEY_SIZE; i++) {
xor_hash[i] ^= hash->bs[0][i];
}
}
if (hash->slices > 1) {
for (uint16_t i = 0; i < HASH_KEY_SIZE; i++) {
hash->bs[0][i] = xor_hash[i];
}
}
hash->slice_calculated = true;
}
uint32_t hash_calculate_list(hash_t *hash, uint8_t function)
{
assert(function < aaaaaa1aaaaaaaaaaaaaaaabaaaaaaaaaaaaaaaaaaaaaaaaaa3aaaaaaaaaaaaaaaabaaaaaaaaaaaaaaaaaaaaaaaaaaaa3aaaaaaaaaaaaaaaabaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaa3aaaS);
assert(hash != NULL);
if (!hash->slice_calculated) {
calculate_bit_slice(hash);
}
uint32_t list = 0;
for (uint8_t i = 0; i < hash->log2_physical_lists; i++) {
list = list << 1;
uint8_t fixed_function = function;
uint8_t fixed_log2_list = i;
if (i >= 11) {
if (function == 0)
fixed_function = 1;
else
fixed_function = function - 1;
fixed_log2_list = i - 11;
}
assert(fixed_log2_list < 11);
const uint16_t bit = fun_sel[fixed_function][fixed_log2_list] + hash->log2_physical_buckets;
list = list | (hash->bs[0][bit] & 1);
}
return list;
}
uint32_t hash_calculate_bucket(hash_t *hash)
{
assert(hash != NULL);
if (!hash->slice_calculated) {
calculate_bit_slice(hash);
}
uint32_t bucket = 0;
for (uint8_t bit = 0; bit < hash->log2_physical_buckets; bit++) {
bucket = aaaaaaaa1aaaaaaaaaaaaaaaabaaaaaaaaaaaaaaaaaaaaaa3aaa(bucket, hash->bs[0][bit], bit, 1);
}
return bucket;
}
#define COUNTER_MAX 31
#define COUNTER_WIDTH 5
#define COUNTER_MASK 0xf400
#define VALUE_MASK 0x07ff
#define VALUE_MAX 2046
#define VALUE_UNKNOWN 2047
struct htable_t
{
uint16_t *entries;
uint8_t width;
uint32_t size;
};
size_t htable_size(void)
{
return sizeof(htable_t);
}
void htable_free(htable_t *htable, cam_free_func free_function)
{
if (htable == NULL)
return;
if (htable->entries != NULL)
{
free_function(htable->entries);
}
free_function(htable);
}
bool htable_init(htable_t *htable, uint32_t size, cam_calloc_func calloc_function)
{
assert(VALUE_MAX >= (aaaaaa1aaaaaaaaaaaaaaaabaaaaaaaaaaaaaaaaaaaaaaaaaa3aaaaaaaaaaaaaaaabaaaaaaaaaaaaaaaaaaaaaaaaaaaa3bbbbbbbbbbbbbbbbbbbbbbbbbbbbbbbbbbb3aaaaaaaaaaaaaaaabaaaaaaaaaaaaaaaaaaaaaaaaaaaa4aaaaaaaaaaaabaaaaaaaaaaaaaaaaa5aaaS - 1));
uint8_t i;
for (i= 1; i < 32; i++)
{
if (((size - 1) >> i) == 0)
{
break;
}
}
htable->width = i + 2; 
htable->size = 1 << htable->width;
htable->entries = calloc_function(htable->size, sizeof(uint16_t));
if (htable->entries == NULL)
{
return false;
}
return true;
}
void htable_inc(htable_t *htable, uint32_t hash_value)
{
assert(htable != NULL);
uint32_t cut_hash_value = aaaaaaaa1aaaaaaaaaaaaaaaabaaaaaaaaaaaa3aaa(hash_value, 0, htable->width);
assert(cut_hash_value < htable->size);
uint16_t entry = htable->entries[cut_hash_value];
uint16_t count = entry >> (16-COUNTER_WIDTH);
if (count < COUNTER_MAX)
{
count++;
count = count << (16-COUNTER_WIDTH);
entry = (entry & VALUE_MASK) | count;
htable->entries[cut_hash_value] = entry;
}
}
void htable_write(struct htable_t *htable, uint32_t hash_value, uint16_t value)
{
assert(htable != NULL);
assert((value <= VALUE_MAX) || (value == VALUE_UNKNOWN));
uint8_t old_counter;
uint16_t old_value;
bool value_unknown;
htable_read(htable, hash_value, &old_counter, &old_value, &value_unknown);
const uint16_t entry = (old_counter << (16 - COUNTER_WIDTH)) + value;
uint32_t cut_hash_value = aaaaaaaa1aaaaaaaaaaaaaaaabaaaaaaaaaaaa3aaa(hash_value, 0, htable->width);
assert(cut_hash_value < htable->size);
htable->entries[cut_hash_value] = entry;
}
void htable_read(const struct htable_t *htable, uint32_t hash_value, uint8_t *counter, uint16_t *value,
bool *value_unknown)
{
assert(htable != NULL);
uint32_t cut_hash_value = aaaaaaaa1aaaaaaaaaaaaaaaabaaaaaaaaaaaa3aaa(hash_value, 0, htable->width);
assert(cut_hash_value < htable->size);
const uint16_t entry = htable->entries[cut_hash_value];
*value_unknown = true;
*counter = entry >> (16 - COUNTER_WIDTH);
*value = entry & VALUE_MASK;
if (*counter > 0 && *value != VALUE_UNKNOWN) {
*value_unknown = false;
}
}
static void dec(htable_t *htable, uint32_t hash_value)
{
assert(htable != NULL);
uint32_t cut_hash_value = aaaaaaaa1aaaaaaaaaaaaaaaabaaaaaaaaaaaa3aaa(hash_value, 0, htable->width);
assert(cut_hash_value < htable->size);
assert(cut_hash_value < htable->size);
uint16_t entry = htable->entries[cut_hash_value];
uint16_t count = entry >> (16-COUNTER_WIDTH);
assert(count > 0);
if (count < COUNTER_MAX)
{
count--;
count = count << (16-COUNTER_WIDTH);
entry = (entry & VALUE_MASK) | count;
htable->entries[cut_hash_value] = entry;
}
}
void htable_dec(htable_t *htable, uint32_t hash_value, uint16_t value)
{
uint8_t old_counter;
uint16_t old_value;
bool value_unknown;
assert((value <= VALUE_MAX) || (value == VALUE_UNKNOWN));
htable_read(htable, hash_value, &old_counter, &old_value, &value_unknown);
if (old_counter > 1) {
if ((old_value == value) && !value_unknown) {
htable_write(htable, hash_value, VALUE_UNKNOWN);
}
}
dec(htable, hash_value);
}
void htable_calc_stats(htable_t *htable, uint32_t *size, uint32_t *zeroes, uint32_t *ones, uint32_t *twoplussum,
uint32_t *onetwoeightplus, uint32_t *sumfirsthalf)
{
uint32_t counts[5] = { 0, 0, 0, 0, 0 };
for (uint32_t i = 0; i < htable->size; i++)
{
uint8_t counter;
uint16_t value;
bool value_unknown;
htable_read(htable, i, &counter, &value, &value_unknown);
if (counter == 0)
{
counts[0]++;
}
else if (counter == 1) {
counts[1]++;
}
else
{
counts[2] = counts[2] + counter;
if (counter >= 128)
counts[3]++;
}
if ((i < htable->size / 2) && (counter > 0))
counts[4] = counts[4] + counter;
}
*size = htable->size;
*zeroes = counts[0];
*ones = counts[1];
*twoplussum = counts[2];
*onetwoeightplus = counts[3];
*sumfirsthalf = counts[4];
}
#ifndef aaaaaaaaaaaa1aaaH
#define aaaaaaaaaaaa1aaaH
typedef struct aaaaaaaaaaaa1aaat aaaaaaaaaaaa1aaat;
void aaaaaaaaaaaa1aaaaaaaaaaaaaabaaaaaaaaaaa3aaa(aaaaaaaaaaaa1aaat *mm, a1aaat *client, uint16_t unit, uint8_t slot_number);
void aaaaaaaaaaaa1aaaaaaaaaaaaaabaaaaaaaaaaaa3aaa(aaaaaaaaaaaa1aaat *mm);
size_t aaaaaaaaaaaa1aaaaaaaaaaaaaabaaaaaaaaaa3aaa(void);
bool aaaaaaaaaaaa1aaaaaaaaaaaaaaabaaaaaaaaaaaa3aaaaaaaaaaaaaaaabaaaaaaaaaaaaaaaaaaaaaaaaaaaa3aaaaaaaaaaaaaaaabaaaaaaaaaaaaaaaaaaaaaaa4aaaaaaaaaaaaaaaabaaaaaaaaaaaaaaaaaaaaaaaaaaaa4aaaaaaaaaaaabaaaaaaaaaaa5aaaaaaaaaaaaaaaabaaaaaaaaaaaaaaaaaaaaaaaaaaaa5aaavalid(const aaaaaaaaaaaa1aaat *mm);
void aaaaaaaaaaaa1aaaaaaaaaaaaaaaabaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaa3aaaaaaaaaaaaaaaabaaaaaaaaaaaaaaaaaaaaaaaaaaaa4aaaaaaaaaaaaaaaabaaaaaaaaaaaaaaaaaaaaaaa5aaaaaaaaaaaaaaaabaaaaaaaaaaaaaaaaaaaaaaaaaaaa5aaaaaaaaaaaabaaaaaaaaaaa6aaa(aaaaaaaaaaaa1aaat *mm, const aaaaaaaaaaaaa1aaat *mask,
uint16_t seed, uint8_t range_valid, uint8_t mask_id);
void aaaaaaaaaaaa1aaaaaaaaaaaaaaaabaaaaaaaaaaaa3aaaaaaaaaaaaaaaabaaaaaaaaaaaaaaaaaaaaaaaaaaaa3aaaaaaaaaaaaaaaabaaaaaaaaaaaaaaaaaaaa4aaa(const aaaaaaaaaaaa1aaat *mm, uint8_t *range_valid);
void aaaaaaaaaaaa1aaaaaaaaaaaaaaaabaaaaaaaaaaaaaaaaaaaaaaa3aaaaaaaaaaaaaaaabaaaaaaaaaaaaaaaaaaaaaaaaaaaa3aaaaaaaaaaaaaaaabaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaa3aaa(const aaaaaaaaaaaa1aaat *mm, const aaaaaaaaaaaaa1aaat *key, aaaaaaaaaaaaa1aaat *masked_key);
bool aaaaaaaaaaaa1aaaaaaaaaaaaaaabaaaaaaaaaaaa3aaaaaaaaaaaaaaaabaaaaaaaaaaaaaaaaaaaaaaaaaaaa3aaawide_search(const aaaaaaaaaaaa1aaat *mm);
void aaaaaaaaaaaa1bbbbbbbbbbbbbbbbb3aaaaaaaaaaaaaaaabaaaaaaaaaaaaaaaaaaaaaaaaaaaa4aaaaaaaaaaaaaaaabaaaaaaaaaaaaaaaaaaaaaaa5aaaaaaaaaaaaaaaabaaaaaaaaaaaaaaaaaaaaaaaaaaaa5aaaaaaaaaaaabaaaaaaaaaaa6aaa(aaaaaaaaaaaa1aaat *mm);
bool aaaaaaaaaaaa1aaaaaaaaaaaaaaabaaaaaaaaaaaa3aaaaaaaaaaaaaaaabaaaaaaaaaaaaaaaaaaaaaaaaaaaa3aaaaaaaaaaaaaaaabaaaaaaaaaaaaaaaaaaaaaaa4aaaaaaaaaaaaaaaabaaaaaaaaaaaaaaaaaaaaaaaaaaaa4aaaequal(const aaaaaaaaaaaa1aaat *mm, const aaaaaaaaaaaaa1aaat *mask, uint8_t range_valid,
uint8_t mask_id);
const a1aaat *aaaaaaaaaaaa1aaaaaaaaaaaaaaaabaaaaaaaaaaaa3aaaaaaaaaaaaaaaabaaaaaaaaaaaaaaaaaaaaaaaaaaaa3aaaclient(const aaaaaaaaaaaa1aaat *mm);
void aaaaaaaaaaaa1aaaread_mask(const aaaaaaaaaaaa1aaat *mm, aaaaaaaaaaaaa1aaat *mask, uint8_t *range_valid,
uint8_t *mask_id);
void aaaaaaaaaaaa1bbbbbbbbbbbbbbbbbb3aaaaaaaaaaaaaaaabaaaaaaaaaaaaaaaaaaaaaaaaaaaa4aaaaaaaaaaaaaaaabaaaaaaaaaaaaaaaaaaaaaaa5aaaaaaaaaaaaaaaabaaaaaaaaaaaaaaaaaaaaaaaaaaaa5aaaaaaaaaaaabaaaaaaaaaaa6aaa(aaaaaaaaaaaa1aaat *mm);
uint16_t aaaaaaaaaaaa1aaaaaaaaaaaaaaaabaaaaaaaaaaaa3aaaaaaaaaaaaaaaabaaaaaaaaaaaaaaaaaaaaaaaaaaaa3aaaseed(const aaaaaaaaaaaa1aaat *mm);
void aaaaaaaaaaaa1bbbbbbbbbbbbbbbbbb3aaaaaaaaaaaaaaaabaaaaaaaaaaaaaaaaaaaaaaaaaaaa4aaaseed(aaaaaaaaaaaa1aaat *mm, uint16_t seed);
uint8_t aaaaaaaaaaaa1aaaaaaaaaaaaaaaabaaaaaaaaaaaa3aaaaaaaaaaaaaaaabaaaaaaaaaaaaaaaaaaaaaaaaaaaa3bbbbbbbbbbbbbbbbbbbbbbbbbbbbbbbbbbbb3aaaaaaaaaaaaaaaabaaaaaaaaaaaaaaaaaaaaaaaaaaaa4aaaaaaaaaaaaaaabaaaaaaaaaaaaaaaa5aaaber(const aaaaaaaaaaaa1aaat *mm);
uint16_t aaaaaaaaaaaa1aaaaaaaaaaaaaaaabaaaaaaaaaaaa3aaaaaaaaaaaaaaaabaaaaaaaaaaaaaaaaaaaaaaaaaaaa3aaaaaaaaaaaabaaaaaaaaaaaaaaaaa4aaa(const aaaaaaaaaaaa1aaat *mm);
#endif
#define KEY_AND_MASK_WIDTH_MEM (CAM_MAX_KEY_WIDTH_MEM * 2)
typedef struct {
uint32_t word[KEY_AND_MASK_WIDTH_MEM]; 
} key_and_mask_t;
typedef struct {
bool direct_pointer;
uint16_t perfect_bucket;
} source_bucket_t;
struct aaaa1aaat {
source_bucket_t *source_bucket;
uint32_t *aaaaaaaaaaaaaa1aaaaaaaaaaaaaaaabaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaa3aaaaaaaaaaaaaaaabaaaaaaaaaaaaaaaaaaaaaaaaaaaa4aaadata;
uint32_t *valid_cache;
bool flush;
a1aaat *client;
uint16_t unit;
uint8_t slot_number;
};
size_t aaaa1aaaaaaaaaaaaaabaaaaaaaaaa3aaa(void)
{
return sizeof(aaaa1aaat);
}
void aaaa1bbbbbbbbbbbbbbbb3aaa(aaaa1aaat *target_km, const aaaa1aaat *source_km)
{
assert(a1aaaaaaaaaaaaaaabaaaaaaaaaaaa3aaaaaaaaaaaaaaaabaaaaaaaaaaaaaaaaaaaaaaaaaaaa3aaaaaaaaaaaaaaaabaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaa3aaa(target_km->client));
uint32_t *aaaaaaaaaaaaaa1aaaaaaaaaaaaaaaabaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaa3aaaaaaaaaaaaaaaabaaaaaaaaaaaaaaaaaaaaaaaaaaaa4aaadata = target_km->aaaaaaaaaaaaaa1aaaaaaaaaaaaaaaabaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaa3aaaaaaaaaaaaaaaabaaaaaaaaaaaaaaaaaaaaaaaaaaaa4aaadata;
source_bucket_t *source_bucket = target_km->source_bucket;
uint32_t *valid_cache = target_km->valid_cache;
*target_km = *source_km;
target_km->aaaaaaaaaaaaaa1aaaaaaaaaaaaaaaabaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaa3aaaaaaaaaaaaaaaabaaaaaaaaaaaaaaaaaaaaaaaaaaaa4aaadata = aaaaaaaaaaaaaa1aaaaaaaaaaaaaaaabaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaa3aaaaaaaaaaaaaaaabaaaaaaaaaaaaaaaaaaaaaaaaaaaa4aaadata;
target_km->source_bucket = source_bucket;
target_km->valid_cache = valid_cache;
const uint32_t num_lists = a1aaaaaaaaaaaaaaaabaaaaaaaaaaaa3aaaaaaaaaaaaaaaabaaaaaaaaaaaaaaaaaaaaaaaaaaaa3aaaaaaaaaaaaaaabaaaaaaaaaaaaaaaa4aaaaaaaaaaaaaaaabaaaaaaaaaaaaaaaaaaaaaaaaaaaa4aaaaaaaaaaaaabaaaaaaaaaaaaaaaaa5aaas(source_km->client);
const uint16_t list_length = a1aaaaaaaaaaaaaaaabaaaaaaaaaaaa3aaaaaaaaaaaaaaaabaaaaaaaaaaaaaaaaaaaaaaaaaaaa3aaaaaaaaaaaaabaaaaaaaaaaaaaaaaa4aaaaaaaaaaaaaaaabaaaaaaaaaaaaaaaaaaaaaaaaaaaa4aaalength(source_km->client);
const uint8_t number_of_word32s = list_length / 32;
memcpy(target_km->aaaaaaaaaaaaaa1aaaaaaaaaaaaaaaabaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaa3aaaaaaaaaaaaaaaabaaaaaaaaaaaaaaaaaaaaaaaaaaaa4aaadata, source_km->aaaaaaaaaaaaaa1aaaaaaaaaaaaaaaabaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaa3aaaaaaaaaaaaaaaabaaaaaaaaaaaaaaaaaaaaaaaaaaaa4aaadata,
number_of_word32s * sizeof(uint32_t) * num_lists);
memcpy(target_km->source_bucket, source_km->source_bucket, sizeof(source_bucket_t) * num_lists);
uint8_t bits_per_list = 1;
memcpy(target_km->valid_cache, source_km->valid_cache, sizeof(uint32_t) * ((bits_per_list * num_lists + 31) / 32));
}
static uint16_t get_key_size(const aaaa1aaat *km)
{
const uint16_t key_width = a1aaaaaaaaaaaaaaaabaaaaaaaaaaaa3aaaaaaaaaaaaaaaabaaaaaaaaaaaaaaaaaaaaaaaaaaaa3aaaaaaaaaaaaaaaabaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaa3aaaaaaaaaaaaaaaabaaaaaaaaaaaaaaaaaaaaaaaaaaaa4aaawidth(km->client);
if (a1aaaaaaaaaaaaaaabaaaaaaaaaaaa3aaaaaaaaaaaaaaaabaaaaaaaaaaaaaaaaaaaaaaaaaaaa3aaaaaaaaaaaaaaaabaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaa3aaa(km->client)) {
return 2 * key_width; 
} 
return key_width; 
}
#define aaaaaa1aaaSUB_PC_BASE 0x80000
#define aaaaaa1aaaPC_BASE 0x200000
static void flush_haa1aaakm(aaaa1aaat *km, uint32_t aaaaaaaaaa1aaaaaaaaaaaaaaaabaaaaaaaaaaaaaaaaaaaaaaaaaaaa3aaaaaaaaaaaaaaabaaaaaaaaaaaaaaaa4aaaber, bool verify, operation_t operation, uint8_t narrow,
uint8_t narrow_element, bool bit511or255, bool wide2narrow)
{
assert((operation != DELETE) || (((operation == DELETE) && bit511or255) || !bit511or255));
assert(!wide2narrow || (wide2narrow && (narrow != 0)));
assert(aaaaaaaaaa1aaaaaaaaaaaaaaaabaaaaaaaaaaaaaaaaaaaaaaaaaaaa3aaaaaaaaaaaaaaabaaaaaaaaaaaaaaaa4aaaber < a1aaaaaaaaaaaaaaaabaaaaaaaaaaaa3aaaaaaaaaaaaaaaabaaaaaaaaaaaaaaaaaaaaaaaaaaaa3aaaaaaaaaaaaaaabaaaaaaaaaaaaaaaa4aaaaaaaaaaaaaaaabaaaaaaaaaaaaaaaaaaaaaaaaaaaa4aaaaaaaaaaaaabaaaaaaaaaaaaaaaaa5aaas(km->client));
const uint8_t num_lists_per_read = a1aaaaaaaaaaaaaaaabaaaaaaaaaaaa3aaaaaaaaaaaaaaaabaaaaaaaaaaaaaaaaaaaaaaaaaaaa3aaaaaaaaaaaaaaabaaaaaaaaaaaaaaaa4aaaaaaaaaaaaaaaabaaaaaaaaaaaaaaaaaaaaaaaaaaaa4aaaaaaaaaaaaabaaaaaaaaaaaaaaaaa5aaas_per_read(km->client);
const uint16_t list_length = a1aaaaaaaaaaaaaaaabaaaaaaaaaaaa3aaaaaaaaaaaaaaaabaaaaaaaaaaaaaaaaaaaaaaaaaaaa3aaaaaaaaaaaaabaaaaaaaaaaaaaaaaa4aaaaaaaaaaaaaaaabaaaaaaaaaaaaaaaaaaaaaaaaaaaa4aaalength(km->client);
const uint16_t number_of_word32s = list_length / 32;
const uint32_t haa1aaaaaaaaaaaaabaaaaaaaaaaaaaaaaa3aaa = aaaaaaaaaa1aaaaaaaaaaaaaaaabaaaaaaaaaaaaaaaaaaaaaaaaaaaa3aaaaaaaaaaaaaaabaaaaaaaaaaaaaaaa4aaaber / num_lists_per_read;
const uint32_t ram_size = a1aaaaaaaaaaaaaaaabaaaaaaaaaaaa3aaaaaaaaaaaaaaaabaaaaaaaaaaaaaaaaaaaaaaaaaaaa3aaaram_size(km->client);
const uint16_t segment = a1aaaaaaaaaaaaaaaabaaaaaaaaaaaa3aaaaaaaaaaaaaaaabaaaaaaaaaaaaaaaaaaaaaaaaaaaa3aaasegment(km->client);
assert(haa1aaaaaaaaaaaaabaaaaaaaaaaaaaaaaa3aaa < ram_size);
const uint32_t haa1aaaaaaaaaaaaabaaaaaaaaaaaaaaaaa3aaaaaaaaaaaaaaaabaaaaaaaaaaaaaaaaaaaaaaaaaaaa3aaastart_word32 = haa1aaaaaaaaaaaaabaaaaaaaaaaaaaaaaa3aaa * num_lists_per_read * number_of_word32s;
const uint8_t replication = a1aaaaaaaaaaaaaaaabaaaaaaaaaaaa3aaaaaaaaaaaaaaaabaaaaaaaaaaaaaaaaaaaaaaaaaaaa3aaareplication(km->client);
uint8_t write_mask = 0;
uint8_t slice_number = aaaaaaaaaa1aaaaaaaaaaaaaaaabaaaaaaaaaaaaaaaaaaaaaaaaaaaa3aaaaaaaaaaaaaaabaaaaaaaaaaaaaaaa4aaaber - haa1aaaaaaaaaaaaabaaaaaaaaaaaaaaaaa3aaa * num_lists_per_read;
if (num_lists_per_read == 1) {
write_mask = 0xf;
if (narrow && !wide2narrow) {
if (narrow_element == 0)
write_mask = 3;
else
write_mask = 12;
}
} else if (num_lists_per_read == 2) {
if (slice_number == 0) {
write_mask = 3;
if (narrow && !wide2narrow) {
if (narrow_element == 0)
write_mask = 1;
else
write_mask = 2;
}
} else {
write_mask = 12;
if (narrow && !wide2narrow) {
if (narrow_element == 0)
write_mask = 4;
else
write_mask = 8;
}
}
} else if (num_lists_per_read == 4) {
write_mask = 1 << slice_number;
} else {
assert(false);
}
uint8_t sub_pc;
uint8_t pc;
if (replication >= 4)
{
pc = km->unit;
sub_pc = 0;
}
else
{
pc = (km->unit * replication) / 4;
sub_pc = km->unit - pc * (4 / replication);
assert(sub_pc < (4 / replication));
}
assert(segment < CAM_MAX_VC_SEGMENTS);
assert(pc < a1aaaaaaaaaaaaaaaabaaaaaaaaaaaa3aaaaaaaaaaaaaaaabaaaaaaaaaaaaaaaaaaaaaaaaaaaa3aaaaaaaaaaaaaaabaaaaaaaaaaaaaaaa4aaaaaaaaaaaaaaaabaaaaaaaaaaaaaaaaaaaaaaaaaaaa4aaapcs(km->client));
const uint32_t address = pc * aaaaaa1aaaPC_BASE + sub_pc * aaaaaa1aaaSUB_PC_BASE
+ haa1aaaaaaaaaaaaabaaaaaaaaaaaaaaaaa3aaa
+ segment * ram_size;
if (!verify) {
a1aaahaa1aaaaaaaaaaaaaaaabaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaa3aaaaaaaaaaaaaaaabaaaaaaaaaaaaaaaaaaaaaaaaaaaa4aaaaaaaaaaaaaaaabaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaa4aaaaaaaaaaaaaaaabaaaaaaaaaaaaaaaaaaaaaaaaaaaa5aaaaaaaaaaaaaaaabaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaa5aaa(km->client, address, &km->aaaaaaaaaaaaaa1aaaaaaaaaaaaaaaabaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaa3aaaaaaaaaaaaaaaabaaaaaaaaaaaaaaaaaaaaaaaaaaaa4aaadata[haa1aaaaaaaaaaaaabaaaaaaaaaaaaaaaaa3aaaaaaaaaaaaaaaabaaaaaaaaaaaaaaaaaaaaaaaaaaaa3aaastart_word32], write_mask,
operation, bit511or255);
} else {
char message[500];
uint32_t read_data[16];
a1aaahaa1aaaaaaaaaaaaaaaabaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaa3aaaaaaaaaaaaaaaabaaaaaaaaaaaaaaaaaaaaaaaaaaaa4aaaaaaaaaaaaaaaabaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaa4aaaaaaaaaaaaaaaabaaaaaaaaaaaaaaaaaaaaaaaaaaaa5aaaread(km->client, address, &read_data[0]);
for (uint8_t i = 0; i < 16; i++) {
const uint32_t data = km->aaaaaaaaaaaaaa1aaaaaaaaaaaaaaaabaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaa3aaaaaaaaaaaaaaaabaaaaaaaaaaaaaaaaaaaaaaaaaaaa4aaadata[haa1aaaaaaaaaaaaabaaaaaaaaaaaaaaaaa3aaaaaaaaaaaaaaaabaaaaaaaaaaaaaaaaaaaaaaaaaaaa3aaastart_word32 + i];
if (read_data[i] != data) {
sprintf(message,
                       "CAM_DEBUG_VERIFY_SHADOW  address = 0x%08" PRIx32 "  data %x= 0x%08" PRIx32 " expected data %x= 0x%08" PRIx32 "     FAIL",
address, i, read_data[i], i, data);
a1aaaaaaaaaaaaaaaabaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaa3aaaaaaaaaaaaaaaabaaaaaaaaaaaaaaaaaaaaaaaaaaaa4aaaerror(km->client, message);
} else if (a1aaaaaaaaaaaaaaaabaaaaaaaaaaaa3aaaaaaaaaaaaaaaabaaaaaaaaaaaaaaaaaaaaaaaaaaaa3bbbbbbbbbbbbbbbbbbbbbbbbbbbbbbbbbbbbb3aaaaaaaaaaaaaaaabaaaaaaaaaaaaaaaaaaaaaaaaaaaa4aaaflags(km->client) & CAM_DEBUG_VERBOSE_VERIFY) {
sprintf(message,
                       "CAM_DEBUG_VERIFY_SHADOW  address = 0x%08" PRIx32 "  data %x= 0x%08" PRIx32 " expected data %x= 0x%08" PRIx32 "     OK",
address, i, read_data[i], i, data);
a1aaaaaaaaaaaaaaaabaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaa3aaaaaaaaaaaaaaaabaaaaaaaaaaaaaaaaaaaaaaaaaaaa4aaainfo(km->client, message);
}
}
}
}
static void flush(aaaa1aaat *km, uint32_t aaaaaaaaaa1aaaaaaaaaaaaaaaabaaaaaaaaaaaaaaaaaaaaaaaaaaaa3aaaaaaaaaaaaaaabaaaaaaaaaaaaaaaa4aaaber, bool init_clear, bool verify, operation_t operation,
uint8_t narrow,
uint8_t narrow_element, bool bit511or255, bool wide2narrow)
{
if (a1aaaaaaaaaaaaaaabaaaaaaaaaaaa3aaaaaaaaaaaaaaaabaaaaaaaaaaaaaaaaaaaaaaaaaaaa3aaahbmbcam(km->client)) {
flush_haa1aaakm(km, aaaaaaaaaa1aaaaaaaaaaaaaaaabaaaaaaaaaaaaaaaaaaaaaaaaaaaa3aaaaaaaaaaaaaaabaaaaaaaaaaaaaaaa4aaaber, verify, operation, narrow, narrow_element, bit511or255, wide2narrow);
return;
}
const uint32_t num_lists = a1aaaaaaaaaaaaaaaabaaaaaaaaaaaa3aaaaaaaaaaaaaaaabaaaaaaaaaaaaaaaaaaaaaaaaaaaa3aaaaaaaaaaaaaaabaaaaaaaaaaaaaaaa4aaaaaaaaaaaaaaaabaaaaaaaaaaaaaaaaaaaaaaaaaaaa4aaaaaaaaaaaaabaaaaaaaaaaaaaaaaa5aaas(km->client);
assert(aaaaaaaaaa1aaaaaaaaaaaaaaaabaaaaaaaaaaaaaaaaaaaaaaaaaaaa3aaaaaaaaaaaaaaabaaaaaaaaaaaaaaaa4aaaber < num_lists);
const uint16_t list_length = a1aaaaaaaaaaaaaaaabaaaaaaaaaaaa3aaaaaaaaaaaaaaaabaaaaaaaaaaaaaaaaaaaaaaaaaaaa3aaaaaaaaaaaaabaaaaaaaaaaaaaaaaa4aaaaaaaaaaaaaaaabaaaaaaaaaaaaaaaaaaaaaaaaaaaa4aaalength(km->client);
const uint16_t number_of_word32s = list_length / 32;
assert(number_of_word32s >= 2);
const uint32_t list_start_word32 = aaaaaaaaaa1aaaaaaaaaaaaaaaabaaaaaaaaaaaaaaaaaaaaaaaaaaaa3aaaaaaaaaaaaaaabaaaaaaaaaaaaaaaa4aaaber * number_of_word32s;
assert(km->slot_number < aaaaaa1aaaaaaaaaaaaaaaabaaaaaaaaaaaaaaaaaaaaaaaaaa3aaaaaaaaaaaaaaaabaaaaaaaaaaaaaaaaaaaaaaaaaaaa3bbbbbbbbbbbbbbbbbbbbbbbbbbbbbbbbbbbb3aaaS);
const uint32_t adj_aaaaaaaaaa1aaaaaaaaaaaaaaaabaaaaaaaaaaaaaaaaaaaaaaaaaaaa3aaaaaaaaaaaaaaabaaaaaaaaaaaaaaaa4aaaber = num_lists * km->slot_number + aaaaaaaaaa1aaaaaaaaaaaaaaaabaaaaaaaaaaaaaaaaaaaaaaaaaaaa3aaaaaaaaaaaaaaabaaaaaaaaaaaaaaaa4aaaber;
assert(adj_aaaaaaaaaa1aaaaaaaaaaaaaaaabaaaaaaaaaaaaaaaaaaaaaaaaaaaa3aaaaaaaaaaaaaaabaaaaaaaaaaaaaaaa4aaaber < (num_lists * a1aaaaaaaaaaaaaaaabaaaaaaaaaaaa3aaaaaaaaaaaaaaaabaaaaaaaaaaaaaaaaaaaaaaaaaaaa3aaaaaaaaaaaaaaabaaaaaaaaaaaaaaaa4aaaaaaaaaaaaaaaabaaaaaaaaaaaaaaaaaaaaaaaaaaaa4bbbbbbbbbbbbbbbbbbbbbbbbbbbbbbbbbbbb4aaas(km->client)));
const uint32_t base = aaaaaa1aaaaaaa1aaaaaaaaaaaaaaaabaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaa3aaa + km->unit * aaaaaa1aaaaaaaaaaaabaaaaaaaaaaaaaaaaa3aaaaaaaaaaaaaaaabaaaaaaaaaaaaaaaaaaaaaaaaaaaa3aaaaaaaaaaaaaaaabaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaa3aaa + adj_aaaaaaaaaa1aaaaaaaaaaaaaaaabaaaaaaaaaaaaaaaaaaaaaaaaaaaa3aaaaaaaaaaaaaaabaaaaaaaaaaaaaaaa4aaaber * aaaaaa1aaaaaaa1aaaWORD;
uint16_t start_word = 0;
if (!init_clear && (km->aaaaaaaaaaaaaa1aaaaaaaaaaaaaaaabaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaa3aaaaaaaaaaaaaaaabaaaaaaaaaaaaaaaaaaaaaaaaaaaa4aaadata[list_start_word32 + number_of_word32s - 1] & 0x80000000) == 0) {
start_word = number_of_word32s - 2;
}
for (uint16_t word_count = start_word; word_count < number_of_word32s; word_count += 2) {
uint64_t data;
data = km->aaaaaaaaaaaaaa1aaaaaaaaaaaaaaaabaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaa3aaaaaaaaaaaaaaaabaaaaaaaaaaaaaaaaaaaaaaaaaaaa4aaadata[list_start_word32 + word_count + 1];
data = data << 32;
data |= km->aaaaaaaaaaaaaa1aaaaaaaaaaaaaaaabaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaa3aaaaaaaaaaaaaaaabaaaaaaaaaaaaaaaaaaaaaaaaaaaa4aaadata[list_start_word32 + word_count];
if (!verify) {
a1aaaaaaaaaaaaaaaabaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaa3aaaaaaaaaaaaaaaabaaaaaaaaaaaaaaaaaaaaaaaaaaaa4aaaaaaaaaaaaaaaabaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaa4aaa(km->client, base + word_count * 4, data);
} else {
uint64_t hw_word;
a1aaaaaaaaaaaaaaaabaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaa3aaaaaaaaaaaaaaaabaaaaaaaaaaaaaaaaaaaaaaaaaaaa4aaaread(km->client, base + word_count * 4, &hw_word);
char message[500];
if (hw_word != data) {
sprintf(message,
                       "CAM_DEBUG_VERIFY_SHADOW  address = 0x%08" PRIx32 "  data = 0x%016" PRIx64 "  shadow data = 0x%016" PRIx64 "    FAIL",
base + word_count * 4, hw_word, data);
a1aaaaaaaaaaaaaaaabaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaa3aaaaaaaaaaaaaaaabaaaaaaaaaaaaaaaaaaaaaaaaaaaa4aaaerror(km->client, message);
} else if (a1aaaaaaaaaaaaaaaabaaaaaaaaaaaa3aaaaaaaaaaaaaaaabaaaaaaaaaaaaaaaaaaaaaaaaaaaa3bbbbbbbbbbbbbbbbbbbbbbbbbbbbbbbbbbbbb3aaaaaaaaaaaaaaaabaaaaaaaaaaaaaaaaaaaaaaaaaaaa4aaaflags(km->client) & CAM_DEBUG_VERBOSE_VERIFY) {
sprintf(message,
                       "CAM_DEBUG_VERIFY_SHADOW  address = 0x%08" PRIx32 "  data = 0x%016" PRIx64 "  shadow data = 0x%016" PRIx64 "    OK",
base + word_count * 4, hw_word, data);
a1aaaaaaaaaaaaaaaabaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaa3aaaaaaaaaaaaaaaabaaaaaaaaaaaaaaaaaaaaaaaaaaaa4aaainfo(km->client, message);
}
}
}
}
bool aaaa1aaaaaaaaaaaaaabaaaaaaaaaaa3aaa(aaaa1aaat *km, a1aaat *client, uint16_t unit, uint8_t slot_number, bool flush_to_hw)
{
assert(unit < aaaaaa1aaaaaaaaaaaaaaaabaaaaaaaaaaaaaaaaaaaaaaaaaa3aaaaaaaaaaaaaaaabaaaaaaaaaaaaaaaaaaaaaaaaaaaa3aaaaaaaaaaaaaaaabaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaa3aaaaaaaaaaaaaaaabaaaaaaaaaaaaaaaaaaaaaaaaaaaa4aaaaaaaaaaaabaaaaaaaaaaaaaaaaa5aaaS);
const uint32_t num_lists = a1aaaaaaaaaaaaaaaabaaaaaaaaaaaa3aaaaaaaaaaaaaaaabaaaaaaaaaaaaaaaaaaaaaaaaaaaa3aaaaaaaaaaaaaaabaaaaaaaaaaaaaaaa4aaaaaaaaaaaaaaaabaaaaaaaaaaaaaaaaaaaaaaaaaaaa4aaaaaaaaaaaaabaaaaaaaaaaaaaaaaa5aaas(client);
const uint16_t list_length = a1aaaaaaaaaaaaaaaabaaaaaaaaaaaa3aaaaaaaaaaaaaaaabaaaaaaaaaaaaaaaaaaaaaaaaaaaa3aaaaaaaaaaaaabaaaaaaaaaaaaaaaaa4aaaaaaaaaaaaaaaabaaaaaaaaaaaaaaaaaaaaaaaaaaaa4aaalength(client);
cam_free_func free_function = a1aaaaaaaaaaaaaaaabaaaaaaaaaaaa3aaaaaaaaaaaaaaaabaaaaaaaaaaaaaaaaaaaaaaaaaaaa3aaaaaaaaaaaaaabaaaaaaaaaaaa4aaaaaaaaaaaaaaaabaaaaaaaaaaaaaaaaaaaaaaaaaaaa4aaaaaaaaaaaaaaaabaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaa4aaa(client);
cam_calloc_func calloc_function = a1aaaaaaaaaaaaaaaabaaaaaaaaaaaa3aaaaaaaaaaaaaaaabaaaaaaaaaaaaaaaaaaaaaaaaaaaa3aaacalloc_function(client);
assert(list_length >= 32);
assert((list_length - (list_length / 32 * 32)) == 0);
km->aaaaaaaaaaaaaa1aaaaaaaaaaaaaaaabaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaa3aaaaaaaaaaaaaaaabaaaaaaaaaaaaaaaaaaaaaaaaaaaa4aaadata = calloc_function(num_lists, sizeof(uint32_t) * list_length / 32);
if (km->aaaaaaaaaaaaaa1aaaaaaaaaaaaaaaabaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaa3aaaaaaaaaaaaaaaabaaaaaaaaaaaaaaaaaaaaaaaaaaaa4aaadata == NULL)
return false;
uint8_t bits_per_list = 1;
if (a1aaaaaaaaaaaaaaabaaaaaaaaaaaa3aaaaaaaaaaaaaaaabaaaaaaaaaaaaaaaaaaaaaaaaaaaa3aaamixed_mode(client)) {
bits_per_list = 4;
assert(!a1aaaaaaaaaaaaaaabaaaaaaaaaaaa3aaaaaaaaaaaaaaaabaaaaaaaaaaaaaaaaaaaaaaaaaaaa3aaaaaaaaaaaaaaaabaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaa3aaa(client));
}
km->valid_cache = calloc_function((bits_per_list * num_lists + 31) / 32, sizeof(uint32_t));
if (km->valid_cache == NULL) {
free_function(km->aaaaaaaaaaaaaa1aaaaaaaaaaaaaaaabaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaa3aaaaaaaaaaaaaaaabaaaaaaaaaaaaaaaaaaaaaaaaaaaa4aaadata);
return false;
}
km->source_bucket = NULL;
if (a1aaaaaaaaaaaaaaabaaaaaaaaaaaa3aaaaaaaaaaaaaaaabaaaaaaaaaaaaaaaaaaaaaaaaaaaa3aaaaaaaaaaaaaaaabaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaa3aaa(client)) {
km->source_bucket = calloc_function(num_lists, sizeof(source_bucket_t));
if (km->source_bucket == NULL) {
free_function(km->aaaaaaaaaaaaaa1aaaaaaaaaaaaaaaabaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaa3aaaaaaaaaaaaaaaabaaaaaaaaaaaaaaaaaaaaaaaaaaaa4aaadata);
free_function(km->valid_cache);
return false;
}
}
km->flush = flush_to_hw;
km->unit = unit;
km->client = client;
km->slot_number = slot_number;
const uint32_t end_list = num_lists - 1;
for (uint32_t i = 0; i <= end_list; i++) {
if (!(a1aaaaaaaaaaaaaaaabaaaaaaaaaaaa3aaaaaaaaaaaaaaaabaaaaaaaaaaaaaaaaaaaaaaaaaaaa3bbbbbbbbbbbbbbbbbbbbbbbbbbbbbbbbbbbbb3aaaaaaaaaaaaaaaabaaaaaaaaaaaaaaaaaaaaaaaaaaaa4aaaflags(km->client) & CAM_DEBUG_SKIP_MEM_INIT)) {
flush(km, i, true, false, OTHER, 0, 0, false, false);
}
}
return true;
}
void aaaa1aaaaaaaaaaaaaabaaaaaaaaaaaa3aaa(aaaa1aaat *km, cam_free_func free_function)
{
if (km == NULL) {
return;
}
if (km->aaaaaaaaaaaaaa1aaaaaaaaaaaaaaaabaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaa3aaaaaaaaaaaaaaaabaaaaaaaaaaaaaaaaaaaaaaaaaaaa4aaadata != NULL) {
free_function(km->aaaaaaaaaaaaaa1aaaaaaaaaaaaaaaabaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaa3aaaaaaaaaaaaaaaabaaaaaaaaaaaaaaaaaaaaaaaaaaaa4aaadata);
}
if (km->source_bucket != NULL) {
free_function(km->source_bucket);
}
if (km->valid_cache != NULL) {
free_function(km->valid_cache);
}
free_function(km);
}
void aaaa1bbbbbbbbbbbbbbbbbb3aaaaaaaaaaaaaaaabaaaaaaaaaaaaaaaaaaaaaaaaaaaa4bbbbbbbbbbbbbbbbbbb4aaa(aaaa1aaat *km)
{
km->flush = true;
}
void aaaa1bbbbbbbbbbbbbbbbb3aaaaaaaaaaaaaaaabaaaaaaaaaaaaaaaaaaaaaaaaaaaa4bbbbbbbbbbbbbbbbbbb4aaa(aaaa1aaat *km)
{
km->flush = false;
}
static void set_valid_bit(const aaaa1aaat *km, uint32_t aaaaaaaaaa1aaaaaaaaaaaaaaaabaaaaaaaaaaaaaaaaaaaaaaaaaaaa3aaaaaaaaaaaaaaabaaaaaaaaaaaaaaaa4aaaber, uint32_t valid)
{
assert(!a1aaaaaaaaaaaaaaabaaaaaaaaaaaa3aaaaaaaaaaaaaaaabaaaaaaaaaaaaaaaaaaaaaaaaaaaa3aaamixed_mode(km->client));
assert(aaaaaaaaaa1aaaaaaaaaaaaaaaabaaaaaaaaaaaaaaaaaaaaaaaaaaaa3aaaaaaaaaaaaaaabaaaaaaaaaaaaaaaa4aaaber < a1aaaaaaaaaaaaaaaabaaaaaaaaaaaa3aaaaaaaaaaaaaaaabaaaaaaaaaaaaaaaaaaaaaaaaaaaa3aaaaaaaaaaaaaaabaaaaaaaaaaaaaaaa4aaaaaaaaaaaaaaaabaaaaaaaaaaaaaaaaaaaaaaaaaaaa4aaaaaaaaaaaaabaaaaaaaaaaaaaaaaa5aaas(km->client));
assert(valid < 2);
const uint16_t list_length = a1aaaaaaaaaaaaaaaabaaaaaaaaaaaa3aaaaaaaaaaaaaaaabaaaaaaaaaaaaaaaaaaaaaaaaaaaa3aaaaaaaaaaaaabaaaaaaaaaaaaaaaaa4aaaaaaaaaaaaaaaabaaaaaaaaaaaaaaaaaaaaaaaaaaaa4aaalength(km->client);
const uint8_t number_of_word32s = list_length / 32;
const uint32_t word32 = aaaaaaaaaa1aaaaaaaaaaaaaaaabaaaaaaaaaaaaaaaaaaaaaaaaaaaa3aaaaaaaaaaaaaaabaaaaaaaaaaaaaaaa4aaaber * number_of_word32s;
km->aaaaaaaaaaaaaa1aaaaaaaaaaaaaaaabaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaa3aaaaaaaaaaaaaaaabaaaaaaaaaaaaaaaaaaaaaaaaaaaa4aaadata[word32 + number_of_word32s - 1] = aaaaaaaa1aaaaaaaaaaaaaaaabaaaaaaaaaaaaaaaaaaaaaa3aaa(
km->aaaaaaaaaaaaaa1aaaaaaaaaaaaaaaabaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaa3aaaaaaaaaaaaaaaabaaaaaaaaaaaaaaaaaaaaaaaaaaaa4aaadata[word32 + number_of_word32s - 1], valid, 31, 1);
const uint32_t valid_entry = aaaaaaaaaa1aaaaaaaaaaaaaaaabaaaaaaaaaaaaaaaaaaaaaaaaaaaa3aaaaaaaaaaaaaaabaaaaaaaaaaaaaaaa4aaaber / 32;
const uint32_t start = aaaaaaaaaa1aaaaaaaaaaaaaaaabaaaaaaaaaaaaaaaaaaaaaaaaaaaa3aaaaaaaaaaaaaaabaaaaaaaaaaaaaaaa4aaaber - valid_entry * 32;
km->valid_cache[valid_entry] = aaaaaaaa1aaaaaaaaaaaaaaaabaaaaaaaaaaaaaaaaaaaaaa3aaa(km->valid_cache[valid_entry], valid, start, 1);
}
void aaaa1aaaaaaaaaaaaaaaabaaaaaaaaaaaa3aaaaaaaaaaaaaaaabaaaaaaaaaaaaaaaaaaaaaaaaaaaa3aaaaaaaaaaaaaaaabaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaa3aaaaaaaaaaaaaaaabaaaaaaaaaaaaaaaaaaaaaaaaaaaa4aaabits(const aaaa1aaat *km, uint32_t aaaaaaaaaa1aaaaaaaaaaaaaaaabaaaaaaaaaaaaaaaaaaaaaaaaaaaa3aaaaaaaaaaaaaaabaaaaaaaaaaaaaaaa4aaaber, bool *wide_valid, bool *narrow1_valid,
bool *narrow0_valid)
{
assert(a1aaaaaaaaaaaaaaabaaaaaaaaaaaa3aaaaaaaaaaaaaaaabaaaaaaaaaaaaaaaaaaaaaaaaaaaa3aaamixed_mode(km->client));
assert(!a1aaaaaaaaaaaaaaabaaaaaaaaaaaa3aaaaaaaaaaaaaaaabaaaaaaaaaaaaaaaaaaaaaaaaaaaa3aaaaaaaaaaaaaaaabaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaa3aaa(km->client));
assert(aaaaaaaaaa1aaaaaaaaaaaaaaaabaaaaaaaaaaaaaaaaaaaaaaaaaaaa3aaaaaaaaaaaaaaabaaaaaaaaaaaaaaaa4aaaber < a1aaaaaaaaaaaaaaaabaaaaaaaaaaaa3aaaaaaaaaaaaaaaabaaaaaaaaaaaaaaaaaaaaaaaaaaaa3aaaaaaaaaaaaaaabaaaaaaaaaaaaaaaa4aaaaaaaaaaaaaaaabaaaaaaaaaaaaaaaaaaaaaaaaaaaa4aaaaaaaaaaaaabaaaaaaaaaaaaaaaaa5aaas(km->client));
*wide_valid = false;
*narrow1_valid = false;
*narrow0_valid = false;
const uint32_t valid_entry = aaaaaaaaaa1aaaaaaaaaaaaaaaabaaaaaaaaaaaaaaaaaaaaaaaaaaaa3aaaaaaaaaaaaaaabaaaaaaaaaaaaaaaa4aaaber / (32 / 4);
const uint32_t start = aaaaaaaaaa1aaaaaaaaaaaaaaaabaaaaaaaaaaaaaaaaaaaaaaaaaaaa3aaaaaaaaaaaaaaabaaaaaaaaaaaaaaaa4aaaber - valid_entry * (32 / 4);
const uint8_t status = aaaaaaaa1aaaaaaaaaaaaaaaabaaaaaaaaaaaa3aaa(km->valid_cache[valid_entry], start * 4, 4);
if ((status & 4) == 4) {
*wide_valid = true;
return;
}
if ((status & 8) == 8) {
*narrow1_valid = true;
}
if ((status & 2) == 2) {
*narrow0_valid = true;
}
}
static void set_control_bits(const aaaa1aaat *km, uint32_t aaaaaaaaaa1aaaaaaaaaaaaaaaabaaaaaaaaaaaaaaaaaaaaaaaaaaaa3aaaaaaaaaaaaaaabaaaaaaaaaaaaaaaa4aaaber, uint8_t valid, 
uint8_t narrow,
uint8_t narrow_element)
{
assert(!a1aaaaaaaaaaaaaaabaaaaaaaaaaaa3aaaaaaaaaaaaaaaabaaaaaaaaaaaaaaaaaaaaaaaaaaaa3aaaaaaaaaaaaaaaabaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaa3aaa(km->client));
assert(aaaaaaaaaa1aaaaaaaaaaaaaaaabaaaaaaaaaaaaaaaaaaaaaaaaaaaa3aaaaaaaaaaaaaaabaaaaaaaaaaaaaaaa4aaaber < a1aaaaaaaaaaaaaaaabaaaaaaaaaaaa3aaaaaaaaaaaaaaaabaaaaaaaaaaaaaaaaaaaaaaaaaaaa3aaaaaaaaaaaaaaabaaaaaaaaaaaaaaaa4aaaaaaaaaaaaaaaabaaaaaaaaaaaaaaaaaaaaaaaaaaaa4aaaaaaaaaaaaabaaaaaaaaaaaaaaaaa5aaas(km->client));
assert(valid < 2);
assert(narrow < 2);
assert(narrow_element < 2);
if (!a1aaaaaaaaaaaaaaabaaaaaaaaaaaa3aaaaaaaaaaaaaaaabaaaaaaaaaaaaaaaaaaaaaaaaaaaa3aaamixed_mode(km->client)) {
set_valid_bit(km, aaaaaaaaaa1aaaaaaaaaaaaaaaabaaaaaaaaaaaaaaaaaaaaaaaaaaaa3aaaaaaaaaaaaaaabaaaaaaaaaaaaaaaa4aaaber, valid);
return;
}
const uint16_t list_length = a1aaaaaaaaaaaaaaaabaaaaaaaaaaaa3aaaaaaaaaaaaaaaabaaaaaaaaaaaaaaaaaaaaaaaaaaaa3aaaaaaaaaaaaabaaaaaaaaaaaaaaaaa4aaaaaaaaaaaaaaaabaaaaaaaaaaaaaaaaaaaaaaaaaaaa4aaalength(km->client);
const uint8_t number_of_word32s = list_length / 32;
const uint32_t word32 = aaaaaaaaaa1aaaaaaaaaaaaaaaabaaaaaaaaaaaaaaaaaaaaaaaaaaaa3aaaaaaaaaaaaaaabaaaaaaaaaaaaaaaa4aaaber * number_of_word32s;
const uint32_t valid_entry = aaaaaaaaaa1aaaaaaaaaaaaaaaabaaaaaaaaaaaaaaaaaaaaaaaaaaaa3aaaaaaaaaaaaaaabaaaaaaaaaaaaaaaa4aaaber / (32 / 4); 
const uint32_t start = aaaaaaaaaa1aaaaaaaaaaaaaaaabaaaaaaaaaaaaaaaaaaaaaaaaaaaa3aaaaaaaaaaaaaaabaaaaaaaaaaaaaaaa4aaaber - valid_entry * (32 / 4); 
if (narrow && (narrow_element == 0)) {
assert(!((km->aaaaaaaaaaaaaa1aaaaaaaaaaaaaaaabaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaa3aaaaaaaaaaaaaaaabaaaaaaaaaaaaaaaaaaaaaaaaaaaa4aaadata[word32 + number_of_word32s - 1] & 0x40000000) == 0x40000000));
assert(0 == aaaaaaaa1aaaaaaaaaaaaaaaabaaaaaaaaaaaa3aaa(km->valid_cache[valid_entry], start * 4 + 2, 1));
km->aaaaaaaaaaaaaa1aaaaaaaaaaaaaaaabaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaa3aaaaaaaaaaaaaaaabaaaaaaaaaaaaaaaaaaaaaaaaaaaa4aaadata[word32 + number_of_word32s / 2 - 1] = aaaaaaaa1aaaaaaaaaaaaaaaabaaaaaaaaaaaaaaaaaaaaaa3aaa(
km->aaaaaaaaaaaaaa1aaaaaaaaaaaaaaaabaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaa3aaaaaaaaaaaaaaaabaaaaaaaaaaaaaaaaaaaaaaaaaaaa4aaadata[word32 + number_of_word32s / 2 - 1], valid, 31, 1);
km->valid_cache[valid_entry] = aaaaaaaa1aaaaaaaaaaaaaaaabaaaaaaaaaaaaaaaaaaaaaa3aaa(km->valid_cache[valid_entry], valid, start * 4 + 1, 1);
} else if (narrow && (narrow_element == 1)) {
assert(!((km->aaaaaaaaaaaaaa1aaaaaaaaaaaaaaaabaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaa3aaaaaaaaaaaaaaaabaaaaaaaaaaaaaaaaaaaaaaaaaaaa4aaadata[word32 + number_of_word32s - 1] & 0x40000000) == 0x40000000));
assert(0 == aaaaaaaa1aaaaaaaaaaaaaaaabaaaaaaaaaaaa3aaa(km->valid_cache[valid_entry], start * 4 + 2, 1));
km->aaaaaaaaaaaaaa1aaaaaaaaaaaaaaaabaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaa3aaaaaaaaaaaaaaaabaaaaaaaaaaaaaaaaaaaaaaaaaaaa4aaadata[word32 + number_of_word32s - 1] = aaaaaaaa1aaaaaaaaaaaaaaaabaaaaaaaaaaaaaaaaaaaaaa3aaa(
km->aaaaaaaaaaaaaa1aaaaaaaaaaaaaaaabaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaa3aaaaaaaaaaaaaaaabaaaaaaaaaaaaaaaaaaaaaaaaaaaa4aaadata[word32 + number_of_word32s - 1], valid, 31, 1);
km->valid_cache[valid_entry] = aaaaaaaa1aaaaaaaaaaaaaaaabaaaaaaaaaaaaaaaaaaaaaa3aaa(km->valid_cache[valid_entry], valid, start * 4 + 3, 1);
} else if (!narrow) {
if (valid) {
km->aaaaaaaaaaaaaa1aaaaaaaaaaaaaaaabaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaa3aaaaaaaaaaaaaaaabaaaaaaaaaaaaaaaaaaaaaaaaaaaa4aaadata[word32 + number_of_word32s - 1] = aaaaaaaa1aaaaaaaaaaaaaaaabaaaaaaaaaaaaaaaaaaaaaa3aaa(
km->aaaaaaaaaaaaaa1aaaaaaaaaaaaaaaabaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaa3aaaaaaaaaaaaaaaabaaaaaaaaaaaaaaaaaaaaaaaaaaaa4aaadata[word32 + number_of_word32s - 1], 1, 30, 1);
km->valid_cache[valid_entry] = aaaaaaaa1aaaaaaaaaaaaaaaabaaaaaaaaaaaaaaaaaaaaaa3aaa(km->valid_cache[valid_entry], 1, start * 4 + 2, 1);
} else {
km->aaaaaaaaaaaaaa1aaaaaaaaaaaaaaaabaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaa3aaaaaaaaaaaaaaaabaaaaaaaaaaaaaaaaaaaaaaaaaaaa4aaadata[word32 + number_of_word32s / 2 - 1] = aaaaaaaa1aaaaaaaaaaaaaaaabaaaaaaaaaaaaaaaaaaaaaa3aaa(
km->aaaaaaaaaaaaaa1aaaaaaaaaaaaaaaabaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaa3aaaaaaaaaaaaaaaabaaaaaaaaaaaaaaaaaaaaaaaaaaaa4aaadata[word32 + number_of_word32s / 2 - 1], 0, 31, 1);
km->valid_cache[valid_entry] = aaaaaaaa1aaaaaaaaaaaaaaaabaaaaaaaaaaaaaaaaaaaaaa3aaa(km->valid_cache[valid_entry], 0, start * 4 + 1, 1);
km->aaaaaaaaaaaaaa1aaaaaaaaaaaaaaaabaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaa3aaaaaaaaaaaaaaaabaaaaaaaaaaaaaaaaaaaaaaaaaaaa4aaadata[word32 + number_of_word32s - 1] = aaaaaaaa1aaaaaaaaaaaaaaaabaaaaaaaaaaaaaaaaaaaaaa3aaa(
km->aaaaaaaaaaaaaa1aaaaaaaaaaaaaaaabaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaa3aaaaaaaaaaaaaaaabaaaaaaaaaaaaaaaaaaaaaaaaaaaa4aaadata[word32 + number_of_word32s - 1], 0, 30, 2);
km->valid_cache[valid_entry] = aaaaaaaa1aaaaaaaaaaaaaaaabaaaaaaaaaaaaaaaaaaaaaa3aaa(km->valid_cache[valid_entry], 0, start * 4 + 2, 2);
}
}
}
static bool get_bit511or255(const aaaa1aaat *km, uint32_t aaaaaaaaaa1aaaaaaaaaaaaaaaabaaaaaaaaaaaaaaaaaaaaaaaaaaaa3aaaaaaaaaaaaaaabaaaaaaaaaaaaaaaa4aaaber)
{
assert(a1aaaaaaaaaaaaaaabaaaaaaaaaaaa3aaaaaaaaaaaaaaaabaaaaaaaaaaaaaaaaaaaaaaaaaaaa3aaamixed_mode(km->client));
assert(!a1aaaaaaaaaaaaaaabaaaaaaaaaaaa3aaaaaaaaaaaaaaaabaaaaaaaaaaaaaaaaaaaaaaaaaaaa3aaaaaaaaaaaaaaaabaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaa3aaa(km->client));
assert(aaaaaaaaaa1aaaaaaaaaaaaaaaabaaaaaaaaaaaaaaaaaaaaaaaaaaaa3aaaaaaaaaaaaaaabaaaaaaaaaaaaaaaa4aaaber < a1aaaaaaaaaaaaaaaabaaaaaaaaaaaa3aaaaaaaaaaaaaaaabaaaaaaaaaaaaaaaaaaaaaaaaaaaa3aaaaaaaaaaaaaaabaaaaaaaaaaaaaaaa4aaaaaaaaaaaaaaaabaaaaaaaaaaaaaaaaaaaaaaaaaaaa4aaaaaaaaaaaaabaaaaaaaaaaaaaaaaa5aaas(km->client));
const uint16_t list_length = a1aaaaaaaaaaaaaaaabaaaaaaaaaaaa3aaaaaaaaaaaaaaaabaaaaaaaaaaaaaaaaaaaaaaaaaaaa3aaaaaaaaaaaaabaaaaaaaaaaaaaaaaa4aaaaaaaaaaaaaaaabaaaaaaaaaaaaaaaaaaaaaaaaaaaa4aaalength(km->client);
const uint8_t number_of_word32s = list_length / 32;
const uint32_t word32 = aaaaaaaaaa1aaaaaaaaaaaaaaaabaaaaaaaaaaaaaaaaaaaaaaaaaaaa3aaaaaaaaaaaaaaabaaaaaaaaaaaaaaaa4aaaber * number_of_word32s;
uint32_t bit511or255 = aaaaaaaa1aaaaaaaaaaaaaaaabaaaaaaaaaaaa3aaa(km->aaaaaaaaaaaaaa1aaaaaaaaaaaaaaaabaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaa3aaaaaaaaaaaaaaaabaaaaaaaaaaaaaaaaaaaaaaaaaaaa4aaadata[word32 + number_of_word32s / 2 - 1], 31, 1);
if (bit511or255)
return true;
return false;
}
static void set_key(const aaaa1aaat *km, uint32_t list_number, const key_and_mask_t *key, 
uint8_t narrow, uint8_t narrow_element)
{
uint16_t key_size = get_key_size(km);
const uint16_t list_length = a1aaaaaaaaaaaaaaaabaaaaaaaaaaaa3aaaaaaaaaaaaaaaabaaaaaaaaaaaaaaaaaaaaaaaaaaaa3aaaaaaaaaaaaabaaaaaaaaaaaaaaaaa4aaaaaaaaaaaaaaaabaaaaaaaaaaaaaaaaaaaaaaaaaaaa4aaalength(km->client);
const uint16_t number_of_word32s = list_length / 32;
uint16_t prio_end_pos = list_length - 2;
const bool mixed_mode = a1aaaaaaaaaaaaaaabaaaaaaaaaaaa3aaaaaaaaaaaaaaaabaaaaaaaaaaaaaaaaaaaaaaaaaaaa3aaamixed_mode(km->client);
uint16_t key_start_pos = 0;
assert((!mixed_mode && narrow == false) || mixed_mode);
if (mixed_mode) {
assert(!a1aaaaaaaaaaaaaaabaaaaaaaaaaaa3aaaaaaaaaaaaaaaabaaaaaaaaaaaaaaaaaaaaaaaaaaaa3aaaaaaaaaaaaaaaabaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaa3aaa(km->client));
if (narrow != 0) {
key_size = a1aaaaaaaaaaaaaaaabaaaaaaaaaaaa3aaaaaaaaaaaaaaaabaaaaaaaaaaaaaaaaaaaaaaaaaaaa3aaanarrow_key_width(km->client);
}
if ((narrow != 0) && (narrow_element == 0)) {
prio_end_pos = list_length / 2 - 3;
} else if ((narrow != 0) && (narrow_element == 1)) {
key_start_pos = list_length / 2;
prio_end_pos = list_length - 3;
} else if (narrow == 0) {
prio_end_pos = list_length - 3;
} else {
assert(false);
}
}
const uint16_t key_end_pos = key_start_pos + key_size - 1;
cam_write_field(&km->aaaaaaaaaaaaaa1aaaaaaaaaaaaaaaabaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaa3aaaaaaaaaaaaaaaabaaaaaaaaaaaaaaaaaaaaaaaaaaaa4aaadata[list_number * number_of_word32s], key_start_pos, key_end_pos,
(uint32_t *) key,
prio_end_pos);
}
static void get_key(const aaaa1aaat *km, uint32_t list_number, key_and_mask_t *key, uint8_t narrow, uint8_t narrow_element)
{
uint16_t key_size = get_key_size(km);
uint16_t key_start_pos = 0;
const uint16_t list_length = a1aaaaaaaaaaaaaaaabaaaaaaaaaaaa3aaaaaaaaaaaaaaaabaaaaaaaaaaaaaaaaaaaaaaaaaaaa3aaaaaaaaaaaaabaaaaaaaaaaaaaaaaa4aaaaaaaaaaaaaaaabaaaaaaaaaaaaaaaaaaaaaaaaaaaa4aaalength(km->client);
const uint16_t number_of_word32s = list_length / 32;
if (a1aaaaaaaaaaaaaaabaaaaaaaaaaaa3aaaaaaaaaaaaaaaabaaaaaaaaaaaaaaaaaaaaaaaaaaaa3aaamixed_mode(km->client)) {
assert(!a1aaaaaaaaaaaaaaabaaaaaaaaaaaa3aaaaaaaaaaaaaaaabaaaaaaaaaaaaaaaaaaaaaaaaaaaa3aaaaaaaaaaaaaaaabaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaa3aaa(km->client));
if (narrow != 0) {
key_size = a1aaaaaaaaaaaaaaaabaaaaaaaaaaaa3aaaaaaaaaaaaaaaabaaaaaaaaaaaaaaaaaaaaaaaaaaaa3aaanarrow_key_width(km->client);
}
if ((narrow != 0) && (narrow_element == 1)) {
key_start_pos = list_length / 2;
}
}
const uint16_t key_end_pos = key_start_pos + key_size - 1;
cam_read_field(&km->aaaaaaaaaaaaaa1aaaaaaaaaaaaaaaabaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaa3aaaaaaaaaaaaaaaabaaaaaaaaaaaaaaaaaaaaaaaaaaaa4aaadata[list_number * number_of_word32s], key_start_pos, key_end_pos,
(uint32_t *) key);
}
static void set_aaaaaaaaaaaaaa1aaaaaaaaaaaaaaaabaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaa3aaa(const aaaa1aaat *km, uint32_t list_number, const aaaaaaaaaaaaaaaa1aaaaaaaaaaaaaaaabaaaaaaaaaaaaaaaaaaaaaaaaaaaa3aaat *aaaaaaaaaaaaaa1aaaaaaaaaaaaaaaabaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaa3aaa,
uint8_t narrow, uint8_t narrow_element)
{
const uint16_t list_length = a1aaaaaaaaaaaaaaaabaaaaaaaaaaaa3aaaaaaaaaaaaaaaabaaaaaaaaaaaaaaaaaaaaaaaaaaaa3aaaaaaaaaaaaabaaaaaaaaaaaaaaaaa4aaaaaaaaaaaaaaaabaaaaaaaaaaaaaaaaaaaaaaaaaaaa4aaalength(km->client);
uint16_t prio_field_end_pos = list_length - 2;
uint16_t aaaaaaaaaaaaaa1aaaaaaaaaaaaaaaabaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaa3aaaaaaaaaaaaaaaabaaaaaaaaaaaaaaaaaaaaaaaaaaaa4aaawidth = a1aaaaaaaaaaaaaaaabaaaaaaaaaaaa3aaaaaaaaaaaaaaaabaaaaaaaaaaaaaaaaaaaaaaaaaaaa3aaaaaaaaaaaaaaabaaaaaaaaaaaaaaaaa4aaaaaaaaaaaaaaaabaaaaaaaaaaaaaaaaaaaaaaaaaaaa4aaawidth(km->client) + a1aaaaaaaaaaaaaaaabaaaaaaaaaaaa3aaaaaaaaaaaaaaaabaaaaaaaaaaaaaaaaaaaaaaaaaaaa3aaaaaaaaaaaaaaaabaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaa3aaaaaaaaaaaaaaaabaaaaaaaaaaaaaaaaaaaaaaaaaaaa4aaawidth(km->client);
const uint16_t number_of_word32s = list_length / 32;
const bool mixed_mode = a1aaaaaaaaaaaaaaabaaaaaaaaaaaa3aaaaaaaaaaaaaaaabaaaaaaaaaaaaaaaaaaaaaaaaaaaa3aaamixed_mode(km->client);
assert((!mixed_mode && narrow == false) || mixed_mode);
if (mixed_mode) {
assert(!a1aaaaaaaaaaaaaaabaaaaaaaaaaaa3aaaaaaaaaaaaaaaabaaaaaaaaaaaaaaaaaaaaaaaaaaaa3aaaaaaaaaaaaaaaabaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaa3aaa(km->client));
if (narrow && (narrow_element == 0)) {
prio_field_end_pos = list_length / 2 - 3;
} else {
prio_field_end_pos = list_length - 3;
}
}
const uint16_t response_field_start_pos = prio_field_end_pos - aaaaaaaaaaaaaa1aaaaaaaaaaaaaaaabaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaa3aaaaaaaaaaaaaaaabaaaaaaaaaaaaaaaaaaaaaaaaaaaa4aaawidth + 1;
cam_write_field(&km->aaaaaaaaaaaaaa1aaaaaaaaaaaaaaaabaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaa3aaaaaaaaaaaaaaaabaaaaaaaaaaaaaaaaaaaaaaaaaaaa4aaadata[list_number * number_of_word32s], response_field_start_pos,
prio_field_end_pos, (uint32_t *) aaaaaaaaaaaaaa1aaaaaaaaaaaaaaaabaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaa3aaa, prio_field_end_pos);
}
static void set_response(const aaaa1aaat *km, uint32_t list_number, const aaaaaaaaaaaaaaaa1aaaaaaaaaaaaaaaabaaaaaaaaaaaaaaaaaaaaaaaaaaaa3aaat *aaaaaaaaaaaaaa1aaaaaaaaaaaaaaaabaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaa3aaa,
uint8_t narrow, uint8_t narrow_element)
{
const uint16_t list_length = a1aaaaaaaaaaaaaaaabaaaaaaaaaaaa3aaaaaaaaaaaaaaaabaaaaaaaaaaaaaaaaaaaaaaaaaaaa3aaaaaaaaaaaaabaaaaaaaaaaaaaaaaa4aaaaaaaaaaaaaaaabaaaaaaaaaaaaaaaaaaaaaaaaaaaa4aaalength(km->client);
uint16_t prio_field_end_pos = list_length - 2;
const uint8_t prio_width = a1aaaaaaaaaaaaaaaabaaaaaaaaaaaa3aaaaaaaaaaaaaaaabaaaaaaaaaaaaaaaaaaaaaaaaaaaa3aaaaaaaaaaaaaaabaaaaaaaaaaaaaaaaa4aaaaaaaaaaaaaaaabaaaaaaaaaaaaaaaaaaaaaaaaaaaa4aaawidth(km->client);
uint16_t response_width = a1aaaaaaaaaaaaaaaabaaaaaaaaaaaa3aaaaaaaaaaaaaaaabaaaaaaaaaaaaaaaaaaaaaaaaaaaa3aaaaaaaaaaaaaaaabaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaa3aaaaaaaaaaaaaaaabaaaaaaaaaaaaaaaaaaaaaaaaaaaa4aaawidth(km->client);
uint16_t aaaaaaaaaaaaaa1aaaaaaaaaaaaaaaabaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaa3aaaaaaaaaaaaaaaabaaaaaaaaaaaaaaaaaaaaaaaaaaaa4aaawidth = prio_width + response_width;
const uint16_t number_of_word32s = list_length / 32;
const bool mixed_mode = a1aaaaaaaaaaaaaaabaaaaaaaaaaaa3aaaaaaaaaaaaaaaabaaaaaaaaaaaaaaaaaaaaaaaaaaaa3aaamixed_mode(km->client);
assert((!mixed_mode && narrow == false) || mixed_mode);
if (mixed_mode) {
assert(!a1aaaaaaaaaaaaaaabaaaaaaaaaaaa3aaaaaaaaaaaaaaaabaaaaaaaaaaaaaaaaaaaaaaaaaaaa3aaaaaaaaaaaaaaaabaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaa3aaa(km->client));
if (narrow && (narrow_element == 0)) {
prio_field_end_pos = list_length / 2 - 3;
} else {
prio_field_end_pos = list_length - 3;
}
}
const uint16_t response_field_start_pos = prio_field_end_pos - aaaaaaaaaaaaaa1aaaaaaaaaaaaaaaabaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaa3aaaaaaaaaaaaaaaabaaaaaaaaaaaaaaaaaaaaaaaaaaaa4aaawidth + 1;
const uint16_t response_field_end_pos = response_field_start_pos + response_width - 1;
cam_write_field(&km->aaaaaaaaaaaaaa1aaaaaaaaaaaaaaaabaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaa3aaaaaaaaaaaaaaaabaaaaaaaaaaaaaaaaaaaaaaaaaaaa4aaadata[list_number * number_of_word32s], response_field_start_pos,
response_field_end_pos, (uint32_t *) aaaaaaaaaaaaaa1aaaaaaaaaaaaaaaabaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaa3aaa, prio_field_end_pos);
}
static void get_aaaaaaaaaaaaaa1aaaaaaaaaaaaaaaabaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaa3aaa(const aaaa1aaat *km, uint32_t list_number, aaaaaaaaaaaaaaaa1aaaaaaaaaaaaaaaabaaaaaaaaaaaaaaaaaaaaaaaaaaaa3aaat *aaaaaaaaaaaaaa1aaaaaaaaaaaaaaaabaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaa3aaa,
uint8_t narrow, uint8_t narrow_element)
{
const uint16_t list_length = a1aaaaaaaaaaaaaaaabaaaaaaaaaaaa3aaaaaaaaaaaaaaaabaaaaaaaaaaaaaaaaaaaaaaaaaaaa3aaaaaaaaaaaaabaaaaaaaaaaaaaaaaa4aaaaaaaaaaaaaaaabaaaaaaaaaaaaaaaaaaaaaaaaaaaa4aaalength(km->client);
uint16_t prio_field_end_pos = list_length - 2;
uint16_t aaaaaaaaaaaaaa1aaaaaaaaaaaaaaaabaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaa3aaaaaaaaaaaaaaaabaaaaaaaaaaaaaaaaaaaaaaaaaaaa4aaawidth = a1aaaaaaaaaaaaaaaabaaaaaaaaaaaa3aaaaaaaaaaaaaaaabaaaaaaaaaaaaaaaaaaaaaaaaaaaa3aaaaaaaaaaaaaaabaaaaaaaaaaaaaaaaa4aaaaaaaaaaaaaaaabaaaaaaaaaaaaaaaaaaaaaaaaaaaa4aaawidth(km->client) + a1aaaaaaaaaaaaaaaabaaaaaaaaaaaa3aaaaaaaaaaaaaaaabaaaaaaaaaaaaaaaaaaaaaaaaaaaa3aaaaaaaaaaaaaaaabaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaa3aaaaaaaaaaaaaaaabaaaaaaaaaaaaaaaaaaaaaaaaaaaa4aaawidth(km->client);
const uint16_t number_of_word32s = list_length / 32;
const bool mixed_mode = a1aaaaaaaaaaaaaaabaaaaaaaaaaaa3aaaaaaaaaaaaaaaabaaaaaaaaaaaaaaaaaaaaaaaaaaaa3aaamixed_mode(km->client);
assert((!mixed_mode && (narrow == 0)) || mixed_mode);
if (mixed_mode) {
assert(!a1aaaaaaaaaaaaaaabaaaaaaaaaaaa3aaaaaaaaaaaaaaaabaaaaaaaaaaaaaaaaaaaaaaaaaaaa3aaaaaaaaaaaaaaaabaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaa3aaa(km->client));
if (narrow && (narrow_element == 0)) {
prio_field_end_pos = list_length / 2 - 3;
} else {
prio_field_end_pos = list_length - 3;
}
}
const uint16_t response_field_start_pos = prio_field_end_pos - aaaaaaaaaaaaaa1aaaaaaaaaaaaaaaabaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaa3aaaaaaaaaaaaaaaabaaaaaaaaaaaaaaaaaaaaaaaaaaaa4aaawidth + 1;
cam_read_field(&km->aaaaaaaaaaaaaa1aaaaaaaaaaaaaaaabaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaa3aaaaaaaaaaaaaaaabaaaaaaaaaaaaaaaaaaaaaaaaaaaa4aaadata[list_number * number_of_word32s], response_field_start_pos,
prio_field_end_pos,
(uint32_t *) aaaaaaaaaaaaaa1aaaaaaaaaaaaaaaabaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaa3aaa);
}
void aaaa1bbbbbbbbbbbbbbbbbbbb3aaaaaaaaaaaaaaaabaaaaaaaaaaaaaaaaaaaaaaaaaaaa4aaaaaaaaaaaaaaaaa1aaaaaaaaaaaaaaaabaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaa3aaa(aaaa1aaat *km, uint32_t aaaaaaaaaa1aaaaaaaaaaaaaaaabaaaaaaaaaaaaaaaaaaaaaaaaaaaa3aaaaaaaaaaaaaaabaaaaaaaaaaaaaaaa4aaaber, const aaaaaaaaaaaaaaaa1aaaaaaaaaaaaaaaabaaaaaaaaaaaaaaaaaaaaaaaaaaaa3aaat *aaaaaaaaaaaaaa1aaaaaaaaaaaaaaaabaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaa3aaa,
uint8_t narrow, uint8_t narrow_element)
{
set_aaaaaaaaaaaaaa1aaaaaaaaaaaaaaaabaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaa3aaa(km, aaaaaaaaaa1aaaaaaaaaaaaaaaabaaaaaaaaaaaaaaaaaaaaaaaaaaaa3aaaaaaaaaaaaaaabaaaaaaaaaaaaaaaa4aaaber, aaaaaaaaaaaaaa1aaaaaaaaaaaaaaaabaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaa3aaa, narrow, narrow_element);
if (km->flush == true) {
flush(km, aaaaaaaaaa1aaaaaaaaaaaaaaaabaaaaaaaaaaaaaaaaaaaaaaaaaaaa3aaaaaaaaaaaaaaabaaaaaaaaaaaaaaaa4aaaber, false, false, OTHER, narrow, narrow_element, false, false);
}
}
void aaaa1bbbbbbbbbbbbbbbbbbbb3aaaaaaaaaaaaaaaabaaaaaaaaaaaaaaaaaaaaaaaaaaaa4aaaaaaaaaaaaaaaabaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaa4aaa(aaaa1aaat *km, uint32_t aaaaaaaaaa1aaaaaaaaaaaaaaaabaaaaaaaaaaaaaaaaaaaaaaaaaaaa3aaaaaaaaaaaaaaabaaaaaaaaaaaaaaaa4aaaber, const aaaaaaaaaaaaaaaa1aaaaaaaaaaaaaaaabaaaaaaaaaaaaaaaaaaaaaaaaaaaa3aaat *aaaaaaaaaaaaaa1aaaaaaaaaaaaaaaabaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaa3aaa, uint8_t narrow,
uint8_t narrow_element)
{
set_response(km, aaaaaaaaaa1aaaaaaaaaaaaaaaabaaaaaaaaaaaaaaaaaaaaaaaaaaaa3aaaaaaaaaaaaaaabaaaaaaaaaaaaaaaa4aaaber, aaaaaaaaaaaaaa1aaaaaaaaaaaaaaaabaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaa3aaa, narrow, narrow_element);
if (km->flush == true) {
flush(km, aaaaaaaaaa1aaaaaaaaaaaaaaaabaaaaaaaaaaaaaaaaaaaaaaaaaaaa3aaaaaaaaaaaaaaabaaaaaaaaaaaaaaaa4aaaber, false, false, UPDATE, narrow, narrow_element, false, false);
}
}
static void divide_key_and_mask(aaaaaaaaaaaaa1aaat *key, aaaaaaaaaaaaa1aaat *ternary_mask,
const key_and_mask_t *key_and_mask)
{
memset(&(key->word[0]), 0, sizeof(aaaaaaaaaaaaa1aaat));
memset(&(ternary_mask->word[0]), 0, sizeof(aaaaaaaaaaaaa1aaat));
for (uint16_t i = 0; i < KEY_AND_MASK_WIDTH_MEM; i++) {
uint32_t word = key_and_mask->word[i];
for (uint16_t shift = 0; shift < 16; shift++) {
uint16_t key_bit = word & 1;
uint16_t mask_bit = (word & 2) >> 1;
word = word >> 2;
const uint16_t hi = (i & 1) * 16;
key->word[i / 2] = aaaaaaaa1aaaaaaaaaaaaaaaabaaaaaaaaaaaaaaaaaaaaaa3aaa(key->word[i / 2], key_bit, hi + shift, 1);
ternary_mask->word[i / 2] = aaaaaaaa1aaaaaaaaaaaaaaaabaaaaaaaaaaaaaaaaaaaaaa3aaa(ternary_mask->word[i / 2], mask_bit, hi + shift, 1);
}
}
}
static void merge_key_and_mask(key_and_mask_t *key_and_mask, const aaaaaaaaaaaaa1aaat *aaaaaaaaa1aaa,
const aaaaaaaaaaaaa1aaat *ternary_mask)
{
memset(&(key_and_mask->word[0]), 0, sizeof(key_and_mask_t));
for (uint16_t i = 0; i < KEY_AND_MASK_WIDTH_MEM; i++) {
uint32_t key_word = aaaaaaaaa1aaa->word[i / 2];
uint32_t mask_word = ternary_mask->word[i / 2];
if ((i & 1) == 1) {
key_word = key_word >> 16;
mask_word = mask_word >> 16;
}
uint32_t new_word = 0;
uint32_t bit_mask = 1;
for (uint16_t shift = 0; shift < 16; shift++) {
new_word |= key_word & bit_mask;
key_word <<= 1;
bit_mask <<= 1;
mask_word <<= 1;
new_word |= mask_word & bit_mask;
bit_mask <<= 1;
}
key_and_mask->word[i] = new_word;
}
}
void aaaa1aaaaaaaaaaaaaaaabaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaa3aaa(aaaa1aaat *km, uint32_t aaaaaaaaaa1aaaaaaaaaaaaaaaabaaaaaaaaaaaaaaaaaaaaaaaaaaaa3aaaaaaaaaaaaaaabaaaaaaaaaaaaaaaa4aaaber, const aaaaaaaaaaaaaaa1aaat *pointer_list, uint8_t narrow, uint8_t narrow_element)
{
assert(aaaaaaaaaaaaaaa1aaaaaaaaaaaaaaaabaaaaaaaaaaaa3aaaaaaaaaaaaaaaabaaaaaaaaaaaaaaaaaaaaaaaaaaaa3aaaaaaaaaaaaaaabaaaaaaaaaaaaaaaa4aaaber_of_keys(pointer_list) > 0);
bool wide2narrow = false;
const aaaaaaaaaaaaa1aaat *aaaaaaaaa1aaa = aaaaaaaaaaaaaaa1aaaaaaaaaaaaaaaabaaaaaaaaaaaa3aaaaaaaaaaaaaaaabaaaaaaaaaaaaaaaaaaaaaaaaaaaa3aaaaaaaaaaaa1aaa(pointer_list, 0);
const aaaaaaaaaaaaaaaa1aaaaaaaaaaaaaaaabaaaaaaaaaaaaaaaaaaaaaaaaaaaa3aaat *aaaaaaaaaaaaaa1aaaaaaaaaaaaaaaabaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaa3aaaaaaaaaaaaaaaabaaaaaaaaaaaaaaaaaaaaaaaaaaaa4aaaptr = aaaaaaaaaaaaaaa1aaaaaaaaaaaaaaaabaaaaaaaaaaaa3aaaaaaaaaaaaaaaabaaaaaaaaaaaaaaaaaaaaaaaaaaaa3aaaaaaaaaaaaaaabaaaaaaaaaaaaaaaaa4aaa(pointer_list, 0);
set_aaaaaaaaaaaaaa1aaaaaaaaaaaaaaaabaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaa3aaa(km, aaaaaaaaaa1aaaaaaaaaaaaaaaabaaaaaaaaaaaaaaaaaaaaaaaaaaaa3aaaaaaaaaaaaaaabaaaaaaaaaaaaaaaa4aaaber, aaaaaaaaaaaaaa1aaaaaaaaaaaaaaaabaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaa3aaaaaaaaaaaaaaaabaaaaaaaaaaaaaaaaaaaaaaaaaaaa4aaaptr, narrow, narrow_element);
if (a1aaaaaaaaaaaaaaabaaaaaaaaaaaa3aaaaaaaaaaaaaaaabaaaaaaaaaaaaaaaaaaaaaaaaaaaa3aaaaaaaaaaaaaaaabaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaa3aaa(km->client)) {
const aaaaaaaaaaaaa1aaat *ternary_mask = aaaaaaaaaaaaaaa1aaaaaaaaaaaaaaaabaaaaaaaaaaaa3aaaaaaaaaaaaaaaabaaaaaaaaaaaaaaaaaaaaaaaaaaaa3aaaternary_mask(pointer_list, 0);
key_and_mask_t new_key;
merge_key_and_mask(&new_key, aaaaaaaaa1aaa, ternary_mask);
set_key(km, aaaaaaaaaa1aaaaaaaaaaaaaaaabaaaaaaaaaaaaaaaaaaaaaaaaaaaa3aaaaaaaaaaaaaaabaaaaaaaaaaaaaaaa4aaaber, &new_key, narrow, narrow_element);
if (aaaaaaaaaaaaaaa1aaaaaaaaaaaaaaabaaaaaaaaaaaa3aaaaaaaaaaaaaaaabaaaaaaaaaaaaaaaaaaaaaaaaaaaa3aaaaaaaaaaaaaaaabaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaa3aaaaaaaaaaaaaaaabaaaaaaaaaaaaaaaaaaaaaaaaaaaa4aaapointer(pointer_list)) {
km->source_bucket[aaaaaaaaaa1aaaaaaaaaaaaaaaabaaaaaaaaaaaaaaaaaaaaaaaaaaaa3aaaaaaaaaaaaaaabaaaaaaaaaaaaaaaa4aaaber].direct_pointer = true;
} else {
km->source_bucket[aaaaaaaaaa1aaaaaaaaaaaaaaaabaaaaaaaaaaaaaaaaaaaaaaaaaaaa3aaaaaaaaaaaaaaabaaaaaaaaaaaaaaaa4aaaber].direct_pointer = false;
}
const uint32_t temp_bucket = aaaaaaaaaaaaaaa1aaaaaaaaaaaaaaaabaaaaaaaaaaaa3aaaaaaaaaaaaaaaabaaaaaaaaaaaaaaaaaaaaaaaaaaaa3aaaaaaaaaabaaaaaaaaaaa4aaa(pointer_list);
assert(temp_bucket <= UINT16_MAX);
km->source_bucket[aaaaaaaaaa1aaaaaaaaaaaaaaaabaaaaaaaaaaaaaaaaaaaaaaaaaaaa3aaaaaaaaaaaaaaabaaaaaaaaaaaaaaaa4aaaber].perfect_bucket = temp_bucket;
set_valid_bit(km, aaaaaaaaaa1aaaaaaaaaaaaaaaabaaaaaaaaaaaaaaaaaaaaaaaaaaaa3aaaaaaaaaaaaaaabaaaaaaaaaaaaaaaa4aaaber, 1);
} else {
set_key(km, aaaaaaaaaa1aaaaaaaaaaaaaaaabaaaaaaaaaaaaaaaaaaaaaaaaaaaa3aaaaaaaaaaaaaaabaaaaaaaaaaaaaaaa4aaaber, (key_and_mask_t *) aaaaaaaaa1aaa, narrow, narrow_element);
if (a1aaaaaaaaaaaaaaabaaaaaaaaaaaa3aaaaaaaaaaaaaaaabaaaaaaaaaaaaaaaaaaaaaaaaaaaa3aaamixed_mode(km->client)) {
bool wide_valid, narrow1_valid, narrow0_valid;
aaaa1aaaaaaaaaaaaaaaabaaaaaaaaaaaa3aaaaaaaaaaaaaaaabaaaaaaaaaaaaaaaaaaaaaaaaaaaa3aaaaaaaaaaaaaaaabaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaa3aaaaaaaaaaaaaaaabaaaaaaaaaaaaaaaaaaaaaaaaaaaa4aaabits(km, aaaaaaaaaa1aaaaaaaaaaaaaaaabaaaaaaaaaaaaaaaaaaaaaaaaaaaa3aaaaaaaaaaaaaaabaaaaaaaaaaaaaaaa4aaaber, &wide_valid, &narrow1_valid, &narrow0_valid);
if (wide_valid && narrow) {
set_control_bits(km, aaaaaaaaaa1aaaaaaaaaaaaaaaabaaaaaaaaaaaaaaaaaaaaaaaaaaaa3aaaaaaaaaaaaaaabaaaaaaaaaaaaaaaa4aaaber, 0, 0, 0);
wide2narrow = true;
}
}
set_control_bits(km, aaaaaaaaaa1aaaaaaaaaaaaaaaabaaaaaaaaaaaaaaaaaaaaaaaaaaaa3aaaaaaaaaaaaaaabaaaaaaaaaaaaaaaa4aaaber, 1, narrow, narrow_element);
}
if (km->flush == true) {
flush(km, aaaaaaaaaa1aaaaaaaaaaaaaaaabaaaaaaaaaaaaaaaaaaaaaaaaaaaa3aaaaaaaaaaaaaaabaaaaaaaaaaaaaaaa4aaaber, false, false, OTHER, narrow, narrow_element, false, wide2narrow);
}
}
void aaaa1aaaread(const aaaa1aaat *km, uint32_t aaaaaaaaaa1aaaaaaaaaaaaaaaabaaaaaaaaaaaaaaaaaaaaaaaaaaaa3aaaaaaaaaaaaaaabaaaaaaaaaaaaaaaa4aaaber, aaaaaaaaaaaaaaa1aaat *pointer_list)
{
assert(a1aaaaaaaaaaaaaaabaaaaaaaaaaaa3aaaaaaaaaaaaaaaabaaaaaaaaaaaaaaaaaaaaaaaaaaaa3aaaaaaaaaaaaaaaabaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaa3aaa(km->client));
if (aaaa1aaaaaaaaaaaaaaabaaaaaaaaaaaa3aaaaaaaaaaaaaaaabaaaaaaaaaaaaaaaaaaaaaaaaaaaa3aaaaaaaaaaaaaaaabaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaa3aaa(km, aaaaaaaaaa1aaaaaaaaaaaaaaaabaaaaaaaaaaaaaaaaaaaaaaaaaaaa3aaaaaaaaaaaaaaabaaaaaaaaaaaaaaaa4aaaber))
return;
aaaaaaaaaaaaaaaa1aaaaaaaaaaaaaaaabaaaaaaaaaaaaaaaaaaaaaaaaaaaa3aaat aaaaaaaaaaaaaa1aaaaaaaaaaaaaaaabaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaa3aaa;
memset(&aaaaaaaaaaaaaa1aaaaaaaaaaaaaaaabaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaa3aaa, 0, sizeof(aaaaaaaaaaaaaa1aaaaaaaaaaaaaaaabaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaa3aaa));
key_and_mask_t aaaaaaaaa1aaa;
aaaaaaaaaaaaa1aaat ternary_mask;
memset(&aaaaaaaaa1aaa, 0, sizeof(aaaaaaaaa1aaa));
if (((aaaaaaaaaaaaaaa1aaaaaaaaaaaaaaabaaaaaaaaaaaa3aaaaaaaaaaaaaaaabaaaaaaaaaaaaaaaaaaaaaaaaaaaa3aaaaaaaaaaaaaaaabaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaa3aaaaaaaaaaaaaaaabaaaaaaaaaaaaaaaaaaaaaaaaaaaa4aaapointer(pointer_list)) && km->source_bucket[aaaaaaaaaa1aaaaaaaaaaaaaaaabaaaaaaaaaaaaaaaaaaaaaaaaaaaa3aaaaaaaaaaaaaaabaaaaaaaaaaaaaaaa4aaaber].direct_pointer)
|| ((!aaaaaaaaaaaaaaa1aaaaaaaaaaaaaaabaaaaaaaaaaaa3aaaaaaaaaaaaaaaabaaaaaaaaaaaaaaaaaaaaaaaaaaaa3aaaaaaaaaaaaaaaabaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaa3aaaaaaaaaaaaaaaabaaaaaaaaaaaaaaaaaaaaaaaaaaaa4aaapointer(pointer_list)) && !km->source_bucket[aaaaaaaaaa1aaaaaaaaaaaaaaaabaaaaaaaaaaaaaaaaaaaaaaaaaaaa3aaaaaaaaaaaaaaabaaaaaaaaaaaaaaaa4aaaber].direct_pointer)) {
const uint32_t temp_bucket = aaaaaaaaaaaaaaa1aaaaaaaaaaaaaaaabaaaaaaaaaaaa3aaaaaaaaaaaaaaaabaaaaaaaaaaaaaaaaaaaaaaaaaaaa3aaaaaaaaaabaaaaaaaaaaa4aaa(pointer_list);
assert(temp_bucket <= UINT16_MAX);
if (km->source_bucket[aaaaaaaaaa1aaaaaaaaaaaaaaaabaaaaaaaaaaaaaaaaaaaaaaaaaaaa3aaaaaaaaaaaaaaabaaaaaaaaaaaaaaaa4aaaber].perfect_bucket == temp_bucket) {
get_aaaaaaaaaaaaaa1aaaaaaaaaaaaaaaabaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaa3aaa(km, aaaaaaaaaa1aaaaaaaaaaaaaaaabaaaaaaaaaaaaaaaaaaaaaaaaaaaa3aaaaaaaaaaaaaaabaaaaaaaaaaaaaaaa4aaaber, &aaaaaaaaaaaaaa1aaaaaaaaaaaaaaaabaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaa3aaa, 0, 0);
get_key(km, aaaaaaaaaa1aaaaaaaaaaaaaaaabaaaaaaaaaaaaaaaaaaaaaaaaaaaa3aaaaaaaaaaaaaaabaaaaaaaaaaaaaaaa4aaaber, &aaaaaaaaa1aaa, 0, 0);
aaaaaaaaaaaaa1aaat new_key;
divide_key_and_mask(&new_key, &ternary_mask, &aaaaaaaaa1aaa);
aaaaaaaaaaaaaaa1bbbbbbbbbbbbbbbbbbbbbbbbbbbbbbbb3aaa(pointer_list, &aaaaaaaaaaaaaa1aaaaaaaaaaaaaaaabaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaa3aaa, &new_key, &ternary_mask, false);
}
}
}
void aaaa1bbbbbbbbbbbbbbbbb3aaa(aaaa1aaat *km, uint32_t aaaaaaaaaa1aaaaaaaaaaaaaaaabaaaaaaaaaaaaaaaaaaaaaaaaaaaa3aaaaaaaaaaaaaaabaaaaaaaaaaaaaaaa4aaaber)
{
assert(a1aaaaaaaaaaaaaaabaaaaaaaaaaaa3aaaaaaaaaaaaaaaabaaaaaaaaaaaaaaaaaaaaaaaaaaaa3aaaaaaaaaaaaaaaabaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaa3aaa(km->client));
assert(!aaaa1aaaaaaaaaaaaaaabaaaaaaaaaaaa3aaaaaaaaaaaaaaaabaaaaaaaaaaaaaaaaaaaaaaaaaaaa3aaaaaaaaaaaaaaaabaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaa3aaa(km, aaaaaaaaaa1aaaaaaaaaaaaaaaabaaaaaaaaaaaaaaaaaaaaaaaaaaaa3aaaaaaaaaaaaaaabaaaaaaaaaaaaaaaa4aaaber));
set_valid_bit(km, aaaaaaaaaa1aaaaaaaaaaaaaaaabaaaaaaaaaaaaaaaaaaaaaaaaaaaa3aaaaaaaaaaaaaaabaaaaaaaaaaaaaaaa4aaaber, 0);
if (km->flush == true) {
flush(km, aaaaaaaaaa1aaaaaaaaaaaaaaaabaaaaaaaaaaaaaaaaaaaaaaaaaaaa3aaaaaaaaaaaaaaabaaaaaaaaaaaaaaaa4aaaber, false, false, OTHER, 0, 0, false, false);
}
}
bool aaaa1aaaaaaaaaaaaaaabaaaaaaaaaaaa3aaaaaaaaaaaaaaaabaaaaaaaaaaaaaaaaaaaaaaaaaaaa3aaaaaaaaaaaaaaaabaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaa3aaa(const aaaa1aaat *km, uint32_t aaaaaaaaaa1aaaaaaaaaaaaaaaabaaaaaaaaaaaaaaaaaaaaaaaaaaaa3aaaaaaaaaaaaaaabaaaaaaaaaaaaaaaa4aaaber)
{
assert(aaaaaaaaaa1aaaaaaaaaaaaaaaabaaaaaaaaaaaaaaaaaaaaaaaaaaaa3aaaaaaaaaaaaaaabaaaaaaaaaaaaaaaa4aaaber < a1aaaaaaaaaaaaaaaabaaaaaaaaaaaa3aaaaaaaaaaaaaaaabaaaaaaaaaaaaaaaaaaaaaaaaaaaa3aaaaaaaaaaaaaaabaaaaaaaaaaaaaaaa4aaaaaaaaaaaaaaaabaaaaaaaaaaaaaaaaaaaaaaaaaaaa4aaaaaaaaaaaaabaaaaaaaaaaaaaaaaa5aaas(km->client));
uint32_t valid;
assert(!a1aaaaaaaaaaaaaaabaaaaaaaaaaaa3aaaaaaaaaaaaaaaabaaaaaaaaaaaaaaaaaaaaaaaaaaaa3aaamixed_mode(km->client));
const uint32_t valid_entry = aaaaaaaaaa1aaaaaaaaaaaaaaaabaaaaaaaaaaaaaaaaaaaaaaaaaaaa3aaaaaaaaaaaaaaabaaaaaaaaaaaaaaaa4aaaber / 32;
const uint32_t start = aaaaaaaaaa1aaaaaaaaaaaaaaaabaaaaaaaaaaaaaaaaaaaaaaaaaaaa3aaaaaaaaaaaaaaabaaaaaaaaaaaaaaaa4aaaber - valid_entry * 32;
valid = aaaaaaaa1aaaaaaaaaaaaaaaabaaaaaaaaaaaa3aaa(km->valid_cache[valid_entry], start, 1);
if (valid)
return false;
return true;
}
bool aaaa1aaaaaaaaaaaaaaabaaaaaaaaaaaa3aaaaaaaaaaaaaaaabaaaaaaaaaaaaaaaaaaaaaaaaaaaa3aaaaaaaaaaaaaaaabaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaa3aaaaaaaaaaaaaaaabaaaaaaaaaaaaaaaaaaaaaaaaaaaa4aaapointer(const aaaa1aaat *km, uint32_t aaaaaaaaaa1aaaaaaaaaaaaaaaabaaaaaaaaaaaaaaaaaaaaaaaaaaaa3aaaaaaaaaaaaaaabaaaaaaaaaaaaaaaa4aaaber)
{
assert(a1aaaaaaaaaaaaaaabaaaaaaaaaaaa3aaaaaaaaaaaaaaaabaaaaaaaaaaaaaaaaaaaaaaaaaaaa3aaaaaaaaaaaaaaaabaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaa3aaa(km->client));
assert(aaaaaaaaaa1aaaaaaaaaaaaaaaabaaaaaaaaaaaaaaaaaaaaaaaaaaaa3aaaaaaaaaaaaaaabaaaaaaaaaaaaaaaa4aaaber < a1aaaaaaaaaaaaaaaabaaaaaaaaaaaa3aaaaaaaaaaaaaaaabaaaaaaaaaaaaaaaaaaaaaaaaaaaa3aaaaaaaaaaaaaaabaaaaaaaaaaaaaaaa4aaaaaaaaaaaaaaaabaaaaaaaaaaaaaaaaaaaaaaaaaaaa4aaaaaaaaaaaaabaaaaaaaaaaaaaaaaa5aaas(km->client));
if (aaaa1aaaaaaaaaaaaaaabaaaaaaaaaaaa3aaaaaaaaaaaaaaaabaaaaaaaaaaaaaaaaaaaaaaaaaaaa3aaaaaaaaaaaaaaaabaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaa3aaa(km, aaaaaaaaaa1aaaaaaaaaaaaaaaabaaaaaaaaaaaaaaaaaaaaaaaaaaaa3aaaaaaaaaaaaaaabaaaaaaaaaaaaaaaa4aaaber))
return false;
return km->source_bucket[aaaaaaaaaa1aaaaaaaaaaaaaaaabaaaaaaaaaaaaaaaaaaaaaaaaaaaa3aaaaaaaaaaaaaaabaaaaaaaaaaaaaaaa4aaaber].direct_pointer;
}
uint32_t aaaa1aaaaaaaaaaaaaaaabaaaaaaaaaaaa3aaaaaaaaaaaaaaaabaaaaaaaaaaaaaaaaaaaaaaaaaaaa3aaaaaaaaaabaaaaaaaaaaa4aaa(const aaaa1aaat *km, uint32_t aaaaaaaaaa1aaaaaaaaaaaaaaaabaaaaaaaaaaaaaaaaaaaaaaaaaaaa3aaaaaaaaaaaaaaabaaaaaaaaaaaaaaaa4aaaber)
{
assert(a1aaaaaaaaaaaaaaabaaaaaaaaaaaa3aaaaaaaaaaaaaaaabaaaaaaaaaaaaaaaaaaaaaaaaaaaa3aaaaaaaaaaaaaaaabaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaa3aaa(km->client));
assert(false == aaaa1aaaaaaaaaaaaaaabaaaaaaaaaaaa3aaaaaaaaaaaaaaaabaaaaaaaaaaaaaaaaaaaaaaaaaaaa3aaaaaaaaaaaaaaaabaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaa3aaa(km, aaaaaaaaaa1aaaaaaaaaaaaaaaabaaaaaaaaaaaaaaaaaaaaaaaaaaaa3aaaaaaaaaaaaaaabaaaaaaaaaaaaaaaa4aaaber));
return km->source_bucket[aaaaaaaaaa1aaaaaaaaaaaaaaaabaaaaaaaaaaaaaaaaaaaaaaaaaaaa3aaaaaaaaaaaaaaabaaaaaaaaaaaaaaaa4aaaber].perfect_bucket;
}
bool aaaa1aaafind_first_fit_for_pointer_list(const aaaa1aaat *km,
const aaaaaaaaaaaaaaa1aaat *pointer_list, uint32_t *aaaaaaaaaa1aaaaaaaaaaaaaaaabaaaaaaaaaaaaaaaaaaaaaaaaaaaa3aaaaaaaaaaaaaaabaaaaaaaaaaaaaaaa4aaaber)
{
assert(a1aaaaaaaaaaaaaaabaaaaaaaaaaaa3aaaaaaaaaaaaaaaabaaaaaaaaaaaaaaaaaaaaaaaaaaaa3aaaaaaaaaaaaaaaabaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaa3aaa(km->client));
const uint32_t end_list = a1aaaaaaaaaaaaaaaabaaaaaaaaaaaa3aaaaaaaaaaaaaaaabaaaaaaaaaaaaaaaaaaaaaaaaaaaa3aaaaaaaaaaaaaaabaaaaaaaaaaaaaaaa4aaaaaaaaaaaaaaaabaaaaaaaaaaaaaaaaaaaaaaaaaaaa4aaaaaaaaaaaaabaaaaaaaaaaaaaaaaa5aaas(km->client) - 1;
assert(*aaaaaaaaaa1aaaaaaaaaaaaaaaabaaaaaaaaaaaaaaaaaaaaaaaaaaaa3aaaaaaaaaaaaaaabaaaaaaaaaaaaaaaa4aaaber <= end_list);
uint32_t list_number = *aaaaaaaaaa1aaaaaaaaaaaaaaaabaaaaaaaaaaaaaaaaaaaaaaaaaaaa3aaaaaaaaaaaaaaabaaaaaaaaaaaaaaaa4aaaber;
assert(aaaaaaaaaaaaaaa1aaaaaaaaaaaaaaaabaaaaaaaaaaaa3aaaaaaaaaaaaaaaabaaaaaaaaaaaaaaaaaaaaaaaaaaaa3aaaaaaaaaaaaaaabaaaaaaaaaaaaaaaa4aaaber_of_keys(pointer_list) == 1);
const uint32_t number_of_iterations = end_list + 1;
uint16_t i = 0;
while (i < number_of_iterations) {
if (list_number > end_list) {
list_number = 0;
}
if (aaaa1aaaaaaaaaaaaaaabaaaaaaaaaaaa3aaaaaaaaaaaaaaaabaaaaaaaaaaaaaaaaaaaaaaaaaaaa3aaaaaaaaaaaaaaaabaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaa3aaa(km, list_number)) {
*aaaaaaaaaa1aaaaaaaaaaaaaaaabaaaaaaaaaaaaaaaaaaaaaaaaaaaa3aaaaaaaaaaaaaaabaaaaaaaaaaaaaaaa4aaaber = list_number;
return true;
}
list_number++;
i++;
}
return false;
}
void aaaa1aaaaaaaaaaaaaaaabaaaaaaaaaaaaaaaaaaa3aaa(aaaa1aaat *km)
{
assert(a1aaaaaaaaaaaaaaabaaaaaaaaaaaa3aaaaaaaaaaaaaaaabaaaaaaaaaaaaaaaaaaaaaaaaaaaa3aaaaaaaaaaaaaaaabaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaa3aaa(km->client));
const uint32_t end_list = a1aaaaaaaaaaaaaaaabaaaaaaaaaaaa3aaaaaaaaaaaaaaaabaaaaaaaaaaaaaaaaaaaaaaaaaaaa3aaaaaaaaaaaaaaabaaaaaaaaaaaaaaaa4aaaaaaaaaaaaaaaabaaaaaaaaaaaaaaaaaaaaaaaaaaaa4aaaaaaaaaaaaabaaaaaaaaaaaaaaaaa5aaas(km->client) - 1;
for (uint32_t i = 0; i <= end_list; i++) {
set_valid_bit(km, i, 0);
if (!(a1aaaaaaaaaaaaaaaabaaaaaaaaaaaa3aaaaaaaaaaaaaaaabaaaaaaaaaaaaaaaaaaaaaaaaaaaa3bbbbbbbbbbbbbbbbbbbbbbbbbbbbbbbbbbbbb3aaaaaaaaaaaaaaaabaaaaaaaaaaaaaaaaaaaaaaaaaaaa4aaaflags(km->client) & CAM_DEBUG_SKIP_MEM_INIT)) {
flush(km, i, false, false, OTHER, 0, 0, false, false);
}
}
}
void aaaa1aaaaaaaaaaaaaaaabaaaaaaaaaaaaaaaaaaa3aaaaaaaaaaaaaaaabaaaaaaaaaaaaaaaaaaaaaaaaaaaa3aaaelement(aaaa1aaat *km, uint32_t aaaaaaaaaa1aaaaaaaaaaaaaaaabaaaaaaaaaaaaaaaaaaaaaaaaaaaa3aaaaaaaaaaaaaaabaaaaaaaaaaaaaaaa4aaaber, uint8_t narrow, uint8_t narrow_element)
{
bool bit511or255 = false;
const bool mixed = a1aaaaaaaaaaaaaaabaaaaaaaaaaaa3aaaaaaaaaaaaaaaabaaaaaaaaaaaaaaaaaaaaaaaaaaaa3aaamixed_mode(km->client);
if ((narrow == 0) && mixed) {
bit511or255 = get_bit511or255(km, aaaaaaaaaa1aaaaaaaaaaaaaaaabaaaaaaaaaaaaaaaaaaaaaaaaaaaa3aaaaaaaaaaaaaaabaaaaaaaaaaaaaaaa4aaaber);
}
if (mixed)
set_control_bits(km, aaaaaaaaaa1aaaaaaaaaaaaaaaabaaaaaaaaaaaaaaaaaaaaaaaaaaaa3aaaaaaaaaaaaaaabaaaaaaaaaaaaaaaa4aaaber, 0, narrow, narrow_element);
else
set_valid_bit(km, aaaaaaaaaa1aaaaaaaaaaaaaaaabaaaaaaaaaaaaaaaaaaaaaaaaaaaa3aaaaaaaaaaaaaaabaaaaaaaaaaaaaaaa4aaaber, 0);
assert(km->flush == true);
flush(km, aaaaaaaaaa1aaaaaaaaaaaaaaaabaaaaaaaaaaaaaaaaaaaaaaaaaaaa3aaaaaaaaaaaaaaabaaaaaaaaaaaaaaaa4aaaber, false, false, DELETE, narrow, narrow_element, bit511or255, false);
}
bool aaaa1aaaaaaaaaaaaaaabaaaaaaaaaaaa3aaaaaaaaaaaaaaaabaaaaaaaaaaaaaaaaaaaaaaaaaaaa3aaapresent(const aaaa1aaat *km, uint32_t aaaaaaaaaa1aaaaaaaaaaaaaaaabaaaaaaaaaaaaaaaaaaaaaaaaaaaa3aaaaaaaaaaaaaaabaaaaaaaaaaaaaaaa4aaaber, uint8_t narrow, uint8_t narrow_element)
{
if (a1aaaaaaaaaaaaaaabaaaaaaaaaaaa3aaaaaaaaaaaaaaaabaaaaaaaaaaaaaaaaaaaaaaaaaaaa3aaamixed_mode(km->client)) {
bool wide_valid, narrow1_valid, narrow0_valid;
aaaa1aaaaaaaaaaaaaaaabaaaaaaaaaaaa3aaaaaaaaaaaaaaaabaaaaaaaaaaaaaaaaaaaaaaaaaaaa3aaaaaaaaaaaaaaaabaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaa3aaaaaaaaaaaaaaaabaaaaaaaaaaaaaaaaaaaaaaaaaaaa4aaabits(km, aaaaaaaaaa1aaaaaaaaaaaaaaaabaaaaaaaaaaaaaaaaaaaaaaaaaaaa3aaaaaaaaaaaaaaabaaaaaaaaaaaaaaaa4aaaber, &wide_valid, &narrow1_valid, &narrow0_valid);
if (narrow == 0 && wide_valid == false)
return false;
if (!(narrow == 0) && narrow_element == 0 && narrow0_valid == false)
return false;
if (!(narrow == 0) && narrow_element == 1 && narrow1_valid == false)
return false;
} else if (aaaa1aaaaaaaaaaaaaaabaaaaaaaaaaaa3aaaaaaaaaaaaaaaabaaaaaaaaaaaaaaaaaaaaaaaaaaaa3aaaaaaaaaaaaaaaabaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaa3aaa(km, aaaaaaaaaa1aaaaaaaaaaaaaaaabaaaaaaaaaaaaaaaaaaaaaaaaaaaa3aaaaaaaaaaaaaaabaaaaaaaaaaaaaaaa4aaaber))
return false;
return true;
}
bool aaaa1aaaread_element(aaaa1aaat *km, uint32_t aaaaaaaaaa1aaaaaaaaaaaaaaaabaaaaaaaaaaaaaaaaaaaaaaaaaaaa3aaaaaaaaaaaaaaabaaaaaaaaaaaaaaaa4aaaber, aaaaaaaaaaaaaaa1aaat *pointer_list, bool verify, uint8_t narrow,
uint8_t narrow_element)
{
const bool present = aaaa1aaaaaaaaaaaaaaabaaaaaaaaaaaa3aaaaaaaaaaaaaaaabaaaaaaaaaaaaaaaaaaaaaaaaaaaa3aaapresent(km, aaaaaaaaaa1aaaaaaaaaaaaaaaabaaaaaaaaaaaaaaaaaaaaaaaaaaaa3aaaaaaaaaaaaaaabaaaaaaaaaaaaaaaa4aaaber, narrow, narrow_element);
if (!present)
return false;
aaaaaaaaaaaaaaaa1aaaaaaaaaaaaaaaabaaaaaaaaaaaaaaaaaaaaaaaaaaaa3aaat aaaaaaaaaaaaaa1aaaaaaaaaaaaaaaabaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaa3aaa;
memset(&aaaaaaaaaaaaaa1aaaaaaaaaaaaaaaabaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaa3aaa, 0, sizeof(aaaaaaaaaaaaaa1aaaaaaaaaaaaaaaabaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaa3aaa));
key_and_mask_t aaaaaaaaa1aaa;
memset(&aaaaaaaaa1aaa, 0, sizeof(aaaaaaaaa1aaa));
get_aaaaaaaaaaaaaa1aaaaaaaaaaaaaaaabaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaa3aaa(km, aaaaaaaaaa1aaaaaaaaaaaaaaaabaaaaaaaaaaaaaaaaaaaaaaaaaaaa3aaaaaaaaaaaaaaabaaaaaaaaaaaaaaaa4aaaber, &aaaaaaaaaaaaaa1aaaaaaaaaaaaaaaabaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaa3aaa, narrow, narrow_element);
if (a1aaaaaaaaaaaaaaabaaaaaaaaaaaa3aaaaaaaaaaaaaaaabaaaaaaaaaaaaaaaaaaaaaaaaaaaa3aaaaaaaaaaaaaaaabaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaa3aaa(km->client)) {
aaaaaaaaaaaaa1aaat ternary_mask;
aaaaaaaaaaaaa1aaat new_key;
aaaaaaaaaaaaaaa1aaaaaaaaaaaaaabaaaaaaaaaaa3aaa(pointer_list, km->source_bucket[aaaaaaaaaa1aaaaaaaaaaaaaaaabaaaaaaaaaaaaaaaaaaaaaaaaaaaa3aaaaaaaaaaaaaaabaaaaaaaaaaaaaaaa4aaaber].perfect_bucket,
km->source_bucket[aaaaaaaaaa1aaaaaaaaaaaaaaaabaaaaaaaaaaaaaaaaaaaaaaaaaaaa3aaaaaaaaaaaaaaabaaaaaaaaaaaaaaaa4aaaber].direct_pointer, true);
get_key(km, aaaaaaaaaa1aaaaaaaaaaaaaaaabaaaaaaaaaaaaaaaaaaaaaaaaaaaa3aaaaaaaaaaaaaaabaaaaaaaaaaaaaaaa4aaaber, &aaaaaaaaa1aaa, narrow, narrow_element);
divide_key_and_mask(&new_key, &ternary_mask, &aaaaaaaaa1aaa);
aaaaaaaaaaaaaaa1bbbbbbbbbbbbbbbbbbbbbbbbbbbbbbbb3aaa(pointer_list, &aaaaaaaaaaaaaa1aaaaaaaaaaaaaaaabaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaa3aaa, &new_key, &ternary_mask, false);
} else {
aaaaaaaaaaaaaaa1aaaaaaaaaaaaaabaaaaaaaaaaa3aaa(pointer_list, UINT32_MAX, true, false);
get_key(km, aaaaaaaaaa1aaaaaaaaaaaaaaaabaaaaaaaaaaaaaaaaaaaaaaaaaaaa3aaaaaaaaaaaaaaabaaaaaaaaaaaaaaaa4aaaber, &aaaaaaaaa1aaa, narrow, narrow_element);
bool narrow_key = false;
if (narrow != 0)
narrow_key = true;
aaaaaaaaaaaaaaa1bbbbbbbbbbbbbbbbbbbbbbbbbbbbbbbb3aaa(pointer_list, &aaaaaaaaaaaaaa1aaaaaaaaaaaaaaaabaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaa3aaa, (aaaaaaaaaaaaa1aaat *) &aaaaaaaaa1aaa, NULL, narrow_key);
}
if (verify) {
flush(km, aaaaaaaaaa1aaaaaaaaaaaaaaaabaaaaaaaaaaaaaaaaaaaaaaaaaaaa3aaaaaaaaaaaaaaabaaaaaaaaaaaaaaaa4aaaber, false, true, OTHER, narrow, narrow_element, false, false);
}
return true;
}
void aaaa1bbbbbbbbbbbbbbbb3aaaaaaaaaaaaaaaabaaaaaaaaaaaaaaaaaaaaaaaaaaaa4aaaand_flush(aaaa1aaat *target_km, aaaa1aaat *source_km, uint32_t list)
{
assert(a1aaaaaaaaaaaaaaabaaaaaaaaaaaa3aaaaaaaaaaaaaaaabaaaaaaaaaaaaaaaaaaaaaaaaaaaa3aaaaaaaaaaaaaaaabaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaa3aaa(target_km->client));
const uint16_t list_length = a1aaaaaaaaaaaaaaaabaaaaaaaaaaaa3aaaaaaaaaaaaaaaabaaaaaaaaaaaaaaaaaaaaaaaaaaaa3aaaaaaaaaaaaabaaaaaaaaaaaaaaaaa4aaaaaaaaaaaaaaaabaaaaaaaaaaaaaaaaaaaaaaaaaaaa4aaalength(target_km->client);
const uint16_t number_of_word32s = list_length / 32;
const uint32_t word32 = list * number_of_word32s;
memcpy(&target_km->aaaaaaaaaaaaaa1aaaaaaaaaaaaaaaabaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaa3aaaaaaaaaaaaaaaabaaaaaaaaaaaaaaaaaaaaaaaaaaaa4aaadata[word32], &source_km->aaaaaaaaaaaaaa1aaaaaaaaaaaaaaaabaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaa3aaaaaaaaaaaaaaaabaaaaaaaaaaaaaaaaaaaaaaaaaaaa4aaadata[word32],
number_of_word32s * sizeof(uint32_t));
memcpy(&target_km->source_bucket[list], &source_km->source_bucket[list], sizeof(source_bucket_t));
if (aaaa1aaaaaaaaaaaaaaabaaaaaaaaaaaa3aaaaaaaaaaaaaaaabaaaaaaaaaaaaaaaaaaaaaaaaaaaa3aaaaaaaaaaaaaaaabaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaa3aaa(source_km, list))
set_valid_bit(target_km, list, 0);
else
set_valid_bit(target_km, list, 1);
assert(target_km->flush == true);
flush(target_km, list, false, false, OTHER, 0, 0, false, false);
}
void aaaa1bbbbbbbbbbbbbbbbbbb3aaaaaaaaaaaaaaaabaaaaaaaaaaaaaaaaaaaaaaaaaaaa4aaaall(aaaa1aaat *km)
{
const uint32_t end_list = a1aaaaaaaaaaaaaaaabaaaaaaaaaaaa3aaaaaaaaaaaaaaaabaaaaaaaaaaaaaaaaaaaaaaaaaaaa3aaaaaaaaaaaaaaabaaaaaaaaaaaaaaaa4aaaaaaaaaaaaaaaabaaaaaaaaaaaaaaaaaaaaaaaaaaaa4aaaaaaaaaaaaabaaaaaaaaaaaaaaaaa5aaas(km->client) - 1;
for (uint32_t i = 0; i <= end_list; i++) {
flush(km, i, true, false, OTHER, 0, 0, false, false);
}
}
uint64_t aaaa1aaaread_and_clear_ecc_addresses(aaaa1aaat *km)
{
const uint32_t base = aaaaaa1aaaECC_ADDR_BASE + km->unit * aaaaaa1aaaaaaaaaaaabaaaaaaaaaaaaaaaaa3aaaaaaaaaaaaaaaabaaaaaaaaaaaaaaaaaaaaaaaaaaaa3aaaaaaaaaaaaaaaabaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaa3aaa;
uint64_t data;
a1aaaaaaaaaaaaaaaabaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaa3aaaaaaaaaaaaaaaabaaaaaaaaaaaaaaaaaaaaaaaaaaaa4aaaread(km->client, base, &data);
return data;
}
#ifndef _aaaaa1aaaaaaaaaaaaaaaabaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaa3aaaaaaaaaaaaaaaabaaaaaaaaaaaaaaaaaaaaaaaaaaaa4aaaH
#define _aaaaa1aaaaaaaaaaaaaaaabaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaa3aaaaaaaaaaaaaaaabaaaaaaaaaaaaaaaaaaaaaaaaaaaa4aaaH
struct aaaaa1aaaaaaaaaaaaaaaabaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaa3aaaaaaaaaaaaaaaabaaaaaaaaaaaaaaaaaaaaaaaaaaaa4aaaaaaaaaaaabaaaaaaaaaaa5aaa {
uint16_t id;
};
struct aaaaa1aaaaaaaaaaaaaaaabaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaa3aaa {
uint16_t num_entries;
uint16_t size;
struct aaaaa1aaaaaaaaaaaaaaaabaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaa3aaaaaaaaaaaaaaaabaaaaaaaaaaaaaaaaaaaaaaaaaaaa4aaaaaaaaaaaabaaaaaaaaaaa5aaa *data;
};
int aaaaa1aaaaaaaaaaaaaaaabaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaa3aaaaaaaaaaaaaaaabaaaaaaaaaaaaaaaaaaaaaaaaaaaa4bbbbbbbbbbbbbbbbbbbbbbbbbbbbbbbbbbbbbbb4aaaeate(struct aaaaa1aaaaaaaaaaaaaaaabaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaa3aaa *marr, void* (*malloc_function)(size_t));
int aaaaa1aaaaaaaaaaaaaaaabaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaa3aaaaaaaaaaaaaaaabaaaaaaaaaaaaaaaaaaaaaaaaaaaa4aaaaaaaaaaaaaaaabaaaaaaaaaaaaaaaaaaaaaaaaa5aaa(struct aaaaa1aaaaaaaaaaaaaaaabaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaa3aaa *marr, void* free_function);
int aaaaa1aaaaaaaaaaaaaaaabaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaa3aaaaaaaaaaaaaaaabaaaaaaaaaaaaaaaaaaaaaaaaaaaa4bbbbbbbbbbbbbbbbbbbbbbbbbbbbbbbb4aaa(struct aaaaa1aaaaaaaaaaaaaaaabaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaa3aaa *marr, uint16_t id);
int aaaaa1aaaaaaaaaaaaaaaabaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaa3aaaaaaaaaaaaaaaabaaaaaaaaaaaaaaaaaaaaaaaaaaaa4aaafind(struct aaaaa1aaaaaaaaaaaaaaaabaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaa3aaa *marr, uint16_t id,
uint16_t *out_index);
int aaaaa1aaaaaaaaaaaaaaaabaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaa3aaaaaaaaaaaaaaaabaaaaaaaaaaaaaaaaaaaaaaaaaaaa4aaaaaaaaaaaaaaaabaaaaaaaaaaaaaaaaaaa5aaa(struct aaaaa1aaaaaaaaaaaaaaaabaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaa3aaa *marr, uint16_t id);
#endif
int
aaaaa1aaaaaaaaaaaaaaaabaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaa3aaaaaaaaaaaaaaaabaaaaaaaaaaaaaaaaaaaaaaaaaaaa4bbbbbbbbbbbbbbbbbbbbbbbbbbbbbbbbbbbbbbb4aaaeate(struct aaaaa1aaaaaaaaaaaaaaaabaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaa3aaa* marr, void* (*malloc_function)(size_t))
{
marr->data = malloc_function(2 * sizeof(struct aaaaa1aaaaaaaaaaaaaaaabaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaa3aaaaaaaaaaaaaaaabaaaaaaaaaaaaaaaaaaaaaaaaaaaa4aaaaaaaaaaaabaaaaaaaaaaa5aaa));
if (marr->data == NULL)
return CAM_ERROR_NOMEM;
marr->size = 2;
return 0;
}
int
aaaaa1aaaaaaaaaaaaaaaabaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaa3aaaaaaaaaaaaaaaabaaaaaaaaaaaaaaaaaaaaaaaaaaaa4aaaaaaaaaaaaaaaabaaaaaaaaaaaaaaaaaaaaaaaaa5aaa(struct aaaaa1aaaaaaaaaaaaaaaabaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaa3aaa *marr, void* free_function)
{
typedef void (*aaaaa1aaaaaaaaaaaaaabaaaaaaaaaaaa3aaaaaaaaaaaaaaaabaaaaaaaaaaaaaaaaaaaaaaaaaaaa3aaafunc)(void* ptr);
((aaaaa1aaaaaaaaaaaaaabaaaaaaaaaaaa3aaaaaaaaaaaaaaaabaaaaaaaaaaaaaaaaaaaaaaaaaaaa3aaafunc)(free_function))(marr->data);
return 0;
}
int
aaaaa1aaaaaaaaaaaaaaaabaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaa3aaaaaaaaaaaaaaaabaaaaaaaaaaaaaaaaaaaaaaaaaaaa4bbbbbbbbbbbbbbbbbbbbbbbbbbbbbbbb4aaa(struct aaaaa1aaaaaaaaaaaaaaaabaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaa3aaa *marr, uint16_t id)
{
int i;
if (marr->num_entries == marr->size) {
uint16_t new_size = marr->size + (marr->size >> 1);
struct aaaaa1aaaaaaaaaaaaaaaabaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaa3aaaaaaaaaaaaaaaabaaaaaaaaaaaaaaaaaaaaaaaaaaaa4aaaaaaaaaaaabaaaaaaaaaaa5aaa *tmp =
realloc(marr->data, new_size * sizeof(struct aaaaa1aaaaaaaaaaaaaaaabaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaa3aaaaaaaaaaaaaaaabaaaaaaaaaaaaaaaaaaaaaaaaaaaa4aaaaaaaaaaaabaaaaaaaaaaa5aaa));
if (tmp == NULL)
return CAM_ERROR_NOMEM;
marr->data = tmp;
marr->size = new_size;
}
i = marr->num_entries;
marr->data[i].id = id;
marr->num_entries++;
return 0;
}
int
aaaaa1aaaaaaaaaaaaaaaabaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaa3aaaaaaaaaaaaaaaabaaaaaaaaaaaaaaaaaaaaaaaaaaaa4aaafind(struct aaaaa1aaaaaaaaaaaaaaaabaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaa3aaa *marr, uint16_t id, uint16_t * out_index)
{
int i;
for (i = 0; i < marr->num_entries; i++)
if (marr->data[i].id == id) {
*out_index = i;
return 0;
}
return -1;
}
int
aaaaa1aaaaaaaaaaaaaaaabaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaa3aaaaaaaaaaaaaaaabaaaaaaaaaaaaaaaaaaaaaaaaaaaa4aaaaaaaaaaaaaaaabaaaaaaaaaaaaaaaaaaa5aaa(struct aaaaa1aaaaaaaaaaaaaaaabaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaa3aaa *marr, uint16_t id)
{
int rc;
uint16_t index;
rc = aaaaa1aaaaaaaaaaaaaaaabaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaa3aaaaaaaaaaaaaaaabaaaaaaaaaaaaaaaaaaaaaaaaaaaa4aaafind(marr, id, &index);
assert(rc == 0);
if (rc)
return rc;
marr->num_entries--;
if (index < marr->num_entries)
memmove(&marr->data[index], &marr->data[index + 1],
(marr->num_entries - index) * sizeof(struct aaaaa1aaaaaaaaaaaaaaaabaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaa3aaaaaaaaaaaaaaaabaaaaaaaaaaaaaaaaaaaaaaaaaaaa4aaaaaaaaaaaabaaaaaaaaaaa5aaa));
uint16_t new_size = marr->size / 2;
if (new_size >= 2 && marr->num_entries < new_size) {
struct aaaaa1aaaaaaaaaaaaaaaabaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaa3aaaaaaaaaaaaaaaabaaaaaaaaaaaaaaaaaaaaaaaaaaaa4aaaaaaaaaaaabaaaaaaaaaaa5aaa *tmp = realloc(marr->data, new_size *
sizeof(struct aaaaa1aaaaaaaaaaaaaaaabaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaa3aaaaaaaaaaaaaaaabaaaaaaaaaaaaaaaaaaaaaaaaaaaa4aaaaaaaaaaaabaaaaaaaaaaa5aaa));
if (tmp == NULL)
return CAM_ERROR_NOMEM;
marr->data = tmp;
marr->size = new_size;
}
return 0;
}
#ifndef _aaaaa1aaaaaaaaaaaaaaaabaaaaaaaaaaaaaaaaaaaaaaa3aaaaaaaaaaaaaaaabaaaaaaaaaaaaaaaaaaaaaaaaaaaa3aaaH
#define _aaaaa1aaaaaaaaaaaaaaaabaaaaaaaaaaaaaaaaaaaaaaa3aaaaaaaaaaaaaaaabaaaaaaaaaaaaaaaaaaaaaaaaaaaa3aaaH
#define aaaaa1aaaaaaaaaaaaaaaabaaaaaaaaaaaaaaaaaaaaaaa3aaaaaaaaaaaaaaaabaaaaaaaaaaaaaaaaaaaaaaaaaaaa3aaaaaaaaaaaaaaabaaaaaaaaaaaaaaaa4aaaaaaaaaaaaaaaabaaaaaaaaaaaaaaaaaaaaaaaaaaaa4aaaaaaaaaaaaaaaabaaaaaaaaaaaaaaaaaaaaaaa5aaaS 256
#define aaaaa1aaaaaaaaaaaaaaaabaaaaaaaaaaaaaaaaaaaaaaa3aaaaaaaaaaaaaaaabaaaaaaaaaaaaaaaaaaaaaaaaaaaa3aaaRESVD_INSTANCE (aaaaa1aaaaaaaaaaaaaaaabaaaaaaaaaaaaaaaaaaaaaaa3aaaaaaaaaaaaaaaabaaaaaaaaaaaaaaaaaaaaaaaaaaaa3aaaaaaaaaaaaaaabaaaaaaaaaaaaaaaa4aaaaaaaaaaaaaaaabaaaaaaaaaaaaaaaaaaaaaaaaaaaa4aaaaaaaaaaaaaaaabaaaaaaaaaaaaaaaaaaaaaaa5aaaS - 1)
struct aaaaa1aaaaaaaaaaaaaaaabaaaaaaaaaaaaaaaaaaaaaaa3aaa {
uint8_t use_range;
uint32_t tot_pop;
uint16_t max_pop;
uint16_t const_pop;
uint32_t active_fields;
aaaaaaaaaaaaa1aaat mask;
};
struct aaaaa1aaaaaaaaaaaaaaaabaaaaaaaaaaaaaaaaaaaaaaa3aaaaaaaaaaaaaaaabaaaaaaaaaaaaaaaaaaaaaaaaaaaa3aaaaaaaaaaaabaaaaaaaaaa4aaa {
struct aaaaa1aaaaaaaaaaaaaaaabaaaaaaaaaaaaaaaaaaaaaaa3aaa mask;
mh_handle mh_handle;
};
struct aaaaa1aaaaaaaaaaaaaaaabaaaaaaaaaaaaaaaaaaaaaaa3aaaaaaaaaaaaaaaabaaaaaaaaaaaaaaaaaaaaaaaaaaaa3aaainstance {
uint8_t instances[aaaaa1aaaaaaaaaaaaaaaabaaaaaaaaaaaaaaaaaaaaaaa3aaaaaaaaaaaaaaaabaaaaaaaaaaaaaaaaaaaaaaaaaaaa3aaaaaaaaaaaaaaabaaaaaaaaaaaaaaaa4aaaaaaaaaaaaaaaabaaaaaaaaaaaaaaaaaaaaaaaaaaaa4aaaaaaaaaaaaaaaabaaaaaaaaaaaaaaaaaaaaaaa5aaaS / 8];
struct aaaaa1aaaaaaaaaaaaaaaabaaaaaaaaaaaaaaaaaaaaaaa3aaa mask;
mh_handle mh_handle;
};
int aaaaa1aaaaaaaaaaaaaaaabaaaaaaaaaaaaaaaaaaaaaaa3aaaaaaaaaaaaaaaabaaaaaaaaaaaaaaaaaaaaaaaaaaaa3bbbbbbbbbbbbbbbbbbbbbbbbbbbbbbbbbbbbbbb3aaaeate_exact(struct tcam *magg, struct aaaaa1aaaaaaaaaaaabaaaaaaaaaaa3aaa *me);
void aaaaa1aaaaaaaaaaaaaaaabaaaaaaaaaaaaaaaaaaaaaaa3aaaaaaaaaaaaaaaabaaaaaaaaaaaaaaaaaaaaaaaaaaaa3aaarelax_key(struct tcam *magg, struct aaaaa1aaaaaaaaaaaabaaaaaaaaaaa3aaa *me,
struct aaaaa1aaaaaaaaaaaaaaaabaaaaaaaaaaaaaaaaaaaaaaa3aaa *mask,
struct aaaaa1aaaaaaaaaaaaaaaabaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaa3aaaaaaaaaaaaaaaabaaaaaaaaaaaaaaaaaaaaaaaaaaaa4aaarelax_var_array *relax_key);
int aaaaa1aaaaaaaaaaaaaaaabaaaaaaaaaaaaaaaaaaaaaaa3aaaaaaaaaaaaaaaabaaaaaaaaaaaaaaaaaaaaaaaaaaaa3aaarelax_fields(struct tcam *magg, struct aaaaa1aaaaaaaaaaaabaaaaaaaaaaa3aaa *me);
int aaaaa1aaaaaaaaaaaaaaaabaaaaaaaaaaaaaaaaaaaaaaa3aaaaaaaaaaaaaaaabaaaaaaaaaaaaaaaaaaaaaaaaaaaa3bbbbbbbbbbbbbbbbbbbbbbbbbbbbbbbbbbbbbbb3aaaeate_hash(struct tcam *magg, struct aaaaa1aaaaaaaaaaaabaaaaaaaaaaa3aaa *me);
int aaaaa1aaaaaaaaaaaaaaaabaaaaaaaaaaaaaaaaaaaaaaa3aaaaaaaaaaaaaaaabaaaaaaaaaaaaaaaaaaaaaaaaaaaa3aaaaaaaaaaaaaaaabaaaaaaaaaaaaaaaaaaaaaaaaa4aaaaaaaaaaaaaaaabaaaaaaaaaaaaaaaaaaaaaaaaaaaa4aaaaaaaaaaaabaaaaaaaaaa5aaa(struct tcam *magg, struct aaaaa1aaaaaaaaaaaabaaaaaaaaaaa3aaa *me);
int aaaaa1aaaaaaaaaaaaaaaabaaaaaaaaaaaaaaaaaaaaaaa3aaaaaaaaaaaaaaaabaaaaaaaaaaaaaaaaaaaaaaaaaaaa3aaaaaaaaaaaabaaaaaaaaaa4aaaaaaaaaaaaaaaabaaaaaaaaaaaaaaaaaaaaaaaaaaaa4aaaaaaaaaaaaaaabaaaaaaaaaaaa5aaaaaaaaaaaaaaaabaaaaaaaaaaaaaaaaaaaaaaaaaaaa5aaamember(struct tcam *magg, struct aaaaa1aaaaaaaaaaaaaaaabaaaaaaaaaaaaaaaaaaaaaaa3aaa *mask,
struct aaaaa1aaaaaaaaaaaabaaaaaaaaaaa3aaa *me);
int aaaaa1aaaaaaaaaaaaaaaabaaaaaaaaaaaaaaaaaaaaaaa3aaaaaaaaaaaaaaaabaaaaaaaaaaaaaaaaaaaaaaaaaaaa3aaaaaaaaaaaaaaaabaaaaaaaaaaaa4aaaaaaaaaaaaaaaabaaaaaaaaaaaaaaaaaaaaaaaaaaaa4aaainstance(struct tcam *magg, struct aaaaa1aaaaaaaaaaaaaaaabaaaaaaaaaaaaaaaaaaaaaaa3aaa *mask,
uint8_t *instance);
int aaaaa1aaaaaaaaaaaaaaaabaaaaaaaaaaaaaaaaaaaaaaa3aaaaaaaaaaaaaaaabaaaaaaaaaaaaaaaaaaaaaaaaaaaa3aaaput_instance(struct tcam *magg, struct aaaaa1aaaaaaaaaaaaaaaabaaaaaaaaaaaaaaaaaaaaaaa3aaa *mask,
uint8_t instance);
int aaaaa1aaaaaaaaaaaaaaaabaaaaaaaaaaaaaaaaaaaaaaa3aaaaaaaaaaaaaaaabaaaaaaaaaaaaaaaaaaaaaaaaaaaa3aaaaaaaaaaaaaabaaaaaaaaaaaa4aaaaaaaaaaaaaaaabaaaaaaaaaaaaaaaaaaaaaaaaaaaa4aaainstances(struct tcam *magg);
int aaaaa1aaaaaaaaaaaaaaaabaaaaaaaaaaaaaaaaaaaaaaa3aaaaaaaaaaaaaaaabaaaaaaaaaaaaaaaaaaaaaaaaaaaa3aaaaaaaaaaaabaaaaaaaaaa4aaaaaaaaaaaaaaaabaaaaaaaaaaaaaaaaaaaaaaaaaaaa4aaavalue(struct aaaaa1aaaaaaaaaaaaaaaabaaaaaaaaaaaaaaaaaaaaaaa3aaa *mask);
void aaaaa1aaaaaaaaaaaaaaaabaaaaaaaaaaaaaaaaaaaaaaa3aaaaaaaaaaaaaaaabaaaaaaaaaaaaaaaaaaaaaaaaaaaa3aaaaaaaaaaaaaaaabaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaa3aaa(struct tcam *magg, struct aaaaa1aaaaaaaaaaaaaaaabaaaaaaaaaaaaaaaaaaaaaaa3aaa *mask,
int indent);
#endif
#ifndef _aaaaa1aaaaaaaaaaaabaaaaaaaaaaa3aaaaaaaaaaaaaaaabaaaaaaaaaaaaaaaaaaaaaaaaaaaa3aaaH_
#define _aaaaa1aaaaaaaaaaaabaaaaaaaaaaa3aaaaaaaaaaaaaaaabaaaaaaaaaaaaaaaaaaaaaaaaaaaa3aaaH_
struct aaaaa1aaaaaaaaaaaabaaaaaaaaaaa3aaaaaaaaaaaaaaaabaaaaaaaaaaaaaaaaaaaaaaaaaaaa3aaaaaaaaaaaabaaaaaaaaaaa4bbbbbbbbbbbbbbbbbb4aaa {
struct aaaaa1aaaaaaaaaaaabaaaaaaaaaaa3bbbbbbbbbbbbbbbbbb3aaa *mes;
struct aaaaa1bbbbbbbbbbbbbbbbbbbbbbbbbbbbbbbbb3aaa *collset;
uint8_t instance;
};
struct aaaaa1aaaaaaaaaaaabaaaaaaaaaaa3aaa {
uint16_t id;
aaaaaaaaaaaaaaaa1aaaaaaaaaaaaaaaabaaaaaaaaaaaaaaaaaaaaaaaaaaaa3aaat priority;
aaaaaaaaaaaaa1aaat exact_key;
struct aaaaa1aaaaaaaaaaaaaaaabaaaaaaaaaaaaaaaaaaaaaaa3aaa exact_mask;
uint32_t relax_fields;
uint32_t multiply_fields;
m_array *collsets;
uint16_t num_collsets;
struct aaaaa1aaaaaaaaaaaabaaaaaaaaaaa3aaaaaaaaaaaaaaaabaaaaaaaaaaaaaaaaaaaaaaaaaaaa3aaaaaaaaaaaabaaaaaaaaaaa4bbbbbbbbbbbbbbbbbb4aaa current_entryset;
struct aaaaa1aaaaaaaaaaaabaaaaaaaaaaa3aaaaaaaaaaaaaaaabaaaaaaaaaaaaaaaaaaaaaaaaaaaa3aaaaaaaaaaaabaaaaaaaaaaa4bbbbbbbbbbbbbbbbbb4aaa next_entryset;
uint8_t allocated;
struct aaaaa1aaaaaaaaaaaaaaaabaaaaaaaaaaaaaaaaaaaaaaa3aaaaaaaaaaaaaaaabaaaaaaaaaaaaaaaaaaaaaaaaaaaa3aaaaaaaaaaaabaaaaaaaaaa4aaa *mask_by_mask;
mh_handle mh_handle;
union aaaaaaaaaaa1aaa fields[];
};
struct aaaaa1aaaaaaaaaaaabaaaaaaaaaaa3aaaaaaaaaaaaaaaabaaaaaaaaaaaaaaaaaaaaaaaaaaaa3aaaaaaaaaaaaabaaaaaaaaaaaaaaaaa4aaa {
struct aaaaa1aaaaaaaaaaaabaaaaaaaaaaa3aaa *entry;
struct aaaaa1aaaaaaaaaaaabaaaaaaaaaaa3aaaaaaaaaaaaaaaabaaaaaaaaaaaaaaaaaaaaaaaaaaaa3aaaaaaaaaaaaabaaaaaaaaaaaaaaaaa4aaa *next;
};
int aaaaa1aaaaaaaaaaaabaaaaaaaaaaa3aaaaaaaaaaaaaaaabaaaaaaaaaaaaaaaaaaaaaaaaaaaa3bbbbbbbbbbbbbbbbbbbbbbbbbbbbbbbbbbbbbbb3aaaeate(struct tcam *magg, uint16_t id, const union aaaaaaaaaaa1aaa *fields,
const aaaaaaaaaaaaaaaa1aaaaaaaaaaaaaaaabaaaaaaaaaaaaaaaaaaaaaaaaaaaa3aaat *priority,
struct aaaaa1aaaaaaaaaaaabaaaaaaaaaaa3aaa **me);
int aaaaa1aaaaaaaaaaaabaaaaaaaaaaa3aaaaaaaaaaaaaaaabaaaaaaaaaaaaaaaaaaaaaaaaaaaa3aaaaaaaaaaaaaaaabaaaaaaaaaaaaaaaaaaaaaaaaa4aaa(struct tcam *magg, struct aaaaa1aaaaaaaaaaaabaaaaaaaaaaa3aaa *me);
int aaaaa1aaaaaaaaaaaabaaaaaaaaaaa3aaaaaaaaaaaaaaaabaaaaaaaaaaaaaaaaaaaaaaaaaaaa3bbbbbbbbbbbbbbbbbbbbbbbbbbbbbbbbbbbbbbb3aaaeate_collset(struct tcam *magg, struct aaaaa1aaaaaaaaaaaabaaaaaaaaaaa3aaa *me);
int aaaaa1aaaaaaaaaaaabaaaaaaaaaaa3aaaaaaaaaaaaaaaabaaaaaaaaaaaaaaaaaaaaaaaaaaaa3aaaaaaaaaaaaaaaabaaaaaaaaaaaaaaaaaaaaaaaaa4aaaaaaaaaaaaaaaabaaaaaaaaaaaaaaaaaaaaaaaaaaaa4bbbbbbbbbbbbbbbbbbbbbbbbbbbbbbbbb4aaa(struct tcam *magg, struct aaaaa1aaaaaaaaaaaabaaaaaaaaaaa3aaa *me);
int aaaaa1aaaaaaaaaaaabaaaaaaaaaaa3aaaaaaaaaaaaaaaabaaaaaaaaaaaaaaaaaaaaaaaaaaaa3bbbbbbbbbbbbbbbbbbbbbbbbbbbbbbbb3aaaaaaaaaaaaaaaabaaaaaaaaaaaaaaaaaaaaaaaaaaaa4bbbbbbbbbbbbbbbbbbbbbbbbbbbbbbbbb4aaa(struct tcam *magg, struct aaaaa1aaaaaaaaaaaabaaaaaaaaaaa3aaa *me,
struct aaaaa1bbbbbbbbbbbbbbbbbbbbbbbbbbbbbbbbb3aaa *collset);
int aaaaa1aaaaaaaaaaaabaaaaaaaaaaa3aaaaaaaaaaaaaaaabaaaaaaaaaaaaaaaaaaaaaaaaaaaa3aaaaaaaaaaaaaaaabaaaaaaaaaaaaaaaaaaa4aaaaaaaaaaaaaaaabaaaaaaaaaaaaaaaaaaaaaaaaaaaa4bbbbbbbbbbbbbbbbbbbbbbbbbbbbbbbbb4aaa(struct tcam *magg, struct aaaaa1aaaaaaaaaaaabaaaaaaaaaaa3aaa *me,
struct aaaaa1bbbbbbbbbbbbbbbbbbbbbbbbbbbbbbbbb3aaa *collset);
int aaaaa1aaaaaaaaaaaabaaaaaaaaaaa3aaaaaaaaaaaaaaaabaaaaaaaaaaaaaaaaaaaaaaaaaaaa3aaaaaaaaaaaaaaaabaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaa3aaa(struct tcam *magg, struct aaaaa1aaaaaaaaaaaabaaaaaaaaaaa3aaa *me, int indent);
#endif
#ifndef _aaaaa1aaaaaaaaaaaaaaaabaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaa3aaaaaaaaaaaaaaaabaaaaaaaaaaaaaaaaaaaaaaaaaaaa4aaaH_
#define _aaaaa1aaaaaaaaaaaaaaaabaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaa3aaaaaaaaaaaaaaaabaaaaaaaaaaaaaaaaaaaaaaaaaaaa4aaaH_
struct aaaaa1aaaaaaaaaaaaaaaabaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaa3aaa {
uint8_t is_solved;
uint16_t num_entries;
struct aaaaa1aaaaaaaaaaaabaaaaaaaaaaa3bbbbbbbbbbbbbbbbbb3aaa *entryset_by_mask;
};
int aaaaa1aaaaaaaaaaaaaaaabaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaa3aaaaaaaaaaaaaaaabaaaaaaaaaaaaaaaaaaaaaaaaaaaa4bbbbbbbbbbbbbbbbbbbbbbbbbbbbbbbbbbbbbbb4aaaeate(struct tcam *magg,
struct aaaaa1aaaaaaaaaaaaaaaabaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaa3aaa *problem);
int aaaaa1aaaaaaaaaaaaaaaabaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaa3aaaaaaaaaaaaaaaabaaaaaaaaaaaaaaaaaaaaaaaaaaaa4aaaaaaaaaaaaaaaabaaaaaaaaaaaaaaaaaaaaaaaaa5aaa(struct tcam *magg, struct aaaaa1aaaaaaaaaaaaaaaabaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaa3aaa *problem);
int aaaaa1aaaaaaaaaaaaaaaabaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaa3aaaaaaaaaaaaaaaabaaaaaaaaaaaaaaaaaaaaaaaaaaaa4bbbbbbbbbbbbbbbbbbbbbbbbbbbbbbbb4aaa(struct tcam *magg, struct aaaaa1aaaaaaaaaaaaaaaabaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaa3aaa *problem,
struct aaaaa1aaaaaaaaaaaabaaaaaaaaaaa3aaa *me);
int aaaaa1aaaaaaaaaaaaaaaabaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaa3aaaaaaaaaaaaaaaabaaaaaaaaaaaaaaaaaaaaaaaaaaaa4aaaaaaaaaaaaaaaabaaaaaaaaaaaaaaaaaaa5aaa(struct tcam *magg, struct aaaaa1aaaaaaaaaaaaaaaabaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaa3aaa *problem,
struct aaaaa1aaaaaaaaaaaabaaaaaaaaaaa3aaa *me);
int aaaaa1aaaaaaaaaaaaaaaabaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaa3aaaaaaaaaaaaaaaabaaaaaaaaaaaaaaaaaaaaaaaaaaaa4aaareset(struct tcam *magg, struct aaaaa1aaaaaaaaaaaaaaaabaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaa3aaa *problem);
int aaaaa1aaaaaaaaaaaaaaaabaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaa3aaaaaaaaaaaaaaaabaaaaaaaaaaaaaaaaaaaaaaaaaaaa4aaawinner(struct tcam *magg, struct aaaaa1aaaaaaaaaaaaaaaabaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaa3aaa *problem,
struct aaaaa1aaaaaaaaaaaabaaaaaaaaaaa3bbbbbbbbbbbbbbbbbb3aaa **out_mes);
int aaaaa1aaaaaaaaaaaaaaaabaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaa3aaaaaaaaaaaaaaaabaaaaaaaaaaaaaaaaaaaaaaaaaaaa4aaareduce(struct tcam *magg, struct aaaaa1aaaaaaaaaaaaaaaabaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaa3aaa *problem,
struct aaaaa1aaaaaaaaaaaabaaaaaaaaaaa3aaa *me);
int aaaaa1aaaaaaaaaaaaaaaabaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaa3aaaaaaaaaaaaaaaabaaaaaaaaaaaaaaaaaaaaaaaaaaaa4aaaaaaaaaaaaaaaabaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaa4aaa(struct tcam *magg, struct aaaaa1aaaaaaaaaaaaaaaabaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaa3aaa *problem,
int indent);
#endif
#ifndef _aaaaa1bbbbbbbbbbbbbbbbbbbbbbbbbb3aaaaaaaaaaaaaaaabaaaaaaaaaaaaaaaaaaaaaaaaaaaa4aaaH_
#define _aaaaa1bbbbbbbbbbbbbbbbbbbbbbbbbb3aaaaaaaaaaaaaaaabaaaaaaaaaaaaaaaaaaaaaaaaaaaa4aaaH_
enum {
aaaaa1aaaOP_NOP = 0,
aaaaa1aaaOP_ADD,
aaaaa1aaaOP_DEL
};
struct aaaaa1bbbbbbbbbbbbbbbbbbbbbbbbbb3aaaaaaaaaaaaaaaabaaaaaaaaaaaaaaaaaaaaaaaaaaaa4aaaop {
struct aaaaa1aaaaaaaaaaaabaaaaaaaaaaa3bbbbbbbbbbbbbbbbbb3aaa *src_entryset;
struct aaaaa1aaaaaaaaaaaabaaaaaaaaaaa3bbbbbbbbbbbbbbbbbb3aaa *dst_entryset;
struct aaaaa1bbbbbbbbbbbbbbbbbbbbbbbbbbbbbbbbb3aaa *dst_collset;
uint8_t src_instance;
uint8_t dst_instance;
uint8_t src_op;
uint8_t dst_op;
};
struct aaaaa1bbbbbbbbbbbbbbbbbbbbbbbbbb3aaa {
struct aaaaa1aaaaaaaaaaaabaaaaaaaaaaa3bbbbbbbbbbbbbbbbbb3aaaaaaaaaaaaaaaabaaaaaaaaaaaaaaaaaaaaaaaaaaaa4aaaaaaaaaaaaabaaaaaaaaaaaaaaaaa5aaa *mask_list;
uint16_t num_masks;
struct aaaaa1aaaaaaaaaaaabaaaaaaaaaaa3aaaaaaaaaaaaaaaabaaaaaaaaaaaaaaaaaaaaaaaaaaaa3aaaaaaaaaaaaabaaaaaaaaaaaaaaaaa4aaa *collision_list;
};
struct aaaaa1aaaaaaaaaaaaaaaabaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaa3aaa;
int aaaaa1bbbbbbbbbbbbbbbbbbbbbbbbbb3aaaaaaaaaaaaaaaabaaaaaaaaaaaaaaaaaaaaaaaaaaaa4bbbbbbbbbbbbbbbbbbbbbbbbbbbbbbbbbbbbbbb4aaaeate(struct tcam *magg,
struct aaaaa1bbbbbbbbbbbbbbbbbbbbbbbbbb3aaa *solution);
int aaaaa1bbbbbbbbbbbbbbbbbbbbbbbbbb3aaaaaaaaaaaaaaaabaaaaaaaaaaaaaaaaaaaaaaaaaaaa4aaaaaaaaaaaaaaaabaaaaaaaaaaaaaaaaaaaaaaaaa5aaa(struct tcam *magg, struct aaaaa1bbbbbbbbbbbbbbbbbbbbbbbbbb3aaa *solution);
int aaaaa1bbbbbbbbbbbbbbbbbbbbbbbbbb3aaaaaaaaaaaaaaaabaaaaaaaaaaaaaaaaaaaaaaaaaaaa4bbbbbbbbbbbbbbbbbbbbbbbbbbbbbbbb4aaa(struct tcam *magg,
struct aaaaa1aaaaaaaaaaaabaaaaaaaaaaa3bbbbbbbbbbbbbbbbbb3aaaaaaaaaaaaaaaabaaaaaaaaaaaaaaaaaaaaaaaaaaaa4aaaaaaaaaaaaabaaaaaaaaaaaaaaaaa5aaa *mesli,
struct aaaaa1aaaaaaaaaaaabaaaaaaaaaaa3aaa *me);
int aaaaa1bbbbbbbbbbbbbbbbbbbbbbbbbb3aaaaaaaaaaaaaaaabaaaaaaaaaaaaaaaaaaaaaaaaaaaa4aaaaaaaaaaaaaaaabaaaaaaaaaaaaaaaaaaa5aaa(struct tcam *magg, struct aaaaa1bbbbbbbbbbbbbbbbbbbbbbbbbb3aaa *solution,
struct aaaaa1aaaaaaaaaaaabaaaaaaaaaaa3aaa *me,
struct aaaaa1aaaaaaaaaaaabaaaaaaaaaaa3bbbbbbbbbbbbbbbbbb3aaaaaaaaaaaaaaaabaaaaaaaaaaaaaaaaaaaaaaaaaaaa4aaaaaaaaaaaaabaaaaaaaaaaaaaaaaa5aaa **out_mesli);
int aaaaa1bbbbbbbbbbbbbbbbbbbbbbbbbb3aaaaaaaaaaaaaaaabaaaaaaaaaaaaaaaaaaaaaaaaaaaa4bbbbbbbbbbbbbbbbbbbbbbbbbbbbbbbb4aaaaaaaaaaaaaaaabaaaaaaaaaaaaaaaaaaaaaaaaaaaa5aaaaaaaaaaaabaaaaaaaaaaa6bbbbbbbbbbbbbbbbbb6aaa(struct tcam *magg,
struct aaaaa1aaaaaaaaaaaaaaaabaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaa3aaa *probsol,
struct aaaaa1aaaaaaaaaaaabaaaaaaaaaaa3bbbbbbbbbbbbbbbbbb3aaa *mes,
struct aaaaa1aaaaaaaaaaaabaaaaaaaaaaa3bbbbbbbbbbbbbbbbbb3aaaaaaaaaaaaaaaabaaaaaaaaaaaaaaaaaaaaaaaaaaaa4aaaaaaaaaaaaabaaaaaaaaaaaaaaaaa5aaa **out_mesli);
int aaaaa1bbbbbbbbbbbbbbbbbbbbbbbbbb3aaaaaaaaaaaaaaaabaaaaaaaaaaaaaaaaaaaaaaaaaaaa4aaafind_entryset(struct tcam *magg,
struct aaaaa1aaaaaaaaaaaaaaaabaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaa3aaa *probsol,
struct aaaaa1aaaaaaaaaaaabaaaaaaaaaaa3aaa *me,
struct aaaaa1aaaaaaaaaaaabaaaaaaaaaaa3bbbbbbbbbbbbbbbbbb3aaaaaaaaaaaaaaaabaaaaaaaaaaaaaaaaaaaaaaaaaaaa4aaaaaaaaaaaaabaaaaaaaaaaaaaaaaa5aaa **out_mesli);
int aaaaa1bbbbbbbbbbbbbbbbbbbbbbbbbb3aaaaaaaaaaaaaaaabaaaaaaaaaaaaaaaaaaaaaaaaaaaa4bbbbbbbbbbbbbbbbbbbbbbbbbbbbbb4aaa(struct tcam *magg, struct aaaaa1aaaaaaaaaaaaaaaabaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaa3aaa *probsol,
int max_num_masks);
#endif
#ifndef _aaaaa1aaaaaaaaaaaaaaaabaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaa3aaaaaaaaaaaaaaaabaaaaaaaaaaaaaaaaaaaaaaaaaaaa4aaaH_
#define _aaaaa1aaaaaaaaaaaaaaaabaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaa3aaaaaaaaaaaaaaaabaaaaaaaaaaaaaaaaaaaaaaaaaaaa4aaaH_
struct aaaaa1aaaaaaaaaaaaaaaabaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaa3aaa {
uint8_t is_solved;
uint8_t do_refill;
struct aaaaa1aaaaaaaaaaaaaaaabaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaa3aaa problem;
struct aaaaa1bbbbbbbbbbbbbbbbbbbbbbbbbb3aaa curr_solution;
struct aaaaa1bbbbbbbbbbbbbbbbbbbbbbbbbb3aaa prev_solution;
struct aaaaa1aaaaaaaaaaaaaaaabaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaa3aaa *next;
};
int aaaaa1aaaaaaaaaaaaaaaabaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaa3aaaaaaaaaaaaaaaabaaaaaaaaaaaaaaaaaaaaaaaaaaaa4bbbbbbbbbbbbbbbbbbbbbbbbbbbbbbbbbbbbbbb4aaaeate(struct tcam *magg, struct aaaaa1aaaaaaaaaaaaaaaabaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaa3aaa **out_probsol);
int aaaaa1aaaaaaaaaaaaaaaabaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaa3aaaaaaaaaaaaaaaabaaaaaaaaaaaaaaaaaaaaaaaaaaaa4aaaaaaaaaaaaaaaabaaaaaaaaaaaaaaaaaaaaaaaaa5aaa(struct tcam *magg, struct aaaaa1aaaaaaaaaaaaaaaabaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaa3aaa *probsol);
int aaaaa1aaaaaaaaaaaaaaaabaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaa3aaaaaaaaaaaaaaaabaaaaaaaaaaaaaaaaaaaaaaaaaaaa4bbbbbbbbbbbbbbbbbbbbbbbbbbbbbbbb4aaa(struct tcam *magg, struct aaaaa1aaaaaaaaaaaabaaaaaaaaaaa3aaa *me);
int aaaaa1aaaaaaaaaaaaaaaabaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaa3aaaaaaaaaaaaaaaabaaaaaaaaaaaaaaaaaaaaaaaaaaaa4aaaaaaaaaaaaaaaabaaaaaaaaaaaaaaaaaaa5aaa(struct tcam *magg, struct aaaaa1aaaaaaaaaaaabaaaaaaaaaaa3aaa *me);
int aaaaa1aaaaaaaaaaaaaaaabaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaa3aaaaaaaaaaaaaaaabaaaaaaaaaaaaaaaaaaaaaaaaaaaa4bbbbbbbbbbbbbbbbbbbbbbbbbbbbbb4aaa(struct tcam *magg);
int aaaaa1aaaaaaaaaaaaaaaabaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaa3aaaaaaaaaaaaaaaabaaaaaaaaaaaaaaaaaaaaaaaaaaaa4aaaaaaaaaaaaaaaabaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaa4aaa(struct tcam *magg, struct aaaaa1aaaaaaaaaaaaaaaabaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaa3aaa *probsol,
int indent);
#endif
#ifndef _aaaaa1bbbbbbbbbbbbbbbbbbbbbbbbbbbbbbbbbbbbb3aaaaaaaaaaaaaaaabaaaaaaaaaaaaaaaaaaaaaaaaaaaa4aaaH_
#define _aaaaa1bbbbbbbbbbbbbbbbbbbbbbbbbbbbbbbbbbbbb3aaaaaaaaaaaaaaaabaaaaaaaaaaaaaaaaaaaaaaaaaaaa4aaaH_
#ifdef __cplusplus
extern "C" {
#endif
enum aaaaa1bbbbbbbbbbbbbbbbbbbbbbbbbbbbbbbbbbbbb3aaaaaaaaaaaaaaaabaaaaaaaaaaaaaaaaaaaaaaaaaaaa4aaaflags {
aaaaa1bbbbbbbbbbbbbbbbbbbbbbbbbbbbbbbbbbbbb3aaaaaaaaaaaaaaaabaaaaaaaaaaaaaaaaaaaaaaaaaaaa4aaaNONE = 0x0000,
aaaaa1bbbbbbbbbbbbbbbbbbbbbbbbbbbbbbbbbbbbb3aaaaaaaaaaaaaaaabaaaaaaaaaaaaaaaaaaaaaaaaaaaa4aaaTEST = 0x0001,
aaaaa1bbbbbbbbbbbbbbbbbbbbbbbbbbbbbbbbbbbbb3aaaaaaaaaaaaaaaabaaaaaaaaaaaaaaaaaaaaaaaaaaaa4aaaaaaaaaaaaaaaabaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaa4aaa = 0x0002,
aaaaa1bbbbbbbbbbbbbbbbbbbbbbbbbbbbbbbbbbbbb3aaaaaaaaaaaaaaaabaaaaaaaaaaaaaaaaaaaaaaaaaaaa4bbbbbbbbbbbbbbbbbb4aaaaaaaaaaaaaaaabaaaaaaaaaaaaaaaaaaaaaaaaaaaa5aaaCOVER = 0x0004,
aaaaa1bbbbbbbbbbbbbbbbbbbbbbbbbbbbbbbbbbbbb3aaaaaaaaaaaaaaaabaaaaaaaaaaaaaaaaaaaaaaaaaaaa4bbbbbbbbbbbbbbbbbbbbbbbbbbbbbbbb4aaaaaaaaaaaaaaaabaaaaaaaaaaaaaaaaaaaaaaaaaaaa5aaaDEL = 0x0008,
aaaaa1bbbbbbbbbbbbbbbbbbbbbbbbbbbbbbbbbbbbb3aaaaaaaaaaaaaaaabaaaaaaaaaaaaaaaaaaaaaaaaaaaa4aaaaaaaaaaaaaaaabaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaa4aaa = 0x0010,
aaaaa1bbbbbbbbbbbbbbbbbbbbbbbbbbbbbbbbbbbbb3aaaaaaaaaaaaaaaabaaaaaaaaaaaaaaaaaaaaaaaaaaaa4aaaaaaaaaaaaaaaabaaaaaaaaaaaaaaaaaaaaaaa5aaaaaaaaaaaaaaaabaaaaaaaaaaaaaaaaaaaaaaaaaaaa5aaaaaaaaaaaabaaaaaaaaaa6aaa = 0x0020,
aaaaa1bbbbbbbbbbbbbbbbbbbbbbbbbbbbbbbbbbbbb3aaaaaaaaaaaaaaaabaaaaaaaaaaaaaaaaaaaaaaaaaaaa4aaaSORTEDSET = 0x0040,
aaaaa1bbbbbbbbbbbbbbbbbbbbbbbbbbbbbbbbbbbbb3aaaaaaaaaaaaaaaabaaaaaaaaaaaaaaaaaaaaaaaaaaaa4aaaOPARRAY = 0x0080,
aaaaa1bbbbbbbbbbbbbbbbbbbbbbbbbbbbbbbbbbbbb3aaaaaaaaaaaaaaaabaaaaaaaaaaaaaaaaaaaaaaaaaaaa4aaaINSTANCE = 0x0100,
aaaaa1bbbbbbbbbbbbbbbbbbbbbbbbbbbbbbbbbbbbb3aaaaaaaaaaaaaaaabaaaaaaaaaaaaaaaaaaaaaaaaaaaa4aaaaaaaaaaaabaaaaaaaaaaa5bbbbbbbbbbbbbbbbbb5aaa = 0x0200,
aaaaa1bbbbbbbbbbbbbbbbbbbbbbbbbbbbbbbbbbbbb3aaaaaaaaaaaaaaaabaaaaaaaaaaaaaaaaaaaaaaaaaaaa4aaaCONFIG = 0x0400,
aaaaa1aaaaaaaaaaaaaaaabaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaa3aaaaaaaaaaaaaaaabaaaaaaaaaaaaaaaaaaaaaaaaaaaa4aaaaaaaaaaaaaaaabaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaa4aaa = 0x1000,
aaaaa1aaaaaaaaaaaaaaaabaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaa3aaaaaaaaaaaaaaaabaaaaaaaaaaaaaaaaaaaaaaaaaaaa4aaaaaaaaaaaaaaaabaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaa4aaa = 0x2000,
aaaaa1aaaaaaaaaaaaaaaabaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaa3aaaaaaaaaaaaaaaabaaaaaaaaaaaaaaaaaaaaaaaaaaaa4aaaaaaaaaaaabaaaaaaaaaaa5bbbbbbbbbbbbbbbbbb5aaa = 0x4000,
aaaaa1aaaaaaaaaaaaaaaabaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaa3aaaaaaaaaaaaaaaabaaaaaaaaaaaaaaaaaaaaaaaaaaaa4bbbbbbbbbbbbbbbbbbbbbbbbbbbbbbbbb4aaa = 0x8000,
aaaaa1aaaaaaaaaaaaaaaabaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaa3aaaaaaaaaaaaaaaabaaaaaaaaaaaaaaaaaaaaaaaaaaaa4aaaaaaaaaaaabaaaaaaaaaaa5aaa = 0x10000,
aaaaa1aaaaaaaaaaaaaaaabaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaa3aaaaaaaaaaaaaaaabaaaaaaaaaaaaaaaaaaaaaaaaaaaa4aaaTABLE = 0x20000,
aaaaa1aaaaaaaaaaaaaaaabaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaa3aaaaaaaaaaaaaaaabaaaaaaaaaaaaaaaaaaaaaaaaaaaa4aaaDUMP = 0x40000
};
int aaaaa1bbbbbbbbbbbbbbbbbbbbbbbbbbbbbbbbbbbbb3aaaaaaaaaaaaaaaabaaaaaaaaaaaaaaaaaaaaaaaaaaaa4aaarun(struct tcam *tcam);
int aaaaa1bbbbbbbbbbbbbbbbbbbbbbbbbbbbbbbbbbbbb3aaaaaaaaaaaaaaaabaaaaaaaaaaaaaaaaaaaaaaaaaaaa4bbbbbbbbbbbbbbbbbb4aaaaaaaaaaaaaaaabaaaaaaaaaaaaaaaaaaaaaaaaaaaa5aaaaaaaaaaaaaaaabaaaaaaaaaaaaaaaaaaaaaaa6aaa(struct tcam *tcam, enum aaaaa1bbbbbbbbbbbbbbbbbbbbbbbbbbbbbbbbbbbbb3aaaaaaaaaaaaaaaabaaaaaaaaaaaaaaaaaaaaaaaaaaaa4aaaflags debug_flags);
enum aaaaa1bbbbbbbbbbbbbbbbbbbbbbbbbbbbbbbbbbbbb3aaaaaaaaaaaaaaaabaaaaaaaaaaaaaaaaaaaaaaaaaaaa4aaaflags aaaaa1bbbbbbbbbbbbbbbbbbbbbbbbbbbbbbbbbbbbb3aaaaaaaaaaaaaaaabaaaaaaaaaaaaaaaaaaaaaaaaaaaa4aaaaaaaaaaaaaaaabaaaaaaaaaaaa5aaaaaaaaaaaaaaaabaaaaaaaaaaaaaaaaaaaaaaaaaaaa5aaaaaaaaaaaaaaaabaaaaaaaaaaaaaaaaaaaaaaa6aaa(struct tcam *tcam);
int aaaaa1bbbbbbbbbbbbbbbbbbbbbbbbbbbbbbbbbbbbb3aaaaaaaaaaaaaaaabaaaaaaaaaaaaaaaaaaaaaaaaaaaa4aaadump(struct tcam *tcam);
int aaaaa1bbbbbbbbbbbbbbbbbbbbbbbbbbbbbbbbbbbbb3aaaaaaaaaaaaaaaabaaaaaaaaaaaaaaaaaaaaaaaaaaaa4aaaaaaaaaaaaaaaabaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaa4aaa(struct tcam *tcam, int indent);
void cam_mem_debug(struct tcam *tcam);
void cam_resource_debug(struct tcam *tcam);
#ifdef __cplusplus
}
#endif
#endif
#ifndef _aaaaa1aaaaaaaaaaaabaaaaaaaaaa3aaaaaaaaaaaaaaaabaaaaaaaaaaaaaaaaaaaaaaaaaaaa3aaaH_
#define _aaaaa1aaaaaaaaaaaabaaaaaaaaaa3aaaaaaaaaaaaaaaabaaaaaaaaaaaaaaaaaaaaaaaaaaaa3aaaH_
#define aaaaa1aaaaaaaaaaaabaaaaaaaaaa3aaaaaaaaaaaaaaaabaaaaaaaaaaaaaaaaaaaaaaaaaaaa3aaaaaaaaaaaaaaabaaaaaaaaaaaaaaaa4aaaaaaaaaaaaaaaabaaaaaaaaaaaaaaaaaaaaaaaaaaaa4aaaaaaaaaabaaaaaaaaaaa5aaaS 16
struct aaaaa1aaaaaaaaaaaabaaaaaaaaaa3aaa {
struct aaaaa1bbbbbbbbbbbbbbbbbbbbbbbbbbbbbbbbb3aaa *buckets[aaaaa1aaaaaaaaaaaabaaaaaaaaaa3aaaaaaaaaaaaaaaabaaaaaaaaaaaaaaaaaaaaaaaaaaaa3aaaaaaaaaaaaaaabaaaaaaaaaaaaaaaa4aaaaaaaaaaaaaaaabaaaaaaaaaaaaaaaaaaaaaaaaaaaa4aaaaaaaaaabaaaaaaaaaaa5aaaS];
};
int aaaaa1aaaaaaaaaaaabaaaaaaaaaa3aaaaaaaaaaaaaaaabaaaaaaaaaaaaaaaaaaaaaaaaaaaa3bbbbbbbbbbbbbbbbbbbbbbbbbbbbbbbb3aaa(struct tcam *magg, struct aaaaa1aaaaaaaaaaaabaaaaaaaaaaa3bbbbbbbbbbbbbbbbbb3aaa *mes,
struct aaaaa1bbbbbbbbbbbbbbbbbbbbbbbbbbbbbbbbb3aaa *collset);
int aaaaa1aaaaaaaaaaaabaaaaaaaaaa3aaaaaaaaaaaaaaaabaaaaaaaaaaaaaaaaaaaaaaaaaaaa3aaafind(struct tcam *magg, struct aaaaa1aaaaaaaaaaaabaaaaaaaaaaa3bbbbbbbbbbbbbbbbbb3aaa *mes,
aaaaaaaaaaaaa1aaat *relax_key,
struct aaaaa1bbbbbbbbbbbbbbbbbbbbbbbbbbbbbbbbb3aaa **out_collset);
int aaaaa1aaaaaaaaaaaabaaaaaaaaaa3aaaaaaaaaaaaaaaabaaaaaaaaaaaaaaaaaaaaaaaaaaaa3aaaaaaaaaaaaaaaabaaaaaaaaaaaaaaaaaaa4aaa(struct tcam *magg, struct aaaaa1aaaaaaaaaaaabaaaaaaaaaaa3bbbbbbbbbbbbbbbbbb3aaa *mes,
struct aaaaa1bbbbbbbbbbbbbbbbbbbbbbbbbbbbbbbbb3aaa *collset);
#endif
#ifndef _aaaaa1bbbbbbbbbbbbbbbbbbbbbbbbbbbbbbbbb3aaaaaaaaaaaaaaaabaaaaaaaaaaaaaaaaaaaaaaaaaaaa4aaaH_
#define _aaaaa1bbbbbbbbbbbbbbbbbbbbbbbbbbbbbbbbb3aaaaaaaaaaaaaaaabaaaaaaaaaaaaaaaaaaaaaaaaaaaa4aaaH_
#define aaaaa1bbbbbbbbbbbbbbbbbbbbbbbbbbbbbbbbb3aaaaaaaaaaaaaaaabaaaaaaaaaaaaaaaaaaaaaaaaaaaa4aaaWEIGHT 1
struct aaaaa1bbbbbbbbbbbbbbbbbbbbbbbbbbbbbbbbb3aaa {
struct aaaaa1aaaaaaaaaaaaaaaabaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaa3aaa entry_ids;
uint16_t remaining_entries;
uint16_t num_populated;
struct aaaaa1aaaaaaaaaaaabaaaaaaaaaaa3bbbbbbbbbbbbbbbbbb3aaa *entryset;
struct aaaaa1bbbbbbbbbbbbbbbbbbbbbbbbbbbbbbbbb3aaa *next;
struct aaaaa1aaaaaaaaaaaaaaaabaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaa3aaaaaaaaaaaaaaaabaaaaaaaaaaaaaaaaaaaaaaaaaaaa4aaarelax_var_array relax_key;
};
int aaaaa1bbbbbbbbbbbbbbbbbbbbbbbbbbbbbbbbb3aaaaaaaaaaaaaaaabaaaaaaaaaaaaaaaaaaaaaaaaaaaa4bbbbbbbbbbbbbbbbbbbbbbbbbbbbbbbbbbbbbbb4aaaeate(struct tcam *magg, struct aaaaa1bbbbbbbbbbbbbbbbbbbbbbbbbbbbbbbbb3aaa **collset);
int aaaaa1bbbbbbbbbbbbbbbbbbbbbbbbbbbbbbbbb3aaaaaaaaaaaaaaaabaaaaaaaaaaaaaaaaaaaaaaaaaaaa4aaaaaaaaaaaaaaaabaaaaaaaaaaaaaaaaaaaaaaaaa5aaa(struct aaaaa1bbbbbbbbbbbbbbbbbbbbbbbbbbbbbbbbb3aaa *collset, cam_free_func free_function);
int aaaaa1bbbbbbbbbbbbbbbbbbbbbbbbbbbbbbbbb3aaaaaaaaaaaaaaaabaaaaaaaaaaaaaaaaaaaaaaaaaaaa4bbbbbbbbbbbbbbbbbbbbbbbbbbbbbbbb4aaa(struct tcam *magg, struct aaaaa1bbbbbbbbbbbbbbbbbbbbbbbbbbbbbbbbb3aaa *collset,
struct aaaaa1aaaaaaaaaaaabaaaaaaaaaaa3aaa *me);
int aaaaa1bbbbbbbbbbbbbbbbbbbbbbbbbbbbbbbbb3aaaaaaaaaaaaaaaabaaaaaaaaaaaaaaaaaaaaaaaaaaaa4aaaaaaaaaaaaaaaabaaaaaaaaaaaaaaaaaaa5aaa(struct tcam *magg, struct aaaaa1bbbbbbbbbbbbbbbbbbbbbbbbbbbbbbbbb3aaa *collset,
struct aaaaa1aaaaaaaaaaaabaaaaaaaaaaa3aaa *me);
int aaaaa1bbbbbbbbbbbbbbbbbbbbbbbbbbbbbbbbb3aaaaaaaaaaaaaaaabaaaaaaaaaaaaaaaaaaaaaaaaaaaa4aaafind(struct tcam *magg, struct aaaaa1aaaaaaaaaaaabaaaaaaaaaaa3bbbbbbbbbbbbbbbbbb3aaa *mes,
struct aaaaa1aaaaaaaaaaaabaaaaaaaaaaa3aaa *me, struct aaaaa1bbbbbbbbbbbbbbbbbbbbbbbbbbbbbbbbb3aaa **collset);
int aaaaa1bbbbbbbbbbbbbbbbbbbbbbbbbbbbbbbbb3aaaaaaaaaaaaaaaabaaaaaaaaaaaaaaaaaaaaaaaaaaaa4aaaaaaaaaaaaaaaabaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaa4aaa(struct tcam *magg, struct aaaaa1bbbbbbbbbbbbbbbbbbbbbbbbbbbbbbbbb3aaa *collset,
int indent);
#endif
#ifndef _aaaaa1aaaaaaaaaaaaaaaabaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaa3aaaaaaaaaaaaaaaabaaaaaaaaaaaaaaaaaaaaaaaaaaaa4aaaH_
#define _aaaaa1aaaaaaaaaaaaaaaabaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaa3aaaaaaaaaaaaaaaabaaaaaaaaaaaaaaaaaaaaaaaaaaaa4aaaH_
int aaaaa1aaaaaaaaaaaaaaaabaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaa3aaaaaaaaaaaaaaaabaaaaaaaaaaaaaaaaaaaaaaaaaaaa4bbbbbbbbbbbbbbbbbbbbbbbbbbbbbbbb4aaa(struct tcam *magg, struct aaaaa1aaaaaaaaaaaabaaaaaaaaaaa3aaa *me,
struct aaaaa1aaaaaaaaaaaabaaaaaaaaaaa3bbbbbbbbbbbbbbbbbb3aaa *mes, uint8_t mes_instance,
struct aaaaa1bbbbbbbbbbbbbbbbbbbbbbbbbbbbbbbbb3aaa *collset);
int aaaaa1aaaaaaaaaaaaaaaabaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaa3aaaaaaaaaaaaaaaabaaaaaaaaaaaaaaaaaaaaaaaaaaaa4aaaaaaaaaaaaaaaabaaaaaaaaaaaaaaaaaaa5aaa(struct tcam *magg, struct aaaaa1aaaaaaaaaaaabaaaaaaaaaaa3aaa *me,
struct aaaaa1aaaaaaaaaaaabaaaaaaaaaaa3bbbbbbbbbbbbbbbbbb3aaa *mes, uint8_t mes_instance);
#endif
#ifndef _aaaaa1aaaaaaaaaaaabaaaaaaaaaaa3bbbbbbbbbbbbbbbbbb3aaaaaaaaaaaaaaaabaaaaaaaaaaaaaaaaaaaaaaaaaaaa4aaaH_
#define _aaaaa1aaaaaaaaaaaabaaaaaaaaaaa3bbbbbbbbbbbbbbbbbb3aaaaaaaaaaaaaaaabaaaaaaaaaaaaaaaaaaaaaaaaaaaa4aaaH_
struct aaaaa1aaaaaaaaaaaabaaaaaaaaaaa3bbbbbbbbbbbbbbbbbb3aaa {
struct aaaaa1aaaaaaaaaaaaaaaabaaaaaaaaaaaaaaaaaaaaaaa3aaa mask;
uint32_t num_entries;
uint32_t weight;
uint32_t remaining_entries;
uint32_t remaining_weight;
struct aaaaa1aaaaaaaaaaaabaaaaaaaaaa3aaa collset_by_key;
mh_handle mh_handle;
struct aaaaa1aaaaaaaaaaaabaaaaaaaaaaa3bbbbbbbbbbbbbbbbbb3aaa *entryset_next;
uint8_t members[];
};
struct aaaaa1aaaaaaaaaaaabaaaaaaaaaaa3bbbbbbbbbbbbbbbbbb3aaaaaaaaaaaaaaaabaaaaaaaaaaaaaaaaaaaaaaaaaaaa4aaaaaaaaaaaaabaaaaaaaaaaaaaaaaa5aaa {
struct aaaaa1aaaaaaaaaaaabaaaaaaaaaaa3bbbbbbbbbbbbbbbbbb3aaa *entryset;
uint8_t instance;
uint16_t weight;
uint16_t num_entries;
struct aaaaa1aaaaaaaaaaaabaaaaaaaaaaa3aaaaaaaaaaaaaaaabaaaaaaaaaaaaaaaaaaaaaaaaaaaa3aaaaaaaaaaaaabaaaaaaaaaaaaaaaaa4aaa *entry_list;
struct aaaaa1aaaaaaaaaaaabaaaaaaaaaaa3bbbbbbbbbbbbbbbbbb3aaaaaaaaaaaaaaaabaaaaaaaaaaaaaaaaaaaaaaaaaaaa4aaaaaaaaaaaaabaaaaaaaaaaaaaaaaa5aaa *next;
};
struct aaaaa1aaaaaaaaaaaaaaaabaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaa3aaa;
int aaaaa1aaaaaaaaaaaabaaaaaaaaaaa3bbbbbbbbbbbbbbbbbb3aaaaaaaaaaaaaaaabaaaaaaaaaaaaaaaaaaaaaaaaaaaa4bbbbbbbbbbbbbbbbbbbbbbbbbbbbbbbbbbbbbbb4aaaeate(struct tcam *magg, struct aaaaa1aaaaaaaaaaaaaaaabaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaa3aaa *problem,
struct aaaaa1aaaaaaaaaaaaaaaabaaaaaaaaaaaaaaaaaaaaaaa3aaa *mask,
struct aaaaa1aaaaaaaaaaaabaaaaaaaaaaa3bbbbbbbbbbbbbbbbbb3aaa **out_mes);
int aaaaa1aaaaaaaaaaaabaaaaaaaaaaa3bbbbbbbbbbbbbbbbbb3aaaaaaaaaaaaaaaabaaaaaaaaaaaaaaaaaaaaaaaaaaaa4aaaaaaaaaaaaaaaabaaaaaaaaaaaaaaaaaaaaaaaaa5aaa(struct tcam *magg, struct aaaaa1aaaaaaaaaaaaaaaabaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaa3aaa *problem,
struct aaaaa1aaaaaaaaaaaabaaaaaaaaaaa3bbbbbbbbbbbbbbbbbb3aaa *mes);
int aaaaa1aaaaaaaaaaaabaaaaaaaaaaa3bbbbbbbbbbbbbbbbbb3aaaaaaaaaaaaaaaabaaaaaaaaaaaaaaaaaaaaaaaaaaaa4bbbbbbbbbbbbbbbbbbbbbbbbbbbbbbbb4aaa(struct tcam *magg, struct aaaaa1aaaaaaaaaaaaaaaabaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaa3aaa *problem,
struct aaaaa1aaaaaaaaaaaabaaaaaaaaaaa3bbbbbbbbbbbbbbbbbb3aaa *mes,
struct aaaaa1aaaaaaaaaaaabaaaaaaaaaaa3aaa *me);
int aaaaa1aaaaaaaaaaaabaaaaaaaaaaa3bbbbbbbbbbbbbbbbbb3aaaaaaaaaaaaaaaabaaaaaaaaaaaaaaaaaaaaaaaaaaaa4aaaaaaaaaaaaaaaabaaaaaaaaaaaaaaaaaaa5aaa(struct tcam *magg, struct aaaaa1aaaaaaaaaaaaaaaabaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaa3aaa *problem,
struct aaaaa1aaaaaaaaaaaabaaaaaaaaaaa3bbbbbbbbbbbbbbbbbb3aaa *mes,
struct aaaaa1aaaaaaaaaaaabaaaaaaaaaaa3aaa *me);
int aaaaa1aaaaaaaaaaaabaaaaaaaaaaa3bbbbbbbbbbbbbbbbbb3aaaaaaaaaaaaaaaabaaaaaaaaaaaaaaaaaaaaaaaaaaaa4bbbbbbbbbbbbbbbbbbbbbbbbbbbbbbbb4aaaaaaaaaaaaaaaabaaaaaaaaaaaaaaaaaaaaaaaaaaaa5aaaopen(struct tcam *magg, struct aaaaa1aaaaaaaaaaaaaaaabaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaa3aaa *problem,
struct aaaaa1aaaaaaaaaaaabaaaaaaaaaaa3aaa *me);
int aaaaa1aaaaaaaaaaaabaaaaaaaaaaa3bbbbbbbbbbbbbbbbbb3aaaaaaaaaaaaaaaabaaaaaaaaaaaaaaaaaaaaaaaaaaaa4bbbbbbbbbbbbbbbbbbbbbbbbbbbbbbbb4aaaaaaaaaaaaaaaabaaaaaaaaaaaaaaaaaaaaaaaaaaaa5aaasolved(struct tcam *magg, struct aaaaa1aaaaaaaaaaaaaaaabaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaa3aaa *problem,
struct aaaaa1aaaaaaaaaaaabaaaaaaaaaaa3aaa *me);
int aaaaa1aaaaaaaaaaaabaaaaaaaaaaa3bbbbbbbbbbbbbbbbbb3aaaaaaaaaaaaaaaabaaaaaaaaaaaaaaaaaaaaaaaaaaaa4aaaaaaaaaaaaaaaabaaaaaaaaaaaaaaaaaaa5aaaaaaaaaaaaaaaabaaaaaaaaaaaaaaaaaaaaaaaaaaaa5aaaopen(struct tcam *magg, struct aaaaa1aaaaaaaaaaaaaaaabaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaa3aaa *problem,
struct aaaaa1aaaaaaaaaaaabaaaaaaaaaaa3aaa *me);
int aaaaa1aaaaaaaaaaaabaaaaaaaaaaa3bbbbbbbbbbbbbbbbbb3aaaaaaaaaaaaaaaabaaaaaaaaaaaaaaaaaaaaaaaaaaaa4aaaaaaaaaaaaaaaabaaaaaaaaaaaaaaaaaaa5aaaaaaaaaaaaaaaabaaaaaaaaaaaaaaaaaaaaaaaaaaaa5aaasolved(struct tcam *magg, struct aaaaa1aaaaaaaaaaaaaaaabaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaa3aaa *problem,
struct aaaaa1aaaaaaaaaaaabaaaaaaaaaaa3aaa *me);
int aaaaa1aaaaaaaaaaaabaaaaaaaaaaa3bbbbbbbbbbbbbbbbbb3aaaaaaaaaaaaaaaabaaaaaaaaaaaaaaaaaaaaaaaaaaaa4aaareset(struct tcam *magg, struct aaaaa1aaaaaaaaaaaabaaaaaaaaaaa3bbbbbbbbbbbbbbbbbb3aaa *mes);
int aaaaa1aaaaaaaaaaaabaaaaaaaaaaa3bbbbbbbbbbbbbbbbbb3aaaaaaaaaaaaaaaabaaaaaaaaaaaaaaaaaaaaaaaaaaaa4aaapopulate(struct tcam *magg, struct aaaaa1aaaaaaaaaaaabaaaaaaaaaaa3bbbbbbbbbbbbbbbbbb3aaa *mes,
struct aaaaa1aaaaaaaaaaaabaaaaaaaaaaa3bbbbbbbbbbbbbbbbbb3aaaaaaaaaaaaaaaabaaaaaaaaaaaaaaaaaaaaaaaaaaaa4aaaaaaaaaaaaabaaaaaaaaaaaaaaaaa5aaa *mesli,
uint16_t *num_populated);
int aaaaa1aaaaaaaaaaaabaaaaaaaaaaa3bbbbbbbbbbbbbbbbbb3aaaaaaaaaaaaaaaabaaaaaaaaaaaaaaaaaaaaaaaaaaaa4aaaaaaaaaaaaaaabaaaaaaaaaaaa5aaaaaaaaaaaaaaaabaaaaaaaaaaaaaaaaaaaaaaaaaaaa5aaamember(struct tcam *magg, struct aaaaa1aaaaaaaaaaaabaaaaaaaaaaa3bbbbbbbbbbbbbbbbbb3aaa *mes,
struct aaaaa1aaaaaaaaaaaabaaaaaaaaaaa3aaa *me);
int aaaaa1aaaaaaaaaaaabaaaaaaaaaaa3bbbbbbbbbbbbbbbbbb3aaaaaaaaaaaaaaaabaaaaaaaaaaaaaaaaaaaaaaaaaaaa4aaaaaaaaaaaaaaaabaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaa4aaa(struct tcam *magg, struct aaaaa1aaaaaaaaaaaabaaaaaaaaaaa3bbbbbbbbbbbbbbbbbb3aaa *mes,
int indent);
#endif
int
aaaaa1bbbbbbbbbbbbbbbbbbbbbbbbbbbbbbbbb3aaaaaaaaaaaaaaaabaaaaaaaaaaaaaaaaaaaaaaaaaaaa4bbbbbbbbbbbbbbbbbbbbbbbbbbbbbbbbbbbbbbb4aaaeate(struct tcam *magg, struct aaaaa1bbbbbbbbbbbbbbbbbbbbbbbbbbbbbbbbb3aaa **out_collset)
{
int rc;
struct aaaaa1bbbbbbbbbbbbbbbbbbbbbbbbbbbbbbbbb3aaa *collset;
cam_calloc_func calloc_function = a1aaaaaaaaaaaaaaaabaaaaaaaaaaaa3aaaaaaaaaaaaaaaabaaaaaaaaaaaaaaaaaaaaaaaaaaaa3aaacalloc_function((a1aaat*) (magg->client));
collset = calloc_function(1, sizeof(struct aaaaa1bbbbbbbbbbbbbbbbbbbbbbbbbbbbbbbbb3aaa) + sizeof(aaaaaaaaaaaaa1aaat));
if (collset == NULL)
return CAM_ERROR_NOMEM;
cam_malloc_func malloc_function = a1aaaaaaaaaaaaaaaabaaaaaaaaaaaa3aaaaaaaaaaaaaaaabaaaaaaaaaaaaaaaaaaaaaaaaaaaa3aaamalloc_function((a1aaat*) (magg->client));
rc = aaaaa1aaaaaaaaaaaaaaaabaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaa3aaaaaaaaaaaaaaaabaaaaaaaaaaaaaaaaaaaaaaaaaaaa4bbbbbbbbbbbbbbbbbbbbbbbbbbbbbbbbbbbbbbb4aaaeate(&collset->entry_ids, malloc_function);
if (rc)
goto error;
magg->stats.curr_num_collsets++;
magg->stats.max_num_collsets = MAX(magg->stats.curr_num_collsets,
magg->stats.max_num_collsets);
*out_collset = collset;
return 0;
error:
(a1aaaaaaaaaaaaaaaabaaaaaaaaaaaa3aaaaaaaaaaaaaaaabaaaaaaaaaaaaaaaaaaaaaaaaaaaa3aaaaaaaaaaaaaabaaaaaaaaaaaa4aaaaaaaaaaaaaaaabaaaaaaaaaaaaaaaaaaaaaaaaaaaa4aaaaaaaaaaaaaaaabaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaa4aaa((a1aaat*) (magg->client)))(collset);
return rc;
}
int
aaaaa1bbbbbbbbbbbbbbbbbbbbbbbbbbbbbbbbb3aaaaaaaaaaaaaaaabaaaaaaaaaaaaaaaaaaaaaaaaaaaa4bbbbbbbbbbbbbbbbbbbbbbbbbbbbbbbb4aaa(struct tcam *magg, struct aaaaa1bbbbbbbbbbbbbbbbbbbbbbbbbbbbbbbbb3aaa *collset,
struct aaaaa1aaaaaaaaaaaabaaaaaaaaaaa3aaa *me)
{
(void) magg;
int rc;
rc = aaaaa1aaaaaaaaaaaaaaaabaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaa3aaaaaaaaaaaaaaaabaaaaaaaaaaaaaaaaaaaaaaaaaaaa4bbbbbbbbbbbbbbbbbbbbbbbbbbbbbbbb4aaa(&collset->entry_ids, me->id);
if (rc)
return rc;
me->num_collsets++;
return 0;
}
int
aaaaa1bbbbbbbbbbbbbbbbbbbbbbbbbbbbbbbbb3aaaaaaaaaaaaaaaabaaaaaaaaaaaaaaaaaaaaaaaaaaaa4aaaaaaaaaaaaaaaabaaaaaaaaaaaaaaaaaaa5aaa(struct tcam *magg, struct aaaaa1bbbbbbbbbbbbbbbbbbbbbbbbbbbbbbbbb3aaa *collset,
struct aaaaa1aaaaaaaaaaaabaaaaaaaaaaa3aaa *me)
{
(void) magg;
int rc;
rc = aaaaa1aaaaaaaaaaaaaaaabaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaa3aaaaaaaaaaaaaaaabaaaaaaaaaaaaaaaaaaaaaaaaaaaa4aaaaaaaaaaaaaaaabaaaaaaaaaaaaaaaaaaa5aaa(&collset->entry_ids, me->id);
if (rc)
return rc;
me->num_collsets--;
return 0;
}
int
aaaaa1bbbbbbbbbbbbbbbbbbbbbbbbbbbbbbbbb3aaaaaaaaaaaaaaaabaaaaaaaaaaaaaaaaaaaaaaaaaaaa4aaafind(struct tcam *magg, struct aaaaa1aaaaaaaaaaaabaaaaaaaaaaa3bbbbbbbbbbbbbbbbbb3aaa *mes,
struct aaaaa1aaaaaaaaaaaabaaaaaaaaaaa3aaa *me, struct aaaaa1bbbbbbbbbbbbbbbbbbbbbbbbbbbbbbbbb3aaa **out_collset)
{
int rc;
struct aaaaa1bbbbbbbbbbbbbbbbbbbbbbbbbbbbbbbbb3aaa *collset;
aaaaaaaaaaaaa1aaat relax_key;
aaaaa1aaaaaaaaaaaaaaaabaaaaaaaaaaaaaaaaaaaaaaa3aaaaaaaaaaaaaaaabaaaaaaaaaaaaaaaaaaaaaaaaaaaa3aaarelax_key(magg, me, &mes->mask,
(struct aaaaa1aaaaaaaaaaaaaaaabaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaa3aaaaaaaaaaaaaaaabaaaaaaaaaaaaaaaaaaaaaaaaaaaa4aaarelax_var_array *) &relax_key);
rc = aaaaa1aaaaaaaaaaaabaaaaaaaaaa3aaaaaaaaaaaaaaaabaaaaaaaaaaaaaaaaaaaaaaaaaaaa3aaafind(magg, mes, &relax_key, &collset);
if (rc)
return rc;
*out_collset = collset;
if (collset == NULL)
return 1;
return 0;
}
int
aaaaa1bbbbbbbbbbbbbbbbbbbbbbbbbbbbbbbbb3aaaaaaaaaaaaaaaabaaaaaaaaaaaaaaaaaaaaaaaaaaaa4aaaaaaaaaaaaaaaabaaaaaaaaaaaaaaaaaaaaaaaaa5aaa(struct aaaaa1bbbbbbbbbbbbbbbbbbbbbbbbbbbbbbbbb3aaa *collset, cam_free_func free_function)
{
(void) aaaaa1aaaaaaaaaaaaaaaabaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaa3aaaaaaaaaaaaaaaabaaaaaaaaaaaaaaaaaaaaaaaaaaaa4aaaaaaaaaaaaaaaabaaaaaaaaaaaaaaaaaaaaaaaaa5aaa(&collset->entry_ids, (void*)free_function);
free_function(collset);
return 0;
}
int
aaaaa1bbbbbbbbbbbbbbbbbbbbbbbbbbbbbbbbb3aaaaaaaaaaaaaaaabaaaaaaaaaaaaaaaaaaaaaaaaaaaa4aaaaaaaaaaaaaaaabaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaa4aaa(struct tcam *magg, struct aaaaa1bbbbbbbbbbbbbbbbbbbbbbbbbbbbbbbbb3aaa *collset, int indent)
{
   printf("%*caaaaa1bbbbbbbbbbbbbbbbbbbbbbbbbbbbbbbbb3aaa %p num_entries %u\n", indent, ' ', collset,
collset->entry_ids.num_entries);
if (!(magg->debug_mask & aaaaa1aaaaaaaaaaaaaaaabaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaa3aaaaaaaaaaaaaaaabaaaaaaaaaaaaaaaaaaaaaaaaaaaa4aaaaaaaaaaaabaaaaaaaaaaa5aaa))
return 0;
int i;
for (i = 0; i < collset->entry_ids.num_entries; i++) {
uint16_t id = collset->entry_ids.data[i].id;
struct aaaaa1aaaaaaaaaaaabaaaaaaaaaaa3aaa *me = magg->entries[id];
aaaaa1aaaaaaaaaaaabaaaaaaaaaaa3aaaaaaaaaaaaaaaabaaaaaaaaaaaaaaaaaaaaaaaaaaaa3aaaaaaaaaaaaaaaabaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaa3aaa(magg, me, indent + 2);
}
return 0;
}
int
aaaaa1bbbbbbbbbbbbbbbbbbbbbbbbbbbbbbbbbbbbb3aaaaaaaaaaaaaaaabaaaaaaaaaaaaaaaaaaaaaaaaaaaa4aaarun(struct tcam *magg)
{
int rc;
rc = aaaaa1aaaaaaaaaaaaaaaabaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaa3aaaaaaaaaaaaaaaabaaaaaaaaaaaaaaaaaaaaaaaaaaaa4bbbbbbbbbbbbbbbbbbbbbbbbbbbbbb4aaa(magg);
if (rc)
return rc;
return 0;
}
int
aaaaa1bbbbbbbbbbbbbbbbbbbbbbbbbbbbbbbbbbbbb3aaaaaaaaaaaaaaaabaaaaaaaaaaaaaaaaaaaaaaaaaaaa4bbbbbbbbbbbbbbbbbb4aaaaaaaaaaaaaaaabaaaaaaaaaaaaaaaaaaaaaaaaaaaa5aaaaaaaaaaaaaaaabaaaaaaaaaaaaaaaaaaaaaaa6aaa(struct tcam *magg, enum aaaaa1bbbbbbbbbbbbbbbbbbbbbbbbbbbbbbbbbbbbb3aaaaaaaaaaaaaaaabaaaaaaaaaaaaaaaaaaaaaaaaaaaa4aaaflags debug_flags)
{
magg->debug_mask = debug_flags;
return 0;
}
enum aaaaa1bbbbbbbbbbbbbbbbbbbbbbbbbbbbbbbbbbbbb3aaaaaaaaaaaaaaaabaaaaaaaaaaaaaaaaaaaaaaaaaaaa4aaaflags
aaaaa1bbbbbbbbbbbbbbbbbbbbbbbbbbbbbbbbbbbbb3aaaaaaaaaaaaaaaabaaaaaaaaaaaaaaaaaaaaaaaaaaaa4aaaaaaaaaaaaaaaabaaaaaaaaaaaa5aaaaaaaaaaaaaaaabaaaaaaaaaaaaaaaaaaaaaaaaaaaa5aaaaaaaaaaaaaaaabaaaaaaaaaaaaaaaaaaaaaaa6aaa(struct tcam *magg)
{
return magg->debug_mask;
}
int
aaaaa1bbbbbbbbbbbbbbbbbbbbbbbbbbbbbbbbbbbbb3aaaaaaaaaaaaaaaabaaaaaaaaaaaaaaaaaaaaaaaaaaaa4aaadump(struct tcam *magg)
{
struct aaaaa1aaaaaaaaaaaaaaaabaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaa3aaa *probsol;
struct aaaaa1aaaaaaaaaaaabaaaaaaaaaaa3bbbbbbbbbbbbbbbbbb3aaaaaaaaaaaaaaaabaaaaaaaaaaaaaaaaaaaaaaaaaaaa4aaaaaaaaaaaaabaaaaaaaaaaaaaaaaa5aaa *mesli;
struct aaaaa1aaaaaaaaaaaabaaaaaaaaaaa3aaaaaaaaaaaaaaaabaaaaaaaaaaaaaaaaaaaaaaaaaaaa3aaaaaaaaaaaaabaaaaaaaaaaaaaaaaa4aaa *meli;
LIST_FOREACH(magg->probsols, probsol)
{
LIST_FOREACH(probsol->curr_solution.mask_list, mesli)
{
int num_entries = 0;
LIST_FOREACH(mesli->entry_list, meli)
num_entries++;
           printf("Mask %08x instance %u with %d entries use ranges %x:\n  ",
mesli->entryset->mh_handle.hashv,
mesli->instance, num_entries,
mesli->entryset->mask.use_range);
for (int i = 0; i < sizeof(aaaaaaaaaaaaa1aaat) / 4; i++)
               printf("%08x ", mesli->entryset->mask.mask.word[i]);
           printf("\n");
LIST_FOREACH(mesli->entry_list, meli)
{
               printf("  Entry %p prio %u collset %p\n",
meli->entry, meli->entry->priority.word[0],
meli->entry->current_entryset.collset);
               printf("    K ");
for (int i = 0; i < sizeof(aaaaaaaaaaaaa1aaat) / 4; i++)
                   printf("%08x ", meli->entry->exact_key.word[i]);
               printf("\n");
               printf("    M ");
for (int i = 0; i < sizeof(aaaaaaaaaaaaa1aaat) / 4; i++)
                   printf("%08x ", meli->entry->exact_mask.mask.word[i]);
               printf("\n");
}
}
}
return 0;
}
int
aaaaa1bbbbbbbbbbbbbbbbbbbbbbbbbbbbbbbbbbbbb3aaaaaaaaaaaaaaaabaaaaaaaaaaaaaaaaaaaaaaaaaaaa4aaaaaaaaaaaaaaaabaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaa4aaa(struct tcam *magg, int indent)
{
if (!(magg->debug_mask & aaaaa1aaaaaaaaaaaaaaaabaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaa3aaaaaaaaaaaaaaaabaaaaaaaaaaaaaaaaaaaaaaaaaaaa4aaaaaaaaaaaaaaaabaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaa4aaa))
return 0;
struct aaaaa1aaaaaaaaaaaaaaaabaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaa3aaa *probsol;
LIST_FOREACH(magg->probsols, probsol)
aaaaa1aaaaaaaaaaaaaaaabaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaa3aaaaaaaaaaaaaaaabaaaaaaaaaaaaaaaaaaaaaaaaaaaa4aaaaaaaaaaaaaaaabaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaa4aaa(magg, probsol, indent);
return 0;
}
void cam_mem_debug(struct tcam *tcam)
{
a1aaaaaaaaaaaaaaaabaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaa3aaa(tcam->client);
}
void cam_resource_debug(struct tcam *tcam)
{
aaaaa1aaaaaaaaaaaaaaaabaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaa3aaaaaaaaaaaaaaaabaaaaaaaaaaaaaaaaaaaaaaaaaaaa4aaastats(tcam);
}
static void
aaaaa1aaaaaaaaaaaabaaaaaaaaaaa3aaaaaaaaaaaaaaaabaaaaaaaaaaaaaaaaaaaaaaaaaaaa3bbbbbbbbbbbbbbbbbbbbbbbbbbbbbbbbb3aaas_copy(void *dst, const void *src)
{
struct aaaaa1bbbbbbbbbbbbbbbbbbbbbbbbbbbbbbbbb3aaa **dp = (struct aaaaa1bbbbbbbbbbbbbbbbbbbbbbbbbbbbbbbbb3aaa **) dst;
struct aaaaa1bbbbbbbbbbbbbbbbbbbbbbbbbbbbbbbbb3aaa **sp = (struct aaaaa1bbbbbbbbbbbbbbbbbbbbbbbbbbbbbbbbb3aaa **) src;
*dp = *sp;
}
int
aaaaa1aaaaaaaaaaaabaaaaaaaaaaa3aaaaaaaaaaaaaaaabaaaaaaaaaaaaaaaaaaaaaaaaaaaa3bbbbbbbbbbbbbbbbbbbbbbbbbbbbbbbbbbbbbbb3aaaeate(struct tcam *magg, uint16_t id, const union aaaaaaaaaaa1aaa *fields,
const aaaaaaaaaaaaaaaa1aaaaaaaaaaaaaaaabaaaaaaaaaaaaaaaaaaaaaaaaaaaa3aaat *priority,
struct aaaaa1aaaaaaaaaaaabaaaaaaaaaaa3aaa **me_out)
{
int rc;
struct aaaaa1aaaaaaaaaaaabaaaaaaaaaaa3aaa *me;
const uint8_t num_fields = a1aaaaaaaaaaaaaaaabaaaaaaaaaaaa3aaaaaaaaaaaaaaaabaaaaaaaaaaaaaaaaaaaaaaaaaaaa3aaaaaaaaaaaaaaabaaaaaaaaaaaaaaaa4aaaaaaaaaaaaaaaabaaaaaaaaaaaaaaaaaaaaaaaaaaaa4aaaaaaaaaaaaaaabaaaaaaaaaaaaaaaaaa5aaas(magg->client);
cam_free_func free_function = a1aaaaaaaaaaaaaaaabaaaaaaaaaaaa3aaaaaaaaaaaaaaaabaaaaaaaaaaaaaaaaaaaaaaaaaaaa3aaaaaaaaaaaaaabaaaaaaaaaaaa4aaaaaaaaaaaaaaaabaaaaaaaaaaaaaaaaaaaaaaaaaaaa4aaaaaaaaaaaaaaaabaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaa4aaa((a1aaat*) (magg->client));
cam_malloc_func malloc_function = a1aaaaaaaaaaaaaaaabaaaaaaaaaaaa3aaaaaaaaaaaaaaaabaaaaaaaaaaaaaaaaaaaaaaaaaaaa3aaamalloc_function((a1aaat*) (magg->client));
cam_calloc_func calloc_function = a1aaaaaaaaaaaaaaaabaaaaaaaaaaaa3aaaaaaaaaaaaaaaabaaaaaaaaaaaaaaaaaaaaaaaaaaaa3aaacalloc_function((a1aaat*) (magg->client));
me = calloc_function(1, sizeof(*me) + num_fields * sizeof(union aaaaaaaaaaa1aaa));
if (me == NULL)
return CAM_ERROR_NOMEM;
me->id = id;
memcpy(&me->fields, fields, num_fields * sizeof(union aaaaaaaaaaa1aaa));
me->priority = *priority;
rc = aaaaa1aaaaaaaaaaaaaaaabaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaa3aaaaaaaaaaaaaaaabaaaaaaaaaaaaaaaaaaaaaaaaaaaa4bbbbbbbbbbbbbbbbbbbbbbbbbbbbbbbbbbbbbbb4aaaeate_exact(magg, me);
if (rc)
goto error;
rc = aaaaa1aaaaaaaaaaaaaaaabaaaaaaaaaaaaaaaaaaaaaaa3aaaaaaaaaaaaaaaabaaaaaaaaaaaaaaaaaaaaaaaaaaaa3bbbbbbbbbbbbbbbbbbbbbbbbbbbbbbbbbbbbbbb3aaaeate_exact(magg, me);
if (rc)
goto error;
rc = aaaaa1aaaaaaaaaaaaaaaabaaaaaaaaaaaaaaaaaaaaaaa3aaaaaaaaaaaaaaaabaaaaaaaaaaaaaaaaaaaaaaaaaaaa3aaarelax_fields(magg, me);
if (rc)
goto error;
rc = aaaaa1aaaaaaaaaaaabaaaaaaaaaaa3aaaaaaaaaaaaaaaabaaaaaaaaaaaaaaaaaaaaaaaaaaaa3bbbbbbbbbbbbbbbbbbbbbbbbbbbbbbbbbbbbbbb3aaaeate_collset(magg, me);
if (rc)
goto error;
rc = CAM_ERROR_NOMEM;
MH_ADD_KEYPTR(mh_handle, magg->entry_by_fields, &me->fields, num_fields * sizeof(union aaaaaaaaaaa1aaa), me, free_function, malloc_function);
*me_out = me;
return 0;
error:
if (me->collsets)
(void) aaaaa1aaaaaaaaaaaabaaaaaaaaaaa3aaaaaaaaaaaaaaaabaaaaaaaaaaaaaaaaaaaaaaaaaaaa3aaaaaaaaaaaaaaaabaaaaaaaaaaaaaaaaaaaaaaaaa4aaaaaaaaaaaaaaaabaaaaaaaaaaaaaaaaaaaaaaaaaaaa4bbbbbbbbbbbbbbbbbbbbbbbbbbbbbbbbb4aaa(magg, me);
free_function(me);
*me_out = NULL;
return rc;
}
int
aaaaa1aaaaaaaaaaaabaaaaaaaaaaa3aaaaaaaaaaaaaaaabaaaaaaaaaaaaaaaaaaaaaaaaaaaa3aaaaaaaaaaaaaaaabaaaaaaaaaaaaaaaaaaaaaaaaa4aaa(struct tcam *magg, struct aaaaa1aaaaaaaaaaaabaaaaaaaaaaa3aaa *me)
{
cam_free_func free_function = a1aaaaaaaaaaaaaaaabaaaaaaaaaaaa3aaaaaaaaaaaaaaaabaaaaaaaaaaaaaaaaaaaaaaaaaaaa3aaaaaaaaaaaaaabaaaaaaaaaaaa4aaaaaaaaaaaaaaaabaaaaaaaaaaaaaaaaaaaaaaaaaaaa4aaaaaaaaaaaaaaaabaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaa4aaa((a1aaat*) (magg->client));
MH_DELETE(mh_handle, magg->entry_by_fields, me, free_function);
magg->entries[me->id] = 0;
(void) aaaaa1aaaaaaaaaaaabaaaaaaaaaaa3aaaaaaaaaaaaaaaabaaaaaaaaaaaaaaaaaaaaaaaaaaaa3aaaaaaaaaaaaaaaabaaaaaaaaaaaaaaaaaaaaaaaaa4aaaaaaaaaaaaaaaabaaaaaaaaaaaaaaaaaaaaaaaaaaaa4bbbbbbbbbbbbbbbbbbbbbbbbbbbbbbbbb4aaa(magg, me);
free_function(me);
return 0;
}
int
aaaaa1aaaaaaaaaaaabaaaaaaaaaaa3aaaaaaaaaaaaaaaabaaaaaaaaaaaaaaaaaaaaaaaaaaaa3bbbbbbbbbbbbbbbbbbbbbbbbbbbbbbbbbbbbbbb3aaaeate_collset(struct tcam *magg, struct aaaaa1aaaaaaaaaaaabaaaaaaaaaaa3aaa *me)
{
(void) magg;
m_icd ut_icd = { sizeof(struct aaaaa1bbbbbbbbbbbbbbbbbbbbbbbbbbbbbbbbb3aaa *), NULL,
aaaaa1aaaaaaaaaaaabaaaaaaaaaaa3aaaaaaaaaaaaaaaabaaaaaaaaaaaaaaaaaaaaaaaaaaaa3bbbbbbbbbbbbbbbbbbbbbbbbbbbbbbbbb3aaas_copy, NULL
};
cam_malloc_func malloc_function = a1aaaaaaaaaaaaaaaabaaaaaaaaaaaa3aaaaaaaaaaaaaaaabaaaaaaaaaaaaaaaaaaaaaaaaaaaa3aaamalloc_function((a1aaat*) (magg->client));
me->collsets = malloc_function(sizeof(m_array));
if (me->collsets == NULL)
return CAM_ERROR_NOMEM;
array_init(me->collsets, &ut_icd);
me->num_collsets = 0;
return 0;
}
int
aaaaa1aaaaaaaaaaaabaaaaaaaaaaa3aaaaaaaaaaaaaaaabaaaaaaaaaaaaaaaaaaaaaaaaaaaa3aaaaaaaaaaaaaaaabaaaaaaaaaaaaaaaaaaaaaaaaa4aaaaaaaaaaaaaaaabaaaaaaaaaaaaaaaaaaaaaaaaaaaa4bbbbbbbbbbbbbbbbbbbbbbbbbbbbbbbbb4aaa(struct tcam *magg, struct aaaaa1aaaaaaaaaaaabaaaaaaaaaaa3aaa *me)
{
cam_free_func free_function = a1aaaaaaaaaaaaaaaabaaaaaaaaaaaa3aaaaaaaaaaaaaaaabaaaaaaaaaaaaaaaaaaaaaaaaaaaa3aaaaaaaaaaaaaabaaaaaaaaaaaa4aaaaaaaaaaaaaaaabaaaaaaaaaaaaaaaaaaaaaaaaaaaa4aaaaaaaaaaaaaaaabaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaa4aaa((a1aaat*) (magg->client));
array_free(me->collsets, free_function);
me->num_collsets = 0;
return 0;
}
int
aaaaa1aaaaaaaaaaaabaaaaaaaaaaa3aaaaaaaaaaaaaaaabaaaaaaaaaaaaaaaaaaaaaaaaaaaa3bbbbbbbbbbbbbbbbbbbbbbbbbbbbbbbb3aaaaaaaaaaaaaaaabaaaaaaaaaaaaaaaaaaaaaaaaaaaa4bbbbbbbbbbbbbbbbbbbbbbbbbbbbbbbbb4aaa(struct tcam *magg, struct aaaaa1aaaaaaaaaaaabaaaaaaaaaaa3aaa *me,
struct aaaaa1bbbbbbbbbbbbbbbbbbbbbbbbbbbbbbbbb3aaa *collset)
{
(void) magg;
array_push_back(me->collsets, &collset);
return 0;
error:
return CAM_ERROR_NOMEM;
}
int
aaaaa1aaaaaaaaaaaabaaaaaaaaaaa3aaaaaaaaaaaaaaaabaaaaaaaaaaaaaaaaaaaaaaaaaaaa3aaaaaaaaaaaaaaaabaaaaaaaaaaaaaaaaaaa4aaaaaaaaaaaaaaaabaaaaaaaaaaaaaaaaaaaaaaaaaaaa4bbbbbbbbbbbbbbbbbbbbbbbbbbbbbbbbb4aaa(struct tcam *magg, struct aaaaa1aaaaaaaaaaaabaaaaaaaaaaa3aaa *me,
struct aaaaa1bbbbbbbbbbbbbbbbbbbbbbbbbbbbbbbbb3aaa *collset)
{
(void) magg;
uint16_t index = 0;
struct aaaaa1bbbbbbbbbbbbbbbbbbbbbbbbbbbbbbbbb3aaa **collsetp;
for (collsetp = (struct aaaaa1bbbbbbbbbbbbbbbbbbbbbbbbbbbbbbbbb3aaa **) array_front(me->collsets);
collsetp; collsetp = (struct aaaaa1bbbbbbbbbbbbbbbbbbbbbbbbbbbbbbbbb3aaa **)
array_next(me->collsets, collsetp)) {
if (*collsetp == collset) {
array_erase(me->collsets, index, 1);
break;
}
index++;
}
assert(collsetp);
return 0;
}
int aaaaa1aaaaaaaaaaaabaaaaaaaaaaa3aaaaaaaaaaaaaaaabaaaaaaaaaaaaaaaaaaaaaaaaaaaa3aaaaaaaaaaaaaaaabaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaa3aaa(struct tcam *magg, struct aaaaa1aaaaaaaaaaaabaaaaaaaaaaa3aaa *me, int indent)
{
   printf("%*caaaaa1aaaaaaaaaaaabaaaaaaaaaaa3aaa %p prio %u\n", indent, ' ', me,
me->priority.word[0]);
aaaaa1aaaaaaaaaaaaaaaabaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaa3aaaaaaaaaaaaaaaabaaaaaaaaaaaaaaaaaaaaaaaaaaaa4aaaaaaaaaaaaaaaabaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaa4aaa(magg, &me->exact_key, indent + 2);
aaaaa1aaaaaaaaaaaaaaaabaaaaaaaaaaaaaaaaaaaaaaa3aaaaaaaaaaaaaaaabaaaaaaaaaaaaaaaaaaaaaaaaaaaa3aaaaaaaaaaaaaaaabaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaa3aaa(magg, &me->exact_mask, indent + 2);
return 0;
}
int
aaaaa1aaaaaaaaaaaabaaaaaaaaaaa3bbbbbbbbbbbbbbbbbb3aaaaaaaaaaaaaaaabaaaaaaaaaaaaaaaaaaaaaaaaaaaa4bbbbbbbbbbbbbbbbbbbbbbbbbbbbbbbbbbbbbbb4aaaeate(struct tcam *magg, struct aaaaa1aaaaaaaaaaaaaaaabaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaa3aaa *problem,
struct aaaaa1aaaaaaaaaaaaaaaabaaaaaaaaaaaaaaaaaaaaaaa3aaa *mask, struct aaaaa1aaaaaaaaaaaabaaaaaaaaaaa3bbbbbbbbbbbbbbbbbb3aaa **out_mes)
{
struct aaaaa1aaaaaaaaaaaabaaaaaaaaaaa3bbbbbbbbbbbbbbbbbb3aaa *mes;
const uint32_t max_num_entries = a1aaaaaaaaaaaaaaaabaaaaaaaaaaaa3aaaaaaaaaaaaaaaabaaaaaaaaaaaaaaaaaaaaaaaaaaaa3aaaaaaaaaaaaaaabaaaaaaaaaaaaaaaa4aaaaaaaaaaaaaaaabaaaaaaaaaaaaaaaaaaaaaaaaaaaa4aaaaaaaaaaaaaaaabaaaaaaaaaaaaaaaaaaaaa5aaa(magg->client);
cam_free_func free_function = a1aaaaaaaaaaaaaaaabaaaaaaaaaaaa3aaaaaaaaaaaaaaaabaaaaaaaaaaaaaaaaaaaaaaaaaaaa3aaaaaaaaaaaaaabaaaaaaaaaaaa4aaaaaaaaaaaaaaaabaaaaaaaaaaaaaaaaaaaaaaaaaaaa4aaaaaaaaaaaaaaaabaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaa4aaa((a1aaat*) (magg->client));
cam_calloc_func calloc_function = a1aaaaaaaaaaaaaaaabaaaaaaaaaaaa3aaaaaaaaaaaaaaaabaaaaaaaaaaaaaaaaaaaaaaaaaaaa3aaacalloc_function((a1aaat*) (magg->client));
cam_malloc_func malloc_function = a1aaaaaaaaaaaaaaaabaaaaaaaaaaaa3aaaaaaaaaaaaaaaabaaaaaaaaaaaaaaaaaaaaaaaaaaaa3aaamalloc_function((a1aaat*) (magg->client));
mes = calloc_function(1, sizeof(*mes) + max_num_entries / 8 + 1);
if (mes == 0)
return CAM_ERROR_NOMEM;
memcpy(&mes->mask, mask, sizeof(mes->mask));
int rc = CAM_ERROR_NOMEM;
MH_ADD(mh_handle, problem->entryset_by_mask, mask, sizeof(mes->mask), mes, free_function, malloc_function);
magg->stats.curr_num_entrysets++;
magg->stats.max_num_entrysets = MAX(magg->stats.curr_num_entrysets,
magg->stats.max_num_entrysets);
*out_mes = mes;
return 0;
error: free_function(mes);
return rc;
}
static int
aaaaa1aaaaaaaaaaaabaaaaaaaaaaa3bbbbbbbbbbbbbbbbbb3aaaaaaaaaaaaaaaabaaaaaaaaaaaaaaaaaaaaaaaaaaaa4aaaaaaaaaaaaaaaabaaaaaaaaaaaaaaaaaaa5aaaaaaaaaaaaaaaabaaaaaaaaaaaaaaaaaaaaaaaaaaaa5bbbbbbbbbbbbbbbbbbbbbbbbbbbbbbbbb5aaa(struct tcam *magg, struct aaaaa1aaaaaaaaaaaabaaaaaaaaaaa3bbbbbbbbbbbbbbbbbb3aaa *mes,
struct aaaaa1bbbbbbbbbbbbbbbbbbbbbbbbbbbbbbbbb3aaa *collset, cam_free_func free_function)
{
int rc;
rc = aaaaa1aaaaaaaaaaaabaaaaaaaaaa3aaaaaaaaaaaaaaaabaaaaaaaaaaaaaaaaaaaaaaaaaaaa3aaaaaaaaaaaaaaaabaaaaaaaaaaaaaaaaaaa4aaa(magg, mes, collset);
if (rc)
return rc;
rc = aaaaa1bbbbbbbbbbbbbbbbbbbbbbbbbbbbbbbbb3aaaaaaaaaaaaaaaabaaaaaaaaaaaaaaaaaaaaaaaaaaaa4aaaaaaaaaaaaaaaabaaaaaaaaaaaaaaaaaaaaaaaaa5aaa(collset, free_function);
if (rc)
return rc;
magg->stats.curr_num_collsets--;
return 0;
}
int
aaaaa1aaaaaaaaaaaabaaaaaaaaaaa3bbbbbbbbbbbbbbbbbb3aaaaaaaaaaaaaaaabaaaaaaaaaaaaaaaaaaaaaaaaaaaa4aaaaaaaaaaaaaaaabaaaaaaaaaaaaaaaaaaaaaaaaa5aaa(struct tcam *magg, struct aaaaa1aaaaaaaaaaaaaaaabaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaa3aaa *problem,
struct aaaaa1aaaaaaaaaaaabaaaaaaaaaaa3bbbbbbbbbbbbbbbbbb3aaa *mes)
{
int i;
struct aaaaa1bbbbbbbbbbbbbbbbbbbbbbbbbbbbbbbbb3aaa *collset, *tmp;
cam_free_func free_function = a1aaaaaaaaaaaaaaaabaaaaaaaaaaaa3aaaaaaaaaaaaaaaabaaaaaaaaaaaaaaaaaaaaaaaaaaaa3aaaaaaaaaaaaaabaaaaaaaaaaaa4aaaaaaaaaaaaaaaabaaaaaaaaaaaaaaaaaaaaaaaaaaaa4aaaaaaaaaaaaaaaabaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaa4aaa(magg->client);
for (i = 0; i < aaaaa1aaaaaaaaaaaabaaaaaaaaaa3aaaaaaaaaaaaaaaabaaaaaaaaaaaaaaaaaaaaaaaaaaaa3aaaaaaaaaaaaaaabaaaaaaaaaaaaaaaa4aaaaaaaaaaaaaaaabaaaaaaaaaaaaaaaaaaaaaaaaaaaa4aaaaaaaaaabaaaaaaaaaaa5aaaS; i++) {
if (mes->collset_by_key.buckets[i] == NULL)
continue;
LIST_FOREACH_SAFE(mes->collset_by_key.buckets[i], collset, tmp)
(void) aaaaa1aaaaaaaaaaaabaaaaaaaaaaa3bbbbbbbbbbbbbbbbbb3aaaaaaaaaaaaaaaabaaaaaaaaaaaaaaaaaaaaaaaaaaaa4aaaaaaaaaaaaaaaabaaaaaaaaaaaaaaaaaaa5aaaaaaaaaaaaaaaabaaaaaaaaaaaaaaaaaaaaaaaaaaaa5bbbbbbbbbbbbbbbbbbbbbbbbbbbbbbbbb5aaa(magg, mes, collset, free_function);
}
MH_DELETE(mh_handle, problem->entryset_by_mask, mes, free_function);
magg->stats.curr_num_entrysets--;
free_function(mes);
return 0;
}
static void
aaaaa1aaaaaaaaaaaabaaaaaaaaaaa3bbbbbbbbbbbbbbbbbb3aaaaaaaaaaaaaaaabaaaaaaaaaaaaaaaaaaaaaaaaaaaa4aaamember_add(struct tcam *magg, struct aaaaa1aaaaaaaaaaaabaaaaaaaaaaa3bbbbbbbbbbbbbbbbbb3aaa *mes,
struct aaaaa1aaaaaaaaaaaabaaaaaaaaaaa3aaa *me)
{
(void) magg;
mes->members[me->id / 8] |= 1 << me->id % 8;
}
static void
aaaaa1aaaaaaaaaaaabaaaaaaaaaaa3bbbbbbbbbbbbbbbbbb3aaaaaaaaaaaaaaaabaaaaaaaaaaaaaaaaaaaaaaaaaaaa4aaamember_delete(struct tcam *magg, struct aaaaa1aaaaaaaaaaaabaaaaaaaaaaa3bbbbbbbbbbbbbbbbbb3aaa *mes,
struct aaaaa1aaaaaaaaaaaabaaaaaaaaaaa3aaa *me)
{
(void) magg;
mes->members[me->id / 8] &= ~(1 << me->id % 8);
}
int
aaaaa1aaaaaaaaaaaabaaaaaaaaaaa3bbbbbbbbbbbbbbbbbb3aaaaaaaaaaaaaaaabaaaaaaaaaaaaaaaaaaaaaaaaaaaa4aaaaaaaaaaaaaaabaaaaaaaaaaaa5aaaaaaaaaaaaaaaabaaaaaaaaaaaaaaaaaaaaaaaaaaaa5aaamember(struct tcam *magg, struct aaaaa1aaaaaaaaaaaabaaaaaaaaaaa3bbbbbbbbbbbbbbbbbb3aaa *mes,
struct aaaaa1aaaaaaaaaaaabaaaaaaaaaaa3aaa *me)
{
(void) magg;
return mes->members[me->id / 8] & (1 << me->id % 8);
}
static int
aaaaa1aaaaaaaaaaaabaaaaaaaaaaa3bbbbbbbbbbbbbbbbbb3aaaaaaaaaaaaaaaabaaaaaaaaaaaaaaaaaaaaaaaaaaaa4bbbbbbbbbbbbbbbbbbbbbbbbbbbbbbbb4aaaaaaaaaaaaaaaabaaaaaaaaaaaaaaaaaaaaaaaaaaaa5bbbbbbbbbbbbbbbbbbbbbbbbbbbbbbbbb5aaa(struct tcam *magg, struct aaaaa1aaaaaaaaaaaabaaaaaaaaaaa3bbbbbbbbbbbbbbbbbb3aaa *mes,
struct aaaaa1bbbbbbbbbbbbbbbbbbbbbbbbbbbbbbbbb3aaa *collset)
{
int rc;
rc = aaaaa1aaaaaaaaaaaabaaaaaaaaaa3aaaaaaaaaaaaaaaabaaaaaaaaaaaaaaaaaaaaaaaaaaaa3bbbbbbbbbbbbbbbbbbbbbbbbbbbbbbbb3aaa(magg, mes, collset);
if (rc)
return rc;
collset->entryset = mes;
return 0;
}
int
aaaaa1aaaaaaaaaaaabaaaaaaaaaaa3bbbbbbbbbbbbbbbbbb3aaaaaaaaaaaaaaaabaaaaaaaaaaaaaaaaaaaaaaaaaaaa4bbbbbbbbbbbbbbbbbbbbbbbbbbbbbbbb4aaa(struct tcam *magg, struct aaaaa1aaaaaaaaaaaaaaaabaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaa3aaa *problem,
struct aaaaa1aaaaaaaaaaaabaaaaaaaaaaa3bbbbbbbbbbbbbbbbbb3aaa *mes,
struct aaaaa1aaaaaaaaaaaabaaaaaaaaaaa3aaa *me)
{
int rc;
struct aaaaa1bbbbbbbbbbbbbbbbbbbbbbbbbbbbbbbbb3aaa *collset;
rc = aaaaa1bbbbbbbbbbbbbbbbbbbbbbbbbbbbbbbbb3aaaaaaaaaaaaaaaabaaaaaaaaaaaaaaaaaaaaaaaaaaaa4aaafind(magg, mes, me, &collset);
if (rc) {
rc = aaaaa1bbbbbbbbbbbbbbbbbbbbbbbbbbbbbbbbb3aaaaaaaaaaaaaaaabaaaaaaaaaaaaaaaaaaaaaaaaaaaa4bbbbbbbbbbbbbbbbbbbbbbbbbbbbbbbbbbbbbbb4aaaeate(magg, &collset);
if (rc)
goto error;
aaaaa1aaaaaaaaaaaaaaaabaaaaaaaaaaaaaaaaaaaaaaa3aaaaaaaaaaaaaaaabaaaaaaaaaaaaaaaaaaaaaaaaaaaa3aaarelax_key(magg, me, &mes->mask,
&collset->relax_key);
rc = aaaaa1aaaaaaaaaaaabaaaaaaaaaaa3bbbbbbbbbbbbbbbbbb3aaaaaaaaaaaaaaaabaaaaaaaaaaaaaaaaaaaaaaaaaaaa4bbbbbbbbbbbbbbbbbbbbbbbbbbbbbbbb4aaaaaaaaaaaaaaaabaaaaaaaaaaaaaaaaaaaaaaaaaaaa5bbbbbbbbbbbbbbbbbbbbbbbbbbbbbbbbb5aaa(magg, mes, collset);
if (rc)
goto error;
}
if (problem->is_solved &&
collset->entry_ids.num_entries >= magg->max_num_collisions)
return -1;
rc = aaaaa1bbbbbbbbbbbbbbbbbbbbbbbbbbbbbbbbb3aaaaaaaaaaaaaaaabaaaaaaaaaaaaaaaaaaaaaaaaaaaa4bbbbbbbbbbbbbbbbbbbbbbbbbbbbbbbb4aaa(magg, collset, me);
if (rc)
goto error;
rc = aaaaa1aaaaaaaaaaaabaaaaaaaaaaa3aaaaaaaaaaaaaaaabaaaaaaaaaaaaaaaaaaaaaaaaaaaa3bbbbbbbbbbbbbbbbbbbbbbbbbbbbbbbb3aaaaaaaaaaaaaaaabaaaaaaaaaaaaaaaaaaaaaaaaaaaa4bbbbbbbbbbbbbbbbbbbbbbbbbbbbbbbbb4aaa(magg, me, collset);
if (rc)
goto error;
mes->num_entries++;
aaaaa1aaaaaaaaaaaabaaaaaaaaaaa3bbbbbbbbbbbbbbbbbb3aaaaaaaaaaaaaaaabaaaaaaaaaaaaaaaaaaaaaaaaaaaa4aaamember_add(magg, mes, me);
if (collset->entry_ids.num_entries <= magg->max_num_collisions)
mes->weight += aaaaa1bbbbbbbbbbbbbbbbbbbbbbbbbbbbbbbbb3aaaaaaaaaaaaaaaabaaaaaaaaaaaaaaaaaaaaaaaaaaaa4aaaWEIGHT;
return 0;
error:
return rc;
}
int
aaaaa1aaaaaaaaaaaabaaaaaaaaaaa3bbbbbbbbbbbbbbbbbb3aaaaaaaaaaaaaaaabaaaaaaaaaaaaaaaaaaaaaaaaaaaa4aaaaaaaaaaaaaaaabaaaaaaaaaaaaaaaaaaa5aaa(struct tcam *magg, struct aaaaa1aaaaaaaaaaaaaaaabaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaa3aaa *problem,
struct aaaaa1aaaaaaaaaaaabaaaaaaaaaaa3bbbbbbbbbbbbbbbbbb3aaa *mes, struct aaaaa1aaaaaaaaaaaabaaaaaaaaaaa3aaa *me)
{
(void) problem;
int rc;
struct aaaaa1bbbbbbbbbbbbbbbbbbbbbbbbbbbbbbbbb3aaa *collset;
mes->num_entries--;
rc = aaaaa1bbbbbbbbbbbbbbbbbbbbbbbbbbbbbbbbb3aaaaaaaaaaaaaaaabaaaaaaaaaaaaaaaaaaaaaaaaaaaa4aaafind(magg, mes, me, &collset);
assert(rc == 0);
rc = aaaaa1bbbbbbbbbbbbbbbbbbbbbbbbbbbbbbbbb3aaaaaaaaaaaaaaaabaaaaaaaaaaaaaaaaaaaaaaaaaaaa4aaaaaaaaaaaaaaaabaaaaaaaaaaaaaaaaaaa5aaa(magg, collset, me);
if (rc)
return rc;
rc = aaaaa1aaaaaaaaaaaabaaaaaaaaaaa3aaaaaaaaaaaaaaaabaaaaaaaaaaaaaaaaaaaaaaaaaaaa3aaaaaaaaaaaaaaaabaaaaaaaaaaaaaaaaaaa4aaaaaaaaaaaaaaaabaaaaaaaaaaaaaaaaaaaaaaaaaaaa4bbbbbbbbbbbbbbbbbbbbbbbbbbbbbbbbb4aaa(magg, me, collset);
if (rc)
return rc;
if (collset->entry_ids.num_entries < magg->max_num_collisions)
mes->weight -= aaaaa1bbbbbbbbbbbbbbbbbbbbbbbbbbbbbbbbb3aaaaaaaaaaaaaaaabaaaaaaaaaaaaaaaaaaaaaaaaaaaa4aaaWEIGHT;
if (collset->entry_ids.num_entries == 0) {
cam_free_func free_function = a1aaaaaaaaaaaaaaaabaaaaaaaaaaaa3aaaaaaaaaaaaaaaabaaaaaaaaaaaaaaaaaaaaaaaaaaaa3aaaaaaaaaaaaaabaaaaaaaaaaaa4aaaaaaaaaaaaaaaabaaaaaaaaaaaaaaaaaaaaaaaaaaaa4aaaaaaaaaaaaaaaabaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaa4aaa((a1aaat*) (magg->client));
rc = aaaaa1aaaaaaaaaaaabaaaaaaaaaaa3bbbbbbbbbbbbbbbbbb3aaaaaaaaaaaaaaaabaaaaaaaaaaaaaaaaaaaaaaaaaaaa4aaaaaaaaaaaaaaaabaaaaaaaaaaaaaaaaaaa5aaaaaaaaaaaaaaaabaaaaaaaaaaaaaaaaaaaaaaaaaaaa5bbbbbbbbbbbbbbbbbbbbbbbbbbbbbbbbb5aaa(magg, mes, collset, free_function);
if (rc)
return rc;
}
aaaaa1aaaaaaaaaaaabaaaaaaaaaaa3bbbbbbbbbbbbbbbbbb3aaaaaaaaaaaaaaaabaaaaaaaaaaaaaaaaaaaaaaaaaaaa4aaamember_delete(magg, mes, me);
return 0;
}
int
aaaaa1aaaaaaaaaaaabaaaaaaaaaaa3bbbbbbbbbbbbbbbbbb3aaaaaaaaaaaaaaaabaaaaaaaaaaaaaaaaaaaaaaaaaaaa4bbbbbbbbbbbbbbbbbbbbbbbbbbbbbbbb4aaaaaaaaaaaaaaaabaaaaaaaaaaaaaaaaaaaaaaaaaaaa5aaaopen(struct tcam *magg, struct aaaaa1aaaaaaaaaaaaaaaabaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaa3aaa *problem,
struct aaaaa1aaaaaaaaaaaabaaaaaaaaaaa3aaa *me)
{
int rc;
struct aaaaa1aaaaaaaaaaaabaaaaaaaaaaa3bbbbbbbbbbbbbbbbbb3aaa *mes = NULL;
assert(me->mask_by_mask);
struct aaaaa1aaaaaaaaaaaaaaaabaaaaaaaaaaaaaaaaaaaaaaa3aaaaaaaaaaaaaaaabaaaaaaaaaaaaaaaaaaaaaaaaaaaa3aaaaaaaaaaaabaaaaaaaaaa4aaa *mfh, *mfh_tmp;
MH_ITER(mh_handle, me->mask_by_mask, mfh, mfh_tmp)
{
struct aaaaa1aaaaaaaaaaaaaaaabaaaaaaaaaaaaaaaaaaaaaaa3aaa *mask = &mfh->mask;
MH_FIND(mh_handle, problem->entryset_by_mask, mask, sizeof(*mask), mes);
if (mes == 0) {
rc = aaaaa1aaaaaaaaaaaabaaaaaaaaaaa3bbbbbbbbbbbbbbbbbb3aaaaaaaaaaaaaaaabaaaaaaaaaaaaaaaaaaaaaaaaaaaa4bbbbbbbbbbbbbbbbbbbbbbbbbbbbbbbbbbbbbbb4aaaeate(magg, problem, mask, &mes);
if (rc)
return rc;
}
rc = aaaaa1aaaaaaaaaaaabaaaaaaaaaaa3bbbbbbbbbbbbbbbbbb3aaaaaaaaaaaaaaaabaaaaaaaaaaaaaaaaaaaaaaaaaaaa4bbbbbbbbbbbbbbbbbbbbbbbbbbbbbbbb4aaa(magg, problem, mes, me);
if (rc)
return rc;
}
return 0;
}
int
aaaaa1aaaaaaaaaaaabaaaaaaaaaaa3bbbbbbbbbbbbbbbbbb3aaaaaaaaaaaaaaaabaaaaaaaaaaaaaaaaaaaaaaaaaaaa4bbbbbbbbbbbbbbbbbbbbbbbbbbbbbbbb4aaaaaaaaaaaaaaaabaaaaaaaaaaaaaaaaaaaaaaaaaaaa5aaasolved(struct tcam *magg, struct aaaaa1aaaaaaaaaaaaaaaabaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaa3aaa *problem,
struct aaaaa1aaaaaaaaaaaabaaaaaaaaaaa3aaa *me)
{
int rc;
struct aaaaa1aaaaaaaaaaaabaaaaaaaaaaa3bbbbbbbbbbbbbbbbbb3aaa *mes = NULL;
assert(me->mask_by_mask);
struct aaaaa1aaaaaaaaaaaaaaaabaaaaaaaaaaaaaaaaaaaaaaa3aaaaaaaaaaaaaaaabaaaaaaaaaaaaaaaaaaaaaaaaaaaa3aaaaaaaaaaaabaaaaaaaaaa4aaa *mfh, *mfh_tmp;
MH_ITER(mh_handle, me->mask_by_mask, mfh, mfh_tmp)
{
struct aaaaa1aaaaaaaaaaaaaaaabaaaaaaaaaaaaaaaaaaaaaaa3aaa *mask = &mfh->mask;
MH_FIND(mh_handle, problem->entryset_by_mask, mask, sizeof(*mask), mes);
if (mes == 0)
continue;
rc = aaaaa1aaaaaaaaaaaabaaaaaaaaaaa3bbbbbbbbbbbbbbbbbb3aaaaaaaaaaaaaaaabaaaaaaaaaaaaaaaaaaaaaaaaaaaa4bbbbbbbbbbbbbbbbbbbbbbbbbbbbbbbb4aaa(magg, problem, mes, me);
if (rc == -1)
continue;
if (rc)
return rc;
return 0;
}
return -1;
}
int
aaaaa1aaaaaaaaaaaabaaaaaaaaaaa3bbbbbbbbbbbbbbbbbb3aaaaaaaaaaaaaaaabaaaaaaaaaaaaaaaaaaaaaaaaaaaa4aaaaaaaaaaaaaaaabaaaaaaaaaaaaaaaaaaa5aaaaaaaaaaaaaaaabaaaaaaaaaaaaaaaaaaaaaaaaaaaa5aaasolved(struct tcam *magg, struct aaaaa1aaaaaaaaaaaaaaaabaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaa3aaa *problem,
struct aaaaa1aaaaaaaaaaaabaaaaaaaaaaa3aaa *me)
{
int rc;
struct aaaaa1aaaaaaaaaaaabaaaaaaaaaaa3bbbbbbbbbbbbbbbbbb3aaa *mes;
mes = me->current_entryset.mes;
rc = aaaaa1aaaaaaaaaaaabaaaaaaaaaaa3bbbbbbbbbbbbbbbbbb3aaaaaaaaaaaaaaaabaaaaaaaaaaaaaaaaaaaaaaaaaaaa4aaaaaaaaaaaaaaaabaaaaaaaaaaaaaaaaaaa5aaa(magg, problem, mes, me);
if (rc)
return rc;
if (mes->num_entries == 0) {
rc = aaaaa1aaaaaaaaaaaabaaaaaaaaaaa3bbbbbbbbbbbbbbbbbb3aaaaaaaaaaaaaaaabaaaaaaaaaaaaaaaaaaaaaaaaaaaa4aaaaaaaaaaaaaaaabaaaaaaaaaaaaaaaaaaaaaaaaa5aaa(magg, problem, mes);
if (rc)
return rc;
}
return 0;
}
int
aaaaa1aaaaaaaaaaaabaaaaaaaaaaa3bbbbbbbbbbbbbbbbbb3aaaaaaaaaaaaaaaabaaaaaaaaaaaaaaaaaaaaaaaaaaaa4aaaaaaaaaaaaaaaabaaaaaaaaaaaaaaaaaaa5aaaaaaaaaaaaaaaabaaaaaaaaaaaaaaaaaaaaaaaaaaaa5aaaopen(struct tcam *magg, struct aaaaa1aaaaaaaaaaaaaaaabaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaa3aaa *problem,
struct aaaaa1aaaaaaaaaaaabaaaaaaaaaaa3aaa *me)
{
int rc;
struct aaaaa1aaaaaaaaaaaabaaaaaaaaaaa3bbbbbbbbbbbbbbbbbb3aaa *mes = NULL;
struct aaaaa1aaaaaaaaaaaaaaaabaaaaaaaaaaaaaaaaaaaaaaa3aaa *mask;
rc = aaaaa1aaaaaaaaaaaaaaaabaaaaaaaaaaaaaaaaaaaaaaa3aaaaaaaaaaaaaaaabaaaaaaaaaaaaaaaaaaaaaaaaaaaa3bbbbbbbbbbbbbbbbbbbbbbbbbbbbbbbbbbbbbbb3aaaeate_hash(magg, me);
if (rc)
return rc;
struct aaaaa1aaaaaaaaaaaaaaaabaaaaaaaaaaaaaaaaaaaaaaa3aaaaaaaaaaaaaaaabaaaaaaaaaaaaaaaaaaaaaaaaaaaa3aaaaaaaaaaaabaaaaaaaaaa4aaa *mfh, *mfh_tmp;
MH_ITER(mh_handle, me->mask_by_mask, mfh, mfh_tmp)
{
mask = &mfh->mask;
MH_FIND(mh_handle, problem->entryset_by_mask, mask, sizeof(*mask), mes);
if (mes == NULL || !aaaaa1aaaaaaaaaaaabaaaaaaaaaaa3bbbbbbbbbbbbbbbbbb3aaaaaaaaaaaaaaaabaaaaaaaaaaaaaaaaaaaaaaaaaaaa4aaaaaaaaaaaaaaabaaaaaaaaaaaa5aaaaaaaaaaaaaaaabaaaaaaaaaaaaaaaaaaaaaaaaaaaa5aaamember(magg, mes, me))
continue;
rc = aaaaa1aaaaaaaaaaaabaaaaaaaaaaa3bbbbbbbbbbbbbbbbbb3aaaaaaaaaaaaaaaabaaaaaaaaaaaaaaaaaaaaaaaaaaaa4aaaaaaaaaaaaaaaabaaaaaaaaaaaaaaaaaaa5aaa(magg, problem, mes, me);
if (rc)
goto error;
if (mes->num_entries == 0) {
rc = aaaaa1aaaaaaaaaaaabaaaaaaaaaaa3bbbbbbbbbbbbbbbbbb3aaaaaaaaaaaaaaaabaaaaaaaaaaaaaaaaaaaaaaaaaaaa4aaaaaaaaaaaaaaaabaaaaaaaaaaaaaaaaaaaaaaaaa5aaa(magg, problem, mes);
if (rc)
goto error;
}
}
error:
(void) aaaaa1aaaaaaaaaaaaaaaabaaaaaaaaaaaaaaaaaaaaaaa3aaaaaaaaaaaaaaaabaaaaaaaaaaaaaaaaaaaaaaaaaaaa3aaaaaaaaaaaaaaaabaaaaaaaaaaaaaaaaaaaaaaaaa4aaaaaaaaaaaaaaaabaaaaaaaaaaaaaaaaaaaaaaaaaaaa4aaaaaaaaaaaabaaaaaaaaaa5aaa(magg, me);
return 0;
}
int aaaaa1aaaaaaaaaaaabaaaaaaaaaaa3bbbbbbbbbbbbbbbbbb3aaaaaaaaaaaaaaaabaaaaaaaaaaaaaaaaaaaaaaaaaaaa4aaapopulate(struct tcam *magg, struct aaaaa1aaaaaaaaaaaabaaaaaaaaaaa3bbbbbbbbbbbbbbbbbb3aaa *mes, struct aaaaa1aaaaaaaaaaaabaaaaaaaaaaa3bbbbbbbbbbbbbbbbbb3aaaaaaaaaaaaaaaabaaaaaaaaaaaaaaaaaaaaaaaaaaaa4aaaaaaaaaaaaabaaaaaaaaaaaaaaaaa5aaa *mesli,
uint16_t * num_populated)
{
int bucket;
struct aaaaa1aaaaaaaaaaaabaaaaaaaaaaa3aaa *me;
struct aaaaa1bbbbbbbbbbbbbbbbbbbbbbbbbbbbbbbbb3aaa *collset;
struct aaaaa1aaaaaaaaaaaabaaaaaaaaaaa3aaaaaaaaaaaaaaaabaaaaaaaaaaaaaaaaaaaaaaaaaaaa3aaaaaaaaaaaaabaaaaaaaaaaaaaaaaa4aaa *meli;
struct aaaaa1aaaaaaaaaaaabaaaaaaaaaaa3aaa *best_me;
struct aaaaa1bbbbbbbbbbbbbbbbbbbbbbbbbbbbbbbbb3aaa *best_collset;
cam_calloc_func calloc_function = a1aaaaaaaaaaaaaaaabaaaaaaaaaaaa3aaaaaaaaaaaaaaaabaaaaaaaaaaaaaaaaaaaaaaaaaaaa3aaacalloc_function((a1aaat*) (magg->client));
*num_populated = 0;
for (bucket = 0; bucket < aaaaa1aaaaaaaaaaaabaaaaaaaaaa3aaaaaaaaaaaaaaaabaaaaaaaaaaaaaaaaaaaaaaaaaaaa3aaaaaaaaaaaaaaabaaaaaaaaaaaaaaaa4aaaaaaaaaaaaaaaabaaaaaaaaaaaaaaaaaaaaaaaaaaaa4aaaaaaaaaabaaaaaaaaaaa5aaaS; bucket++) {
if (mes->collset_by_key.buckets[bucket] == NULL)
continue;
LIST_FOREACH(mes->collset_by_key.buckets[bucket], collset)
{
collset->num_populated = 0;
}
}
while(true) {
uint32_t best_score = UINT32_MAX;
bool winner_found = false;
bool perfect_winner = false;
for (bucket = 0; bucket < aaaaa1aaaaaaaaaaaabaaaaaaaaaa3aaaaaaaaaaaaaaaabaaaaaaaaaaaaaaaaaaaaaaaaaaaa3aaaaaaaaaaaaaaabaaaaaaaaaaaaaaaa4aaaaaaaaaaaaaaaabaaaaaaaaaaaaaaaaaaaaaaaaaaaa4aaaaaaaaaabaaaaaaaaaaa5aaaS; bucket++) {
if (mes->collset_by_key.buckets[bucket] == NULL)
continue;
LIST_FOREACH(mes->collset_by_key.buckets[bucket], collset)
{
int i;
if (collset->num_populated >= 1)
continue;
uint16_t id;
for (i = 0; i < collset->entry_ids.num_entries; i++) {
id = collset->entry_ids.data[i].id;
me = magg->entries[id];
assert(me);
if (me->allocated)
continue;
if (me->num_collsets < best_score) {
winner_found = true;
best_score = me->num_collsets;
best_me = me;
best_collset = collset;
}
if (me->num_collsets == 1) {
perfect_winner = true;
break;
}
}
if (perfect_winner) {
break;
}
}
if (perfect_winner) {
break;
}
}
if (winner_found) {
best_me->next_entryset.collset = best_collset;
best_me->next_entryset.mes = mesli->entryset;
best_me->next_entryset.instance = mesli->instance;
best_me->allocated = 1;
best_collset->num_populated++;
meli = calloc_function(1, sizeof(*meli));
if (meli == NULL)
return CAM_ERROR_NOMEM;
meli->entry = best_me;
LIST_PREPEND2(mesli->entry_list, meli, next);
(*num_populated)++;
if (*num_populated == a1aaaaaaaaaaaaaaaabaaaaaaaaaaaa3aaaaaaaaaaaaaaaabaaaaaaaaaaaaaaaaaaaaaaaaaaaa3aaaaaaaaaaaaaaabaaaaaaaaaaaaaaaa4aaaaaaaaaaaaaaaabaaaaaaaaaaaaaaaaaaaaaaaaaaaa4aaaaaaaaaaaaaaaabaaaaaaaaaaaaaaaaaaaaa5aaaaaaaaaaaaaaaabaaaaaaaaaaaaaaaaaaaaaaaaaaaa5aaaper_unit(magg->client))
return 0;
} else {
break;
}
}
return 0;
}
int
aaaaa1aaaaaaaaaaaabaaaaaaaaaaa3bbbbbbbbbbbbbbbbbb3aaaaaaaaaaaaaaaabaaaaaaaaaaaaaaaaaaaaaaaaaaaa4aaareset(struct tcam *magg, struct aaaaa1aaaaaaaaaaaabaaaaaaaaaaa3bbbbbbbbbbbbbbbbbb3aaa *mes)
{
(void) magg;
int i;
struct aaaaa1bbbbbbbbbbbbbbbbbbbbbbbbbbbbbbbbb3aaa *collset;
mes->remaining_entries = mes->num_entries;
mes->remaining_weight = mes->weight;
for (i = 0; i < aaaaa1aaaaaaaaaaaabaaaaaaaaaa3aaaaaaaaaaaaaaaabaaaaaaaaaaaaaaaaaaaaaaaaaaaa3aaaaaaaaaaaaaaabaaaaaaaaaaaaaaaa4aaaaaaaaaaaaaaaabaaaaaaaaaaaaaaaaaaaaaaaaaaaa4aaaaaaaaaabaaaaaaaaaaa5aaaS; i++) {
if (mes->collset_by_key.buckets[i] == NULL)
continue;
LIST_FOREACH(mes->collset_by_key.buckets[i], collset)
collset->remaining_entries = collset->entry_ids.num_entries;
}
return 0;
}
int
aaaaa1aaaaaaaaaaaabaaaaaaaaaaa3bbbbbbbbbbbbbbbbbb3aaaaaaaaaaaaaaaabaaaaaaaaaaaaaaaaaaaaaaaaaaaa4aaaaaaaaaaaaaaaabaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaa4aaa(struct tcam *magg, struct aaaaa1aaaaaaaaaaaabaaaaaaaaaaa3bbbbbbbbbbbbbbbbbb3aaa *mes, int indent)
{
   printf("%*caaaaa1aaaaaaaaaaaabaaaaaaaaaaa3bbbbbbbbbbbbbbbbbb3aaa %p num_entries %u weight %u max pop %u active fields %u\n", indent, ' ',
mes, mes->num_entries, mes->weight, mes->mask.max_pop,
__builtin_popcount(mes->mask.active_fields));
aaaaa1aaaaaaaaaaaaaaaabaaaaaaaaaaaaaaaaaaaaaaa3aaaaaaaaaaaaaaaabaaaaaaaaaaaaaaaaaaaaaaaaaaaa3aaaaaaaaaaaaaaaabaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaa3aaa(magg, &mes->mask, indent + 2);
if (magg->debug_mask & aaaaa1aaaaaaaaaaaaaaaabaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaa3aaaaaaaaaaaaaaaabaaaaaaaaaaaaaaaaaaaaaaaaaaaa4bbbbbbbbbbbbbbbbbbbbbbbbbbbbbbbbb4aaa) {
int i;
for (i = 0; i < aaaaa1aaaaaaaaaaaabaaaaaaaaaa3aaaaaaaaaaaaaaaabaaaaaaaaaaaaaaaaaaaaaaaaaaaa3aaaaaaaaaaaaaaabaaaaaaaaaaaaaaaa4aaaaaaaaaaaaaaaabaaaaaaaaaaaaaaaaaaaaaaaaaaaa4aaaaaaaaaabaaaaaaaaaaa5aaaS; i++) {
struct aaaaa1bbbbbbbbbbbbbbbbbbbbbbbbbbbbbbbbb3aaa *collset;
LIST_FOREACH(mes->collset_by_key.buckets[i], collset)
aaaaa1bbbbbbbbbbbbbbbbbbbbbbbbbbbbbbbbb3aaaaaaaaaaaaaaaabaaaaaaaaaaaaaaaaaaaaaaaaaaaa4aaaaaaaaaaaaaaaabaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaa4aaa(magg, collset, indent + 2);
}
}
return 0;
}
int
aaaaa1aaaaaaaaaaaabaaaaaaaaaa3aaaaaaaaaaaaaaaabaaaaaaaaaaaaaaaaaaaaaaaaaaaa3bbbbbbbbbbbbbbbbbbbbbbbbbbbbbbbb3aaa(struct tcam *magg, struct aaaaa1aaaaaaaaaaaabaaaaaaaaaaa3bbbbbbbbbbbbbbbbbb3aaa *mes,
struct aaaaa1bbbbbbbbbbbbbbbbbbbbbbbbbbbbbbbbb3aaa *collset)
{
uint32_t index, hash_tmp;
murmur3_bucket(&collset->relax_key, sizeof(aaaaaaaaaaaaa1aaat), aaaaa1aaaaaaaaaaaabaaaaaaaaaa3aaaaaaaaaaaaaaaabaaaaaaaaaaaaaaaaaaaaaaaaaaaa3aaaaaaaaaaaaaaabaaaaaaaaaaaaaaaa4aaaaaaaaaaaaaaaabaaaaaaaaaaaaaaaaaaaaaaaaaaaa4aaaaaaaaaabaaaaaaaaaaa5aaaS, &hash_tmp, &index);
LIST_PREPEND(mes->collset_by_key.buckets[index], collset);
return 0;
}
int
aaaaa1aaaaaaaaaaaabaaaaaaaaaa3aaaaaaaaaaaaaaaabaaaaaaaaaaaaaaaaaaaaaaaaaaaa3aaafind(struct tcam *magg, struct aaaaa1aaaaaaaaaaaabaaaaaaaaaaa3bbbbbbbbbbbbbbbbbb3aaa *mes,
aaaaaaaaaaaaa1aaat *relax_key,
struct aaaaa1bbbbbbbbbbbbbbbbbbbbbbbbbbbbbbbbb3aaa **out_collset)
{
uint32_t index, hash_tmp;
struct aaaaa1bbbbbbbbbbbbbbbbbbbbbbbbbbbbbbbbb3aaa *collset;
murmur3_bucket(relax_key, sizeof(aaaaaaaaaaaaa1aaat), aaaaa1aaaaaaaaaaaabaaaaaaaaaa3aaaaaaaaaaaaaaaabaaaaaaaaaaaaaaaaaaaaaaaaaaaa3aaaaaaaaaaaaaaabaaaaaaaaaaaaaaaa4aaaaaaaaaaaaaaaabaaaaaaaaaaaaaaaaaaaaaaaaaaaa4aaaaaaaaaabaaaaaaaaaaa5aaaS, &hash_tmp, &index);
LIST_FOREACH(mes->collset_by_key.buckets[index], collset)
{
if (memcmp(&collset->relax_key, relax_key, sizeof(aaaaaaaaaaaaa1aaat)) == 0) {
*out_collset = collset;
return 0;
}
}
*out_collset = NULL;
return -1;
}
int
aaaaa1aaaaaaaaaaaabaaaaaaaaaa3aaaaaaaaaaaaaaaabaaaaaaaaaaaaaaaaaaaaaaaaaaaa3aaaaaaaaaaaaaaaabaaaaaaaaaaaaaaaaaaa4aaa(struct tcam *magg, struct aaaaa1aaaaaaaaaaaabaaaaaaaaaaa3bbbbbbbbbbbbbbbbbb3aaa *mes,
struct aaaaa1bbbbbbbbbbbbbbbbbbbbbbbbbbbbbbbbb3aaa *collset)
{
uint32_t index, hash_tmp;
murmur3_bucket(&collset->relax_key, sizeof(aaaaaaaaaaaaa1aaat), aaaaa1aaaaaaaaaaaabaaaaaaaaaa3aaaaaaaaaaaaaaaabaaaaaaaaaaaaaaaaaaaaaaaaaaaa3aaaaaaaaaaaaaaabaaaaaaaaaaaaaaaa4aaaaaaaaaaaaaaaabaaaaaaaaaaaaaaaaaaaaaaaaaaaa4aaaaaaaaaabaaaaaaaaaaa5aaaS, &hash_tmp, &index);
LIST_DELETE(mes->collset_by_key.buckets[index], collset);
return 0;
}
int
aaaaa1aaaaaaaaaaaaaaaabaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaa3aaaaaaaaaaaaaaaabaaaaaaaaaaaaaaaaaaaaaaaaaaaa4bbbbbbbbbbbbbbbbbbbbbbbbbbbbbbbb4aaa(struct tcam *magg, struct aaaaa1aaaaaaaaaaaabaaaaaaaaaaa3aaa *me,
struct aaaaa1aaaaaaaaaaaabaaaaaaaaaaa3bbbbbbbbbbbbbbbbbb3aaa *mes,
uint8_t mes_instance,
struct aaaaa1bbbbbbbbbbbbbbbbbbbbbbbbbbbbbbbbb3aaa *collset)
{
int rc;
aaaaaaaaaaaaa1aaat key;
aaaaaaaaaaaaa1aaat mask;
aaaaaaaaaaaaa1aaat ternary_mask;
memset(&key, 0, sizeof(key));
memset(&mask, 0, sizeof(mask));
memset(&ternary_mask, 0, sizeof(ternary_mask));
memcpy(&key, &me->exact_key.word[0], sizeof(aaaaaaaaaaaaa1aaat));
memcpy(&mask, &mes->mask.mask.word[0], sizeof(aaaaaaaaaaaaa1aaat));
memcpy(&ternary_mask, &me->exact_mask.mask.word[0],
sizeof(aaaaaaaaaaaaa1aaat));
const uint8_t num_fields = a1aaaaaaaaaaaaaaaabaaaaaaaaaaaa3aaaaaaaaaaaaaaaabaaaaaaaaaaaaaaaaaaaaaaaaaaaa3aaaaaaaaaaaaaaabaaaaaaaaaaaaaaaa4aaaaaaaaaaaaaaaabaaaaaaaaaaaaaaaaaaaaaaaaaaaa4aaaaaaaaaaaaaaabaaaaaaaaaaaaaaaaaa5aaas(magg->client);
int field;
for (field = 0; field < num_fields; field++) {
aaaaaaaaaaa1aaaaaaaaaaaaaaaabaaaaaaaaaaaaaaaaaaaaaaaaaaaa3aaadesc mfd;
rc = a1aaaaaaaaaaaaaaaabaaaaaaaaaaaa3aaaaaaaaaaaaaaaabaaaaaaaaaaaaaaaaaaaaaaaaaaaa3aaaaaaaaaaaaaaaaaaaaa1aaa(magg->client, field, &mfd);
assert(rc == 0);
if (mfd.type != aaaaaaaaaaa1aaaaaaaaaaaaaaaabaaaaaaaaaaaaaaaaaaaaaaaaaaaa3aaaR16 ||
(me->exact_mask.use_range &
1 << mfd.instance) == 0)
continue;
if (mes->mask.use_range & 1 << mfd.instance)
aaaaa1aaaaaaaaaaaaaaaabaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaa3aaaaaaaaaaaaaaaabaaaaaaaaaaaaaaaaaaaaaaaaaaaa4bbbbbbbbbbbbbbbb4aaaaaaaaaaaaaaaabaaaaaaaaaaaaaaaaaaaaaaaaaaaa5aaauint2bit((uint8_t *) &ternary_mask.word[0],
sizeof(aaaaaaaaaaaaa1aaat),
mfd.start_pos,
(uint8_t *) &me->fields[field].r16.end,
mfd.len);
else
aaaaa1aaaaaaaaaaaaaaaabaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaa3aaaaaaaaaaaaaaaabaaaaaaaaaaaaaaaaaaaaaaaaaaaa4bbbbbbbbbbbbbbbbbb4aaaaaaaaaaaaaaaabaaaaaaaaaaaaaaaaaaaaaaaaaaaa5aaabits((uint8_t *) &ternary_mask.word[0],
sizeof(aaaaaaaaaaaaa1aaat),
mfd.start_pos, mfd.len);
}
if (magg->debug_mask & aaaaa1bbbbbbbbbbbbbbbbbbbbbbbbbbbbbbbbbbbbb3aaaaaaaaaaaaaaaabaaaaaaaaaaaaaaaaaaaaaaaaaaaa4aaaaaaaaaaaaaaaabaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaa4aaa) {
int i;
       printf("A %05u %p %3u %x %u %u %u %p %x:\n", me->priority.word[0],
mes, mes_instance,
aaaaa1aaaaaaaaaaaaaaaabaaaaaaaaaaaaaaaaaaaaaaa3aaaaaaaaaaaaaaaabaaaaaaaaaaaaaaaaaaaaaaaaaaaa3aaaaaaaaaaaabaaaaaaaaaa4aaaaaaaaaaaaaaaabaaaaaaaaaaaaaaaaaaaaaaaaaaaa4aaavalue(&mes->mask), magg->num_masks,
mes->mask.max_pop, __builtin_popcount(mes->mask.active_fields),
collset, mes->mask.use_range);
       printf("  K ");
for (i = 0; i < sizeof(aaaaaaaaaaaaa1aaat); i++)
           printf("%02x ", *(((char *) &key) + i) & 0xff);
       printf("\n  M ");
for (i = 0; i < sizeof(aaaaaaaaaaaaa1aaat); i++)
           printf("%02x ", *(((char *) &mask) + i) & 0xff);
       printf("\n  T ");
for (i = 0; i < sizeof(aaaaaaaaaaaaa1aaat); i++)
           printf("%02x ", *(((char *) &ternary_mask) + i) & 0xff);
       printf("\n");
}
#ifdef aaaaa1aaaaaaaaaaaaaaaabaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaa3aaaaaaaaaaaaaaaabaaaaaaaaaaaaaaaaaaaaaaaaaaaa4aaaERROR_INSERT
int err = random() & 0x3ff;
if (err == 0) {
rc = -1;
if (magg->debug_mask & aaaaa1bbbbbbbbbbbbbbbbbbbbbbbbbbbbbbbbbbbbb3aaaaaaaaaaaaaaaabaaaaaaaaaaaaaaaaaaaaaaaaaaaa4aaaaaaaaaaaaaaaabaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaa4aaa)
           printf("%d\n", rc);
return rc;
}
#endif
rc = a1bbbbbbbbbbbbbbbbbbbb3aaaaaaaaaaaaaaaabaaaaaaaaaaaaaaaaaaaaaaaaaaaa4aaaaaaaaaaaaaaaabaaaaaaaaaaaaaaaaaaaa5aaaaaaaaaaaaaaaabaaaaaaaaaaaaaaaaaaaaaaaaaaaa5aaaaaaaaaaaaaaaabaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaa5aaa(magg->client, &key, &ternary_mask, &me->priority,
&mask, mes->mask.use_range, mes_instance);
if (rc == 0) {
me->current_entryset.mes = mes;
me->current_entryset.instance = mes_instance;
me->current_entryset.collset = collset;
return 0;
}
if (rc == CAM_ERROR_DUPLICATE_FOUND)
return rc;
assert(false);
return rc; 
}
int
aaaaa1aaaaaaaaaaaaaaaabaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaa3aaaaaaaaaaaaaaaabaaaaaaaaaaaaaaaaaaaaaaaaaaaa4aaaaaaaaaaaaaaaabaaaaaaaaaaaaaaaaaaa5aaa(struct tcam *magg, struct aaaaa1aaaaaaaaaaaabaaaaaaaaaaa3aaa *me,
struct aaaaa1aaaaaaaaaaaabaaaaaaaaaaa3bbbbbbbbbbbbbbbbbb3aaa *mes, uint8_t mes_instance)
{
int rc;
aaaaaaaaaaaaa1aaat key;
aaaaaaaaaaaaa1aaat mask;
aaaaaaaaaaaaa1aaat ternary_mask;
memset(&key, 0, sizeof(key));
memset(&mask, 0, sizeof(mask));
memset(&ternary_mask, 0, sizeof(ternary_mask));
memcpy(&key, &me->exact_key.word[0], sizeof(aaaaaaaaaaaaa1aaat));
memcpy(&mask, &mes->mask.mask.word[0], sizeof(aaaaaaaaaaaaa1aaat));
memcpy(&ternary_mask, &me->exact_mask.mask.word[0],
sizeof(aaaaaaaaaaaaa1aaat));
const uint8_t num_fields = a1aaaaaaaaaaaaaaaabaaaaaaaaaaaa3aaaaaaaaaaaaaaaabaaaaaaaaaaaaaaaaaaaaaaaaaaaa3aaaaaaaaaaaaaaabaaaaaaaaaaaaaaaa4aaaaaaaaaaaaaaaabaaaaaaaaaaaaaaaaaaaaaaaaaaaa4aaaaaaaaaaaaaaabaaaaaaaaaaaaaaaaaa5aaas(magg->client);
int field;
for (field = 0; field < num_fields; field++) {
aaaaaaaaaaa1aaaaaaaaaaaaaaaabaaaaaaaaaaaaaaaaaaaaaaaaaaaa3aaadesc mfd;
rc = a1aaaaaaaaaaaaaaaabaaaaaaaaaaaa3aaaaaaaaaaaaaaaabaaaaaaaaaaaaaaaaaaaaaaaaaaaa3aaaaaaaaaaaaaaaaaaaaa1aaa(magg->client, field, &mfd);
assert(rc == 0);
if (mfd.type != aaaaaaaaaaa1aaaaaaaaaaaaaaaabaaaaaaaaaaaaaaaaaaaaaaaaaaaa3aaaR16 ||
(me->exact_mask.use_range &
1 << mfd.instance) == 0)
continue;
if (mes->mask.use_range & 1 << mfd.instance)
aaaaa1aaaaaaaaaaaaaaaabaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaa3aaaaaaaaaaaaaaaabaaaaaaaaaaaaaaaaaaaaaaaaaaaa4bbbbbbbbbbbbbbbb4aaaaaaaaaaaaaaaabaaaaaaaaaaaaaaaaaaaaaaaaaaaa5aaauint2bit((uint8_t *) &ternary_mask.word[0],
sizeof(aaaaaaaaaaaaa1aaat),
mfd.start_pos,
(uint8_t *) &me->fields[field].r16.end,
mfd.len);
else
aaaaa1aaaaaaaaaaaaaaaabaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaa3aaaaaaaaaaaaaaaabaaaaaaaaaaaaaaaaaaaaaaaaaaaa4bbbbbbbbbbbbbbbbbb4aaaaaaaaaaaaaaaabaaaaaaaaaaaaaaaaaaaaaaaaaaaa5aaabits((uint8_t *) &ternary_mask.word[0],
sizeof(aaaaaaaaaaaaa1aaat),
mfd.start_pos, mfd.len);
}
if (magg->debug_mask & aaaaa1bbbbbbbbbbbbbbbbbbbbbbbbbbbbbbbbbbbbb3aaaaaaaaaaaaaaaabaaaaaaaaaaaaaaaaaaaaaaaaaaaa4aaaaaaaaaaaaaaaabaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaa4aaa) {
int i;
       printf("D %05u %p %3u %x %u %u %u %x:\n", me->priority.word[0],
mes, mes_instance,
aaaaa1aaaaaaaaaaaaaaaabaaaaaaaaaaaaaaaaaaaaaaa3aaaaaaaaaaaaaaaabaaaaaaaaaaaaaaaaaaaaaaaaaaaa3aaaaaaaaaaaabaaaaaaaaaa4aaaaaaaaaaaaaaaabaaaaaaaaaaaaaaaaaaaaaaaaaaaa4aaavalue(&mes->mask), magg->num_masks,
mes->mask.max_pop, __builtin_popcount(mes->mask.active_fields),
mes->mask.use_range);
       printf("  K ");
for (i = 0; i < sizeof(aaaaaaaaaaaaa1aaat); i++)
           printf("%02x ", *(((char *) &key) + i) & 0xff);
       printf("\n  M ");
for (i = 0; i < sizeof(aaaaaaaaaaaaa1aaat); i++)
           printf("%02x ", *(((char *) &mask) + i) & 0xff);
       printf("\n  T ");
for (i = 0; i < sizeof(aaaaaaaaaaaaa1aaat); i++)
           printf("%02x ", *(((char *) &ternary_mask) + i) & 0xff);
       printf("\n");
}
#ifdef aaaaa1aaaaaaaaaaaaaaaabaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaa3aaaaaaaaaaaaaaaabaaaaaaaaaaaaaaaaaaaaaaaaaaaa4aaaERROR_INSERT
int err = random() & 0x3ff;
if (err == 0) {
rc = -1;
if (magg->debug_mask & aaaaa1bbbbbbbbbbbbbbbbbbbbbbbbbbbbbbbbbbbbb3aaaaaaaaaaaaaaaabaaaaaaaaaaaaaaaaaaaaaaaaaaaa4aaaaaaaaaaaaaaaabaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaa4aaa)
           printf("%d\n", rc);
return rc;
}
#endif
rc = a1aaaaaaaaaaaaaaaabaaaaaaaaaaaaaaaaaaa3aaaaaaaaaaaaaaaabaaaaaaaaaaaaaaaaaaaaaaaaaaaa3aaaaaaaaaaaaaaaabaaaaaaaaaaaaaaaaaaaa4aaaaaaaaaaaaaaaabaaaaaaaaaaaaaaaaaaaaaaaaaaaa4aaaaaaaaaaaaaaaabaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaa4aaa(magg->client, &key, &ternary_mask, &mask,
mes->mask.use_range, mes_instance);
if (rc == 0)
return 0;
assert(false);
return rc; 
}
static int
aaaaa1aaaaaaaaaaaaaaaabaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaa3aaaaaaaaaaaaaaaabaaaaaaaaaaaaaaaaaaaaaaaaaaaa4aaatest_prefix(struct tcam *magg, struct aaaaa1aaaaaaaaaaaabaaaaaaaaaaa3aaa *me, uint8_t index)
{
struct aaaaaaaaaaa1aaaaaaaaaaaaaaaabaaaaaaaaaaaaaaaaaaaaaaaaaaaa3aaab128 b128;
memset(&b128, 0, sizeof(b128));
aaaaaaaaaaa1aaaaaaaaaaaaaaaabaaaaaaaaaaaaaaaaaaaaaaaaaaaa3aaadesc mfd;
int rc = a1aaaaaaaaaaaaaaaabaaaaaaaaaaaa3aaaaaaaaaaaaaaaabaaaaaaaaaaaaaaaaaaaaaaaaaaaa3aaaaaaaaaaaaaaaaaaaaa1aaa(magg->client, index, &mfd);
assert(rc == 0);
aaaaa1aaaaaaaaaaaaaaaabaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaa3aaaaaaaaaaaaaaaabaaaaaaaaaaaaaaaaaaaaaaaaaaaa4bbbbbbbbbbbbbbbb4aaaaaaaaaaaaaaaabaaaaaaaaaaaaaaaaaaaaaaaaaaaa5aaauint2bit(&b128.key[0], sizeof(aaaaaaaaaaaaa1aaat), 0,
&me->fields[index].p128.key[0],
mfd.len);
aaaaa1aaaaaaaaaaaaaaaabaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaa3aaaaaaaaaaaaaaaabaaaaaaaaaaaaaaaaaaaaaaaaaaaa4bbbbbbbbbbbbbbbbbb4aaaaaaaaaaaaaaaabaaaaaaaaaaaaaaaaaaaaaaaaaaaa5aaabits(&b128.mask[0], sizeof(aaaaaaaaaaaaa1aaat),
mfd.len -
me->fields[index].p128.len,
me->fields[index].p128.len);
int i;
for (i = 0; i < aaaaaaaaaaa1aaaaaaaaaaaaaaaabaaaaaaaaaaaaaaaaaaaaaaaaaaaa3aaaaaaaaaaaaaaaabaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaa3aaaaaaaaaaaaaaaabaaaaaaaaaaaaaaaaaaaaaaaaaaaa4aaaWIDTH_MEM_128; i++)
if ((b128.key[i] & b128.mask[i]) != b128.key[i])
return CAM_ERROR_INVALID_PREFIX_KEY;
return 0;
}
static int
aaaaa1aaaaaaaaaaaaaaaabaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaa3aaaaaaaaaaaaaaaabaaaaaaaaaaaaaaaaaaaaaaaaaaaa4bbbbbbbbbbbbbbbb4aaaaaaaaaaaaaaaabaaaaaaaaaaaaaaaaaaaaaaaaaaaa5aaaaaaaaaaaaaaabaaaaaaaaaaaaaaaaaa6aaa(struct tcam *magg, struct aaaaa1aaaaaaaaaaaabaaaaaaaaaaa3aaa *me, uint8_t index)
{
aaaaaaaaaaa1aaaaaaaaaaaaaaaabaaaaaaaaaaaaaaaaaaaaaaaaaaaa3aaadesc mfd;
int rc = a1aaaaaaaaaaaaaaaabaaaaaaaaaaaa3aaaaaaaaaaaaaaaabaaaaaaaaaaaaaaaaaaaaaaaaaaaa3aaaaaaaaaaaaaaaaaaaaa1aaa(magg->client, index, &mfd);
assert(rc == 0);
switch (mfd.type) {
case aaaaaaaaaaa1aaaaaaaaaaaaaaaabaaaaaaaaaaaaaaaaaaaaaaaaaaaa3aaaR16:
if (me->fields[index].r16.start > me->fields[index].r16.end)
return CAM_ERROR_WRONG_RANGE;
aaaaa1aaaaaaaaaaaaaaaabaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaa3aaaaaaaaaaaaaaaabaaaaaaaaaaaaaaaaaaaaaaaaaaaa4bbbbbbbbbbbbbbbb4aaaaaaaaaaaaaaaabaaaaaaaaaaaaaaaaaaaaaaaaaaaa5aaauint2bit((uint8_t *) &me->exact_key.word[0], sizeof(aaaaaaaaaaaaa1aaat),
mfd.start_pos,
(uint8_t *) &me->fields[index].r16.start, mfd.len);
break;
case aaaaaaaaaaa1aaaaaaaaaaaaaaaabaaaaaaaaaaaaaaaaaaaaaaaaaaaa3aaaP128:
if (me->fields[index].p128.len > 128)
return CAM_ERROR_INVALID_PREFIX_LEN;
rc = aaaaa1aaaaaaaaaaaaaaaabaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaa3aaaaaaaaaaaaaaaabaaaaaaaaaaaaaaaaaaaaaaaaaaaa4aaatest_prefix(magg, me, index);
if (rc)
return rc;
aaaaa1aaaaaaaaaaaaaaaabaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaa3aaaaaaaaaaaaaaaabaaaaaaaaaaaaaaaaaaaaaaaaaaaa4bbbbbbbbbbbbbbbb4aaaaaaaaaaaaaaaabaaaaaaaaaaaaaaaaaaaaaaaaaaaa5aaauint2bit((uint8_t *) &me->exact_key.word[0], sizeof(aaaaaaaaaaaaa1aaat),
mfd.start_pos,
&me->fields[index].p128.key[0], mfd.len);
break;
case aaaaaaaaaaa1aaaaaaaaaaaaaaaabaaaaaaaaaaaaaaaaaaaaaaaaaaaa3aaaT64:
aaaaa1aaaaaaaaaaaaaaaabaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaa3aaaaaaaaaaaaaaaabaaaaaaaaaaaaaaaaaaaaaaaaaaaa4bbbbbbbbbbbbbbbb4aaaaaaaaaaaaaaaabaaaaaaaaaaaaaaaaaaaaaaaaaaaa5aaauint2bit((uint8_t *) &me->exact_key.word[0], sizeof(aaaaaaaaaaaaa1aaat),
mfd.start_pos,
&me->fields[index].t64.key[0], mfd.len);
break;
case aaaaaaaaaaa1aaaaaaaaaaaaaaaabaaaaaaaaaaaaaaaaaaaaaaaaaaaa3aaaB128:
aaaaa1aaaaaaaaaaaaaaaabaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaa3aaaaaaaaaaaaaaaabaaaaaaaaaaaaaaaaaaaaaaaaaaaa4bbbbbbbbbbbbbbbb4aaaaaaaaaaaaaaaabaaaaaaaaaaaaaaaaaaaaaaaaaaaa5aaauint2bit((uint8_t *) &me->exact_key.word[0], sizeof(aaaaaaaaaaaaa1aaat),
mfd.start_pos,
&me->fields[index].b128.key[0], mfd.len);
break;
case aaaaaaaaaaa1aaaaaaaaaaaaaaaabaaaaaaaaaaaaaaaaaaaaaaaaaaaa3aaaC128:
aaaaa1aaaaaaaaaaaaaaaabaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaa3aaaaaaaaaaaaaaaabaaaaaaaaaaaaaaaaaaaaaaaaaaaa4bbbbbbbbbbbbbbbb4aaaaaaaaaaaaaaaabaaaaaaaaaaaaaaaaaaaaaaaaaaaa5aaauint2bit((uint8_t *) &me->exact_key.word[0], sizeof(aaaaaaaaaaaaa1aaat),
mfd.start_pos,
&me->fields[index].c128.key[0], mfd.len);
break;
case aaaaaaaaaaa1aaaaaaaaaaaaaaaabaaaaaaaaaaaaaaaaaaaaaaaaaaaa3aaaU128:
break;
default:
assert(0);
}
return 0;
}
int
aaaaa1aaaaaaaaaaaaaaaabaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaa3aaaaaaaaaaaaaaaabaaaaaaaaaaaaaaaaaaaaaaaaaaaa4bbbbbbbbbbbbbbbbbbbbbbbbbbbbbbbbbbbbbbb4aaaeate_exact(struct tcam *magg, struct aaaaa1aaaaaaaaaaaabaaaaaaaaaaa3aaa *me)
{
int rc, i;
const uint8_t num_fields = a1aaaaaaaaaaaaaaaabaaaaaaaaaaaa3aaaaaaaaaaaaaaaabaaaaaaaaaaaaaaaaaaaaaaaaaaaa3aaaaaaaaaaaaaaabaaaaaaaaaaaaaaaa4aaaaaaaaaaaaaaaabaaaaaaaaaaaaaaaaaaaaaaaaaaaa4aaaaaaaaaaaaaaabaaaaaaaaaaaaaaaaaa5aaas(magg->client);
for (i = 0; i < num_fields; i++) {
rc = aaaaa1aaaaaaaaaaaaaaaabaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaa3aaaaaaaaaaaaaaaabaaaaaaaaaaaaaaaaaaaaaaaaaaaa4bbbbbbbbbbbbbbbb4aaaaaaaaaaaaaaaabaaaaaaaaaaaaaaaaaaaaaaaaaaaa5aaaaaaaaaaaaaaabaaaaaaaaaaaaaaaaaa6aaa(magg, me, i);
if (rc)
return rc;
}
return 0;
}
int
aaaaa1aaaaaaaaaaaaaaaabaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaa3aaaaaaaaaaaaaaaabaaaaaaaaaaaaaaaaaaaaaaaaaaaa4aaaaaaaaaaaaaaaabaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaa4aaa(struct tcam *magg, aaaaaaaaaaaaa1aaat *exact_key,
int indent)
{
int i;
   printf("%*cK       ", indent, ' ');
for (i = 0; i < sizeof(aaaaaaaaaaaaa1aaat) / 4; i++) {
       printf("%08x ", exact_key->word[i]);
if (i && (i + 1) % 2 == 0)
           printf(": ");
}
   printf("\n");
return 0;
}
#define aaaaa1aaaaaaaaaaaaaaabaaaaaaaaaaaaaaaaaa3aaaaaaaaaaaaaaaabaaaaaaaaaaaaaaaaaaaaaaaaaaaa3aaaaaaaaaaaaaaaabaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaa3aaaLEN_BIT_128 128
int
aaaaa1aaaaaaaa1bbbbbbbbbbbbbbbbbbbbbbbbbbbbbbbbbbbbbbb3aaaeate(a1aaat * client, struct tcam **out_tcam)
{
int rc;
struct tcam *magg;
struct aaaaa1aaaaaaaaaaaaaaaabaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaa3aaa *probsol;
const uint32_t max_num_entries = a1aaaaaaaaaaaaaaaabaaaaaaaaaaaa3aaaaaaaaaaaaaaaabaaaaaaaaaaaaaaaaaaaaaaaaaaaa3aaaaaaaaaaaaaaabaaaaaaaaaaaaaaaa4aaaaaaaaaaaaaaaabaaaaaaaaaaaaaaaaaaaaaaaaaaaa4aaaaaaaaaaaaaaaabaaaaaaaaaaaaaaaaaaaaa5aaa(client);
cam_calloc_func calloc_function = a1aaaaaaaaaaaaaaaabaaaaaaaaaaaa3aaaaaaaaaaaaaaaabaaaaaaaaaaaaaaaaaaaaaaaaaaaa3aaacalloc_function(client);
magg = calloc_function(1, sizeof(*magg) + max_num_entries *
sizeof(struct aaaaa1aaaaaaaaaaaabaaaaaaaaaaa3aaa *));
if (magg == NULL)
return CAM_ERROR_NOMEM;
magg->oparray = calloc_function(max_num_entries,
sizeof(struct aaaaa1bbbbbbbbbbbbbbbbbbbbbbbbbb3aaaaaaaaaaaaaaaabaaaaaaaaaaaaaaaaaaaaaaaaaaaa4aaaop));
if (magg->oparray == NULL) {
rc = CAM_ERROR_NOMEM;
goto error;
}
magg->client = client;
magg->prefix_scope = aaaaa1aaaaaaaaaaaaaaaabaaaaaaaaaaaaaaaaaaaaaaa3aaaaaaaaaaaaaaaabaaaaaaaaaaaaaaaaaaaaaaaaaaaa3aaaSCOPE;
magg->k_combinations = 2; 
magg->max_num_collisions = 1;
rc = aaaaa1aaaaaaaaaaaaaaaabaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaa3aaaaaaaaaaaaaaaabaaaaaaaaaaaaaaaaaaaaaaaaaaaa4bbbbbbbbbbbbbbbbbbbbbbbbbbbbbbbbbbbbbbb4aaaeate(magg, &probsol);
if (rc)
goto error;
magg->open_probsol = probsol;
LIST_APPEND(magg->probsols, probsol);
magg->do_refill = 0;
*out_tcam = magg;
return 0;
error:;
cam_free_func free_function = a1aaaaaaaaaaaaaaaabaaaaaaaaaaaa3aaaaaaaaaaaaaaaabaaaaaaaaaaaaaaaaaaaaaaaaaaaa3aaaaaaaaaaaaaabaaaaaaaaaaaa4aaaaaaaaaaaaaaaabaaaaaaaaaaaaaaaaaaaaaaaaaaaa4aaaaaaaaaaaaaaaabaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaa4aaa(client);
if (magg->oparray != NULL)
free_function(magg->oparray);
a1aaaaaaaaaaaaaaaabaaaaaaaaaaaaaaaaaaaaaaaaa3aaa(magg->client);
free_function(magg);
return rc;
}
int
aaaaa1aaaaaaaa1aaaaaaaaaaaaaaaabaaaaaaaaaaaaaaaaaaaaaaaaa3aaa(struct tcam *magg)
{
int rc;
struct aaaaa1aaaaaaaaaaaaaaaabaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaa3aaa *probsol, *tmp;
LIST_FOREACH_SAFE(magg->probsols, probsol, tmp)
{
rc = aaaaa1aaaaaaaaaaaaaaaabaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaa3aaaaaaaaaaaaaaaabaaaaaaaaaaaaaaaaaaaaaaaaaaaa4aaaaaaaaaaaaaaaabaaaaaaaaaaaaaaaaaaaaaaaaa5aaa(magg, probsol);
if (rc)
return rc;
}
rc = aaaaa1aaaaaaaaaaaaaaaabaaaaaaaaaaaaaaaaaaaaaaa3aaaaaaaaaaaaaaaabaaaaaaaaaaaaaaaaaaaaaaaaaaaa3aaaaaaaaaaaaaabaaaaaaaaaaaa4aaaaaaaaaaaaaaaabaaaaaaaaaaaaaaaaaaaaaaaaaaaa4aaainstances(magg);
if (rc)
return rc;
cam_free_func free_function = a1aaaaaaaaaaaaaaaabaaaaaaaaaaaa3aaaaaaaaaaaaaaaabaaaaaaaaaaaaaaaaaaaaaaaaaaaa3aaaaaaaaaaaaaabaaaaaaaaaaaa4aaaaaaaaaaaaaaaabaaaaaaaaaaaaaaaaaaaaaaaaaaaa4aaaaaaaaaaaaaaaabaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaa4aaa((a1aaat*) (magg->client));
free_function(magg->oparray);
a1aaaaaaaaaaaaaaaabaaaaaaaaaaaaaaaaaaaaaaaaa3aaa(magg->client);
free_function(magg);
return 0;
}
void aaaaa1aaaaaaaaaaaaaaaabaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaa3aaaaaaaaaaaaaaaabaaaaaaaaaaaaaaaaaaaaaaaaaaaa4aaastats(struct tcam *tcam)
{
   printf("Entries   = %u (peak %u)\n", tcam->stats.curr_num_entries, tcam->stats.max_num_entries);
   printf("Masks     = %u (peak %u)\n",
tcam->stats.curr_num_masks, tcam->stats.max_num_masks);
   printf("Masks closed = %u (peak %u) + open = %u (peak %u)\n",
tcam->stats.curr_closed_masks, tcam->stats.max_closed_masks,
tcam->stats.curr_open_masks, tcam->stats.max_open_masks);
   printf("Entrysets = %u (peak %u)\n", tcam->stats.curr_num_entrysets, tcam->stats.max_num_entrysets);
   printf("Collsets  = %u (peak %u)\n", tcam->stats.curr_num_collsets, tcam->stats.max_num_collsets);
}
void
aaaaa1aaaaaaaaaaaaaaaabaaaaaaaaaaaaaaaaaaaaaaa3aaaaaaaaaaaaaaaabaaaaaaaaaaaaaaaaaaaaaaaaaaaa3aaarelax_key(struct tcam *magg, struct aaaaa1aaaaaaaaaaaabaaaaaaaaaaa3aaa *me,
struct aaaaa1aaaaaaaaaaaaaaaabaaaaaaaaaaaaaaaaaaaaaaa3aaa *mask,
struct aaaaa1aaaaaaaaaaaaaaaabaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaa3aaaaaaaaaaaaaaaabaaaaaaaaaaaaaaaaaaaaaaaaaaaa4aaarelax_var_array *relax_key)
{
int i;
uint8_t *sp = (uint8_t *) &me->exact_key.word[0];
uint8_t *m = (uint8_t *) &mask->mask.word[0];
uint8_t *dp = &relax_key->key[0];
for (i = 0; i < sizeof(aaaaaaaaaaaaa1aaat); i++) {
*dp = *sp & *m;
dp++;
sp++;
m++;
}
int field;
const uint8_t num_fields = a1aaaaaaaaaaaaaaaabaaaaaaaaaaaa3aaaaaaaaaaaaaaaabaaaaaaaaaaaaaaaaaaaaaaaaaaaa3aaaaaaaaaaaaaaabaaaaaaaaaaaaaaaa4aaaaaaaaaaaaaaaabaaaaaaaaaaaaaaaaaaaaaaaaaaaa4aaaaaaaaaaaaaaabaaaaaaaaaaaaaaaaaa5aaas(magg->client);
for (field = 0; field < num_fields; field++) {
aaaaaaaaaaa1aaaaaaaaaaaaaaaabaaaaaaaaaaaaaaaaaaaaaaaaaaaa3aaadesc mfd;
const int rc = a1aaaaaaaaaaaaaaaabaaaaaaaaaaaa3aaaaaaaaaaaaaaaabaaaaaaaaaaaaaaaaaaaaaaaaaaaa3aaaaaaaaaaaaaaaaaaaaa1aaa(magg->client, field, &mfd);
assert(rc == 0);
if (mfd.type != aaaaaaaaaaa1aaaaaaaaaaaaaaaabaaaaaaaaaaaaaaaaaaaaaaaaaaaa3aaaR16 ||
(mask->use_range &
1 << mfd.instance) == 0)
continue;
uint16_t range = 0;
aaaaa1aaaaaaaaaaaaaaaabaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaa3aaaaaaaaaaaaaaaabaaaaaaaaaaaaaaaaaaaaaaaaaaaa4bbbbbbbbbbbbbbbb4aaaaaaaaaaaaaaaabaaaaaaaaaaaaaaaaaaaaaaaaaaaa5aaauint2bit((uint8_t *) &relax_key->key[0],
sizeof(aaaaaaaaaaaaa1aaat),
mfd.start_pos,
(uint8_t *) &range,
mfd.len);
}
}
int
aaaaa1aaaaaaaaaaaaaaaabaaaaaaaaaaaaaaaaaaaaaaa3aaaaaaaaaaaaaaaabaaaaaaaaaaaaaaaaaaaaaaaaaaaa3bbbbbbbbbbbbbbbbbbbbbbbbbbbbbbbbbbbbbbb3aaaeate_exact(struct tcam *magg, struct aaaaa1aaaaaaaaaaaabaaaaaaaaaaa3aaa *me)
{
int field;
struct aaaaa1aaaaaaaaaaaaaaaabaaaaaaaaaaaaaaaaaaaaaaa3aaa *mask = &me->exact_mask;
struct aaaaaaaaaaa1aaaaaaaaaaaaaaaabaaaaaaaaaaaaaaaaaaaaaaaaaaaa3aaat64 t64_zero;
memset(&t64_zero, 0, sizeof(t64_zero));
struct aaaaaaaaaaa1aaaaaaaaaaaaaaaabaaaaaaaaaaaaaaaaaaaaaaaaaaaa3aaab128 b128_zero;
memset(&b128_zero, 0, sizeof(b128_zero));
const uint8_t num_fields = a1aaaaaaaaaaaaaaaabaaaaaaaaaaaa3aaaaaaaaaaaaaaaabaaaaaaaaaaaaaaaaaaaaaaaaaaaa3aaaaaaaaaaaaaaabaaaaaaaaaaaaaaaa4aaaaaaaaaaaaaaaabaaaaaaaaaaaaaaaaaaaaaaaaaaaa4aaaaaaaaaaaaaaabaaaaaaaaaaaaaaaaaa5aaas(magg->client);
for (field = 0; field < num_fields; field++) {
aaaaaaaaaaa1aaaaaaaaaaaaaaaabaaaaaaaaaaaaaaaaaaaaaaaaaaaa3aaadesc mfd;
int rc = a1aaaaaaaaaaaaaaaabaaaaaaaaaaaa3aaaaaaaaaaaaaaaabaaaaaaaaaaaaaaaaaaaaaaaaaaaa3aaaaaaaaaaaaaaaaaaaaa1aaa(magg->client, field, &mfd);
assert(rc == 0);
switch (mfd.type) {
case aaaaaaaaaaa1aaaaaaaaaaaaaaaabaaaaaaaaaaaaaaaaaaaaaaaaaaaa3aaaR16:
mask->use_range |= 1 << mfd.instance;
if (me->fields[field].r16.start == me->fields[field].r16.end) {
if (mask->max_pop < mfd.len || (mask->max_pop == mfd.len && mask->tot_pop < mfd.len)) {
mask->max_pop = mfd.len;
mask->tot_pop = mfd.len;
}
mask->active_fields |= 1 << field;
}
break;
case aaaaaaaaaaa1aaaaaaaaaaaaaaaabaaaaaaaaaaaaaaaaaaaaaaaaaaaa3aaaP128:
aaaaa1aaaaaaaaaaaaaaaabaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaa3aaaaaaaaaaaaaaaabaaaaaaaaaaaaaaaaaaaaaaaaaaaa4bbbbbbbbbbbbbbbbbb4aaaaaaaaaaaaaaaabaaaaaaaaaaaaaaaaaaaaaaaaaaaa5aaabits((uint8_t *) &mask->mask.word[0], sizeof(aaaaaaaaaaaaa1aaat),
mfd.start_pos + mfd.len -
me->fields[field].p128.len,
me->fields[field].p128.len);
if (me->fields[field].p128.len > 0) {
mask->active_fields |= 1 << field;
if (mask->max_pop < me->fields[field].p128.len || (mask->max_pop == me->fields[field].p128.len && mask->tot_pop < mfd.len)) {
mask->max_pop = me->fields[field].p128.len;
mask->tot_pop = mfd.len;
}
}
break;
case aaaaaaaaaaa1aaaaaaaaaaaaaaaabaaaaaaaaaaaaaaaaaaaaaaaaaaaa3aaaT64:
aaaaa1aaaaaaaaaaaaaaaabaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaa3aaaaaaaaaaaaaaaabaaaaaaaaaaaaaaaaaaaaaaaaaaaa4bbbbbbbbbbbbbbbb4aaaaaaaaaaaaaaaabaaaaaaaaaaaaaaaaaaaaaaaaaaaa5aaauint2bit((uint8_t *) &mask->mask.word[0], sizeof(aaaaaaaaaaaaa1aaat),
mfd.start_pos,
&me->fields[field].t64.mask[0], mfd.len);
if (memcmp(&me->fields[field].t64.mask, &t64_zero,
sizeof(t64_zero.mask)) != 0) {
mask->active_fields |= 1 << field;
uint64_t *mask64 = (uint64_t *) &me->fields[field].t64.mask[0];
uint16_t t_pop = __builtin_popcountll(*mask64);
if (mask->max_pop < t_pop || (mask->max_pop == t_pop && mask->tot_pop < mfd.len)) {
mask->max_pop = t_pop;
mask->tot_pop = mfd.len;
}
}
break;
case aaaaaaaaaaa1aaaaaaaaaaaaaaaabaaaaaaaaaaaaaaaaaaaaaaaaaaaa3aaaB128:
aaaaa1aaaaaaaaaaaaaaaabaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaa3aaaaaaaaaaaaaaaabaaaaaaaaaaaaaaaaaaaaaaaaaaaa4bbbbbbbbbbbbbbbb4aaaaaaaaaaaaaaaabaaaaaaaaaaaaaaaaaaaaaaaaaaaa5aaauint2bit((uint8_t *) &mask->mask.word[0], sizeof(aaaaaaaaaaaaa1aaat),
mfd.start_pos,
&me->fields[field].b128.mask[0],
mfd.len);
if (memcmp(&me->fields[field].b128.mask, &b128_zero,
sizeof(b128_zero.mask)) != 0) {
mask->active_fields |= 1 << field;
if (mask->max_pop < mfd.len || (mask->max_pop == mfd.len && mask->tot_pop < mfd.len)) {
mask->max_pop = mfd.len;
mask->tot_pop = mfd.len;
}
}
break;
case aaaaaaaaaaa1aaaaaaaaaaaaaaaabaaaaaaaaaaaaaaaaaaaaaaaaaaaa3aaaC128:
aaaaa1aaaaaaaaaaaaaaaabaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaa3aaaaaaaaaaaaaaaabaaaaaaaaaaaaaaaaaaaaaaaaaaaa4bbbbbbbbbbbbbbbbbb4aaaaaaaaaaaaaaaabaaaaaaaaaaaaaaaaaaaaaaaaaaaa5aaabits((uint8_t *) &mask->mask.word[0], sizeof(aaaaaaaaaaaaa1aaat),
mfd.start_pos, mfd.len);
mask->const_pop += mfd.len;
break;
case aaaaaaaaaaa1aaaaaaaaaaaaaaaabaaaaaaaaaaaaaaaaaaaaaaaaaaaa3aaaU128:
break;
default:
assert(0);
}
}
return 0;
}
static void
aaaaa1aaaaaaaaaaaaaaaabaaaaaaaaaaaaaaaaaaaaaaa3aaaaaaaaaaaaaaaabaaaaaaaaaaaaaaaaaaaaaaaaaaaa3bbbbbbbbbbbbbbbbbbbbbbbbbbbbbbbbbbbbbbb3aaaeate_index2field(uint32_t mask_active_fields, uint8_t * index2field)
{
int i = 0;
memset(index2field, 0, CAM_MAX_NUM_FIELDS);
while (1) {
int field = __builtin_ffs(mask_active_fields);
if (field == 0)
return;
field--;
index2field[i] = field;
mask_active_fields ^= 1 << field;
i++;
assert(i <= CAM_MAX_NUM_FIELDS);
}
}
static inline uint8_t
aaaaa1aaaaaaaaaaaaaaaabaaaaaaaaaaaaaaaaaaaaaaa3aaaaaaaaaaaaaaaabaaaaaaaaaaaaaaaaaaaaaaaaaaaa3aaaindex2field(uint8_t index2field[], int index)
{
assert(index > 0 && index <= CAM_MAX_NUM_FIELDS);
return index2field[index - 1];
}
int
aaaaa1aaaaaaaaaaaaaaaabaaaaaaaaaaaaaaaaaaaaaaa3aaaaaaaaaaaaaaaabaaaaaaaaaaaaaaaaaaaaaaaaaaaa3aaarelax_fields(struct tcam *magg, struct aaaaa1aaaaaaaaaaaabaaaaaaaaaaa3aaa *me)
{
int i;
struct aaaaaaaaaaa1aaaaaaaaaaaaaaaabaaaaaaaaaaaaaaaaaaaaaaaaaaaa3aaat64 t64_zero;
memset(&t64_zero, 0, sizeof(t64_zero));
struct aaaaaaaaaaa1aaaaaaaaaaaaaaaabaaaaaaaaaaaaaaaaaaaaaaaaaaaa3aaab128 b128_zero;
memset(&b128_zero, 0, sizeof(b128_zero));
const uint8_t num_fields = a1aaaaaaaaaaaaaaaabaaaaaaaaaaaa3aaaaaaaaaaaaaaaabaaaaaaaaaaaaaaaaaaaaaaaaaaaa3aaaaaaaaaaaaaaabaaaaaaaaaaaaaaaa4aaaaaaaaaaaaaaaabaaaaaaaaaaaaaaaaaaaaaaaaaaaa4aaaaaaaaaaaaaaabaaaaaaaaaaaaaaaaaa5aaas(magg->client);
for (i = 0; i < num_fields; i++) {
aaaaaaaaaaa1aaaaaaaaaaaaaaaabaaaaaaaaaaaaaaaaaaaaaaaaaaaa3aaadesc mfd;
const int rc = a1aaaaaaaaaaaaaaaabaaaaaaaaaaaa3aaaaaaaaaaaaaaaabaaaaaaaaaaaaaaaaaaaaaaaaaaaa3aaaaaaaaaaaaaaaaaaaaa1aaa(magg->client, i, &mfd);
assert(rc == 0);
switch (mfd.type) {
case aaaaaaaaaaa1aaaaaaaaaaaaaaaabaaaaaaaaaaaaaaaaaaaaaaaaaaaa3aaaR16:
if (me->fields[i].r16.start == me->fields[i].r16.end)
me->relax_fields |= 1 << i;
break;
case aaaaaaaaaaa1aaaaaaaaaaaaaaaabaaaaaaaaaaaaaaaaaaaaaaaaaaaa3aaaP128:
if (me->fields[i].p128.len > 0) {
me->relax_fields |= 1 << i;
me->multiply_fields |= 1 << i;
}
break;
case aaaaaaaaaaa1aaaaaaaaaaaaaaaabaaaaaaaaaaaaaaaaaaaaaaaaaaaa3aaaT64:
if (memcmp(&me->fields[i].t64.mask, &t64_zero, sizeof(t64_zero.mask)) != 0) {
me->relax_fields |= 1 << i;
me->multiply_fields |= 1 << i;
}
break;
case aaaaaaaaaaa1aaaaaaaaaaaaaaaabaaaaaaaaaaaaaaaaaaaaaaaaaaaa3aaaB128:
if (memcmp(&me->fields[i].b128.mask, &b128_zero, sizeof(b128_zero.mask)) != 0)
me->relax_fields |= 1 << i;
break;
default:
break;
}
}
return 0;
}
static int
aaaaa1aaaaaaaaaaaaaaaabaaaaaaaaaaaaaaaaaaaaaaa3aaaaaaaaaaaaaaaabaaaaaaaaaaaaaaaaaaaaaaaaaaaa3bbbbbbbbbbbbbbbbbbbbbbbbbbbbbbbb3aaa(struct tcam *magg, struct aaaaa1aaaaaaaaaaaabaaaaaaaaaaa3aaa *me, struct aaaaa1aaaaaaaaaaaaaaaabaaaaaaaaaaaaaaaaaaaaaaa3aaa *mask)
{
if (magg->debug_mask & aaaaa1bbbbbbbbbbbbbbbbbbbbbbbbbbbbbbbbbbbbb3aaaaaaaaaaaaaaaabaaaaaaaaaaaaaaaaaaaaaaaaaaaa4aaaaaaaaaaaaaaaabaaaaaaaaaaaaaaaaaaaaaaa5aaaaaaaaaaaaaaaabaaaaaaaaaaaaaaaaaaaaaaaaaaaa5aaaaaaaaaaaabaaaaaaaaaa6aaa) {
       printf("      max pop %2u tot pop %2u", mask->max_pop, mask->tot_pop);
aaaaa1aaaaaaaaaaaaaaaabaaaaaaaaaaaaaaaaaaaaaaa3aaaaaaaaaaaaaaaabaaaaaaaaaaaaaaaaaaaaaaaaaaaa3aaaaaaaaaaaaaaaabaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaa3aaa(magg, mask, 0);
}
struct aaaaa1aaaaaaaaaaaaaaaabaaaaaaaaaaaaaaaaaaaaaaa3aaaaaaaaaaaaaaaabaaaaaaaaaaaaaaaaaaaaaaaaaaaa3aaaaaaaaaaaabaaaaaaaaaa4aaa *tmp;
cam_free_func free_function = a1aaaaaaaaaaaaaaaabaaaaaaaaaaaa3aaaaaaaaaaaaaaaabaaaaaaaaaaaaaaaaaaaaaaaaaaaa3aaaaaaaaaaaaaabaaaaaaaaaaaa4aaaaaaaaaaaaaaaabaaaaaaaaaaaaaaaaaaaaaaaaaaaa4aaaaaaaaaaaaaaaabaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaa4aaa((a1aaat*) (magg->client));
cam_malloc_func malloc_function = a1aaaaaaaaaaaaaaaabaaaaaaaaaaaa3aaaaaaaaaaaaaaaabaaaaaaaaaaaaaaaaaaaaaaaaaaaa3aaamalloc_function((a1aaat*) (magg->client));
cam_calloc_func calloc_function = a1aaaaaaaaaaaaaaaabaaaaaaaaaaaa3aaaaaaaaaaaaaaaabaaaaaaaaaaaaaaaaaaaaaaaaaaaa3aaacalloc_function((a1aaat*) (magg->client));
MH_FIND(mh_handle, me->mask_by_mask, mask, sizeof(*mask), tmp);
if (tmp)
return 0;
struct aaaaa1aaaaaaaaaaaaaaaabaaaaaaaaaaaaaaaaaaaaaaa3aaaaaaaaaaaaaaaabaaaaaaaaaaaaaaaaaaaaaaaaaaaa3aaaaaaaaaaaabaaaaaaaaaa4aaa *mask_hash = calloc_function(1, sizeof(*mask_hash));
if (mask_hash == NULL)
return CAM_ERROR_NOMEM;
memcpy(&mask_hash->mask, mask, sizeof(mask_hash->mask));
MH_ADD(mh_handle, me->mask_by_mask, mask, sizeof(mask_hash->mask), mask_hash, free_function, malloc_function);
return 0;
error:
return CAM_ERROR_NOMEM;
}
static int
aaaaa1aaaaaaaaaaaaaaaabaaaaaaaaaaaaaaaaaaaaaaa3aaaaaaaaaaaaaaaabaaaaaaaaaaaaaaaaaaaaaaaaaaaa3aaaaaaaaaaaaaaaabaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaa3aaa(struct tcam *magg, struct aaaaa1aaaaaaaaaaaabaaaaaaaaaaa3aaa *me,
struct aaaaa1aaaaaaaaaaaaaaaabaaaaaaaaaaaaaaaaaaaaaaa3aaa mask, uint32_t remain_fields)
{
uint16_t incoming_pop = mask.max_pop;
uint16_t incoming_tot = mask.tot_pop;
int i, rc;
if (remain_fields == 0) {
rc = aaaaa1aaaaaaaaaaaaaaaabaaaaaaaaaaaaaaaaaaaaaaa3aaaaaaaaaaaaaaaabaaaaaaaaaaaaaaaaaaaaaaaaaaaa3bbbbbbbbbbbbbbbbbbbbbbbbbbbbbbbb3aaa(magg, me, &mask);
if (rc)
return rc;
return 0;
}
int field = __builtin_ffs(remain_fields) - 1;
remain_fields = remain_fields ^ (1 << field);
if (magg->debug_mask & aaaaa1bbbbbbbbbbbbbbbbbbbbbbbbbbbbbbbbbbbbb3aaaaaaaaaaaaaaaabaaaaaaaaaaaaaaaaaaaaaaaaaaaa4aaaaaaaaaaaaaaaabaaaaaaaaaaaaaaaaaaaaaaa5aaaaaaaaaaaaaaaabaaaaaaaaaaaaaaaaaaaaaaaaaaaa5aaaaaaaaaaaabaaaaaaaaaa6aaa)
       printf("    MULT field %d remain %0x\n", field, remain_fields);
aaaaaaaaaaa1aaaaaaaaaaaaaaaabaaaaaaaaaaaaaaaaaaaaaaaaaaaa3aaadesc mfd;
rc = a1aaaaaaaaaaaaaaaabaaaaaaaaaaaa3aaaaaaaaaaaaaaaabaaaaaaaaaaaaaaaaaaaaaaaaaaaa3aaaaaaaaaaaaaaaaaaaaa1aaa(magg->client, field, &mfd);
assert(rc == 0);
switch (mfd.type) {
case aaaaaaaaaaa1aaaaaaaaaaaaaaaabaaaaaaaaaaaaaaaaaaaaaaaaaaaa3aaaP128: {
uint8_t pre_start = me->fields[field].p128.len > magg->prefix_scope ?
me->fields[field].p128.len - magg->prefix_scope : 0;
for (i = pre_start; i <= me->fields[field].p128.len; i++) {
aaaaa1aaaaaaaaaaaaaaaabaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaa3aaaaaaaaaaaaaaaabaaaaaaaaaaaaaaaaaaaaaaaaaaaa4bbbbbbbbbbbbbbbbbb4aaaaaaaaaaaaaaaabaaaaaaaaaaaaaaaaaaaaaaaaaaaa5aaabits((uint8_t *) &mask.mask.word[0], sizeof(aaaaaaaaaaaaa1aaat),
mfd.start_pos + mfd.len - i, i);
if (incoming_pop < i || (incoming_pop == i && incoming_tot < mfd.len)) {
mask.max_pop = i;
mask.tot_pop = mfd.len;
}
rc = aaaaa1aaaaaaaaaaaaaaaabaaaaaaaaaaaaaaaaaaaaaaa3aaaaaaaaaaaaaaaabaaaaaaaaaaaaaaaaaaaaaaaaaaaa3aaaaaaaaaaaaaaaabaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaa3aaa(magg, me, mask, remain_fields);
if (rc)
return rc;
}
break;
}
case aaaaaaaaaaa1aaaaaaaaaaaaaaaabaaaaaaaaaaaaaaaaaaaaaaaaaaaa3aaaT64: {
const uint8_t max_entries_per_unit_bits = 32
- __builtin_clz((uint32_t) a1aaaaaaaaaaaaaaaabaaaaaaaaaaaa3aaaaaaaaaaaaaaaabaaaaaaaaaaaaaaaaaaaaaaaaaaaa3aaaaaaaaaaaaaaabaaaaaaaaaaaaaaaa4aaaaaaaaaaaaaaaabaaaaaaaaaaaaaaaaaaaaaaaaaaaa4aaaaaaaaaaaaaaaabaaaaaaaaaaaaaaaaaaaaa5aaaaaaaaaaaaaaaabaaaaaaaaaaaaaaaaaaaaaaaaaaaa5aaaper_unit(magg->client));
uint64_t mask64;
memcpy(&mask64, &me->fields[field].t64.mask[0], sizeof(mask64));
uint8_t pop = __builtin_popcountll(mask64);
if (pop == 0)
break;
uint64_t start;
if (pop == mfd.len) {
start = mask64;
} else {
start = 1 << __builtin_ctzll(mask64);
}
for (uint64_t t = 0; t <= mask64; t += start) {
if ((t | mask64) != mask64) {
continue;
}
uint8_t t_pop = __builtin_popcountll(t);
if (pop - t_pop > 3 && t != 0) {
continue;
}
if (t_pop > max_entries_per_unit_bits && t != mask64) {
continue;
}
aaaaa1aaaaaaaaaaaaaaaabaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaa3aaaaaaaaaaaaaaaabaaaaaaaaaaaaaaaaaaaaaaaaaaaa4bbbbbbbbbbbbbbbb4aaaaaaaaaaaaaaaabaaaaaaaaaaaaaaaaaaaaaaaaaaaa5aaauint64((uint64_t *) &mask.mask.word[0], mfd.start_pos,
(uint64_t *) &t, 0, mfd.len);
mask.max_pop = MAX(incoming_pop, __builtin_popcountll(t));
rc = aaaaa1aaaaaaaaaaaaaaaabaaaaaaaaaaaaaaaaaaaaaaa3aaaaaaaaaaaaaaaabaaaaaaaaaaaaaaaaaaaaaaaaaaaa3aaaaaaaaaaaaaaaabaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaa3aaa(magg, me, mask, remain_fields);
if (rc)
return rc;
}
break;
}
default:
assert(0);
}
return 0;
}
static void
aaaaa1aaaaaaaaaaaaaaaabaaaaaaaaaaaaaaaaaaaaaaa3aaaaaaaaaaaaaaaabaaaaaaaaaaaaaaaaaaaaaaaaaaaa3aaaaaaaaaaaaaaaabaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaa3aaaaaaaaaaaaaaaabaaaaaaaaaaaaaaaaaaaaaaaaaaaa4aaaaaaaaaaaaaaabaaaaaaaaaaaaaaaaaa5aaa(struct tcam *magg, struct aaaaa1aaaaaaaaaaaabaaaaaaaaaaa3aaa *me,
struct aaaaa1aaaaaaaaaaaaaaaabaaaaaaaaaaaaaaaaaaaaaaa3aaa *mask, uint8_t field)
{
aaaaaaaaaaa1aaaaaaaaaaaaaaaabaaaaaaaaaaaaaaaaaaaaaaaaaaaa3aaadesc mfd;
const int rc = a1aaaaaaaaaaaaaaaabaaaaaaaaaaaa3aaaaaaaaaaaaaaaabaaaaaaaaaaaaaaaaaaaaaaaaaaaa3aaaaaaaaaaaaaaaaaaaaa1aaa(magg->client, field, &mfd);
assert(rc == 0);
switch (mfd.type) {
case aaaaaaaaaaa1aaaaaaaaaaaaaaaabaaaaaaaaaaaaaaaaaaaaaaaaaaaa3aaaR16:
mask->use_range ^= 1 << mfd.instance;
aaaaa1aaaaaaaaaaaaaaaabaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaa3aaaaaaaaaaaaaaaabaaaaaaaaaaaaaaaaaaaaaaaaaaaa4bbbbbbbbbbbbbbbbbb4aaaaaaaaaaaaaaaabaaaaaaaaaaaaaaaaaaaaaaaaaaaa5aaabits((uint8_t *) &mask->mask.word[0], sizeof(aaaaaaaaaaaaa1aaat),
mfd.start_pos, mfd.len);
if (mask->max_pop < 16 || (mask->max_pop == 16 && mask->tot_pop < 16)) {
mask->max_pop = 16;
mask->tot_pop = 16;
}
break;
case aaaaaaaaaaa1aaaaaaaaaaaaaaaabaaaaaaaaaaaaaaaaaaaaaaaaaaaa3aaaP128:
break;
case aaaaaaaaaaa1aaaaaaaaaaaaaaaabaaaaaaaaaaaaaaaaaaaaaaaaaaaa3aaaT64:
break;
case aaaaaaaaaaa1aaaaaaaaaaaaaaaabaaaaaaaaaaaaaaaaaaaaaaaaaaaa3aaaB128:
aaaaa1aaaaaaaaaaaaaaaabaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaa3aaaaaaaaaaaaaaaabaaaaaaaaaaaaaaaaaaaaaaaaaaaa4bbbbbbbbbbbbbbbb4aaaaaaaaaaaaaaaabaaaaaaaaaaaaaaaaaaaaaaaaaaaa5aaauint2bit((uint8_t *) &mask->mask.word[0], sizeof(aaaaaaaaaaaaa1aaat),
mfd.start_pos,
&me->fields[field].b128.mask[0],
mfd.len);
if (mask->max_pop < mfd.len || (mask->max_pop == mfd.len && mask->tot_pop < mfd.len)) {
mask->max_pop = mfd.len;
mask->tot_pop = mfd.len;
}
break;
default:
assert(0);
}
mask->active_fields |= 1 << field;
}
static int
aaaaa1aaaaaaaaaaaaaaaabaaaaaaaaaaaaaaaaaaaaaaa3aaaaaaaaaaaaaaaabaaaaaaaaaaaaaaaaaaaaaaaaaaaa3aaacombine(struct tcam *magg, struct aaaaa1aaaaaaaaaaaabaaaaaaaaaaa3aaa *me,
struct aaaaa1aaaaaaaaaaaaaaaabaaaaaaaaaaaaaaaaaaaaaaa3aaa in_mask, uint8_t index2field[], int n, int k)
{
int i, rc;
if (magg->debug_mask & aaaaa1bbbbbbbbbbbbbbbbbbbbbbbbbbbbbbbbbbbbb3aaaaaaaaaaaaaaaabaaaaaaaaaaaaaaaaaaaaaaaaaaaa4aaaaaaaaaaaaaaaabaaaaaaaaaaaaaaaaaaaaaaa5aaaaaaaaaaaaaaaabaaaaaaaaaaaaaaaaaaaaaaaaaaaa5aaaaaaaaaaaabaaaaaaaaaa6aaa)
       printf("  COMB n %d k %d\n", n, k);
for (i = n; i >= k; i--) {
if (k > 1) {
struct aaaaa1aaaaaaaaaaaaaaaabaaaaaaaaaaaaaaaaaaaaaaa3aaa out_mask = in_mask;
aaaaa1aaaaaaaaaaaaaaaabaaaaaaaaaaaaaaaaaaaaaaa3aaaaaaaaaaaaaaaabaaaaaaaaaaaaaaaaaaaaaaaaaaaa3aaaaaaaaaaaaaaaabaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaa3aaaaaaaaaaaaaaaabaaaaaaaaaaaaaaaaaaaaaaaaaaaa4aaaaaaaaaaaaaaabaaaaaaaaaaaaaaaaaa5aaa(magg, me, &out_mask,
aaaaa1aaaaaaaaaaaaaaaabaaaaaaaaaaaaaaaaaaaaaaa3aaaaaaaaaaaaaaaabaaaaaaaaaaaaaaaaaaaaaaaaaaaa3aaaindex2field(index2field, i));
rc = aaaaa1aaaaaaaaaaaaaaaabaaaaaaaaaaaaaaaaaaaaaaa3aaaaaaaaaaaaaaaabaaaaaaaaaaaaaaaaaaaaaaaaaaaa3aaacombine(magg, me, out_mask, index2field, i - 1,
k - 1);
if (rc)
return rc;
} else {
struct aaaaa1aaaaaaaaaaaaaaaabaaaaaaaaaaaaaaaaaaaaaaa3aaa out_mask = in_mask;
aaaaa1aaaaaaaaaaaaaaaabaaaaaaaaaaaaaaaaaaaaaaa3aaaaaaaaaaaaaaaabaaaaaaaaaaaaaaaaaaaaaaaaaaaa3aaaaaaaaaaaaaaaabaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaa3aaaaaaaaaaaaaaaabaaaaaaaaaaaaaaaaaaaaaaaaaaaa4aaaaaaaaaaaaaaabaaaaaaaaaaaaaaaaaa5aaa(magg, me, &out_mask,
aaaaa1aaaaaaaaaaaaaaaabaaaaaaaaaaaaaaaaaaaaaaa3aaaaaaaaaaaaaaaabaaaaaaaaaaaaaaaaaaaaaaaaaaaa3aaaindex2field(index2field, i));
if ((out_mask.active_fields & me->multiply_fields) == 0) {
rc = aaaaa1aaaaaaaaaaaaaaaabaaaaaaaaaaaaaaaaaaaaaaa3aaaaaaaaaaaaaaaabaaaaaaaaaaaaaaaaaaaaaaaaaaaa3bbbbbbbbbbbbbbbbbbbbbbbbbbbbbbbb3aaa(magg, me, &out_mask);
if (rc)
return rc;
} else {
rc = aaaaa1aaaaaaaaaaaaaaaabaaaaaaaaaaaaaaaaaaaaaaa3aaaaaaaaaaaaaaaabaaaaaaaaaaaaaaaaaaaaaaaaaaaa3aaaaaaaaaaaaaaaabaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaa3aaa(magg, me, out_mask,
out_mask.active_fields & me->multiply_fields);
if (rc)
return rc;
}
}
}
return 0;
}
static void
aaaaa1aaaaaaaaaaaaaaaabaaaaaaaaaaaaaaaaaaaaaaa3aaaaaaaaaaaaaaaabaaaaaaaaaaaaaaaaaaaaaaaaaaaa3aaamandatory_fields(struct tcam *magg, struct aaaaa1aaaaaaaaaaaaaaaabaaaaaaaaaaaaaaaaaaaaaaa3aaa *mask)
{
int field;
const uint8_t num_fields = a1aaaaaaaaaaaaaaaabaaaaaaaaaaaa3aaaaaaaaaaaaaaaabaaaaaaaaaaaaaaaaaaaaaaaaaaaa3aaaaaaaaaaaaaaabaaaaaaaaaaaaaaaa4aaaaaaaaaaaaaaaabaaaaaaaaaaaaaaaaaaaaaaaaaaaa4aaaaaaaaaaaaaaabaaaaaaaaaaaaaaaaaa5aaas(magg->client);
for (field = 0; field < num_fields; field++) {
aaaaaaaaaaa1aaaaaaaaaaaaaaaabaaaaaaaaaaaaaaaaaaaaaaaaaaaa3aaadesc mfd;
const int rc = a1aaaaaaaaaaaaaaaabaaaaaaaaaaaa3aaaaaaaaaaaaaaaabaaaaaaaaaaaaaaaaaaaaaaaaaaaa3aaaaaaaaaaaaaaaaaaaaa1aaa(magg->client, field, &mfd);
assert(rc == 0);
switch (mfd.type) {
case aaaaaaaaaaa1aaaaaaaaaaaaaaaabaaaaaaaaaaaaaaaaaaaaaaaaaaaa3aaaR16:
mask->use_range |= 1 << mfd.instance;
break;
case aaaaaaaaaaa1aaaaaaaaaaaaaaaabaaaaaaaaaaaaaaaaaaaaaaaaaaaa3aaaP128:
break;
case aaaaaaaaaaa1aaaaaaaaaaaaaaaabaaaaaaaaaaaaaaaaaaaaaaaaaaaa3aaaC128:
aaaaa1aaaaaaaaaaaaaaaabaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaa3aaaaaaaaaaaaaaaabaaaaaaaaaaaaaaaaaaaaaaaaaaaa4bbbbbbbbbbbbbbbbbb4aaaaaaaaaaaaaaaabaaaaaaaaaaaaaaaaaaaaaaaaaaaa5aaabits((uint8_t*) &mask->mask.word[0], sizeof(aaaaaaaaaaaaa1aaat),
mfd.start_pos, mfd.len);
mask->const_pop += mfd.len;
break;
default:
break;
}
}
}
int
aaaaa1aaaaaaaaaaaaaaaabaaaaaaaaaaaaaaaaaaaaaaa3aaaaaaaaaaaaaaaabaaaaaaaaaaaaaaaaaaaaaaaaaaaa3aaasort(void *a, void *b)
{
struct aaaaa1aaaaaaaaaaaaaaaabaaaaaaaaaaaaaaaaaaaaaaa3aaaaaaaaaaaaaaaabaaaaaaaaaaaaaaaaaaaaaaaaaaaa3aaaaaaaaaaaabaaaaaaaaaa4aaa *ha = (struct aaaaa1aaaaaaaaaaaaaaaabaaaaaaaaaaaaaaaaaaaaaaa3aaaaaaaaaaaaaaaabaaaaaaaaaaaaaaaaaaaaaaaaaaaa3aaaaaaaaaaaabaaaaaaaaaa4aaa *) a;
struct aaaaa1aaaaaaaaaaaaaaaabaaaaaaaaaaaaaaaaaaaaaaa3aaaaaaaaaaaaaaaabaaaaaaaaaaaaaaaaaaaaaaaaaaaa3aaaaaaaaaaaabaaaaaaaaaa4aaa *hb = (struct aaaaa1aaaaaaaaaaaaaaaabaaaaaaaaaaaaaaaaaaaaaaa3aaaaaaaaaaaaaaaabaaaaaaaaaaaaaaaaaaaaaaaaaaaa3aaaaaaaaaaaabaaaaaaaaaa4aaa *) b;
if (__builtin_popcount(ha->mask.active_fields) > __builtin_popcount(hb->mask.active_fields))
return 1;
if (__builtin_popcount(ha->mask.active_fields) < __builtin_popcount(hb->mask.active_fields))
return -1;
if (ha->mask.max_pop < hb->mask.max_pop)
return 1;
if (ha->mask.max_pop > hb->mask.max_pop)
return -1;
if (ha->mask.tot_pop < hb->mask.tot_pop)
return 1;
if (ha->mask.tot_pop > hb->mask.tot_pop)
return -1;
return 0;
}
int
aaaaa1aaaaaaaaaaaaaaaabaaaaaaaaaaaaaaaaaaaaaaa3aaaaaaaaaaaaaaaabaaaaaaaaaaaaaaaaaaaaaaaaaaaa3bbbbbbbbbbbbbbbbbbbbbbbbbbbbbbbbbbbbbbb3aaaeate_hash(struct tcam *magg, struct aaaaa1aaaaaaaaaaaabaaaaaaaaaaa3aaa *me)
{
int k, rc;
if (me->mask_by_mask)
return 0;
uint8_t index2field[CAM_MAX_NUM_FIELDS];
aaaaa1aaaaaaaaaaaaaaaabaaaaaaaaaaaaaaaaaaaaaaa3aaaaaaaaaaaaaaaabaaaaaaaaaaaaaaaaaaaaaaaaaaaa3bbbbbbbbbbbbbbbbbbbbbbbbbbbbbbbbbbbbbbb3aaaeate_index2field(me->relax_fields, &index2field[0]);
int num_fields_set = __builtin_popcount(me->relax_fields);
struct aaaaa1aaaaaaaaaaaaaaaabaaaaaaaaaaaaaaaaaaaaaaa3aaa mask_template;
memset(&mask_template, 0, sizeof(mask_template));
aaaaa1aaaaaaaaaaaaaaaabaaaaaaaaaaaaaaaaaaaaaaa3aaaaaaaaaaaaaaaabaaaaaaaaaaaaaaaaaaaaaaaaaaaa3aaamandatory_fields(magg, &mask_template);
for (k = 1; k <= magg->k_combinations; k++) {
if (magg->debug_mask & aaaaa1bbbbbbbbbbbbbbbbbbbbbbbbbbbbbbbbbbbbb3aaaaaaaaaaaaaaaabaaaaaaaaaaaaaaaaaaaaaaaaaaaa4aaaaaaaaaaaaaaaabaaaaaaaaaaaaaaaaaaaaaaa5aaaaaaaaaaaaaaaabaaaaaaaaaaaaaaaaaaaaaaaaaaaa5aaaaaaaaaaaabaaaaaaaaaa6aaa)
           printf("K-COMB %d\n", k);
struct aaaaa1aaaaaaaaaaaaaaaabaaaaaaaaaaaaaaaaaaaaaaa3aaa mask = mask_template;
rc = aaaaa1aaaaaaaaaaaaaaaabaaaaaaaaaaaaaaaaaaaaaaa3aaaaaaaaaaaaaaaabaaaaaaaaaaaaaaaaaaaaaaaaaaaa3aaacombine(magg, me, mask, index2field, num_fields_set, k);
if (rc)
goto error;
}
if (me->mask_by_mask == NULL)
aaaaa1aaaaaaaaaaaaaaaabaaaaaaaaaaaaaaaaaaaaaaa3aaaaaaaaaaaaaaaabaaaaaaaaaaaaaaaaaaaaaaaaaaaa3bbbbbbbbbbbbbbbbbbbbbbbbbbbbbbbb3aaa(magg, me, &mask_template);
MH_SORT(me->mask_by_mask, aaaaa1aaaaaaaaaaaaaaaabaaaaaaaaaaaaaaaaaaaaaaa3aaaaaaaaaaaaaaaabaaaaaaaaaaaaaaaaaaaaaaaaaaaa3aaasort);
return 0;
error:
aaaaa1aaaaaaaaaaaaaaaabaaaaaaaaaaaaaaaaaaaaaaa3aaaaaaaaaaaaaaaabaaaaaaaaaaaaaaaaaaaaaaaaaaaa3aaaaaaaaaaaaaaaabaaaaaaaaaaaaaaaaaaaaaaaaa4aaaaaaaaaaaaaaaabaaaaaaaaaaaaaaaaaaaaaaaaaaaa4aaaaaaaaaaaabaaaaaaaaaa5aaa(magg, me);
return rc;
}
int
aaaaa1aaaaaaaaaaaaaaaabaaaaaaaaaaaaaaaaaaaaaaa3aaaaaaaaaaaaaaaabaaaaaaaaaaaaaaaaaaaaaaaaaaaa3aaaaaaaaaaaaaaaabaaaaaaaaaaaaaaaaaaaaaaaaa4aaaaaaaaaaaaaaaabaaaaaaaaaaaaaaaaaaaaaaaaaaaa4aaaaaaaaaaaabaaaaaaaaaa5aaa(struct tcam *magg, struct aaaaa1aaaaaaaaaaaabaaaaaaaaaaa3aaa *me)
{
(void) magg;
struct aaaaa1aaaaaaaaaaaaaaaabaaaaaaaaaaaaaaaaaaaaaaa3aaaaaaaaaaaaaaaabaaaaaaaaaaaaaaaaaaaaaaaaaaaa3aaaaaaaaaaaabaaaaaaaaaa4aaa *mfh, *mfh_tmp;
MH_ITER(mh_handle, me->mask_by_mask, mfh, mfh_tmp)
{
cam_free_func free_function = a1aaaaaaaaaaaaaaaabaaaaaaaaaaaa3aaaaaaaaaaaaaaaabaaaaaaaaaaaaaaaaaaaaaaaaaaaa3aaaaaaaaaaaaaabaaaaaaaaaaaa4aaaaaaaaaaaaaaaabaaaaaaaaaaaaaaaaaaaaaaaaaaaa4aaaaaaaaaaaaaaaabaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaa4aaa((a1aaat*) (magg->client));
MH_DELETE(mh_handle, me->mask_by_mask, mfh, free_function);
free_function(mfh);
}
me->mask_by_mask = NULL;
return 0;
}
int
aaaaa1aaaaaaaaaaaaaaaabaaaaaaaaaaaaaaaaaaaaaaa3aaaaaaaaaaaaaaaabaaaaaaaaaaaaaaaaaaaaaaaaaaaa3aaaaaaaaaaaabaaaaaaaaaa4aaaaaaaaaaaaaaaabaaaaaaaaaaaaaaaaaaaaaaaaaaaa4aaaaaaaaaaaaaaabaaaaaaaaaaaa5aaaaaaaaaaaaaaaabaaaaaaaaaaaaaaaaaaaaaaaaaaaa5aaamember(struct tcam *magg, struct aaaaa1aaaaaaaaaaaaaaaabaaaaaaaaaaaaaaaaaaaaaaa3aaa *mask,
struct aaaaa1aaaaaaaaaaaabaaaaaaaaaaa3aaa *me)
{
(void) magg;
struct aaaaa1aaaaaaaaaaaaaaaabaaaaaaaaaaaaaaaaaaaaaaa3aaaaaaaaaaaaaaaabaaaaaaaaaaaaaaaaaaaaaaaaaaaa3aaaaaaaaaaaabaaaaaaaaaa4aaa *mfh;
assert(me->mask_by_mask);
MH_FIND(mh_handle, me->mask_by_mask, mask, sizeof(struct aaaaa1aaaaaaaaaaaaaaaabaaaaaaaaaaaaaaaaaaaaaaa3aaa), mfh);
return mfh != NULL;
}
int
aaaaa1aaaaaaaaaaaaaaaabaaaaaaaaaaaaaaaaaaaaaaa3aaaaaaaaaaaaaaaabaaaaaaaaaaaaaaaaaaaaaaaaaaaa3aaaaaaaaaaaabaaaaaaaaaa4aaaaaaaaaaaaaaaabaaaaaaaaaaaaaaaaaaaaaaaaaaaa4aaavalue(struct aaaaa1aaaaaaaaaaaaaaaabaaaaaaaaaaaaaaaaaaaaaaa3aaa *mask)
{
uint32_t num_bkts = 1;
uint32_t hashv;
uint32_t bkt;
murmur3_bucket(mask, sizeof(struct aaaaa1aaaaaaaaaaaaaaaabaaaaaaaaaaaaaaaaaaaaaaa3aaa), num_bkts, &hashv, &bkt);
bkt--;
return hashv;
}
int
aaaaa1aaaaaaaaaaaaaaaabaaaaaaaaaaaaaaaaaaaaaaa3aaaaaaaaaaaaaaaabaaaaaaaaaaaaaaaaaaaaaaaaaaaa3aaaaaaaaaaaaaaaabaaaaaaaaaaaa4aaaaaaaaaaaaaaaabaaaaaaaaaaaaaaaaaaaaaaaaaaaa4aaainstance(struct tcam *magg, struct aaaaa1aaaaaaaaaaaaaaaabaaaaaaaaaaaaaaaaaaaaaaa3aaa *mask,
uint8_t * instance)
{
int i;
struct aaaaa1aaaaaaaaaaaaaaaabaaaaaaaaaaaaaaaaaaaaaaa3aaaaaaaaaaaaaaaabaaaaaaaaaaaaaaaaaaaaaaaaaaaa3aaainstance *mai;
cam_calloc_func calloc_function = a1aaaaaaaaaaaaaaaabaaaaaaaaaaaa3aaaaaaaaaaaaaaaabaaaaaaaaaaaaaaaaaaaaaaaaaaaa3aaacalloc_function(magg->client);
MH_FIND(mh_handle, magg->mask_instances_by_mask, mask, sizeof(*mask), mai);
if (mai == NULL) {
mai = calloc_function(1, sizeof(*mai));
if (mai == NULL)
return CAM_ERROR_NOMEM;
mai->mask = *mask;
cam_free_func free_function = a1aaaaaaaaaaaaaaaabaaaaaaaaaaaa3aaaaaaaaaaaaaaaabaaaaaaaaaaaaaaaaaaaaaaaaaaaa3aaaaaaaaaaaaaabaaaaaaaaaaaa4aaaaaaaaaaaaaaaabaaaaaaaaaaaaaaaaaaaaaaaaaaaa4aaaaaaaaaaaaaaaabaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaa4aaa((a1aaat*) (magg->client));
cam_malloc_func malloc_function = a1aaaaaaaaaaaaaaaabaaaaaaaaaaaa3aaaaaaaaaaaaaaaabaaaaaaaaaaaaaaaaaaaaaaaaaaaa3aaamalloc_function((a1aaat*) (magg->client));
MH_ADD(mh_handle, magg->mask_instances_by_mask, mask, sizeof(*mask), mai, free_function, malloc_function);
}
for (i = 0; i < aaaaa1aaaaaaaaaaaaaaaabaaaaaaaaaaaaaaaaaaaaaaa3aaaaaaaaaaaaaaaabaaaaaaaaaaaaaaaaaaaaaaaaaaaa3aaaRESVD_INSTANCE; i++) {
if ((mai->instances[i / 8] & (1 << i % 8)) == 0) {
mai->instances[i / 8] |= 1 << i % 8;
*instance = i;
if (magg->debug_mask & aaaaa1bbbbbbbbbbbbbbbbbbbbbbbbbbbbbbbbbbbbb3aaaaaaaaaaaaaaaabaaaaaaaaaaaaaaaaaaaaaaaaaaaa4aaaINSTANCE)
               printf("MASK INST GET %p hash %x instance %u\n", mask,
aaaaa1aaaaaaaaaaaaaaaabaaaaaaaaaaaaaaaaaaaaaaa3aaaaaaaaaaaaaaaabaaaaaaaaaaaaaaaaaaaaaaaaaaaa3aaaaaaaaaaaabaaaaaaaaaa4aaaaaaaaaaaaaaaabaaaaaaaaaaaaaaaaaaaaaaaaaaaa4aaavalue(mask), *instance);
return 0;
}
}
return CAM_ERROR_TOO_MANY_INSTANCES;
error:;
cam_free_func free_function = a1aaaaaaaaaaaaaaaabaaaaaaaaaaaa3aaaaaaaaaaaaaaaabaaaaaaaaaaaaaaaaaaaaaaaaaaaa3aaaaaaaaaaaaaabaaaaaaaaaaaa4aaaaaaaaaaaaaaaabaaaaaaaaaaaaaaaaaaaaaaaaaaaa4aaaaaaaaaaaaaaaabaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaa4aaa((a1aaat*) (magg->client));
free_function(mai);
return CAM_ERROR_NOMEM;
}
int
aaaaa1aaaaaaaaaaaaaaaabaaaaaaaaaaaaaaaaaaaaaaa3aaaaaaaaaaaaaaaabaaaaaaaaaaaaaaaaaaaaaaaaaaaa3aaaput_instance(struct tcam *magg, struct aaaaa1aaaaaaaaaaaaaaaabaaaaaaaaaaaaaaaaaaaaaaa3aaa *mask,
uint8_t instance)
{
struct aaaaa1aaaaaaaaaaaaaaaabaaaaaaaaaaaaaaaaaaaaaaa3aaaaaaaaaaaaaaaabaaaaaaaaaaaaaaaaaaaaaaaaaaaa3aaainstance *mai;
if (magg->debug_mask & aaaaa1bbbbbbbbbbbbbbbbbbbbbbbbbbbbbbbbbbbbb3aaaaaaaaaaaaaaaabaaaaaaaaaaaaaaaaaaaaaaaaaaaa4aaaINSTANCE)
       printf("MASK INST PUT %p hash %x instance %u\n", mask,
aaaaa1aaaaaaaaaaaaaaaabaaaaaaaaaaaaaaaaaaaaaaa3aaaaaaaaaaaaaaaabaaaaaaaaaaaaaaaaaaaaaaaaaaaa3aaaaaaaaaaaabaaaaaaaaaa4aaaaaaaaaaaaaaaabaaaaaaaaaaaaaaaaaaaaaaaaaaaa4aaavalue(mask), instance);
MH_FIND(mh_handle, magg->mask_instances_by_mask, mask, sizeof(*mask), mai);
assert(mai != NULL);
assert((mai->instances[instance / 8] & (1 << instance % 8)) != 0);
mai->instances[instance / 8] &= ~(1 << instance % 8);
return 0;
}
int
aaaaa1aaaaaaaaaaaaaaaabaaaaaaaaaaaaaaaaaaaaaaa3aaaaaaaaaaaaaaaabaaaaaaaaaaaaaaaaaaaaaaaaaaaa3aaaaaaaaaaaaaabaaaaaaaaaaaa4aaaaaaaaaaaaaaaabaaaaaaaaaaaaaaaaaaaaaaaaaaaa4aaainstances(struct tcam *magg)
{
struct aaaaa1aaaaaaaaaaaaaaaabaaaaaaaaaaaaaaaaaaaaaaa3aaaaaaaaaaaaaaaabaaaaaaaaaaaaaaaaaaaaaaaaaaaa3aaainstance *mai, *mai_tmp;
MH_ITER(mh_handle, magg->mask_instances_by_mask, mai, mai_tmp)
{
cam_free_func free_function = a1aaaaaaaaaaaaaaaabaaaaaaaaaaaa3aaaaaaaaaaaaaaaabaaaaaaaaaaaaaaaaaaaaaaaaaaaa3aaaaaaaaaaaaaabaaaaaaaaaaaa4aaaaaaaaaaaaaaaabaaaaaaaaaaaaaaaaaaaaaaaaaaaa4aaaaaaaaaaaaaaaabaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaa4aaa((a1aaat*) (magg->client));
MH_DELETE(mh_handle, magg->mask_instances_by_mask, mai, free_function);
free_function(mai);
}
return 0;
}
void
aaaaa1aaaaaaaaaaaaaaaabaaaaaaaaaaaaaaaaaaaaaaa3aaaaaaaaaaaaaaaabaaaaaaaaaaaaaaaaaaaaaaaaaaaa3aaaaaaaaaaaaaaaabaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaa3aaa(struct tcam *magg, struct aaaaa1aaaaaaaaaaaaaaaabaaaaaaaaaaaaaaaaaaaaaaa3aaa *mask, int indent)
{
int i;
   printf("%*cM %x : ", indent, ' ', mask->use_range);
for (i = 0; i < sizeof(aaaaaaaaaaaaa1aaat); i++) {
       printf("%02x ", *(((char *) &mask->mask.word[0]) + i) & 0xff);
if (i && (i + 1) % 8 == 0)
           printf(": ");
}
   printf("\n");
}
int
aaaaa1aaaaaaaaaaaaaaaabaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaa3aaaaaaaaaaaaaaaabaaaaaaaaaaaaaaaaaaaaaaaaaaaa4bbbbbbbbbbbbbbbbbbbbbbbbbbbbbbbbbbbbbbb4aaaeate(struct tcam *magg, struct aaaaa1aaaaaaaaaaaaaaaabaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaa3aaa *problem)
{
(void) magg;
memset(problem, 0, sizeof(*problem));
return 0;
}
int
aaaaa1aaaaaaaaaaaaaaaabaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaa3aaaaaaaaaaaaaaaabaaaaaaaaaaaaaaaaaaaaaaaaaaaa4aaaaaaaaaaaaaaaabaaaaaaaaaaaaaaaaaaaaaaaaa5aaa(struct tcam *magg, struct aaaaa1aaaaaaaaaaaaaaaabaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaa3aaa *problem)
{
int rc;
struct aaaaa1aaaaaaaaaaaabaaaaaaaaaaa3bbbbbbbbbbbbbbbbbb3aaa *mes, *tmp;
LIST_FOREACH_SAFE2(problem->entryset_by_mask, mes, tmp, mh_handle.next)
{
rc = aaaaa1aaaaaaaaaaaabaaaaaaaaaaa3bbbbbbbbbbbbbbbbbb3aaaaaaaaaaaaaaaabaaaaaaaaaaaaaaaaaaaaaaaaaaaa4aaaaaaaaaaaaaaaabaaaaaaaaaaaaaaaaaaaaaaaaa5aaa(magg, problem, mes);
if (rc)
return rc;
}
return 0;
}
int
aaaaa1aaaaaaaaaaaaaaaabaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaa3aaaaaaaaaaaaaaaabaaaaaaaaaaaaaaaaaaaaaaaaaaaa4bbbbbbbbbbbbbbbbbbbbbbbbbbbbbbbb4aaa(struct tcam *magg, struct aaaaa1aaaaaaaaaaaaaaaabaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaa3aaa *problem,
struct aaaaa1aaaaaaaaaaaabaaaaaaaaaaa3aaa *me)
{
int rc;
if (problem->is_solved) {
rc = aaaaa1aaaaaaaaaaaabaaaaaaaaaaa3bbbbbbbbbbbbbbbbbb3aaaaaaaaaaaaaaaabaaaaaaaaaaaaaaaaaaaaaaaaaaaa4bbbbbbbbbbbbbbbbbbbbbbbbbbbbbbbb4aaaaaaaaaaaaaaaabaaaaaaaaaaaaaaaaaaaaaaaaaaaa5aaasolved(magg, problem, me);
if (rc)
return rc;
} else {
rc = aaaaa1aaaaaaaaaaaabaaaaaaaaaaa3bbbbbbbbbbbbbbbbbb3aaaaaaaaaaaaaaaabaaaaaaaaaaaaaaaaaaaaaaaaaaaa4bbbbbbbbbbbbbbbbbbbbbbbbbbbbbbbb4aaaaaaaaaaaaaaaabaaaaaaaaaaaaaaaaaaaaaaaaaaaa5aaaopen(magg, problem, me);
if (rc)
return rc;
}
return 0;
}
int
aaaaa1aaaaaaaaaaaaaaaabaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaa3aaaaaaaaaaaaaaaabaaaaaaaaaaaaaaaaaaaaaaaaaaaa4aaaaaaaaaaaaaaaabaaaaaaaaaaaaaaaaaaa5aaa(struct tcam *magg, struct aaaaa1aaaaaaaaaaaaaaaabaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaa3aaa *problem,
struct aaaaa1aaaaaaaaaaaabaaaaaaaaaaa3aaa *me)
{
int rc;
if (problem->is_solved) {
rc = aaaaa1aaaaaaaaaaaabaaaaaaaaaaa3bbbbbbbbbbbbbbbbbb3aaaaaaaaaaaaaaaabaaaaaaaaaaaaaaaaaaaaaaaaaaaa4aaaaaaaaaaaaaaaabaaaaaaaaaaaaaaaaaaa5aaaaaaaaaaaaaaaabaaaaaaaaaaaaaaaaaaaaaaaaaaaa5aaasolved(magg, problem, me);
if (rc)
return rc;
} else {
rc = aaaaa1aaaaaaaaaaaabaaaaaaaaaaa3bbbbbbbbbbbbbbbbbb3aaaaaaaaaaaaaaaabaaaaaaaaaaaaaaaaaaaaaaaaaaaa4aaaaaaaaaaaaaaaabaaaaaaaaaaaaaaaaaaa5aaaaaaaaaaaaaaaabaaaaaaaaaaaaaaaaaaaaaaaaaaaa5aaaopen(magg, problem, me);
if (rc)
return rc;
}
problem->num_entries--;
return 0;
}
int
aaaaa1aaaaaaaaaaaaaaaabaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaa3aaaaaaaaaaaaaaaabaaaaaaaaaaaaaaaaaaaaaaaaaaaa4aaareset(struct tcam *magg, struct aaaaa1aaaaaaaaaaaaaaaabaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaa3aaa *problem)
{
int rc;
struct aaaaa1aaaaaaaaaaaabaaaaaaaaaaa3aaa *me;
struct aaaaa1aaaaaaaaaaaabaaaaaaaaaaa3bbbbbbbbbbbbbbbbbb3aaa *mes;
assert(problem->is_solved == 0);
LIST_FOREACH2(problem->entryset_by_mask, mes, mh_handle.next)
{
rc = aaaaa1aaaaaaaaaaaabaaaaaaaaaaa3bbbbbbbbbbbbbbbbbb3aaaaaaaaaaaaaaaabaaaaaaaaaaaaaaaaaaaaaaaaaaaa4aaareset(magg, mes);
if (rc)
return rc;
}
LIST_FOREACH2(magg->entry_by_fields, me, mh_handle.next)
me->allocated = 0;
return 0;
}
int
aaaaa1aaaaaaaaaaaaaaaabaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaa3aaaaaaaaaaaaaaaabaaaaaaaaaaaaaaaaaaaaaaaaaaaa4aaawinner(struct tcam *magg, struct aaaaa1aaaaaaaaaaaaaaaabaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaa3aaa *problem,
struct aaaaa1aaaaaaaaaaaabaaaaaaaaaaa3bbbbbbbbbbbbbbbbbb3aaa **out_mes)
{
struct aaaaa1aaaaaaaaaaaabaaaaaaaaaaa3bbbbbbbbbbbbbbbbbb3aaa *mes;
*out_mes = NULL;
uint32_t max_weight = 0;
uint16_t max_pop = 0;
LIST_FOREACH2(problem->entryset_by_mask, mes, mh_handle.next)
{
if (mes->remaining_weight < max_weight)
continue;
if (mes->remaining_weight == max_weight) {
const uint16_t max_entries_per_unit = a1aaaaaaaaaaaaaaaabaaaaaaaaaaaa3aaaaaaaaaaaaaaaabaaaaaaaaaaaaaaaaaaaaaaaaaaaa3aaaaaaaaaaaaaaabaaaaaaaaaaaaaaaa4aaaaaaaaaaaaaaaabaaaaaaaaaaaaaaaaaaaaaaaaaaaa4aaaaaaaaaaaaaaaabaaaaaaaaaaaaaaaaaaaaa5aaaaaaaaaaaaaaaabaaaaaaaaaaaaaaaaaaaaaaaaaaaa5aaaper_unit(magg->client);
if (mes->remaining_weight > max_entries_per_unit &&
mes->mask.max_pop >= max_pop)
continue;
if (mes->remaining_weight < max_entries_per_unit &&
mes->mask.max_pop <= max_pop)
continue;
}
*out_mes = mes;
max_weight = mes->remaining_weight;
max_pop = mes->mask.max_pop;
}
return 0;
}
int
aaaaa1aaaaaaaaaaaaaaaabaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaa3aaaaaaaaaaaaaaaabaaaaaaaaaaaaaaaaaaaaaaaaaaaa4aaareduce(struct tcam *magg, struct aaaaa1aaaaaaaaaaaaaaaabaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaa3aaa *problem,
struct aaaaa1aaaaaaaaaaaabaaaaaaaaaaa3aaa *me)
{
(void) problem;
struct aaaaa1bbbbbbbbbbbbbbbbbbbbbbbbbbbbbbbbb3aaa **collsetp;
struct aaaaa1aaaaaaaaaaaabaaaaaaaaaaa3bbbbbbbbbbbbbbbbbb3aaa *mes;
for (collsetp = (struct aaaaa1bbbbbbbbbbbbbbbbbbbbbbbbbbbbbbbbb3aaa **) array_front(me->collsets);
collsetp;
collsetp =
(struct aaaaa1bbbbbbbbbbbbbbbbbbbbbbbbbbbbbbbbb3aaa **) array_next(me->collsets, collsetp)) {
mes = (*collsetp)->entryset;
mes->remaining_entries--;
(*collsetp)->remaining_entries--;
if ((*collsetp)->remaining_entries < magg->max_num_collisions)
mes->remaining_weight -= aaaaa1bbbbbbbbbbbbbbbbbbbbbbbbbbbbbbbbb3aaaaaaaaaaaaaaaabaaaaaaaaaaaaaaaaaaaaaaaaaaaa4aaaWEIGHT;
}
return 0;
}
int
aaaaa1aaaaaaaaaaaaaaaabaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaa3aaaaaaaaaaaaaaaabaaaaaaaaaaaaaaaaaaaaaaaaaaaa4aaaaaaaaaaaaaaaabaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaa4aaaaaaaaaaaaaaaabaaaaaaaaaaaaaaaaaaaaaaaaaaaa5aaasort(void *a, void *b)
{
struct aaaaa1aaaaaaaaaaaabaaaaaaaaaaa3bbbbbbbbbbbbbbbbbb3aaa *ma = (struct aaaaa1aaaaaaaaaaaabaaaaaaaaaaa3bbbbbbbbbbbbbbbbbb3aaa *) a;
struct aaaaa1aaaaaaaaaaaabaaaaaaaaaaa3bbbbbbbbbbbbbbbbbb3aaa *mb = (struct aaaaa1aaaaaaaaaaaabaaaaaaaaaaa3bbbbbbbbbbbbbbbbbb3aaa *) b;
if (ma->weight < mb->weight)
return 1;
if (ma->weight > mb->weight)
return -1;
return 0;
}
int
aaaaa1aaaaaaaaaaaaaaaabaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaa3aaaaaaaaaaaaaaaabaaaaaaaaaaaaaaaaaaaaaaaaaaaa4aaaaaaaaaaaaaaaabaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaa4aaa(struct tcam *magg, struct aaaaa1aaaaaaaaaaaaaaaabaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaa3aaa *problem,
int indent)
{
   printf("%*caaaaa1aaaaaaaaaaaaaaaabaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaa3aaa %p is_solved %u num_entries %u\n", indent, ' ',
problem, problem->is_solved, problem->num_entries);
if (!(magg->debug_mask & aaaaa1aaaaaaaaaaaaaaaabaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaa3aaaaaaaaaaaaaaaabaaaaaaaaaaaaaaaaaaaaaaaaaaaa4aaaaaaaaaaaabaaaaaaaaaaa5bbbbbbbbbbbbbbbbbb5aaa))
return 0;
MH_SORT(problem->entryset_by_mask, aaaaa1aaaaaaaaaaaaaaaabaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaa3aaaaaaaaaaaaaaaabaaaaaaaaaaaaaaaaaaaaaaaaaaaa4aaaaaaaaaaaaaaaabaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaa4aaaaaaaaaaaaaaaabaaaaaaaaaaaaaaaaaaaaaaaaaaaa5aaasort);
struct aaaaa1aaaaaaaaaaaabaaaaaaaaaaa3bbbbbbbbbbbbbbbbbb3aaa *mes;
LIST_FOREACH2(problem->entryset_by_mask, mes, mh_handle.next)
aaaaa1aaaaaaaaaaaabaaaaaaaaaaa3bbbbbbbbbbbbbbbbbb3aaaaaaaaaaaaaaaabaaaaaaaaaaaaaaaaaaaaaaaaaaaa4aaaaaaaaaaaaaaaabaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaa4aaa(magg, mes, indent + 2);
return 0;
}
int
aaaaa1aaaaaaaaaaaaaaaabaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaa3aaaaaaaaaaaaaaaabaaaaaaaaaaaaaaaaaaaaaaaaaaaa4bbbbbbbbbbbbbbbbbbbbbbbbbbbbbbbbbbbbbbb4aaaeate(struct tcam *magg, struct aaaaa1aaaaaaaaaaaaaaaabaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaa3aaa **out_probsol)
{
int rc;
struct aaaaa1aaaaaaaaaaaaaaaabaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaa3aaa *probsol;
cam_calloc_func calloc_function = a1aaaaaaaaaaaaaaaabaaaaaaaaaaaa3aaaaaaaaaaaaaaaabaaaaaaaaaaaaaaaaaaaaaaaaaaaa3aaacalloc_function((a1aaat*) (magg->client));
probsol = calloc_function(1, sizeof(*probsol));
if (probsol == NULL)
return CAM_ERROR_NOMEM;
rc = aaaaa1aaaaaaaaaaaaaaaabaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaa3aaaaaaaaaaaaaaaabaaaaaaaaaaaaaaaaaaaaaaaaaaaa4bbbbbbbbbbbbbbbbbbbbbbbbbbbbbbbbbbbbbbb4aaaeate(magg, &probsol->problem);
if (rc)
goto error;
rc = aaaaa1bbbbbbbbbbbbbbbbbbbbbbbbbb3aaaaaaaaaaaaaaaabaaaaaaaaaaaaaaaaaaaaaaaaaaaa4bbbbbbbbbbbbbbbbbbbbbbbbbbbbbbbbbbbbbbb4aaaeate(magg, &probsol->curr_solution);
if (rc)
goto error;
*out_probsol = probsol;
return 0;
error:;
cam_free_func free_function = a1aaaaaaaaaaaaaaaabaaaaaaaaaaaa3aaaaaaaaaaaaaaaabaaaaaaaaaaaaaaaaaaaaaaaaaaaa3aaaaaaaaaaaaaabaaaaaaaaaaaa4aaaaaaaaaaaaaaaabaaaaaaaaaaaaaaaaaaaaaaaaaaaa4aaaaaaaaaaaaaaaabaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaa4aaa((a1aaat*) (magg->client));
free_function(probsol);
return rc;
}
int
aaaaa1aaaaaaaaaaaaaaaabaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaa3aaaaaaaaaaaaaaaabaaaaaaaaaaaaaaaaaaaaaaaaaaaa4aaaaaaaaaaaaaaaabaaaaaaaaaaaaaaaaaaaaaaaaa5aaa(struct tcam *magg, struct aaaaa1aaaaaaaaaaaaaaaabaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaa3aaa *probsol)
{
int rc;
cam_free_func free_function = a1aaaaaaaaaaaaaaaabaaaaaaaaaaaa3aaaaaaaaaaaaaaaabaaaaaaaaaaaaaaaaaaaaaaaaaaaa3aaaaaaaaaaaaaabaaaaaaaaaaaa4aaaaaaaaaaaaaaaabaaaaaaaaaaaaaaaaaaaaaaaaaaaa4aaaaaaaaaaaaaaaabaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaa4aaa((a1aaat*) (magg->client));
rc = aaaaa1bbbbbbbbbbbbbbbbbbbbbbbbbb3aaaaaaaaaaaaaaaabaaaaaaaaaaaaaaaaaaaaaaaaaaaa4aaaaaaaaaaaaaaaabaaaaaaaaaaaaaaaaaaaaaaaaa5aaa(magg, &probsol->curr_solution);
if (rc)
return rc;
rc = aaaaa1aaaaaaaaaaaaaaaabaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaa3aaaaaaaaaaaaaaaabaaaaaaaaaaaaaaaaaaaaaaaaaaaa4aaaaaaaaaaaaaaaabaaaaaaaaaaaaaaaaaaaaaaaaa5aaa(magg, &probsol->problem);
if (rc)
return rc;
free_function(probsol);
return 0;
}
static int
aaaaa1aaaaaaaaaaaaaaaabaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaa3aaaaaaaaaaaaaaaabaaaaaaaaaaaaaaaaaaaaaaaaaaaa4aaaopen2solved(struct tcam *magg,
struct aaaaa1aaaaaaaaaaaaaaaabaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaa3aaa *open,
struct aaaaa1aaaaaaaaaaaaaaaabaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaa3aaa *solved,
struct aaaaa1aaaaaaaaaaaabaaaaaaaaaaa3bbbbbbbbbbbbbbbbbb3aaaaaaaaaaaaaaaabaaaaaaaaaaaaaaaaaaaaaaaaaaaa4aaaaaaaaaaaaabaaaaaaaaaaaaaaaaa5aaa *mesli)
{
int rc;
struct aaaaa1aaaaaaaaaaaabaaaaaaaaaaa3bbbbbbbbbbbbbbbbbb3aaa *mes;
struct aaaaa1aaaaaaaaaaaabaaaaaaaaaaa3aaaaaaaaaaaaaaaabaaaaaaaaaaaaaaaaaaaaaaaaaaaa3aaaaaaaaaaaaabaaaaaaaaaaaaaaaaa4aaa *meli;
magg->stats.curr_closed_masks++;
magg->stats.max_closed_masks = MAX(magg->stats.curr_closed_masks, magg->stats.max_closed_masks);
magg->stats.curr_open_masks = magg->num_masks - magg->stats.curr_closed_masks;
rc = aaaaa1aaaaaaaaaaaabaaaaaaaaaaa3bbbbbbbbbbbbbbbbbb3aaaaaaaaaaaaaaaabaaaaaaaaaaaaaaaaaaaaaaaaaaaa4bbbbbbbbbbbbbbbbbbbbbbbbbbbbbbbbbbbbbbb4aaaeate(magg, &solved->problem,
&mesli->entryset->mask, &mes);
if (rc)
return rc;
if (magg->debug_mask & aaaaa1bbbbbbbbbbbbbbbbbbbbbbbbbbbbbbbbbbbbb3aaaaaaaaaaaaaaaabaaaaaaaaaaaaaaaaaaaaaaaaaaaa4aaaaaaaaaaaabaaaaaaaaaaa5bbbbbbbbbbbbbbbbbb5aaa) {
       printf("MASK open -> solved from %p to %p hash %x instance %u num_entries %u\n",
&mesli->entryset->mask, &mes->mask,
aaaaa1aaaaaaaaaaaaaaaabaaaaaaaaaaaaaaaaaaaaaaa3aaaaaaaaaaaaaaaabaaaaaaaaaaaaaaaaaaaaaaaaaaaa3aaaaaaaaaaaabaaaaaaaaaa4aaaaaaaaaaaaaaaabaaaaaaaaaaaaaaaaaaaaaaaaaaaa4aaavalue(&mes->mask), mesli->instance,
mesli->num_entries);
aaaaa1aaaaaaaaaaaaaaaabaaaaaaaaaaaaaaaaaaaaaaa3aaaaaaaaaaaaaaaabaaaaaaaaaaaaaaaaaaaaaaaaaaaa3aaaaaaaaaaaaaaaabaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaa3aaa(magg, &mes->mask, 2);
}
mesli->entryset = mes;
LIST_FOREACH(mesli->entry_list, meli)
{
rc = aaaaa1aaaaaaaaaaaaaaaabaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaa3aaaaaaaaaaaaaaaabaaaaaaaaaaaaaaaaaaaaaaaaaaaa4aaaaaaaaaaaaaaaabaaaaaaaaaaaaaaaaaaa5aaa(magg, &open->problem, meli->entry);
if (rc)
return rc;
rc = aaaaa1aaaaaaaaaaaabaaaaaaaaaaa3bbbbbbbbbbbbbbbbbb3aaaaaaaaaaaaaaaabaaaaaaaaaaaaaaaaaaaaaaaaaaaa4bbbbbbbbbbbbbbbbbbbbbbbbbbbbbbbb4aaa(magg, &solved->problem, mes, meli->entry);
if (rc)
return rc;
solved->problem.num_entries++;
meli->entry->current_entryset.mes = mes;
}
LIST_DELETE(open->curr_solution.mask_list, mesli);
open->curr_solution.num_masks--;
LIST_APPEND(solved->curr_solution.mask_list, mesli);
solved->curr_solution.num_masks++;
return 0;
}
static int
aaaaa1aaaaaaaaaaaaaaaabaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaa3aaaaaaaaaaaaaaaabaaaaaaaaaaaaaaaaaaaaaaaaaaaa4aaaaaaaaaaaabaaaaaaaaaaa5aaa2solved(struct tcam *magg,
struct aaaaa1aaaaaaaaaaaabaaaaaaaaaaa3aaa *me,
struct aaaaa1aaaaaaaaaaaaaaaabaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaa3aaa *open,
struct aaaaa1aaaaaaaaaaaaaaaabaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaa3aaa *solved)
{
int rc;
struct aaaaa1aaaaaaaaaaaabaaaaaaaaaaa3bbbbbbbbbbbbbbbbbb3aaaaaaaaaaaaaaaabaaaaaaaaaaaaaaaaaaaaaaaaaaaa4aaaaaaaaaaaaabaaaaaaaaaaaaaaaaa5aaa *mesli;
rc = aaaaa1aaaaaaaaaaaaaaaabaaaaaaaaaaaaaaaaaaaaaaa3aaaaaaaaaaaaaaaabaaaaaaaaaaaaaaaaaaaaaaaaaaaa3bbbbbbbbbbbbbbbbbbbbbbbbbbbbbbbbbbbbbbb3aaaeate_hash(magg, me);
if (rc)
return rc;
rc = aaaaa1bbbbbbbbbbbbbbbbbbbbbbbbbb3aaaaaaaaaaaaaaaabaaaaaaaaaaaaaaaaaaaaaaaaaaaa4aaafind_entryset(magg, solved, me, &mesli);
if (rc)
goto error;
if (mesli == NULL)
goto done;
rc = aaaaa1aaaaaaaaaaaabaaaaaaaaaaa3bbbbbbbbbbbbbbbbbb3aaaaaaaaaaaaaaaabaaaaaaaaaaaaaaaaaaaaaaaaaaaa4bbbbbbbbbbbbbbbbbbbbbbbbbbbbbbbb4aaa(magg, &solved->problem, mesli->entryset, me);
if (rc)
goto error;
solved->problem.num_entries++;
struct aaaaa1aaaaaaaaaaaabaaaaaaaaaaa3bbbbbbbbbbbbbbbbbb3aaa *prev_mes = me->current_entryset.mes;
uint8_t prev_instance = me->current_entryset.instance;
rc = aaaaa1bbbbbbbbbbbbbbbbbbbbbbbbbb3aaaaaaaaaaaaaaaabaaaaaaaaaaaaaaaaaaaaaaaaaaaa4bbbbbbbbbbbbbbbbbbbbbbbbbbbbbbbb4aaa(magg, mesli, me);
if (rc)
goto error;
rc = aaaaa1aaaaaaaaaaaaaaaabaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaa3aaaaaaaaaaaaaaaabaaaaaaaaaaaaaaaaaaaaaaaaaaaa4aaaaaaaaaaaaaaaabaaaaaaaaaaaaaaaaaaa5aaa(magg, me, prev_mes, prev_instance);
if (rc)
goto error;
struct aaaaa1aaaaaaaaaaaabaaaaaaaaaaa3bbbbbbbbbbbbbbbbbb3aaaaaaaaaaaaaaaabaaaaaaaaaaaaaaaaaaaaaaaaaaaa4aaaaaaaaaaaaabaaaaaaaaaaaaaaaaa5aaa *prev_mesli;
rc = aaaaa1bbbbbbbbbbbbbbbbbbbbbbbbbb3aaaaaaaaaaaaaaaabaaaaaaaaaaaaaaaaaaaaaaaaaaaa4aaaaaaaaaaaaaaaabaaaaaaaaaaaaaaaaaaa5aaa(magg, &open->curr_solution, me, &prev_mesli);
if (rc)
goto error;
rc = aaaaa1aaaaaaaaaaaaaaaabaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaa3aaaaaaaaaaaaaaaabaaaaaaaaaaaaaaaaaaaaaaaaaaaa4aaaaaaaaaaaaaaaabaaaaaaaaaaaaaaaaaaa5aaa(magg, &open->problem, me);
if (rc)
goto error;
done:
error:
rc = aaaaa1aaaaaaaaaaaaaaaabaaaaaaaaaaaaaaaaaaaaaaa3aaaaaaaaaaaaaaaabaaaaaaaaaaaaaaaaaaaaaaaaaaaa3aaaaaaaaaaaaaaaabaaaaaaaaaaaaaaaaaaaaaaaaa4aaaaaaaaaaaaaaaabaaaaaaaaaaaaaaaaaaaaaaaaaaaa4aaaaaaaaaaaabaaaaaaaaaa5aaa(magg, me);
if (rc)
return rc;
return 0;
}
static int
aaaaa1aaaaaaaaaaaaaaaabaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaa3aaaaaaaaaaaaaaaabaaaaaaaaaaaaaaaaaaaaaaaaaaaa4aaaall_entries2solved(struct tcam *magg, struct aaaaa1aaaaaaaaaaaaaaaabaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaa3aaa *open,
struct aaaaa1aaaaaaaaaaaaaaaabaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaa3aaa *solved)
{
int rc;
struct aaaaa1aaaaaaaaaaaabaaaaaaaaaaa3aaaaaaaaaaaaaaaabaaaaaaaaaaaaaaaaaaaaaaaaaaaa3aaaaaaaaaaaaabaaaaaaaaaaaaaaaaa4aaa *meli, *meli_tmp;
struct aaaaa1aaaaaaaaaaaabaaaaaaaaaaa3bbbbbbbbbbbbbbbbbb3aaaaaaaaaaaaaaaabaaaaaaaaaaaaaaaaaaaaaaaaaaaa4aaaaaaaaaaaaabaaaaaaaaaaaaaaaaa5aaa *mesli, *mesli_tmp;
LIST_FOREACH_SAFE(open->curr_solution.mask_list, mesli, mesli_tmp)
{
LIST_FOREACH_SAFE(mesli->entry_list, meli, meli_tmp)
{
rc = aaaaa1aaaaaaaaaaaaaaaabaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaa3aaaaaaaaaaaaaaaabaaaaaaaaaaaaaaaaaaaaaaaaaaaa4aaaaaaaaaaaabaaaaaaaaaaa5aaa2solved(magg, meli->entry, open, solved);
if (rc)
return rc;
}
}
return 0;
}
static int
aaaaa1aaaaaaaaaaaaaaaabaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaa3aaaaaaaaaaaaaaaabaaaaaaaaaaaaaaaaaaaaaaaaaaaa4bbbbbbbbbbbbbbbbbbbbbbbbbbbbbbbb4aaaaaaaaaaaaaaaabaaaaaaaaaaaaaaaaaaaaaaaaaaaa5aaaopen(struct tcam *magg, struct aaaaa1aaaaaaaaaaaaaaaabaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaa3aaa *probsol,
struct aaaaa1aaaaaaaaaaaabaaaaaaaaaaa3bbbbbbbbbbbbbbbbbb3aaaaaaaaaaaaaaaabaaaaaaaaaaaaaaaaaaaaaaaaaaaa4aaaaaaaaaaaaabaaaaaaaaaaaaaaaaa5aaa *mesli,
struct aaaaa1aaaaaaaaaaaabaaaaaaaaaaa3aaa *me)
{
int rc;
struct aaaaa1aaaaaaaaaaaabaaaaaaaaaaa3bbbbbbbbbbbbbbbbbb3aaa *mes;
rc = aaaaa1aaaaaaaaaaaaaaaabaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaa3aaaaaaaaaaaaaaaabaaaaaaaaaaaaaaaaaaaaaaaaaaaa4bbbbbbbbbbbbbbbbbbbbbbbbbbbbbbbb4aaa(magg, &probsol->problem, me);
if (rc)
return rc;
probsol->problem.num_entries++;
if (mesli == NULL) {
MH_FIND(mh_handle, probsol->problem.entryset_by_mask, &me->mask_by_mask->mask, sizeof(struct aaaaa1aaaaaaaaaaaaaaaabaaaaaaaaaaaaaaaaaaaaaaa3aaa), mes);
assert(mes);
assert(me->mask_by_mask->mh_handle.prev == NULL);
rc = aaaaa1bbbbbbbbbbbbbbbbbbbbbbbbbb3aaaaaaaaaaaaaaaabaaaaaaaaaaaaaaaaaaaaaaaaaaaa4bbbbbbbbbbbbbbbbbbbbbbbbbbbbbbbb4aaaaaaaaaaaaaaaabaaaaaaaaaaaaaaaaaaaaaaaaaaaa5aaaaaaaaaaaabaaaaaaaaaaa6bbbbbbbbbbbbbbbbbb6aaa(magg, probsol, mes, &mesli);
if (rc)
return rc;
}
rc = aaaaa1bbbbbbbbbbbbbbbbbbbbbbbbbb3aaaaaaaaaaaaaaaabaaaaaaaaaaaaaaaaaaaaaaaaaaaa4bbbbbbbbbbbbbbbbbbbbbbbbbbbbbbbb4aaa(magg, mesli, me);
if (rc)
return rc;
if (mesli->num_entries == a1aaaaaaaaaaaaaaaabaaaaaaaaaaaa3aaaaaaaaaaaaaaaabaaaaaaaaaaaaaaaaaaaaaaaaaaaa3aaaaaaaaaaaaaaabaaaaaaaaaaaaaaaa4aaaaaaaaaaaaaaaabaaaaaaaaaaaaaaaaaaaaaaaaaaaa4aaaaaaaaaaaaaaaabaaaaaaaaaaaaaaaaaaaaa5aaaaaaaaaaaaaaaabaaaaaaaaaaaaaaaaaaaaaaaaaaaa5aaaper_unit(magg->client)) {
struct aaaaa1aaaaaaaaaaaaaaaabaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaa3aaa *solved;
rc = aaaaa1aaaaaaaaaaaaaaaabaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaa3aaaaaaaaaaaaaaaabaaaaaaaaaaaaaaaaaaaaaaaaaaaa4bbbbbbbbbbbbbbbbbbbbbbbbbbbbbbbbbbbbbbb4aaaeate(magg, &solved);
if (rc)
return rc;
solved->is_solved = 1;
solved->problem.is_solved = 1;
rc = aaaaa1aaaaaaaaaaaaaaaabaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaa3aaaaaaaaaaaaaaaabaaaaaaaaaaaaaaaaaaaaaaaaaaaa4aaaopen2solved(magg, probsol, solved, mesli);
if (rc)
return rc;
LIST_PREPEND_ELEM(magg->probsols, magg->open_probsol, solved);
}
return 0;
}
static int
aaaaa1aaaaaaaaaaaaaaaabaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaa3aaaaaaaaaaaaaaaabaaaaaaaaaaaaaaaaaaaaaaaaaaaa4bbbbbbbbbbbbbbbbbbbbbbbbbbbbbbbb4aaaaaaaaaaaaaaaabaaaaaaaaaaaaaaaaaaaaaaaaaaaa5aaasolved(struct tcam *magg, struct aaaaa1aaaaaaaaaaaaaaaabaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaa3aaa *probsol,
struct aaaaa1aaaaaaaaaaaabaaaaaaaaaaa3bbbbbbbbbbbbbbbbbb3aaaaaaaaaaaaaaaabaaaaaaaaaaaaaaaaaaaaaaaaaaaa4aaaaaaaaaaaaabaaaaaaaaaaaaaaaaa5aaa *mesli,
struct aaaaa1aaaaaaaaaaaabaaaaaaaaaaa3aaa *me)
{
int rc;
assert(mesli != NULL);
rc = aaaaa1aaaaaaaaaaaabaaaaaaaaaaa3bbbbbbbbbbbbbbbbbb3aaaaaaaaaaaaaaaabaaaaaaaaaaaaaaaaaaaaaaaaaaaa4bbbbbbbbbbbbbbbbbbbbbbbbbbbbbbbb4aaa(magg, &probsol->problem, mesli->entryset, me);
if (rc)
return rc;
probsol->problem.num_entries++;
rc = aaaaa1bbbbbbbbbbbbbbbbbbbbbbbbbb3aaaaaaaaaaaaaaaabaaaaaaaaaaaaaaaaaaaaaaaaaaaa4bbbbbbbbbbbbbbbbbbbbbbbbbbbbbbbb4aaa(magg, mesli, me);
if (rc)
return rc;
return 0;
}
static int
aaaaa1aaaaaaaaaaaaaaaabaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaa3aaaaaaaaaaaaaaaabaaaaaaaaaaaaaaaaaaaaaaaaaaaa4aaafind_best(struct tcam *magg, struct aaaaa1aaaaaaaaaaaabaaaaaaaaaaa3aaa *me,
struct aaaaa1aaaaaaaaaaaaaaaabaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaa3aaa **out_probsol,
struct aaaaa1aaaaaaaaaaaabaaaaaaaaaaa3bbbbbbbbbbbbbbbbbb3aaaaaaaaaaaaaaaabaaaaaaaaaaaaaaaaaaaaaaaaaaaa4aaaaaaaaaaaaabaaaaaaaaaaaaaaaaa5aaa **out_mesli)
{
int rc;
const uint8_t max_entries_per_unit_bits = 32
- __builtin_clz((uint32_t) a1aaaaaaaaaaaaaaaabaaaaaaaaaaaa3aaaaaaaaaaaaaaaabaaaaaaaaaaaaaaaaaaaaaaaaaaaa3aaaaaaaaaaaaaaabaaaaaaaaaaaaaaaa4aaaaaaaaaaaaaaaabaaaaaaaaaaaaaaaaaaaaaaaaaaaa4aaaaaaaaaaaaaaaabaaaaaaaaaaaaaaaaaaaaa5aaaaaaaaaaaaaaaabaaaaaaaaaaaaaaaaaaaaaaaaaaaa5aaaper_unit(magg->client));
int bits;
int64_t space_left;
int64_t best_space = -1;
int best_pop = -1;
struct aaaaa1aaaaaaaaaaaaaaaabaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaa3aaa *best_probsol = NULL;
struct aaaaa1aaaaaaaaaaaabaaaaaaaaaaa3bbbbbbbbbbbbbbbbbb3aaaaaaaaaaaaaaaabaaaaaaaaaaaaaaaaaaaaaaaaaaaa4aaaaaaaaaaaaabaaaaaaaaaaaaaaaaa5aaa *best_mesli = NULL;
struct aaaaa1aaaaaaaaaaaaaaaabaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaa3aaa *probsol;
LIST_FOREACH(magg->probsols, probsol)
{
struct aaaaa1aaaaaaaaaaaabaaaaaaaaaaa3bbbbbbbbbbbbbbbbbb3aaaaaaaaaaaaaaaabaaaaaaaaaaaaaaaaaaaaaaaaaaaa4aaaaaaaaaaaaabaaaaaaaaaaaaaaaaa5aaa *mesli;
rc = aaaaa1bbbbbbbbbbbbbbbbbbbbbbbbbb3aaaaaaaaaaaaaaaabaaaaaaaaaaaaaaaaaaaaaaaaaaaa4aaafind_entryset(magg, probsol, me, &mesli);
if (rc)
return rc;
if (mesli == NULL)
continue;
bits = MIN(mesli->entryset->mask.const_pop, max_entries_per_unit_bits) +
mesli->entryset->mask.max_pop;
if (bits > 62)
bits = 62;
space_left = ((int64_t) 1 << bits) - mesli->num_entries;
if (space_left > best_space ||
(space_left == best_space && mesli->entryset->mask.max_pop > best_pop)) {
best_mesli = mesli;
best_probsol = probsol;
best_pop = mesli->entryset->mask.max_pop;
best_space = space_left;
}
}
if (best_mesli) {
*out_probsol = best_probsol;
*out_mesli = best_mesli;
} else {
*out_probsol = NULL;
*out_mesli = NULL;
}
return 0;
}
int
aaaaa1aaaaaaaaaaaaaaaabaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaa3aaaaaaaaaaaaaaaabaaaaaaaaaaaaaaaaaaaaaaaaaaaa4aaacompare(const void* a, const void* b)
{
int int_a = * ( (int*) a );
int int_b = * ( (int*) b );
if (int_a == int_b)
return 0;
else if (int_a > int_b)
return -1;
else
return 1;
}
static int
aaaaa1aaaaaaaaaaaaaaaabaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaa3aaaaaaaaaaaaaaaabaaaaaaaaaaaaaaaaaaaaaaaaaaaa4aaatransform(struct tcam *magg, struct aaaaa1aaaaaaaaaaaaaaaabaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaa3aaa *open,
struct aaaaa1aaaaaaaaaaaaaaaabaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaa3aaa *solved, int force)
{
int rc;
struct aaaaa1aaaaaaaaaaaabaaaaaaaaaaa3bbbbbbbbbbbbbbbbbb3aaaaaaaaaaaaaaaabaaaaaaaaaaaaaaaaaaaaaaaaaaaa4aaaaaaaaaaaaabaaaaaaaaaaaaaaaaa5aaa *mesli, *mesli_tmp;
const uint16_t max_num_masks = a1aaaaaaaaaaaaaaaabaaaaaaaaaaaa3aaaaaaaaaaaaaaaabaaaaaaaaaaaaaaaaaaaaaaaaaaaa3aaaaaaaaaaaaaaabaaaaaaaaaaaaaaaa4aaaaaaaaaaaaaaaabaaaaaaaaaaaaaaaaaaaaaaaaaaaa4aaaaaaaaaaaabaaaaaaaaaaaaaaaaa5aaas(magg->client) - 1;
int max_entries[max_num_masks];
for (int i = 0; i < max_num_masks; i++)
max_entries[i] = 0;
int i = 0;
LIST_FOREACH_SAFE(open->curr_solution.mask_list, mesli, mesli_tmp)
{
max_entries[i] = mesli->num_entries;
i++;
}
qsort(max_entries, max_num_masks, sizeof(int), aaaaa1aaaaaaaaaaaaaaaabaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaa3aaaaaaaaaaaaaaaabaaaaaaaaaaaaaaaaaaaaaaaaaaaa4aaacompare);
const uint16_t max_entries_per_unit = a1aaaaaaaaaaaaaaaabaaaaaaaaaaaa3aaaaaaaaaaaaaaaabaaaaaaaaaaaaaaaaaaaaaaaaaaaa3aaaaaaaaaaaaaaabaaaaaaaaaaaaaaaa4aaaaaaaaaaaaaaaabaaaaaaaaaaaaaaaaaaaaaaaaaaaa4aaaaaaaaaaaaaaaabaaaaaaaaaaaaaaaaaaaaa5aaaaaaaaaaaaaaaabaaaaaaaaaaaaaaaaaaaaaaaaaaaa5aaaper_unit(magg->client);
if (max_entries[0] == max_entries_per_unit) {
force = 0;
} else if (max_entries[0] < max_entries_per_unit && force <= 0) {
return 0;
}
int delete_limit = force > 0 ? max_entries[force-1] : max_entries[0];
int delete_count = 0;
LIST_FOREACH_SAFE(open->curr_solution.mask_list, mesli, mesli_tmp)
{
#if 1
if (mesli->num_entries < delete_limit)
continue;
#endif
rc = aaaaa1aaaaaaaaaaaaaaaabaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaa3aaaaaaaaaaaaaaaabaaaaaaaaaaaaaaaaaaaaaaaaaaaa4aaaopen2solved(magg, open, solved, mesli);
if (rc)
return rc;
if (force > 0) {
delete_count++;
if (force == delete_count)
return 0;
}
}
return 0;
}
#ifdef aaaaa1bbbbbbbbbbbbbbbbbbbbbbbbbbbbbbbbbbbbbb3aaa
static int
aaaaa1aaaaaaaaaaaaaaaabaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaa3aaaaaaaaaaaaaaaabaaaaaaaaaaaaaaaaaaaaaaaaaaaa4aaafind_cuckoo(struct tcam *magg, struct aaaaa1aaaaaaaaaaaabaaaaaaaaaaa3aaa *me,
struct aaaaa1aaaaaaaaaaaaaaaabaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaa3aaa **out_probsol,
struct aaaaa1aaaaaaaaaaaabaaaaaaaaaaa3bbbbbbbbbbbbbbbbbb3aaaaaaaaaaaaaaaabaaaaaaaaaaaaaaaaaaaaaaaaaaaa4aaaaaaaaaaaaabaaaaaaaaaaaaaaaaa5aaa **out_mesli,
struct aaaaa1aaaaaaaaaaaabaaaaaaaaaaa3aaa **out_me)
{
int rc;
struct aaaaa1aaaaaaaaaaaabaaaaaaaaaaa3aaa *best_me = me;
struct aaaaa1aaaaaaaaaaaabaaaaaaaaaaa3bbbbbbbbbbbbbbbbbb3aaaaaaaaaaaaaaaabaaaaaaaaaaaaaaaaaaaaaaaaaaaa4aaaaaaaaaaaaabaaaaaaaaaaaaaaaaa5aaa *best_mesli = NULL;
struct aaaaa1aaaaaaaaaaaaaaaabaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaa3aaa *best_probsol = NULL;
int best_fields = __builtin_popcount(me->exact_mask.active_fields);
int best_max_pop = me->exact_mask.max_pop;
int best_tot_pop = me->exact_mask.tot_pop;
struct aaaaa1aaaaaaaaaaaaaaaabaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaa3aaa *probsol;
LIST_FOREACH(magg->probsols, probsol) {
if (!probsol->is_solved)
continue;
struct aaaaa1aaaaaaaaaaaabaaaaaaaaaaa3bbbbbbbbbbbbbbbbbb3aaaaaaaaaaaaaaaabaaaaaaaaaaaaaaaaaaaaaaaaaaaa4aaaaaaaaaaaaabaaaaaaaaaaaaaaaaa5aaa *mesli;
LIST_FOREACH(probsol->curr_solution.mask_list, mesli) {
if (mesli->num_entries != a1aaaaaaaaaaaaaaaabaaaaaaaaaaaa3aaaaaaaaaaaaaaaabaaaaaaaaaaaaaaaaaaaaaaaaaaaa3aaaaaaaaaaaaaaabaaaaaaaaaaaaaaaa4aaaaaaaaaaaaaaaabaaaaaaaaaaaaaaaaaaaaaaaaaaaa4aaaaaaaaaaaaaaaabaaaaaaaaaaaaaaaaaaaaa5aaaaaaaaaaaaaaaabaaaaaaaaaaaaaaaaaaaaaaaaaaaa5aaaper_unit(magg->client) ||
!aaaaa1aaaaaaaaaaaaaaaabaaaaaaaaaaaaaaaaaaaaaaa3aaaaaaaaaaaaaaaabaaaaaaaaaaaaaaaaaaaaaaaaaaaa3aaaaaaaaaaaabaaaaaaaaaa4aaaaaaaaaaaaaaaabaaaaaaaaaaaaaaaaaaaaaaaaaaaa4aaaaaaaaaaaaaaabaaaaaaaaaaaa5aaaaaaaaaaaaaaaabaaaaaaaaaaaaaaaaaaaaaaaaaaaa5aaamember(magg, &mesli->entryset->mask, me))
continue;
struct aaaaa1bbbbbbbbbbbbbbbbbbbbbbbbbbbbbbbbb3aaa *collset;
rc = aaaaa1bbbbbbbbbbbbbbbbbbbbbbbbbbbbbbbbb3aaaaaaaaaaaaaaaabaaaaaaaaaaaaaaaaaaaaaaaaaaaa4aaafind(magg, mesli->entryset, me, &collset);
if (rc) {
struct aaaaa1aaaaaaaaaaaabaaaaaaaaaaa3aaaaaaaaaaaaaaaabaaaaaaaaaaaaaaaaaaaaaaaaaaaa3aaaaaaaaaaaaabaaaaaaaaaaaaaaaaa4aaa *meli;
LIST_FOREACH(mesli->entry_list, meli) {
struct aaaaa1aaaaaaaaaaaabaaaaaaaaaaa3aaa *cuckoo_me = meli->entry;
int num_fields =
__builtin_popcount(cuckoo_me->exact_mask.active_fields);
if (num_fields < best_fields)
continue;
if (num_fields == best_fields) {
if (cuckoo_me->exact_mask.max_pop < best_max_pop)
continue;
if (cuckoo_me->exact_mask.max_pop == best_max_pop &&
cuckoo_me->exact_mask.tot_pop < best_tot_pop)
continue;
}
best_fields = num_fields;
best_max_pop = cuckoo_me->exact_mask.max_pop;
best_tot_pop = cuckoo_me->exact_mask.tot_pop;
best_me = cuckoo_me;
best_mesli = mesli;
best_probsol = probsol;
}
} else {
uint16_t id = collset->entry_ids.data[0].id;
struct aaaaa1aaaaaaaaaaaabaaaaaaaaaaa3aaa *cuckoo_me = magg->entries[id];
int num_fields =
__builtin_popcount(cuckoo_me->exact_mask.active_fields);
if (num_fields < best_fields)
continue;
if (num_fields == best_fields) {
if (cuckoo_me->exact_mask.max_pop < best_max_pop)
continue;
if (cuckoo_me->exact_mask.max_pop == best_max_pop &&
cuckoo_me->exact_mask.tot_pop < best_tot_pop)
continue;
}
best_fields = num_fields;
best_max_pop = cuckoo_me->exact_mask.max_pop;
best_tot_pop = cuckoo_me->exact_mask.tot_pop;
best_me = cuckoo_me;
best_mesli = mesli;
best_probsol = probsol;
}
}
}
if (best_me != me) {
*out_probsol = best_probsol;
*out_mesli = best_mesli;
*out_me = best_me;
} else {
*out_probsol = NULL;
*out_mesli = NULL;
*out_me = NULL;
}
return 0;
}
static int
aaaaa1aaaaaaaaaaaaaaaabaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaa3aaaaaaaaaaaaaaaabaaaaaaaaaaaaaaaaaaaaaaaaaaaa4aaadel_cuckoo(struct tcam *magg, struct aaaaa1aaaaaaaaaaaaaaaabaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaa3aaa *probsol,
struct aaaaa1aaaaaaaaaaaabaaaaaaaaaaa3bbbbbbbbbbbbbbbbbb3aaaaaaaaaaaaaaaabaaaaaaaaaaaaaaaaaaaaaaaaaaaa4aaaaaaaaaaaaabaaaaaaaaaaaaaaaaa5aaa *mesli, struct aaaaa1aaaaaaaaaaaabaaaaaaaaaaa3aaa *me)
{
int rc;
rc = aaaaa1aaaaaaaaaaaaaaaabaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaa3aaaaaaaaaaaaaaaabaaaaaaaaaaaaaaaaaaaaaaaaaaaa4bbbbbbbbbbbbbbbbbbbbbbbbbbbbbbbb4aaa(magg, me, mesli->entryset,
aaaaa1aaaaaaaaaaaaaaaabaaaaaaaaaaaaaaaaaaaaaaa3aaaaaaaaaaaaaaaabaaaaaaaaaaaaaaaaaaaaaaaaaaaa3aaaRESVD_INSTANCE, NULL);
if (rc)
return rc;
rc = aaaaa1aaaaaaaaaaaaaaaabaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaa3aaaaaaaaaaaaaaaabaaaaaaaaaaaaaaaaaaaaaaaaaaaa4aaaaaaaaaaaaaaaabaaaaaaaaaaaaaaaaaaa5aaa(magg, me, mesli->entryset,
mesli->instance);
if (rc)
return rc;
struct aaaaa1aaaaaaaaaaaabaaaaaaaaaaa3bbbbbbbbbbbbbbbbbb3aaaaaaaaaaaaaaaabaaaaaaaaaaaaaaaaaaaaaaaaaaaa4aaaaaaaaaaaaabaaaaaaaaaaaaaaaaa5aaa *tmp_mesli;
rc = aaaaa1bbbbbbbbbbbbbbbbbbbbbbbbbb3aaaaaaaaaaaaaaaabaaaaaaaaaaaaaaaaaaaaaaaaaaaa4aaaaaaaaaaaaaaaabaaaaaaaaaaaaaaaaaaa5aaa(magg, &probsol->curr_solution,
me, &tmp_mesli);
if (rc)
return rc;
assert(tmp_mesli != NULL);
rc = aaaaa1aaaaaaaaaaaaaaaabaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaa3aaaaaaaaaaaaaaaabaaaaaaaaaaaaaaaaaaaaaaaaaaaa4aaaaaaaaaaaaaaaabaaaaaaaaaaaaaaaaaaa5aaa(magg, &probsol->problem, me);
if (rc)
return rc;
return 0;
}
static int
aaaaa1aaaaaaaaaaaaaaaabaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaa3aaaaaaaaaaaaaaaabaaaaaaaaaaaaaaaaaaaaaaaaaaaa4bbbbbbbbbbbbbbbbbbbbbbbbbbbbbbbb4aaaaaaaaaaaaaaaabaaaaaaaaaaaaaaaaaaaaaaaaaaaa5bbbbbbbbbbbbbbbbbbbbbbbbbbbbbbbbbbbbbb5aaa(struct tcam *magg, struct aaaaa1aaaaaaaaaaaabaaaaaaaaaaa3aaa *me)
{
int rc;
struct aaaaa1aaaaaaaaaaaaaaaabaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaa3aaa *probsol;
struct aaaaa1aaaaaaaaaaaabaaaaaaaaaaa3bbbbbbbbbbbbbbbbbb3aaaaaaaaaaaaaaaabaaaaaaaaaaaaaaaaaaaaaaaaaaaa4aaaaaaaaaaaaabaaaaaaaaaaaaaaaaa5aaa *mesli;
const uint16_t max_num_masks = a1aaaaaaaaaaaaaaaabaaaaaaaaaaaa3aaaaaaaaaaaaaaaabaaaaaaaaaaaaaaaaaaaaaaaaaaaa3aaaaaaaaaaaaaaabaaaaaaaaaaaaaaaa4aaaaaaaaaaaaaaaabaaaaaaaaaaaaaaaaaaaaaaaaaaaa4aaaaaaaaaaaabaaaaaaaaaaaaaaaaa5aaas(magg->client) - 1;
rc = aaaaa1aaaaaaaaaaaaaaaabaaaaaaaaaaaaaaaaaaaaaaa3aaaaaaaaaaaaaaaabaaaaaaaaaaaaaaaaaaaaaaaaaaaa3bbbbbbbbbbbbbbbbbbbbbbbbbbbbbbbbbbbbbbb3aaaeate_hash(magg, me);
if (rc)
return rc;
rc = aaaaa1aaaaaaaaaaaaaaaabaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaa3aaaaaaaaaaaaaaaabaaaaaaaaaaaaaaaaaaaaaaaaaaaa4aaafind_best(magg, me, &probsol, &mesli);
if (rc)
goto error;
if (probsol == NULL) {
if (max_num_masks - magg->num_masks - 1 < 0) {
rc = CAM_ERROR_TOO_MANY_MASKS;
assert(0);
} else {
probsol = magg->open_probsol;
mesli = NULL;
}
}
if (probsol->is_solved) {
rc = aaaaa1aaaaaaaaaaaaaaaabaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaa3aaaaaaaaaaaaaaaabaaaaaaaaaaaaaaaaaaaaaaaaaaaa4bbbbbbbbbbbbbbbbbbbbbbbbbbbbbbbb4aaaaaaaaaaaaaaaabaaaaaaaaaaaaaaaaaaaaaaaaaaaa5aaasolved(magg, probsol, mesli, me);
if (rc)
goto error;
} else {
rc = aaaaa1aaaaaaaaaaaaaaaabaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaa3aaaaaaaaaaaaaaaabaaaaaaaaaaaaaaaaaaaaaaaaaaaa4bbbbbbbbbbbbbbbbbbbbbbbbbbbbbbbb4aaaaaaaaaaaaaaaabaaaaaaaaaaaaaaaaaaaaaaaaaaaa5aaaopen(magg, probsol, mesli, me);
if (rc)
goto error;
}
error:
(void) aaaaa1aaaaaaaaaaaaaaaabaaaaaaaaaaaaaaaaaaaaaaa3aaaaaaaaaaaaaaaabaaaaaaaaaaaaaaaaaaaaaaaaaaaa3aaaaaaaaaaaaaaaabaaaaaaaaaaaaaaaaaaaaaaaaa4aaaaaaaaaaaaaaaabaaaaaaaaaaaaaaaaaaaaaaaaaaaa4aaaaaaaaaaaabaaaaaaaaaa5aaa(magg, me);
return 0;
}
#endif
int
aaaaa1aaaaaaaaaaaaaaaabaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaa3aaaaaaaaaaaaaaaabaaaaaaaaaaaaaaaaaaaaaaaaaaaa4bbbbbbbbbbbbbbbbbbbbbbbbbbbbbbbb4aaa(struct tcam *magg, struct aaaaa1aaaaaaaaaaaabaaaaaaaaaaa3aaa *me)
{
int rc;
struct aaaaa1aaaaaaaaaaaaaaaabaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaa3aaa *probsol;
const uint16_t max_num_masks = a1aaaaaaaaaaaaaaaabaaaaaaaaaaaa3aaaaaaaaaaaaaaaabaaaaaaaaaaaaaaaaaaaaaaaaaaaa3aaaaaaaaaaaaaaabaaaaaaaaaaaaaaaa4aaaaaaaaaaaaaaaabaaaaaaaaaaaaaaaaaaaaaaaaaaaa4aaaaaaaaaaaabaaaaaaaaaaaaaaaaa5aaas(magg->client) - 1;
if (magg->do_refill) {
magg->do_refill = 0;
LIST_FOREACH(magg->probsols, probsol)
{
if (probsol->do_refill) {
probsol->do_refill = 0;
if (probsol->is_solved) {
if (magg->num_masks + magg->open_probsol->curr_solution.num_masks >
max_num_masks / 2) {
rc = aaaaa1aaaaaaaaaaaaaaaabaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaa3aaaaaaaaaaaaaaaabaaaaaaaaaaaaaaaaaaaaaaaaaaaa4aaaall_entries2solved(magg, magg->open_probsol,
probsol);
if (rc) {
return rc;
}
}
}
}
}
}
probsol = NULL;
struct aaaaa1aaaaaaaaaaaabaaaaaaaaaaa3bbbbbbbbbbbbbbbbbb3aaaaaaaaaaaaaaaabaaaaaaaaaaaaaaaaaaaaaaaaaaaa4aaaaaaaaaaaaabaaaaaaaaaaaaaaaaa5aaa *mesli = NULL;
rc = aaaaa1aaaaaaaaaaaaaaaabaaaaaaaaaaaaaaaaaaaaaaa3aaaaaaaaaaaaaaaabaaaaaaaaaaaaaaaaaaaaaaaaaaaa3bbbbbbbbbbbbbbbbbbbbbbbbbbbbbbbbbbbbbbb3aaaeate_hash(magg, me);
if (rc)
return rc;
rc = aaaaa1aaaaaaaaaaaaaaaabaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaa3aaaaaaaaaaaaaaaabaaaaaaaaaaaaaaaaaaaaaaaaaaaa4aaafind_best(magg, me, &probsol, &mesli);
if (rc)
return rc;
#ifdef aaaaa1bbbbbbbbbbbbbbbbbbbbbbbbbbbbbbbbbbbbbb3aaa
struct aaaaa1aaaaaaaaaaaabaaaaaaaaaaa3aaa *cuckoo_me = NULL;
struct aaaaa1aaaaaaaaaaaabaaaaaaaaaaa3bbbbbbbbbbbbbbbbbb3aaa cuckoo_mes;
if (probsol == NULL) {
struct aaaaa1aaaaaaaaaaaaaaaabaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaa3aaa *cuckoo_probsol;
struct aaaaa1aaaaaaaaaaaabaaaaaaaaaaa3bbbbbbbbbbbbbbbbbb3aaaaaaaaaaaaaaaabaaaaaaaaaaaaaaaaaaaaaaaaaaaa4aaaaaaaaaaaaabaaaaaaaaaaaaaaaaa5aaa *cuckoo_mesli;
rc = aaaaa1aaaaaaaaaaaaaaaabaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaa3aaaaaaaaaaaaaaaabaaaaaaaaaaaaaaaaaaaaaaaaaaaa4aaafind_cuckoo(magg, me, &cuckoo_probsol, &cuckoo_mesli,
&cuckoo_me);
if (rc)
return rc;
if (cuckoo_me) {
cuckoo_mes = *cuckoo_mesli->entryset;
rc = aaaaa1aaaaaaaaaaaaaaaabaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaa3aaaaaaaaaaaaaaaabaaaaaaaaaaaaaaaaaaaaaaaaaaaa4aaadel_cuckoo(magg, cuckoo_probsol, cuckoo_mesli,
cuckoo_me);
if (rc)
return rc;
probsol = cuckoo_probsol;
mesli = cuckoo_mesli;
}
}
#endif
bool new_mask_added = false;
if (probsol == NULL) {
if (max_num_masks - magg->num_masks - 1 < 0) {
rc = CAM_ERROR_NO_MASK;
goto error;
} else {
probsol = magg->open_probsol;
mesli = NULL;
new_mask_added = true;
}
}
if (probsol->is_solved) {
rc = aaaaa1aaaaaaaaaaaaaaaabaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaa3aaaaaaaaaaaaaaaabaaaaaaaaaaaaaaaaaaaaaaaaaaaa4bbbbbbbbbbbbbbbbbbbbbbbbbbbbbbbb4aaaaaaaaaaaaaaaabaaaaaaaaaaaaaaaaaaaaaaaaaaaa5aaasolved(magg, probsol, mesli, me);
if (rc)
goto error;
} else {
rc = aaaaa1aaaaaaaaaaaaaaaabaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaa3aaaaaaaaaaaaaaaabaaaaaaaaaaaaaaaaaaaaaaaaaaaa4bbbbbbbbbbbbbbbbbbbbbbbbbbbbbbbb4aaaaaaaaaaaaaaaabaaaaaaaaaaaaaaaaaaaaaaaaaaaa5aaaopen(magg, probsol, mesli, me);
if (rc) {
goto error;
}
}
#ifdef aaaaa1bbbbbbbbbbbbbbbbbbbbbbbbbbbbbbbbbbbbbb3aaa
if (cuckoo_me != NULL) {
rc = aaaaa1aaaaaaaaaaaaaaaabaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaa3aaaaaaaaaaaaaaaabaaaaaaaaaaaaaaaaaaaaaaaaaaaa4bbbbbbbbbbbbbbbbbbbbbbbbbbbbbbbb4aaaaaaaaaaaaaaaabaaaaaaaaaaaaaaaaaaaaaaaaaaaa5bbbbbbbbbbbbbbbbbbbbbbbbbbbbbbbbbbbbbb5aaa(magg, cuckoo_me);
if (rc)
return rc;
rc = aaaaa1aaaaaaaaaaaaaaaabaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaa3aaaaaaaaaaaaaaaabaaaaaaaaaaaaaaaaaaaaaaaaaaaa4aaaaaaaaaaaaaaaabaaaaaaaaaaaaaaaaaaa5aaa(magg, cuckoo_me, &cuckoo_mes,
aaaaa1aaaaaaaaaaaaaaaabaaaaaaaaaaaaaaaaaaaaaaa3aaaaaaaaaaaaaaaabaaaaaaaaaaaaaaaaaaaaaaaaaaaa3aaaRESVD_INSTANCE);
if (rc)
return rc;
}
#endif
if (!probsol->is_solved) {
const uint16_t number_of_free_masks = max_num_masks - magg->num_masks;
if (!new_mask_added || (magg->open_probsol->curr_solution.num_masks + 1 <
number_of_free_masks))
goto done;
int deficit_masks = magg->open_probsol->curr_solution.num_masks - number_of_free_masks;
if (deficit_masks > 0) {
struct aaaaa1aaaaaaaaaaaaaaaabaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaa3aaa *solved;
rc = aaaaa1aaaaaaaaaaaaaaaabaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaa3aaaaaaaaaaaaaaaabaaaaaaaaaaaaaaaaaaaaaaaaaaaa4bbbbbbbbbbbbbbbbbbbbbbbbbbbbbbbbbbbbbbb4aaaeate(magg, &solved);
if (rc)
return rc;
solved->is_solved = 1;
solved->problem.is_solved = 1;
rc = aaaaa1aaaaaaaaaaaaaaaabaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaa3aaaaaaaaaaaaaaaabaaaaaaaaaaaaaaaaaaaaaaaaaaaa4aaatransform(magg, magg->open_probsol, solved,
deficit_masks);
if (rc)
return rc;
LIST_PREPEND_ELEM(magg->probsols, magg->open_probsol, solved);
}
if (magg->open_probsol->curr_solution.num_masks > 1) {
rc = aaaaa1aaaaaaaaaaaaaaaabaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaa3aaaaaaaaaaaaaaaabaaaaaaaaaaaaaaaaaaaaaaaaaaaa4bbbbbbbbbbbbbbbbbbbbbbbbbbbbbb4aaa(magg);
if (rc)
goto error;
}
}
done:
error:
(void) aaaaa1aaaaaaaaaaaaaaaabaaaaaaaaaaaaaaaaaaaaaaa3aaaaaaaaaaaaaaaabaaaaaaaaaaaaaaaaaaaaaaaaaaaa3aaaaaaaaaaaaaaaabaaaaaaaaaaaaaaaaaaaaaaaaa4aaaaaaaaaaaaaaaabaaaaaaaaaaaaaaaaaaaaaaaaaaaa4aaaaaaaaaaaabaaaaaaaaaa5aaa(magg, me);
return rc;
}
static int
aaaaa1aaaaaaaaaaaaaaaabaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaa3aaaaaaaaaaaaaaaabaaaaaaaaaaaaaaaaaaaaaaaaaaaa4aaasolved2open(struct tcam *magg,
struct aaaaa1aaaaaaaaaaaaaaaabaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaa3aaa *solved,
struct aaaaa1aaaaaaaaaaaaaaaabaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaa3aaa *open,
struct aaaaa1aaaaaaaaaaaabaaaaaaaaaaa3bbbbbbbbbbbbbbbbbb3aaaaaaaaaaaaaaaabaaaaaaaaaaaaaaaaaaaaaaaaaaaa4aaaaaaaaaaaaabaaaaaaaaaaaaaaaaa5aaa *mesli)
{
magg->stats.curr_closed_masks--;
magg->stats.curr_open_masks = magg->num_masks - magg->stats.curr_closed_masks;
magg->stats.max_open_masks = MAX(magg->stats.curr_open_masks, magg->stats.max_open_masks);
int rc;
struct aaaaa1aaaaaaaaaaaabaaaaaaaaaaa3aaaaaaaaaaaaaaaabaaaaaaaaaaaaaaaaaaaaaaaaaaaa3aaaaaaaaaaaaabaaaaaaaaaaaaaaaaa4aaa *meli;
struct aaaaa1aaaaaaaaaaaaaaaabaaaaaaaaaaaaaaaaaaaaaaa3aaa solved_mask = mesli->entryset->mask;
LIST_FOREACH(mesli->entry_list, meli)
{
rc = aaaaa1aaaaaaaaaaaaaaaabaaaaaaaaaaaaaaaaaaaaaaa3aaaaaaaaaaaaaaaabaaaaaaaaaaaaaaaaaaaaaaaaaaaa3bbbbbbbbbbbbbbbbbbbbbbbbbbbbbbbbbbbbbbb3aaaeate_hash(magg, meli->entry);
if (rc)
return rc;
rc = aaaaa1aaaaaaaaaaaaaaaabaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaa3aaaaaaaaaaaaaaaabaaaaaaaaaaaaaaaaaaaaaaaaaaaa4bbbbbbbbbbbbbbbbbbbbbbbbbbbbbbbb4aaa(magg, &open->problem, meli->entry);
if (rc)
return rc;
open->problem.num_entries++;
rc = aaaaa1aaaaaaaaaaaaaaaabaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaa3aaaaaaaaaaaaaaaabaaaaaaaaaaaaaaaaaaaaaaaaaaaa4aaaaaaaaaaaaaaaabaaaaaaaaaaaaaaaaaaa5aaa(magg, &solved->problem, meli->entry);
if (rc)
return rc;
rc = aaaaa1aaaaaaaaaaaaaaaabaaaaaaaaaaaaaaaaaaaaaaa3aaaaaaaaaaaaaaaabaaaaaaaaaaaaaaaaaaaaaaaaaaaa3aaaaaaaaaaaaaaaabaaaaaaaaaaaaaaaaaaaaaaaaa4aaaaaaaaaaaaaaaabaaaaaaaaaaaaaaaaaaaaaaaaaaaa4aaaaaaaaaaaabaaaaaaaaaa5aaa(magg, meli->entry);
if (rc)
return rc;
}
struct aaaaa1aaaaaaaaaaaabaaaaaaaaaaa3bbbbbbbbbbbbbbbbbb3aaa *mes;
MH_FIND(mh_handle, open->problem.entryset_by_mask, &solved_mask, sizeof(solved_mask), mes);
assert(mes);
if (magg->debug_mask & aaaaa1bbbbbbbbbbbbbbbbbbbbbbbbbbbbbbbbbbbbb3aaaaaaaaaaaaaaaabaaaaaaaaaaaaaaaaaaaaaaaaaaaa4aaaaaaaaaaaabaaaaaaaaaaa5bbbbbbbbbbbbbbbbbb5aaa) {
       printf("MASK solved -> open from %p to %p hash %x instance %u num_entries %u\n",
&mesli->entryset->mask, &mes->mask,
aaaaa1aaaaaaaaaaaaaaaabaaaaaaaaaaaaaaaaaaaaaaa3aaaaaaaaaaaaaaaabaaaaaaaaaaaaaaaaaaaaaaaaaaaa3aaaaaaaaaaaabaaaaaaaaaa4aaaaaaaaaaaaaaaabaaaaaaaaaaaaaaaaaaaaaaaaaaaa4aaavalue(&mes->mask), mesli->instance,
mesli->num_entries);
aaaaa1aaaaaaaaaaaaaaaabaaaaaaaaaaaaaaaaaaaaaaa3aaaaaaaaaaaaaaaabaaaaaaaaaaaaaaaaaaaaaaaaaaaa3aaaaaaaaaaaaaaaabaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaa3aaa(magg, &mes->mask, 2);
}
mesli->entryset = mes;
LIST_FOREACH(mesli->entry_list, meli)
{
struct aaaaa1bbbbbbbbbbbbbbbbbbbbbbbbbbbbbbbbb3aaa *collset;
rc = aaaaa1bbbbbbbbbbbbbbbbbbbbbbbbbbbbbbbbb3aaaaaaaaaaaaaaaabaaaaaaaaaaaaaaaaaaaaaaaaaaaa4aaafind(magg, mes, meli->entry, &collset);
assert(rc == 0);
meli->entry->current_entryset.mes = mes;
meli->entry->current_entryset.collset = collset;
}
LIST_DELETE(solved->curr_solution.mask_list, mesli);
solved->curr_solution.num_masks--;
LIST_APPEND(open->curr_solution.mask_list, mesli);
open->curr_solution.num_masks++;
return 0;
}
int
aaaaa1aaaaaaaaaaaaaaaabaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaa3aaaaaaaaaaaaaaaabaaaaaaaaaaaaaaaaaaaaaaaaaaaa4aaaaaaaaaaaaaaaabaaaaaaaaaaaaaaaaaaa5aaa(struct tcam *magg, struct aaaaa1aaaaaaaaaaaabaaaaaaaaaaa3aaa *me)
{
int rc;
struct aaaaa1aaaaaaaaaaaaaaaabaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaa3aaa *probsol;
struct aaaaa1aaaaaaaaaaaabaaaaaaaaaaa3bbbbbbbbbbbbbbbbbb3aaaaaaaaaaaaaaaabaaaaaaaaaaaaaaaaaaaaaaaaaaaa4aaaaaaaaaaaaabaaaaaaaaaaaaaaaaa5aaa *mesli;
uint16_t min_entries = UINT16_MAX;
const uint16_t max_num_masks = a1aaaaaaaaaaaaaaaabaaaaaaaaaaaa3aaaaaaaaaaaaaaaabaaaaaaaaaaaaaaaaaaaaaaaaaaaa3aaaaaaaaaaaaaaabaaaaaaaaaaaaaaaa4aaaaaaaaaaaaaaaabaaaaaaaaaaaaaaaaaaaaaaaaaaaa4aaaaaaaaaaaabaaaaaaaaaaaaaaaaa5aaas(magg->client) - 1;
LIST_FOREACH(magg->probsols, probsol)
{
LIST_FOREACH(probsol->curr_solution.mask_list, mesli)
{
if (probsol->is_solved && mesli->num_entries < min_entries)
min_entries = mesli->num_entries;
}
}
min_entries = MIN(min_entries, 3 * max_num_masks / 4);
LIST_FOREACH(magg->probsols, probsol)
{
rc = aaaaa1bbbbbbbbbbbbbbbbbbbbbbbbbb3aaaaaaaaaaaaaaaabaaaaaaaaaaaaaaaaaaaaaaaaaaaa4aaaaaaaaaaaaaaaabaaaaaaaaaaaaaaaaaaa5aaa(magg, &probsol->curr_solution, me, &mesli);
if (rc == 0)
break;
}
rc = aaaaa1aaaaaaaaaaaaaaaabaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaa3aaaaaaaaaaaaaaaabaaaaaaaaaaaaaaaaaaaaaaaaaaaa4aaaaaaaaaaaaaaaabaaaaaaaaaaaaaaaaaaa5aaa(magg, &probsol->problem, me);
if (rc)
return rc;
if (probsol->is_solved && mesli && (mesli->num_entries < min_entries)) {
rc = aaaaa1aaaaaaaaaaaaaaaabaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaa3aaaaaaaaaaaaaaaabaaaaaaaaaaaaaaaaaaaaaaaaaaaa4aaasolved2open(magg, probsol, magg->open_probsol, mesli);
if (rc) {
return rc;
}
int cnt = 0;
LIST_COUNT(probsol->curr_solution.mask_list, mesli, cnt);
if (cnt == 0) {
LIST_DELETE(magg->probsols, probsol);
rc = aaaaa1aaaaaaaaaaaaaaaabaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaa3aaaaaaaaaaaaaaaabaaaaaaaaaaaaaaaaaaaaaaaaaaaa4aaaaaaaaaaaaaaaabaaaaaaaaaaaaaaaaaaaaaaaaa5aaa(magg, probsol);
if (rc) {
return rc;
}
}
} else {
if (probsol->is_solved)
probsol->do_refill = 1;
magg->do_refill = 1;
}
return 0;
}
int
aaaaa1aaaaaaaaaaaaaaaabaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaa3aaaaaaaaaaaaaaaabaaaaaaaaaaaaaaaaaaaaaaaaaaaa4bbbbbbbbbbbbbbbbbbbbbbbbbbbbbb4aaa(struct tcam *magg)
{
int rc;
struct aaaaa1aaaaaaaaaaaaaaaabaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaa3aaa *open = magg->open_probsol;
const uint16_t max_num_masks = a1aaaaaaaaaaaaaaaabaaaaaaaaaaaa3aaaaaaaaaaaaaaaabaaaaaaaaaaaaaaaaaaaaaaaaaaaa3aaaaaaaaaaaaaaabaaaaaaaaaaaaaaaa4aaaaaaaaaaaaaaaabaaaaaaaaaaaaaaaaaaaaaaaaaaaa4aaaaaaaaaaaabaaaaaaaaaaaaaaaaa5aaas(magg->client) - 1;
if (magg->debug_mask & aaaaa1bbbbbbbbbbbbbbbbbbbbbbbbbbbbbbbbbbbbb3aaaaaaaaaaaaaaaabaaaaaaaaaaaaaaaaaaaaaaaaaaaa4aaaaaaaaaaaaaaaabaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaa4aaa) {
       printf("Total entries %3u, closed entries %3d, open entries %3u\n",
magg->num_entries, magg->num_entries - open->problem.num_entries,
open->problem.num_entries);
       printf("Problem  with %3u entries in %2u masks, total masks %2u, free masks %2d\n",
open->problem.num_entries, open->curr_solution.num_masks,
magg->num_masks, max_num_masks - magg->num_masks);
}
aaaaa1bbbbbbbbbbbbbbbbbbbbbbbbbbbbbbbbbbbbb3aaaaaaaaaaaaaaaabaaaaaaaaaaaaaaaaaaaaaaaaaaaa4aaaaaaaaaaaaaaaabaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaa4aaa(magg, 0);
rc = aaaaa1bbbbbbbbbbbbbbbbbbbbbbbbbb3aaaaaaaaaaaaaaaabaaaaaaaaaaaaaaaaaaaaaaaaaaaa4bbbbbbbbbbbbbbbbbbbbbbbbbbbbbb4aaa(magg, open, max_num_masks - magg->num_masks - 1);
if (rc && rc != 1)
return rc;
if (magg->debug_mask & aaaaa1bbbbbbbbbbbbbbbbbbbbbbbbbbbbbbbbbbbbb3aaaaaaaaaaaaaaaabaaaaaaaaaaaaaaaaaaaaaaaaaaaa4aaaaaaaaaaaaaaaabaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaa4aaa)
       printf("Solution with %3u entries in %2u masks, total masks %2u, free masks %2d %s\n",
open->problem.num_entries, open->curr_solution.num_masks,
magg->num_masks,
max_num_masks - magg->num_masks,
              rc == 0 ? "committed" : "discarded");
return 0;
}
int
aaaaa1aaaaaaaaaaaaaaaabaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaa3aaaaaaaaaaaaaaaabaaaaaaaaaaaaaaaaaaaaaaaaaaaa4aaaaaaaaaaaaaaaabaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaa4aaa(struct tcam *magg, struct aaaaa1aaaaaaaaaaaaaaaabaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaa3aaa *probsol, int indent)
{
   printf("%*caaaaa1aaaaaaaaaaaaaaaabaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaa3aaa %p is_solved %u\n", indent, ' ',
probsol, probsol->is_solved);
if (!(magg->debug_mask & aaaaa1aaaaaaaaaaaaaaaabaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaa3aaaaaaaaaaaaaaaabaaaaaaaaaaaaaaaaaaaaaaaaaaaa4aaaaaaaaaaaaaaaabaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaa4aaa))
return 0;
aaaaa1aaaaaaaaaaaaaaaabaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaa3aaaaaaaaaaaaaaaabaaaaaaaaaaaaaaaaaaaaaaaaaaaa4aaaaaaaaaaaaaaaabaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaa4aaa(magg, &probsol->problem, indent + 2);
return 0;
}
int
aaaaa1bbbbbbbbbbbbbbbbbbbbbbbbbb3aaaaaaaaaaaaaaaabaaaaaaaaaaaaaaaaaaaaaaaaaaaa4bbbbbbbbbbbbbbbbbbbbbbbbbbbbbbbbbbbbbbb4aaaeate(struct tcam *magg, struct aaaaa1bbbbbbbbbbbbbbbbbbbbbbbbbb3aaa *solution)
{
memset(solution, 0, sizeof(*solution));
const uint32_t max_num_entries = a1aaaaaaaaaaaaaaaabaaaaaaaaaaaa3aaaaaaaaaaaaaaaabaaaaaaaaaaaaaaaaaaaaaaaaaaaa3aaaaaaaaaaaaaaabaaaaaaaaaaaaaaaa4aaaaaaaaaaaaaaaabaaaaaaaaaaaaaaaaaaaaaaaaaaaa4aaaaaaaaaaaaaaaabaaaaaaaaaaaaaaaaaaaaa5aaa(magg->client);
memset(magg->oparray, 0, max_num_entries);
return 0;
}
int
aaaaa1bbbbbbbbbbbbbbbbbbbbbbbbbb3aaaaaaaaaaaaaaaabaaaaaaaaaaaaaaaaaaaaaaaaaaaa4aaaaaaaaaaaaaaaabaaaaaaaaaaaaaaaaaaaaaaaaa5aaa(struct tcam *magg, struct aaaaa1bbbbbbbbbbbbbbbbbbbbbbbbbb3aaa *solution)
{
int rc;
struct aaaaa1aaaaaaaaaaaabaaaaaaaaaaa3aaaaaaaaaaaaaaaabaaaaaaaaaaaaaaaaaaaaaaaaaaaa3aaaaaaaaaaaaabaaaaaaaaaaaaaaaaa4aaa *meli, *meli_tmp;
struct aaaaa1aaaaaaaaaaaabaaaaaaaaaaa3bbbbbbbbbbbbbbbbbb3aaaaaaaaaaaaaaaabaaaaaaaaaaaaaaaaaaaaaaaaaaaa4aaaaaaaaaaaaabaaaaaaaaaaaaaaaaa5aaa *mesli, *mesli_tmp;
cam_free_func free_function = a1aaaaaaaaaaaaaaaabaaaaaaaaaaaa3aaaaaaaaaaaaaaaabaaaaaaaaaaaaaaaaaaaaaaaaaaaa3aaaaaaaaaaaaaabaaaaaaaaaaaa4aaaaaaaaaaaaaaaabaaaaaaaaaaaaaaaaaaaaaaaaaaaa4aaaaaaaaaaaaaaaabaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaa4aaa((a1aaat*) (magg->client));
LIST_FOREACH_SAFE(solution->mask_list, mesli, mesli_tmp)
{
LIST_FOREACH_SAFE(mesli->entry_list, meli, meli_tmp)
{
LIST_DELETE(mesli->entry_list, meli);
free_function(meli);
}
rc = aaaaa1aaaaaaaaaaaaaaaabaaaaaaaaaaaaaaaaaaaaaaa3aaaaaaaaaaaaaaaabaaaaaaaaaaaaaaaaaaaaaaaaaaaa3aaaput_instance(magg, &mesli->entryset->mask,
mesli->instance);
if (rc)
return rc;
LIST_DELETE(solution->mask_list, mesli);
free_function(mesli);
}
memset(solution, 0, sizeof(*solution));
return 0;
}
static int
aaaaa1bbbbbbbbbbbbbbbbbbbbbbbbbb3aaaaaaaaaaaaaaaabaaaaaaaaaaaaaaaaaaaaaaaaaaaa4bbbbbbbbbbbbbbbbbbbbbbbbbbbbbbbbbb4aaa(struct tcam *magg, struct aaaaa1aaaaaaaaaaaaaaaabaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaa3aaa *problem,
struct aaaaa1bbbbbbbbbbbbbbbbbbbbbbbbbb3aaa *solution,
struct aaaaa1aaaaaaaaaaaabaaaaaaaaaaa3bbbbbbbbbbbbbbbbbb3aaa *mes,
uint16_t * num_populated, uint8_t * instance)
{
int rc;
struct aaaaa1aaaaaaaaaaaabaaaaaaaaaaa3bbbbbbbbbbbbbbbbbb3aaaaaaaaaaaaaaaabaaaaaaaaaaaaaaaaaaaaaaaaaaaa4aaaaaaaaaaaaabaaaaaaaaaaaaaaaaa5aaa *mesli;
cam_calloc_func calloc_function = a1aaaaaaaaaaaaaaaabaaaaaaaaaaaa3aaaaaaaaaaaaaaaabaaaaaaaaaaaaaaaaaaaaaaaaaaaa3aaacalloc_function((a1aaat*) (magg->client));
mesli = calloc_function(1, sizeof(*mesli));
if (mesli == NULL)
return CAM_ERROR_NOMEM;
LIST_APPEND(solution->mask_list, mesli);
mesli->entryset = mes;
rc = aaaaa1aaaaaaaaaaaaaaaabaaaaaaaaaaaaaaaaaaaaaaa3aaaaaaaaaaaaaaaabaaaaaaaaaaaaaaaaaaaaaaaaaaaa3aaaaaaaaaaaaaaaabaaaaaaaaaaaa4aaaaaaaaaaaaaaaabaaaaaaaaaaaaaaaaaaaaaaaaaaaa4aaainstance(magg, &mes->mask, &mesli->instance);
if (rc)
return rc;
*instance = mesli->instance;
rc = aaaaa1aaaaaaaaaaaabaaaaaaaaaaa3bbbbbbbbbbbbbbbbbb3aaaaaaaaaaaaaaaabaaaaaaaaaaaaaaaaaaaaaaaaaaaa4aaapopulate(magg, mes, mesli, num_populated);
if (rc)
return rc;
mesli->num_entries = *num_populated;
struct aaaaa1aaaaaaaaaaaabaaaaaaaaaaa3aaaaaaaaaaaaaaaabaaaaaaaaaaaaaaaaaaaaaaaaaaaa3aaaaaaaaaaaaabaaaaaaaaaaaaaaaaa4aaa *meli;
LIST_FOREACH(mesli->entry_list, meli)
{
rc = aaaaa1aaaaaaaaaaaaaaaabaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaa3aaaaaaaaaaaaaaaabaaaaaaaaaaaaaaaaaaaaaaaaaaaa4aaareduce(magg, problem, meli->entry);
if (rc)
return rc;
}
return 0;
}
static int
aaaaa1bbbbbbbbbbbbbbbbbbbbbbbbbb3aaaaaaaaaaaaaaaabaaaaaaaaaaaaaaaaaaaaaaaaaaaa4bbbbbbbbbbbbbbbbbbbbbbbbbbbbbbb4aaa(struct tcam *magg, struct aaaaa1aaaaaaaaaaaaaaaabaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaa3aaa *probsol)
{
struct aaaaa1bbbbbbbbbbbbbbbbbbbbbbbbbb3aaaaaaaaaaaaaaaabaaaaaaaaaaaaaaaaaaaaaaaaaaaa4aaaop *op;
struct aaaaa1aaaaaaaaaaaabaaaaaaaaaaa3aaaaaaaaaaaaaaaabaaaaaaaaaaaaaaaaaaaaaaaaaaaa3aaaaaaaaaaaaabaaaaaaaaaaaaaaaaa4aaa *meli;
struct aaaaa1aaaaaaaaaaaabaaaaaaaaaaa3bbbbbbbbbbbbbbbbbb3aaaaaaaaaaaaaaaabaaaaaaaaaaaaaaaaaaaaaaaaaaaa4aaaaaaaaaaaaabaaaaaaaaaaaaaaaaa5aaa *mesli;
LIST_FOREACH(probsol->prev_solution.mask_list, mesli)
{
LIST_FOREACH(mesli->entry_list, meli)
{
op = &magg->oparray[meli->entry->id];
op->src_op = aaaaa1aaaOP_DEL;
op->src_entryset = mesli->entryset;
op->src_instance = mesli->instance;
}
}
LIST_FOREACH(probsol->curr_solution.mask_list, mesli)
{
LIST_FOREACH(mesli->entry_list, meli)
{
op = &magg->oparray[meli->entry->id];
op->dst_op = aaaaa1aaaOP_ADD;
op->dst_entryset = mesli->entryset;
op->dst_instance = mesli->instance;
op->dst_collset = meli->entry->next_entryset.collset;
}
}
return 0;
}
static int
aaaaa1bbbbbbbbbbbbbbbbbbbbbbbbbb3aaaaaaaaaaaaaaaabaaaaaaaaaaaaaaaaaaaaaaaaaaaa4aaasort_cmp(struct aaaaa1aaaaaaaaaaaabaaaaaaaaaaa3bbbbbbbbbbbbbbbbbb3aaaaaaaaaaaaaaaabaaaaaaaaaaaaaaaaaaaaaaaaaaaa4aaaaaaaaaaaaabaaaaaaaaaaaaaaaaa5aaa *a,
struct aaaaa1aaaaaaaaaaaabaaaaaaaaaaa3bbbbbbbbbbbbbbbbbb3aaaaaaaaaaaaaaaabaaaaaaaaaaaaaaaaaaaaaaaaaaaa4aaaaaaaaaaaaabaaaaaaaaaaaaaaaaa5aaa *b)
{
if (a->weight < b->weight)
return -1;
if (a->weight == b->weight)
return 0;
return 1;
}
static int
aaaaa1bbbbbbbbbbbbbbbbbbbbbbbbbb3aaaaaaaaaaaaaaaabaaaaaaaaaaaaaaaaaaaaaaaaaaaa4aaasort(struct tcam *magg, struct aaaaa1bbbbbbbbbbbbbbbbbbbbbbbbbb3aaa *solution)
{
struct aaaaa1aaaaaaaaaaaabaaaaaaaaaaa3aaaaaaaaaaaaaaaabaaaaaaaaaaaaaaaaaaaaaaaaaaaa3aaaaaaaaaaaaabaaaaaaaaaaaaaaaaa4aaa *meli;
struct aaaaa1bbbbbbbbbbbbbbbbbbbbbbbbbb3aaaaaaaaaaaaaaaabaaaaaaaaaaaaaaaaaaaaaaaaaaaa4aaaop *op;
struct aaaaa1aaaaaaaaaaaabaaaaaaaaaaa3bbbbbbbbbbbbbbbbbb3aaaaaaaaaaaaaaaabaaaaaaaaaaaaaaaaaaaaaaaaaaaa4aaaaaaaaaaaaabaaaaaaaaaaaaaaaaa5aaa *mesli;
LIST_FOREACH(solution->mask_list, mesli)
{
mesli->weight = 0;
LIST_FOREACH(mesli->entry_list, meli)
{
op = &magg->oparray[meli->entry->id];
if (op->src_op == aaaaa1aaaOP_DEL &&
op->dst_op == aaaaa1aaaOP_ADD &&
memcmp(&op->src_entryset->mask, &op->dst_entryset->mask,
sizeof(struct aaaaa1aaaaaaaaaaaaaaaabaaaaaaaaaaaaaaaaaaaaaaa3aaa)) == 0 &&
op->src_instance == op->dst_instance) {
op->dst_op = aaaaa1aaaOP_NOP;
op->src_op = aaaaa1aaaOP_NOP;
}
if (op->dst_op == aaaaa1aaaOP_ADD)
mesli->weight++;
}
}
LIST_SORT(solution->mask_list, aaaaa1bbbbbbbbbbbbbbbbbbbbbbbbbb3aaaaaaaaaaaaaaaabaaaaaaaaaaaaaaaaaaaaaaaaaaaa4aaasort_cmp);
if (magg->debug_mask & aaaaa1bbbbbbbbbbbbbbbbbbbbbbbbbbbbbbbbbbbbb3aaaaaaaaaaaaaaaabaaaaaaaaaaaaaaaaaaaaaaaaaaaa4aaaOPARRAY) {
LIST_FOREACH(solution->mask_list, mesli)
{
LIST_FOREACH(mesli->entry_list, meli)
{
op = &magg->oparray[meli->entry->id];
if (op->dst_op == aaaaa1aaaOP_NOP && op->src_op == aaaaa1aaaOP_NOP)
continue;
               printf("O %05u : %u %p %3u: %u %p %3u\n",
meli->entry->id,
op->src_op, op->src_entryset, op->src_instance,
op->dst_op, op->dst_entryset, op->dst_instance);
}
}
}
return 0;
}
static int
aaaaa1bbbbbbbbbbbbbbbbbbbbbbbbbb3aaaaaaaaaaaaaaaabaaaaaaaaaaaaaaaaaaaaaaaaaaaa4bbbbbbbbbbbbbbbbbbbbbbbbbbb4aaaaaaaaaaaaaaaabaaaaaaaaaaaaaaaaaaaaaaaaaaaa5bbbbbbbbbbbbbbbbbbbbbbbbbbbbb5aaa(struct tcam *magg,
struct aaaaa1bbbbbbbbbbbbbbbbbbbbbbbbbb3aaa *solution,
struct aaaaa1aaaaaaaaaaaabaaaaaaaaaaa3aaaaaaaaaaaaaaaabaaaaaaaaaaaaaaaaaaaaaaaaaaaa3aaaaaaaaaaaaabaaaaaaaaaaaaaaaaa4aaa *outer_meli,
int *out_added)
{
int rc = 0, added = 0;
struct aaaaa1bbbbbbbbbbbbbbbbbbbbbbbbbb3aaaaaaaaaaaaaaaabaaaaaaaaaaaaaaaaaaaaaaaaaaaa4aaaop *op;
struct aaaaa1aaaaaaaaaaaabaaaaaaaaaaa3aaaaaaaaaaaaaaaabaaaaaaaaaaaaaaaaaaaaaaaaaaaa3aaaaaaaaaaaaabaaaaaaaaaaaaaaaaa4aaa *meli;
LIST_FOREACH(solution->collision_list, meli)
{
if (meli == outer_meli || meli->entry == NULL)
continue;
op = &magg->oparray[meli->entry->id];
rc = aaaaa1aaaaaaaaaaaaaaaabaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaa3aaaaaaaaaaaaaaaabaaaaaaaaaaaaaaaaaaaaaaaaaaaa4bbbbbbbbbbbbbbbbbbbbbbbbbbbbbbbb4aaa(magg, meli->entry,
op->dst_entryset, op->dst_instance, op->dst_collset);
if (rc == CAM_ERROR_DUPLICATE_FOUND)
continue;
if (rc)
goto error;
if (op->src_op == aaaaa1aaaOP_DEL) {
rc = aaaaa1aaaaaaaaaaaaaaaabaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaa3aaaaaaaaaaaaaaaabaaaaaaaaaaaaaaaaaaaaaaaaaaaa4aaaaaaaaaaaaaaaabaaaaaaaaaaaaaaaaaaa5aaa(magg, meli->entry, op->src_entryset,
op->src_instance);
if (rc)
goto error;
}
meli->entry = NULL;
added++;
}
rc = 0;
error:
(*out_added) = added;
return rc;
}
static int
aaaaa1bbbbbbbbbbbbbbbbbbbbbbbbbb3aaaaaaaaaaaaaaaabaaaaaaaaaaaaaaaaaaaaaaaaaaaa4bbbbbbbbbbbbbbbbbbbbbbbbbbbb4aaaaaaaaaaaaaaaabaaaaaaaaaaaaaaaaaaaaaaaaaaaa5bbbbbbbbbbbbbbbbbbbbbbbbbbbbb5aaa(struct tcam *magg,
struct aaaaa1bbbbbbbbbbbbbbbbbbbbbbbbbb3aaa *solution)
{
int rc = 0;
struct aaaaa1aaaaaaaaaaaabaaaaaaaaaaa3aaaaaaaaaaaaaaaabaaaaaaaaaaaaaaaaaaaaaaaaaaaa3aaaaaaaaaaaaabaaaaaaaaaaaaaaaaa4aaa *meli;
struct aaaaa1bbbbbbbbbbbbbbbbbbbbbbbbbb3aaaaaaaaaaaaaaaabaaaaaaaaaaaaaaaaaaaaaaaaaaaa4aaaop *op;
LIST_FOREACH(solution->collision_list, meli)
{
if (meli->entry == NULL)
continue;
op = &magg->oparray[meli->entry->id];
rc = aaaaa1aaaaaaaaaaaaaaaabaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaa3aaaaaaaaaaaaaaaabaaaaaaaaaaaaaaaaaaaaaaaaaaaa4bbbbbbbbbbbbbbbbbbbbbbbbbbbbbbbb4aaa(magg, meli->entry, op->dst_entryset,
aaaaa1aaaaaaaaaaaaaaaabaaaaaaaaaaaaaaaaaaaaaaa3aaaaaaaaaaaaaaaabaaaaaaaaaaaaaaaaaaaaaaaaaaaa3aaaRESVD_INSTANCE, op->dst_collset);
if (rc)
goto error;
magg->num_masks++;
magg->stats.curr_num_masks = magg->num_masks;
magg->stats.max_num_masks = MAX(magg->stats.curr_num_masks, magg->stats.max_num_masks);
magg->stats.curr_open_masks = magg->num_masks - magg->stats.curr_closed_masks;
magg->stats.max_open_masks = MAX(magg->stats.curr_open_masks, magg->stats.max_open_masks);
if (op->src_op == aaaaa1aaaOP_DEL) {
rc = aaaaa1aaaaaaaaaaaaaaaabaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaa3aaaaaaaaaaaaaaaabaaaaaaaaaaaaaaaaaaaaaaaaaaaa4aaaaaaaaaaaaaaaabaaaaaaaaaaaaaaaaaaa5aaa(magg, meli->entry, op->src_entryset,
op->src_instance);
if (rc)
goto error;
}
int added;
do {
rc = aaaaa1bbbbbbbbbbbbbbbbbbbbbbbbbb3aaaaaaaaaaaaaaaabaaaaaaaaaaaaaaaaaaaaaaaaaaaa4bbbbbbbbbbbbbbbbbbbbbbbbbbb4aaaaaaaaaaaaaaaabaaaaaaaaaaaaaaaaaaaaaaaaaaaa5bbbbbbbbbbbbbbbbbbbbbbbbbbbbb5aaa(magg, solution, meli, &added);
if (rc)
goto error;
} while (added > 0);
rc = aaaaa1aaaaaaaaaaaaaaaabaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaa3aaaaaaaaaaaaaaaabaaaaaaaaaaaaaaaaaaaaaaaaaaaa4bbbbbbbbbbbbbbbbbbbbbbbbbbbbbbbb4aaa(magg, meli->entry, op->dst_entryset,
op->dst_instance, op->dst_collset);
if (rc)
goto error;
rc = aaaaa1aaaaaaaaaaaaaaaabaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaa3aaaaaaaaaaaaaaaabaaaaaaaaaaaaaaaaaaaaaaaaaaaa4aaaaaaaaaaaaaaaabaaaaaaaaaaaaaaaaaaa5aaa(magg, meli->entry, op->dst_entryset,
aaaaa1aaaaaaaaaaaaaaaabaaaaaaaaaaaaaaaaaaaaaaa3aaaaaaaaaaaaaaaabaaaaaaaaaaaaaaaaaaaaaaaaaaaa3aaaRESVD_INSTANCE);
if (rc)
goto error;
magg->num_masks--;
magg->stats.curr_num_masks = magg->num_masks;
magg->stats.curr_open_masks = magg->num_masks - magg->stats.curr_closed_masks;
meli->entry = NULL;
}
error:
return rc;
}
static int
aaaaa1bbbbbbbbbbbbbbbbbbbbbbbbbb3aaaaaaaaaaaaaaaabaaaaaaaaaaaaaaaaaaaaaaaaaaaa4bbbbbbbbbbbbbbbbbbbbbbbbbbbb4aaa(struct tcam *magg, struct aaaaa1bbbbbbbbbbbbbbbbbbbbbbbbbb3aaa *solution)
{
int rc;
struct aaaaa1aaaaaaaaaaaabaaaaaaaaaaa3aaaaaaaaaaaaaaaabaaaaaaaaaaaaaaaaaaaaaaaaaaaa3aaaaaaaaaaaaabaaaaaaaaaaaaaaaaa4aaa *meli, *tmp;
struct aaaaa1bbbbbbbbbbbbbbbbbbbbbbbbbb3aaaaaaaaaaaaaaaabaaaaaaaaaaaaaaaaaaaaaaaaaaaa4aaaop *op;
struct aaaaa1aaaaaaaaaaaabaaaaaaaaaaa3bbbbbbbbbbbbbbbbbb3aaaaaaaaaaaaaaaabaaaaaaaaaaaaaaaaaaaaaaaaaaaa4aaaaaaaaaaaaabaaaaaaaaaaaaaaaaa5aaa *mesli;
cam_calloc_func calloc_function = a1aaaaaaaaaaaaaaaabaaaaaaaaaaaa3aaaaaaaaaaaaaaaabaaaaaaaaaaaaaaaaaaaaaaaaaaaa3aaacalloc_function((a1aaat*) (magg->client));
LIST_FOREACH(solution->mask_list, mesli)
{
LIST_FOREACH_SAFE(mesli->entry_list, meli, tmp)
{
op = &magg->oparray[meli->entry->id];
if (op->dst_op == aaaaa1aaaOP_ADD) {
rc = aaaaa1aaaaaaaaaaaaaaaabaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaa3aaaaaaaaaaaaaaaabaaaaaaaaaaaaaaaaaaaaaaaaaaaa4bbbbbbbbbbbbbbbbbbbbbbbbbbbbbbbb4aaa(magg, meli->entry, op->dst_entryset,
op->dst_instance, op->dst_collset);
if (rc == CAM_ERROR_DUPLICATE_FOUND) {
#if 0
                   printf("COL prepend\n");
int i;
                   printf("AA %05u %p %3u %x %u %u %p %x:\n", meli->entry->priority,
op->dst_entryset, op->dst_instance,
aaaaa1aaaaaaaaaaaaaaaabaaaaaaaaaaaaaaaaaaaaaaa3aaaaaaaaaaaaaaaabaaaaaaaaaaaaaaaaaaaaaaaaaaaa3aaaaaaaaaaaabaaaaaaaaaa4aaaaaaaaaaaaaaaabaaaaaaaaaaaaaaaaaaaaaaaaaaaa4aaavalue(&op->dst_entryset->mask), magg->num_masks,
op->dst_entryset->mask.max_pop, op->dst_collset, op->dst_entryset->mask.use_range);
                   printf("  K ");
for (i = 0; i < sizeof(aaaaaaaaaaaaa1aaat); i++)
                       printf("%02x ", *(((char *) &meli->entry->exact_key.word[0]) + i) & 0xff);
                   printf("\n  M ");
for (i = 0; i < sizeof(aaaaaaaaaaaaa1aaat); i++)
                       printf("%02x ", *(((char *) &op->dst_entryset->mask.mask.word[0]) + i) & 0xff);
                   printf("\n  T ");
for (i = 0; i < sizeof(aaaaaaaaaaaaa1aaat); i++)
                       printf("%02x ", *(((char *) &meli->entry->exact_mask.mask.word[0]) + i) & 0xff);
                   printf("\n");
#endif
struct aaaaa1aaaaaaaaaaaabaaaaaaaaaaa3aaaaaaaaaaaaaaaabaaaaaaaaaaaaaaaaaaaaaaaaaaaa3aaaaaaaaaaaaabaaaaaaaaaaaaaaaaa4aaa *coll;
coll = calloc_function(1, sizeof(*coll));
coll->entry = meli->entry;
LIST_PREPEND(solution->collision_list, coll);
continue;
}
if (rc)
goto error;
}
if (op->src_op == aaaaa1aaaOP_DEL) {
rc = aaaaa1aaaaaaaaaaaaaaaabaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaa3aaaaaaaaaaaaaaaabaaaaaaaaaaaaaaaaaaaaaaaaaaaa4aaaaaaaaaaaaaaaabaaaaaaaaaaaaaaaaaaa5aaa(magg, meli->entry, op->src_entryset,
op->src_instance);
if (rc)
goto error;
}
}
}
rc = aaaaa1bbbbbbbbbbbbbbbbbbbbbbbbbb3aaaaaaaaaaaaaaaabaaaaaaaaaaaaaaaaaaaaaaaaaaaa4bbbbbbbbbbbbbbbbbbbbbbbbbbbb4aaaaaaaaaaaaaaaabaaaaaaaaaaaaaaaaaaaaaaaaaaaa5bbbbbbbbbbbbbbbbbbbbbbbbbbbbb5aaa(magg, solution);
if (rc)
goto error;
return 0;
error:;
cam_free_func free_function = a1aaaaaaaaaaaaaaaabaaaaaaaaaaaa3aaaaaaaaaaaaaaaabaaaaaaaaaaaaaaaaaaaaaaaaaaaa3aaaaaaaaaaaaaabaaaaaaaaaaaa4aaaaaaaaaaaaaaaabaaaaaaaaaaaaaaaaaaaaaaaaaaaa4aaaaaaaaaaaaaaaabaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaa4aaa((a1aaat*) (magg->client));
LIST_FOREACH_SAFE(solution->collision_list, meli, tmp)
{
LIST_DELETE2(solution->collision_list, meli, next);
free_function(meli);
}
solution->collision_list = NULL;
return rc;
}
static int
aaaaa1bbbbbbbbbbbbbbbbbbbbbbbbbb3aaaaaaaaaaaaaaaabaaaaaaaaaaaaaaaaaaaaaaaaaaaa4bbbbbbbbbbbbbbbbbbbbbbbbbbbbbb4aaaaaaaaaaaaaaaabaaaaaaaaaaaaaaaaaaaaaaaaaaaa5aaado(struct tcam *magg, struct aaaaa1aaaaaaaaaaaaaaaabaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaa3aaa *probsol)
{
int rc;
uint16_t remaining_entries;
struct aaaaa1aaaaaaaaaaaabaaaaaaaaaaa3bbbbbbbbbbbbbbbbbb3aaa *mes;
uint8_t instance;
remaining_entries = probsol->problem.num_entries;
probsol->curr_solution.num_masks = 0;
while (remaining_entries > 0) {
rc = aaaaa1aaaaaaaaaaaaaaaabaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaa3aaaaaaaaaaaaaaaabaaaaaaaaaaaaaaaaaaaaaaaaaaaa4aaawinner(magg, &probsol->problem, &mes);
if (rc)
return rc;
assert(mes);
uint16_t num_populated;
rc = aaaaa1bbbbbbbbbbbbbbbbbbbbbbbbbb3aaaaaaaaaaaaaaaabaaaaaaaaaaaaaaaaaaaaaaaaaaaa4bbbbbbbbbbbbbbbbbbbbbbbbbbbbbbbbbb4aaa(magg, &probsol->problem,
&probsol->curr_solution, mes, &num_populated,
&instance);
if (rc)
return rc;
assert(num_populated > 0);
remaining_entries -= num_populated;
probsol->curr_solution.num_masks++;
if (magg->debug_mask & aaaaa1bbbbbbbbbbbbbbbbbbbbbbbbbbbbbbbbbbbbb3aaaaaaaaaaaaaaaabaaaaaaaaaaaaaaaaaaaaaaaaaaaa4bbbbbbbbbbbbbbbbbb4aaaaaaaaaaaaaaaabaaaaaaaaaaaaaaaaaaaaaaaaaaaa5aaaCOVER) {
           printf("  Winner %2u is %08x instance %u weight %u, remain weight %u, entries %u, remain %u, max pop cnt %u, tot pop cnt %u, active %u, populated %u, total remain %u :\n",
probsol->curr_solution.num_masks,
aaaaa1aaaaaaaaaaaaaaaabaaaaaaaaaaaaaaaaaaaaaaa3aaaaaaaaaaaaaaaabaaaaaaaaaaaaaaaaaaaaaaaaaaaa3aaaaaaaaaaaabaaaaaaaaaa4aaaaaaaaaaaaaaaabaaaaaaaaaaaaaaaaaaaaaaaaaaaa4aaavalue(&mes->mask), instance,
mes->weight, mes->remaining_weight,
mes->num_entries, mes->remaining_entries,
mes->mask.max_pop, mes->mask.tot_pop,
mes->mask.active_fields,
num_populated, remaining_entries);
aaaaa1aaaaaaaaaaaaaaaabaaaaaaaaaaaaaaaaaaaaaaa3aaaaaaaaaaaaaaaabaaaaaaaaaaaaaaaaaaaaaaaaaaaa3aaaaaaaaaaaaaaaabaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaa3aaa(magg, &mes->mask, 4);
if (magg->debug_mask & aaaaa1bbbbbbbbbbbbbbbbbbbbbbbbbbbbbbbbbbbbb3aaaaaaaaaaaaaaaabaaaaaaaaaaaaaaaaaaaaaaaaaaaa4aaaSORTEDSET) {
int i = 0;
LIST_FOREACH2(probsol->problem.entryset_by_mask, mes, mh_handle.next)
{
if (mes == probsol->problem.entryset_by_mask)
continue;
                   printf("                                   weight %u, remain weight %u, entries %u, remain %u, max pop cnt %u :\n",
mes->weight, mes->remaining_weight,
mes->num_entries, mes->remaining_entries,
mes->mask.max_pop);
aaaaa1aaaaaaaaaaaaaaaabaaaaaaaaaaaaaaaaaaaaaaa3aaaaaaaaaaaaaaaabaaaaaaaaaaaaaaaaaaaaaaaaaaaa3aaaaaaaaaaaaaaaabaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaa3aaa(magg, &mes->mask, 4);
i++;
if (i == 9)
break;
}
}
}
}
rc = aaaaa1bbbbbbbbbbbbbbbbbbbbbbbbbb3aaaaaaaaaaaaaaaabaaaaaaaaaaaaaaaaaaaaaaaaaaaa4bbbbbbbbbbbbbbbbbbbbbbbbbbbbbbb4aaa(magg, probsol);
if (rc)
return rc;
rc = aaaaa1bbbbbbbbbbbbbbbbbbbbbbbbbb3aaaaaaaaaaaaaaaabaaaaaaaaaaaaaaaaaaaaaaaaaaaa4aaasort(magg, &probsol->curr_solution);
if (rc)
return rc;
return 0;
}
int
aaaaa1bbbbbbbbbbbbbbbbbbbbbbbbbb3aaaaaaaaaaaaaaaabaaaaaaaaaaaaaaaaaaaaaaaaaaaa4bbbbbbbbbbbbbbbbbbbbbbbbbbbbbbbb4aaaaaaaaaaaaaaaabaaaaaaaaaaaaaaaaaaaaaaaaaaaa5aaaaaaaaaaaabaaaaaaaaaaa6bbbbbbbbbbbbbbbbbb6aaa(struct tcam *magg,
struct aaaaa1aaaaaaaaaaaaaaaabaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaa3aaa *probsol,
struct aaaaa1aaaaaaaaaaaabaaaaaaaaaaa3bbbbbbbbbbbbbbbbbb3aaa *mes,
struct aaaaa1aaaaaaaaaaaabaaaaaaaaaaa3bbbbbbbbbbbbbbbbbb3aaaaaaaaaaaaaaaabaaaaaaaaaaaaaaaaaaaaaaaaaaaa4aaaaaaaaaaaaabaaaaaaaaaaaaaaaaa5aaa **out_mesli)
{
int rc;
struct aaaaa1aaaaaaaaaaaabaaaaaaaaaaa3bbbbbbbbbbbbbbbbbb3aaaaaaaaaaaaaaaabaaaaaaaaaaaaaaaaaaaaaaaaaaaa4aaaaaaaaaaaaabaaaaaaaaaaaaaaaaa5aaa *mesli;
cam_calloc_func calloc_function = a1aaaaaaaaaaaaaaaabaaaaaaaaaaaa3aaaaaaaaaaaaaaaabaaaaaaaaaaaaaaaaaaaaaaaaaaaa3aaacalloc_function((a1aaat*) (magg->client));
mesli = calloc_function(1, sizeof(*mesli));
if (mesli == NULL)
return CAM_ERROR_NOMEM;
mesli->entryset = mes;
rc = aaaaa1aaaaaaaaaaaaaaaabaaaaaaaaaaaaaaaaaaaaaaa3aaaaaaaaaaaaaaaabaaaaaaaaaaaaaaaaaaaaaaaaaaaa3aaaaaaaaaaaaaaaabaaaaaaaaaaaa4aaaaaaaaaaaaaaaabaaaaaaaaaaaaaaaaaaaaaaaaaaaa4aaainstance(magg, &mes->mask, &mesli->instance);
if (rc)
goto error;
LIST_APPEND(probsol->curr_solution.mask_list, mesli);
probsol->curr_solution.num_masks++;
magg->num_masks++;
magg->stats.curr_num_masks = magg->num_masks;
magg->stats.max_num_masks = MAX(magg->stats.curr_num_masks, magg->stats.max_num_masks);
magg->stats.curr_open_masks = magg->num_masks - magg->stats.curr_closed_masks;
magg->stats.max_open_masks = MAX(magg->stats.curr_open_masks, magg->stats.max_open_masks);
*out_mesli = mesli;
return 0;
error:;
cam_free_func free_function = a1aaaaaaaaaaaaaaaabaaaaaaaaaaaa3aaaaaaaaaaaaaaaabaaaaaaaaaaaaaaaaaaaaaaaaaaaa3aaaaaaaaaaaaaabaaaaaaaaaaaa4aaaaaaaaaaaaaaaabaaaaaaaaaaaaaaaaaaaaaaaaaaaa4aaaaaaaaaaaaaaaabaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaa4aaa((a1aaat*) (magg->client));
free_function(mesli);
return rc;
}
int
aaaaa1bbbbbbbbbbbbbbbbbbbbbbbbbb3aaaaaaaaaaaaaaaabaaaaaaaaaaaaaaaaaaaaaaaaaaaa4aaafind_entryset(struct tcam *magg,
struct aaaaa1aaaaaaaaaaaaaaaabaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaa3aaa *probsol,
struct aaaaa1aaaaaaaaaaaabaaaaaaaaaaa3aaa *me,
struct aaaaa1aaaaaaaaaaaabaaaaaaaaaaa3bbbbbbbbbbbbbbbbbb3aaaaaaaaaaaaaaaabaaaaaaaaaaaaaaaaaaaaaaaaaaaa4aaaaaaaaaaaaabaaaaaaaaaaaaaaaaa5aaa **out_mesli)
{
int rc;
struct aaaaa1bbbbbbbbbbbbbbbbbbbbbbbbbbbbbbbbb3aaa *collset;
struct aaaaa1aaaaaaaaaaaabaaaaaaaaaaa3aaaaaaaaaaaaaaaabaaaaaaaaaaaaaaaaaaaaaaaaaaaa3aaaaaaaaaaaaabaaaaaaaaaaaaaaaaa4aaa *meli;
struct aaaaa1aaaaaaaaaaaabaaaaaaaaaaa3bbbbbbbbbbbbbbbbbb3aaaaaaaaaaaaaaaabaaaaaaaaaaaaaaaaaaaaaaaaaaaa4aaaaaaaaaaaaabaaaaaaaaaaaaaaaaa5aaa *mesli;
const uint8_t max_entries_per_unit_bits = 32
- __builtin_clz((uint32_t) a1aaaaaaaaaaaaaaaabaaaaaaaaaaaa3aaaaaaaaaaaaaaaabaaaaaaaaaaaaaaaaaaaaaaaaaaaa3aaaaaaaaaaaaaaabaaaaaaaaaaaaaaaa4aaaaaaaaaaaaaaaabaaaaaaaaaaaaaaaaaaaaaaaaaaaa4aaaaaaaaaaaaaaaabaaaaaaaaaaaaaaaaaaaaa5aaaaaaaaaaaaaaaabaaaaaaaaaaaaaaaaaaaaaaaaaaaa5aaaper_unit(magg->client));
int bits;
int64_t space_left;
int64_t best_space = -1;
int best_pop = -1;
*out_mesli = NULL;
LIST_FOREACH(probsol->curr_solution.mask_list, mesli)
{
if (!aaaaa1aaaaaaaaaaaaaaaabaaaaaaaaaaaaaaaaaaaaaaa3aaaaaaaaaaaaaaaabaaaaaaaaaaaaaaaaaaaaaaaaaaaa3aaaaaaaaaaaabaaaaaaaaaa4aaaaaaaaaaaaaaaabaaaaaaaaaaaaaaaaaaaaaaaaaaaa4aaaaaaaaaaaaaaabaaaaaaaaaaaa5aaaaaaaaaaaaaaaabaaaaaaaaaaaaaaaaaaaaaaaaaaaa5aaamember(magg, &mesli->entryset->mask, me))
continue;
if (mesli->num_entries == a1aaaaaaaaaaaaaaaabaaaaaaaaaaaa3aaaaaaaaaaaaaaaabaaaaaaaaaaaaaaaaaaaaaaaaaaaa3aaaaaaaaaaaaaaabaaaaaaaaaaaaaaaa4aaaaaaaaaaaaaaaabaaaaaaaaaaaaaaaaaaaaaaaaaaaa4aaaaaaaaaaaaaaaabaaaaaaaaaaaaaaaaaaaaa5aaaaaaaaaaaaaaaabaaaaaaaaaaaaaaaaaaaaaaaaaaaa5aaaper_unit(magg->client))
continue;
rc = aaaaa1bbbbbbbbbbbbbbbbbbbbbbbbbbbbbbbbb3aaaaaaaaaaaaaaaabaaaaaaaaaaaaaaaaaaaaaaaaaaaa4aaafind(magg, mesli->entryset, me, &collset);
if (rc) {
bits = MIN(mesli->entryset->mask.const_pop, max_entries_per_unit_bits) +
mesli->entryset->mask.max_pop;
if (bits > 62)
bits = 62;
space_left = ((int64_t) 1 << bits) - mesli->num_entries;
if (space_left > best_space) {
*out_mesli = mesli;
best_space = space_left;
}
continue;
}
if (probsol->is_solved) {
if (collset->entry_ids.num_entries < magg->max_num_collisions) {
bits = MIN(mesli->entryset->mask.const_pop, max_entries_per_unit_bits) +
mesli->entryset->mask.max_pop;
if (bits > max_entries_per_unit_bits)
bits = max_entries_per_unit_bits;
space_left = ((int64_t) 1 << bits) - mesli->num_entries;
if (space_left > best_space ||
(space_left == best_space &&
mesli->entryset->mask.max_pop > best_pop)) {
best_pop = mesli->entryset->mask.max_pop;
*out_mesli = mesli;
best_space = space_left;
}
continue;
}
} else {
int collisions = 0;
LIST_FOREACH(mesli->entry_list, meli)
{
if (collset == meli->entry->current_entryset.collset) {
collisions++;
if (collisions == magg->max_num_collisions) {
break;
}
}
}
if (collisions < magg->max_num_collisions) {
bits = MIN(mesli->entryset->mask.const_pop, max_entries_per_unit_bits) +
mesli->entryset->mask.max_pop;
if (bits > 62)
bits = 62;
space_left = ((int64_t) 1 << bits) - mesli->num_entries;
if (space_left > best_space) {
*out_mesli = mesli;
best_space = space_left;
}
continue;
}
}
}
return 0;
}
int
aaaaa1bbbbbbbbbbbbbbbbbbbbbbbbbb3aaaaaaaaaaaaaaaabaaaaaaaaaaaaaaaaaaaaaaaaaaaa4bbbbbbbbbbbbbbbbbbbbbbbbbbbbbbbb4aaa(struct tcam *magg,
struct aaaaa1aaaaaaaaaaaabaaaaaaaaaaa3bbbbbbbbbbbbbbbbbb3aaaaaaaaaaaaaaaabaaaaaaaaaaaaaaaaaaaaaaaaaaaa4aaaaaaaaaaaaabaaaaaaaaaaaaaaaaa5aaa *mesli, struct aaaaa1aaaaaaaaaaaabaaaaaaaaaaa3aaa *me)
{
int rc;
struct aaaaa1aaaaaaaaaaaabaaaaaaaaaaa3aaaaaaaaaaaaaaaabaaaaaaaaaaaaaaaaaaaaaaaaaaaa3aaaaaaaaaaaaabaaaaaaaaaaaaaaaaa4aaa *meli;
struct aaaaa1bbbbbbbbbbbbbbbbbbbbbbbbbbbbbbbbb3aaa *collset;
cam_calloc_func calloc_function = a1aaaaaaaaaaaaaaaabaaaaaaaaaaaa3aaaaaaaaaaaaaaaabaaaaaaaaaaaaaaaaaaaaaaaaaaaa3aaacalloc_function((a1aaat*) (magg->client));
rc = aaaaa1bbbbbbbbbbbbbbbbbbbbbbbbbbbbbbbbb3aaaaaaaaaaaaaaaabaaaaaaaaaaaaaaaaaaaaaaaaaaaa4aaafind(magg, mesli->entryset, me, &collset);
assert(rc == 0);
meli = calloc_function(1, sizeof(*meli));
if (meli == NULL)
return CAM_ERROR_NOMEM;
rc = aaaaa1aaaaaaaaaaaaaaaabaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaa3aaaaaaaaaaaaaaaabaaaaaaaaaaaaaaaaaaaaaaaaaaaa4bbbbbbbbbbbbbbbbbbbbbbbbbbbbbbbb4aaa(magg, me, mesli->entryset, mesli->instance, collset);
if (rc) {
a1aaaaaaaaaaaaaaaabaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaa3aaa(magg->client);
goto error;
}
meli->entry = me;
LIST_PREPEND2(mesli->entry_list, meli, next);
mesli->num_entries++;
return 0;
error:;
cam_free_func free_function = a1aaaaaaaaaaaaaaaabaaaaaaaaaaaa3aaaaaaaaaaaaaaaabaaaaaaaaaaaaaaaaaaaaaaaaaaaa3aaaaaaaaaaaaaabaaaaaaaaaaaa4aaaaaaaaaaaaaaaabaaaaaaaaaaaaaaaaaaaaaaaaaaaa4aaaaaaaaaaaaaaaabaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaa4aaa((a1aaat*) (magg->client));
free_function(meli);
return rc;
}
int
aaaaa1bbbbbbbbbbbbbbbbbbbbbbbbbb3aaaaaaaaaaaaaaaabaaaaaaaaaaaaaaaaaaaaaaaaaaaa4aaaaaaaaaaaaaaaabaaaaaaaaaaaaaaaaaaa5aaa(struct tcam *magg, struct aaaaa1bbbbbbbbbbbbbbbbbbbbbbbbbb3aaa *solution,
struct aaaaa1aaaaaaaaaaaabaaaaaaaaaaa3aaa *me,
struct aaaaa1aaaaaaaaaaaabaaaaaaaaaaa3bbbbbbbbbbbbbbbbbb3aaaaaaaaaaaaaaaabaaaaaaaaaaaaaaaaaaaaaaaaaaaa4aaaaaaaaaaaaabaaaaaaaaaaaaaaaaa5aaa **out_mesli)
{
int rc;
struct aaaaa1aaaaaaaaaaaabaaaaaaaaaaa3aaaaaaaaaaaaaaaabaaaaaaaaaaaaaaaaaaaaaaaaaaaa3aaaaaaaaaaaaabaaaaaaaaaaaaaaaaa4aaa *meli, *meli_tmp;
struct aaaaa1aaaaaaaaaaaabaaaaaaaaaaa3bbbbbbbbbbbbbbbbbb3aaaaaaaaaaaaaaaabaaaaaaaaaaaaaaaaaaaaaaaaaaaa4aaaaaaaaaaaaabaaaaaaaaaaaaaaaaa5aaa *mesli, *mesli_tmp;
cam_free_func free_function = a1aaaaaaaaaaaaaaaabaaaaaaaaaaaa3aaaaaaaaaaaaaaaabaaaaaaaaaaaaaaaaaaaaaaaaaaaa3aaaaaaaaaaaaaabaaaaaaaaaaaa4aaaaaaaaaaaaaaaabaaaaaaaaaaaaaaaaaaaaaaaaaaaa4aaaaaaaaaaaaaaaabaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaa4aaa((a1aaat*) (magg->client));
rc = -1;
LIST_FOREACH_SAFE(solution->mask_list, mesli, mesli_tmp)
{
LIST_FOREACH_SAFE(mesli->entry_list, meli, meli_tmp)
{
if (meli->entry == me) {
LIST_DELETE2(mesli->entry_list, meli, next);
free_function(meli);
mesli->num_entries--;
(*out_mesli) = mesli;
rc = 0;
break;
}
}
if (mesli->entry_list == NULL) {
solution->num_masks--;
magg->num_masks--;
magg->stats.curr_num_masks = magg->num_masks;
magg->stats.curr_open_masks = magg->num_masks - magg->stats.curr_closed_masks;
rc = aaaaa1aaaaaaaaaaaaaaaabaaaaaaaaaaaaaaaaaaaaaaa3aaaaaaaaaaaaaaaabaaaaaaaaaaaaaaaaaaaaaaaaaaaa3aaaput_instance(magg, &mesli->entryset->mask,
mesli->instance);
if (rc)
return rc;
LIST_DELETE2(solution->mask_list, mesli, next);
free_function(mesli);
(*out_mesli) = NULL;
break;
}
}
return rc;
}
int
aaaaa1bbbbbbbbbbbbbbbbbbbbbbbbbb3aaaaaaaaaaaaaaaabaaaaaaaaaaaaaaaaaaaaaaaaaaaa4bbbbbbbbbbbbbbbbbbbbbbbbbbbbbb4aaa(struct tcam *magg, struct aaaaa1aaaaaaaaaaaaaaaabaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaa3aaa *probsol,
int max_num_masks)
{
int rc;
magg->num_masks -= probsol->curr_solution.num_masks;
magg->stats.curr_num_masks = magg->num_masks;
magg->stats.curr_open_masks = magg->num_masks - magg->stats.curr_closed_masks;
probsol->prev_solution = probsol->curr_solution;
rc = aaaaa1bbbbbbbbbbbbbbbbbbbbbbbbbb3aaaaaaaaaaaaaaaabaaaaaaaaaaaaaaaaaaaaaaaaaaaa4bbbbbbbbbbbbbbbbbbbbbbbbbbbbbbbbbbbbbbb4aaaeate(magg, &probsol->curr_solution);
if (rc)
return rc;
rc = aaaaa1aaaaaaaaaaaaaaaabaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaa3aaaaaaaaaaaaaaaabaaaaaaaaaaaaaaaaaaaaaaaaaaaa4aaareset(magg, &probsol->problem);
if (rc)
return rc;
rc = aaaaa1bbbbbbbbbbbbbbbbbbbbbbbbbb3aaaaaaaaaaaaaaaabaaaaaaaaaaaaaaaaaaaaaaaaaaaa4bbbbbbbbbbbbbbbbbbbbbbbbbbbbbb4aaaaaaaaaaaaaaaabaaaaaaaaaaaaaaaaaaaaaaaaaaaa5aaado(magg, probsol);
if (rc)
return rc;
if (probsol->curr_solution.num_masks > probsol->prev_solution.num_masks ||
probsol->curr_solution.num_masks > max_num_masks) {
rc = aaaaa1bbbbbbbbbbbbbbbbbbbbbbbbbb3aaaaaaaaaaaaaaaabaaaaaaaaaaaaaaaaaaaaaaaaaaaa4aaaaaaaaaaaaaaaabaaaaaaaaaaaaaaaaaaaaaaaaa5aaa(magg, &probsol->curr_solution);
if (rc)
return rc;
probsol->curr_solution = probsol->prev_solution;
magg->num_masks += probsol->curr_solution.num_masks;
return 1;
}
rc = aaaaa1bbbbbbbbbbbbbbbbbbbbbbbbbb3aaaaaaaaaaaaaaaabaaaaaaaaaaaaaaaaaaaaaaaaaaaa4bbbbbbbbbbbbbbbbbbbbbbbbbbbb4aaa(magg, &probsol->curr_solution);
if (rc)
return rc;
rc = aaaaa1bbbbbbbbbbbbbbbbbbbbbbbbbb3aaaaaaaaaaaaaaaabaaaaaaaaaaaaaaaaaaaaaaaaaaaa4aaaaaaaaaaaaaaaabaaaaaaaaaaaaaaaaaaaaaaaaa5aaa(magg, &probsol->prev_solution);
if (rc)
return rc;
magg->num_masks += probsol->curr_solution.num_masks;
magg->stats.curr_num_masks = magg->num_masks;
magg->stats.max_num_masks = MAX(magg->stats.curr_num_masks, magg->stats.max_num_masks);
magg->stats.curr_open_masks = magg->num_masks - magg->stats.curr_closed_masks;
magg->stats.max_open_masks = MAX(magg->stats.curr_open_masks, magg->stats.max_open_masks);
return rc;
}
#ifndef COMP_BCAM_IP
#endif 
static inline uint8_t popcount128(uint64_t word[])
{
return __builtin_popcountll(word[0]) + __builtin_popcountll(word[1]);
}
static inline uint8_t ctz128(uint64_t word[])
{
if (word[0] != 0)
return __builtin_ctzll(word[0]);
if (word[1] == 0)
return 128;
return 64 + __builtin_ctzll(word[1]);
}
static inline void set128(uint64_t word[], uint8_t bits)
{
word[0] = UINT64_MAX;
if (bits <= 64) {
word[0] = word[0] >> (64 - bits);
word[1] = 0;
} else {
word[1] = UINT64_MAX >> (128 - bits);
}
}
void cam_copy_bits(uint8_t *target, const uint8_t *source, uint16_t bit_len)
{
const uint16_t num_bytes = bit_len / 8;
const uint8_t rem_bits = bit_len - num_bytes * 8;
memcpy(target, source, num_bytes);
if (rem_bits)
target[num_bytes] = aaaaaaaa1aaaaaaaaaaaaaaaabaaaaaaaaaaaa3aaa8(source[num_bytes], 0, rem_bits);
}
void aaaaa1aaaaaaaaaaaaaaaabaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaa3aaaaaaaaaaaaaaaabaaaaaaaaaaaaaaaaaaaaaaaaaaaa4bbbbbbbbbbbbbbbb4aaaaaaaaaaaaaaaabaaaaaaaaaaaaaaaaaaaaaaaaaaaa5aaauint2bit(uint8_t * dst, uint8_t dst_len_bytes, uint16_t dst_offset_bits, const uint8_t * src,
const uint16_t src_len_bits)
{
assert(dst_offset_bits < dst_len_bytes * 8);
assert(dst_offset_bits + src_len_bits <= dst_len_bytes * 8);
uint8_t bit_shift = dst_offset_bits % 8;
dst += dst_offset_bits / 8;
int16_t remain_bits = src_len_bits;
while (remain_bits > 0) {
uint8_t tmp = (*src);
if (remain_bits < 8)
tmp &= ~(0xff << remain_bits);
*dst |= tmp << bit_shift;
dst++;
remain_bits -= MIN(remain_bits, 8 - bit_shift);
if (remain_bits == 0)
return;
*dst |= tmp >> (8 - bit_shift);
remain_bits -= MIN(remain_bits, bit_shift);
src++;
}
assert(remain_bits == 0);
}
void aaaaa1aaaaaaaaaaaaaaaabaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaa3aaaaaaaaaaaaaaaabaaaaaaaaaaaaaaaaaaaaaaaaaaaa4bbbbbbbbbbbbbbbb4aaaaaaaaaaaaaaaabaaaaaaaaaaaaaaaaaaaaaaaaaaaa5aaauint64(uint64_t dst[], uint16_t dst_offset_bits,
const uint64_t *src, uint16_t src_offset_bits,
uint16_t src_len_bits)
{
const uint8_t WORD = 64;
const uint8_t WORD_BYTES = WORD / 8;
uint8_t src_word = src_offset_bits / WORD;
src += WORD_BYTES * src_word;
uint8_t src_bit = src_offset_bits % WORD;
uint8_t dst_word = dst_offset_bits / WORD;
dst += WORD_BYTES * dst_word;
uint8_t dst_bit = dst_offset_bits % WORD;
uint16_t remaining_bits = src_len_bits;
uint64_t tmp = 0;
while (remaining_bits > 0) {
uint8_t src_len = MIN(remaining_bits, WORD - src_bit);
uint8_t dst_len = MIN(remaining_bits, WORD - dst_bit);
uint8_t len = MIN(src_len, dst_len);
tmp = aaaaaaaa1aaaaaaaaaaaaaaaabaaaaaaaaaaaa3aaa64(*(uint64_t *) src, src_bit, len);
if (dst_bit == 0)
*dst = tmp;
else
*dst = aaaaaaaa1aaaaaaaaaaaaaaaabaaaaaaaaaaaaaaaaaaaaaa3aaa64(*dst, tmp, dst_bit, len);
src_bit = src_bit + len;
if (src_bit >= WORD) {
src_bit -= WORD;
src += WORD_BYTES;
}
dst_bit = dst_bit + len;
if (dst_bit >= WORD) {
dst_bit -= WORD;
dst++;
}
remaining_bits -= len;
}
}
void aaaaa1aaaaaaaaaaaaaaaabaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaa3aaaaaaaaaaaaaaaabaaaaaaaaaaaaaaaaaaaaaaaaaaaa4bbbbbbbbbbbbbbbbbb4aaaaaaaaaaaaaaaabaaaaaaaaaaaaaaaaaaaaaaaaaaaa5aaabits(uint8_t * dst, uint8_t dst_len_bytes,
uint16_t dst_offset_bits, uint16_t len_bits)
{
if (len_bits == 0)
return;
assert(dst_offset_bits < dst_len_bytes * 8);
assert(dst_offset_bits + len_bits <= dst_len_bytes * 8);
uint8_t bit_shift = dst_offset_bits % 8;
dst += dst_offset_bits / 8;
int16_t remain_bits = len_bits;
while (remain_bits > 0) {
uint8_t tmp = 0xff;
if (remain_bits < 8)
tmp &= ~(0xff << remain_bits);
*dst |= tmp << bit_shift;
dst++;
remain_bits -= MIN(remain_bits, 8 - bit_shift);
if (remain_bits == 0)
return;
*dst |= tmp >> (8 - bit_shift);
remain_bits -= MIN(remain_bits, bit_shift);
}
assert(remain_bits == 0);
}
#ifndef COMP_BCAM_IP
static int aaaaa1aaaaaaaaaaaaaaaabaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaa3aaaaaaaaaaaaaaaabaaaaaaaaaaaaaaaaaaaaaaaaaaaa4aaaaaaaaaaaaaaaabaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaa4aaaaaaaaaaaaaaaabaaaaaaaaaaaaaaaaaaaaaaaaaaaa5bbbbbbbbbbbbbbbb5aaa(struct tcam *tcam, const union aaaaaaaaaaa1aaa fields[], uint8_t index,
uint8_t key[])
{
aaaaaaaaaaa1aaaaaaaaaaaaaaaabaaaaaaaaaaaaaaaaaaaaaaaaaaaa3aaadesc mfd;
const int rc = a1aaaaaaaaaaaaaaaabaaaaaaaaaaaa3aaaaaaaaaaaaaaaabaaaaaaaaaaaaaaaaaaaaaaaaaaaa3aaaaaaaaaaaaaaaaaaaaa1aaa(tcam->client, index, &mfd);
assert(rc == 0);
switch (mfd.type) {
case aaaaaaaaaaa1aaaaaaaaaaaaaaaabaaaaaaaaaaaaaaaaaaaaaaaaaaaa3aaaR16:
aaaaa1aaaaaaaaaaaaaaaabaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaa3aaaaaaaaaaaaaaaabaaaaaaaaaaaaaaaaaaaaaaaaaaaa4bbbbbbbbbbbbbbbb4aaaaaaaaaaaaaaaabaaaaaaaaaaaaaaaaaaaaaaaaaaaa5aaauint2bit(key, sizeof(aaaaaaaaaaaaa1aaat), mfd.start_pos,
(uint8_t *) &fields[index].r16.start, mfd.len);
break;
case aaaaaaaaaaa1aaaaaaaaaaaaaaaabaaaaaaaaaaaaaaaaaaaaaaaaaaaa3aaaP128:
aaaaa1aaaaaaaaaaaaaaaabaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaa3aaaaaaaaaaaaaaaabaaaaaaaaaaaaaaaaaaaaaaaaaaaa4bbbbbbbbbbbbbbbb4aaaaaaaaaaaaaaaabaaaaaaaaaaaaaaaaaaaaaaaaaaaa5aaauint2bit((uint8_t *) key, sizeof(aaaaaaaaaaaaa1aaat), mfd.start_pos,
&fields[index].p128.key[0], mfd.len);
break;
case aaaaaaaaaaa1aaaaaaaaaaaaaaaabaaaaaaaaaaaaaaaaaaaaaaaaaaaa3aaaT64:
aaaaa1aaaaaaaaaaaaaaaabaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaa3aaaaaaaaaaaaaaaabaaaaaaaaaaaaaaaaaaaaaaaaaaaa4bbbbbbbbbbbbbbbb4aaaaaaaaaaaaaaaabaaaaaaaaaaaaaaaaaaaaaaaaaaaa5aaauint2bit((uint8_t *) key, sizeof(aaaaaaaaaaaaa1aaat), mfd.start_pos, &fields[index].t64.key[0], mfd.len);
break;
case aaaaaaaaaaa1aaaaaaaaaaaaaaaabaaaaaaaaaaaaaaaaaaaaaaaaaaaa3aaaB128:
aaaaa1aaaaaaaaaaaaaaaabaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaa3aaaaaaaaaaaaaaaabaaaaaaaaaaaaaaaaaaaaaaaaaaaa4bbbbbbbbbbbbbbbb4aaaaaaaaaaaaaaaabaaaaaaaaaaaaaaaaaaaaaaaaaaaa5aaauint2bit((uint8_t *) key, sizeof(aaaaaaaaaaaaa1aaat), mfd.start_pos,
&fields[index].b128.key[0], mfd.len);
break;
case aaaaaaaaaaa1aaaaaaaaaaaaaaaabaaaaaaaaaaaaaaaaaaaaaaaaaaaa3aaaC128:
aaaaa1aaaaaaaaaaaaaaaabaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaa3aaaaaaaaaaaaaaaabaaaaaaaaaaaaaaaaaaaaaaaaaaaa4bbbbbbbbbbbbbbbb4aaaaaaaaaaaaaaaabaaaaaaaaaaaaaaaaaaaaaaaaaaaa5aaauint2bit((uint8_t *) key, sizeof(aaaaaaaaaaaaa1aaat), mfd.start_pos,
&fields[index].c128.key[0], mfd.len);
break;
case aaaaaaaaaaa1aaaaaaaaaaaaaaaabaaaaaaaaaaaaaaaaaaaaaaaaaaaa3aaaU128:
break;
default:
assert(0);
}
return 0;
}
#endif 
#ifndef COMP_BCAM_IP
static int aaaaa1aaaaaaaaaaaaaaaabaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaa3aaaaaaaaaaaaaaaabaaaaaaaaaaaaaaaaaaaaaaaaaaaa4aaaternary_mask_copy(struct tcam *tcam, const union aaaaaaaaaaa1aaa fields[], uint8_t index,
uint8_t ternary_mask[])
{
aaaaaaaaaaa1aaaaaaaaaaaaaaaabaaaaaaaaaaaaaaaaaaaaaaaaaaaa3aaadesc mfd;
const int rc = a1aaaaaaaaaaaaaaaabaaaaaaaaaaaa3aaaaaaaaaaaaaaaabaaaaaaaaaaaaaaaaaaaaaaaaaaaa3aaaaaaaaaaaaaaaaaaaaa1aaa(tcam->client, index, &mfd);
assert(rc == 0);
switch (mfd.type) {
case aaaaaaaaaaa1aaaaaaaaaaaaaaaabaaaaaaaaaaaaaaaaaaaaaaaaaaaa3aaaR16:
aaaaa1aaaaaaaaaaaaaaaabaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaa3aaaaaaaaaaaaaaaabaaaaaaaaaaaaaaaaaaaaaaaaaaaa4bbbbbbbbbbbbbbbb4aaaaaaaaaaaaaaaabaaaaaaaaaaaaaaaaaaaaaaaaaaaa5aaauint2bit((uint8_t *) ternary_mask, sizeof(aaaaaaaaaaaaa1aaat), mfd.start_pos,
(uint8_t *) &fields[index].r16.end, mfd.len);
break;
case aaaaaaaaaaa1aaaaaaaaaaaaaaaabaaaaaaaaaaaaaaaaaaaaaaaaaaaa3aaaP128:
aaaaa1aaaaaaaaaaaaaaaabaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaa3aaaaaaaaaaaaaaaabaaaaaaaaaaaaaaaaaaaaaaaaaaaa4bbbbbbbbbbbbbbbbbb4aaaaaaaaaaaaaaaabaaaaaaaaaaaaaaaaaaaaaaaaaaaa5aaabits((uint8_t *) ternary_mask, sizeof(aaaaaaaaaaaaa1aaat),
mfd.start_pos + mfd.len - fields[index].p128.len, fields[index].p128.len);
break;
case aaaaaaaaaaa1aaaaaaaaaaaaaaaabaaaaaaaaaaaaaaaaaaaaaaaaaaaa3aaaT64:
aaaaa1aaaaaaaaaaaaaaaabaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaa3aaaaaaaaaaaaaaaabaaaaaaaaaaaaaaaaaaaaaaaaaaaa4bbbbbbbbbbbbbbbb4aaaaaaaaaaaaaaaabaaaaaaaaaaaaaaaaaaaaaaaaaaaa5aaauint2bit((uint8_t *) ternary_mask, sizeof(aaaaaaaaaaaaa1aaat), mfd.start_pos,
&fields[index].t64.mask[0], mfd.len);
break;
case aaaaaaaaaaa1aaaaaaaaaaaaaaaabaaaaaaaaaaaaaaaaaaaaaaaaaaaa3aaaB128:
aaaaa1aaaaaaaaaaaaaaaabaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaa3aaaaaaaaaaaaaaaabaaaaaaaaaaaaaaaaaaaaaaaaaaaa4bbbbbbbbbbbbbbbb4aaaaaaaaaaaaaaaabaaaaaaaaaaaaaaaaaaaaaaaaaaaa5aaauint2bit((uint8_t *) ternary_mask, sizeof(aaaaaaaaaaaaa1aaat), mfd.start_pos,
&fields[index].b128.mask[0], mfd.len);
break;
case aaaaaaaaaaa1aaaaaaaaaaaaaaaabaaaaaaaaaaaaaaaaaaaaaaaaaaaa3aaaC128:
aaaaa1aaaaaaaaaaaaaaaabaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaa3aaaaaaaaaaaaaaaabaaaaaaaaaaaaaaaaaaaaaaaaaaaa4bbbbbbbbbbbbbbbbbb4aaaaaaaaaaaaaaaabaaaaaaaaaaaaaaaaaaaaaaaaaaaa5aaabits((uint8_t *) ternary_mask, sizeof(aaaaaaaaaaaaa1aaat), mfd.start_pos, mfd.len);
break;
case aaaaaaaaaaa1aaaaaaaaaaaaaaaabaaaaaaaaaaaaaaaaaaaaaaaaaaaa3aaaU128:
break;
default:
assert(0);
}
return 0;
}
#endif 
#ifndef COMP_BCAM_IP
static int aaaaa1aaaaaaaaaaaaaaaabaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaa3aaaaaaaaaaaaaaaabaaaaaaaaaaaaaaaaaaaaaaaaaaaa4aaaaaaaaaaaaaaabaaaaaaaaaaaaaaaaaa5aaaaaaaaaaaaaaaabaaaaaaaaaaaaaaaaaaaaaaaaaaaa5bbbbbbbbbbbbbbbb5aaaaaaaaaaaaaaaabaaaaaaaaaaaaaaaaaaaaaaaaaaaa6aaafrom_ternary_mask(const aaaaaaaaaaa1aaaaaaaaaaaaaaaabaaaaaaaaaaaaaaaaaaaaaaaaaaaa3aaadesc *mfd, union aaaaaaaaaaa1aaa fields[],
uint8_t index, const uint8_t ternary_mask[],
const a1aaat *client)
{
uint64_t temp[2];
uint64_t clr_bits[2] = { 0 };
uint64_t set_bits[2];
uint8_t num_ones;
uint8_t num_trailing_zeroes;
uint8_t verbose = (a1aaaaaaaaaaaaaaaabaaaaaaaaaaaa3aaaaaaaaaaaaaaaabaaaaaaaaaaaaaaaaaaaaaaaaaaaa3bbbbbbbbbbbbbbbbbbbbbbbbbbbbbbbbbbbbb3aaaaaaaaaaaaaaaabaaaaaaaaaaaaaaaaaaaaaaaaaaaa4aaaflags(client) & CAM_DEBUG_NO_ERROR_MSG) == 0;
char message[500];
cam_malloc_func malloc_function = a1aaaaaaaaaaaaaaaabaaaaaaaaaaaa3aaaaaaaaaaaaaaaabaaaaaaaaaaaaaaaaaaaaaaaaaaaa3aaamalloc_function(client);
switch (mfd->type) {
case aaaaaaaaaaa1aaaaaaaaaaaaaaaabaaaaaaaaaaaaaaaaaaaaaaaaaaaa3aaaR16:
memset(&fields[index].r16.end, 0, sizeof(fields[index].r16.end));
cam_read_field8((uint8_t *) &fields[index].r16.end, &ternary_mask[0], mfd->start_pos, mfd->len);
break;
case aaaaaaaaaaa1aaaaaaaaaaaaaaaabaaaaaaaaaaaaaaaaaaaaaaaaaaaa3aaaP128:
memset(temp, 0, sizeof(temp));
cam_read_field8((uint8_t *) temp, (uint8_t *) &ternary_mask[0],
mfd->start_pos, mfd->len);
num_trailing_zeroes = MIN(ctz128(temp), mfd->len);
num_ones = popcount128(temp);
assert(num_ones <= mfd->len);
const uint16_t diff = mfd->len - num_ones;
if (diff != num_trailing_zeroes) {
if (verbose) {
char *mask_value = byte_arr_to_str(mfd->len, (uint8_t *) temp, malloc_function);
               sprintf(message, "Mask check: In field %0d/bit %0d, format 'p%d' invalid mask '%s' expected '{p ones, %d-p zeroes}' p = 0..%d\n",
index, mfd->start_pos, mfd->len, mask_value, mfd->len, mfd->len);
a1aaaaaaaaaaaaaaaabaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaa3aaaaaaaaaaaaaaaabaaaaaaaaaaaaaaaaaaaaaaaaaaaa4aaaerror(client, message);
cam_free_func free_function = a1aaaaaaaaaaaaaaaabaaaaaaaaaaaa3aaaaaaaaaaaaaaaabaaaaaaaaaaaaaaaaaaaaaaaaaaaa3aaaaaaaaaaaaaabaaaaaaaaaaaa4aaaaaaaaaaaaaaaabaaaaaaaaaaaaaaaaaaaaaaaaaaaa4aaaaaaaaaaaaaaaabaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaa4aaa(client);
free_function(mask_value);
}
return CAM_ERROR_INVALID_PREFIX_LEN;
}
fields[index].p128.len = num_ones;
break;
case aaaaaaaaaaa1aaaaaaaaaaaaaaaabaaaaaaaaaaaaaaaaaaaaaaaaaaaa3aaaT64:
memset(temp, 0, sizeof(temp));
cam_read_field8((uint8_t *) temp, (uint8_t *) &ternary_mask[0],
mfd->start_pos, mfd->len);
num_ones = popcount128(temp);
assert(num_ones <= mfd->len);
uint64_t *w64 = (uint64_t *) &fields[index].t64.mask[0];
*w64 = temp[0];
break;
case aaaaaaaaaaa1aaaaaaaaaaaaaaaabaaaaaaaaaaaaaaaaaaaaaaaaaaaa3aaaB128:
memset(temp, 0, sizeof(temp));
cam_read_field8((uint8_t *) temp, (uint8_t *) &ternary_mask[0],
mfd->start_pos, mfd->len);
num_ones = popcount128(temp);
if (num_ones != 0 && num_ones != mfd->len) {
if (verbose) {
set128(set_bits, mfd->len);
char *mask_value = byte_arr_to_str(mfd->len, (uint8_t *) temp, malloc_function);
char *expect_zero = byte_arr_to_str(mfd->len, (uint8_t *) clr_bits, malloc_function);
char *expect_one = byte_arr_to_str(mfd->len, (uint8_t *) set_bits, malloc_function);
               sprintf(message, "Mask check: In field %0d/bit %0d, format '%c%d' invalid mask '%s' expected '%s' or '%s'\n",
index, mfd->start_pos, 'b', mfd->len, mask_value, expect_zero, expect_one);
a1aaaaaaaaaaaaaaaabaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaa3aaaaaaaaaaaaaaaabaaaaaaaaaaaaaaaaaaaaaaaaaaaa4aaaerror(client, message);
cam_free_func free_function = a1aaaaaaaaaaaaaaaabaaaaaaaaaaaa3aaaaaaaaaaaaaaaabaaaaaaaaaaaaaaaaaaaaaaaaaaaa3aaaaaaaaaaaaaabaaaaaaaaaaaa4aaaaaaaaaaaaaaaabaaaaaaaaaaaaaaaaaaaaaaaaaaaa4aaaaaaaaaaaaaaaabaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaa4aaa(client);
free_function(mask_value);
free_function(expect_zero);
free_function(expect_one);
}
return CAM_ERROR_WRONG_BIT_FIELD_MASK;
}
if (num_ones == mfd->len)
aaaaa1aaaaaaaaaaaaaaaabaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaa3aaaaaaaaaaaaaaaabaaaaaaaaaaaaaaaaaaaaaaaaaaaa4bbbbbbbbbbbbbbbbbb4aaaaaaaaaaaaaaaabaaaaaaaaaaaaaaaaaaaaaaaaaaaa5aaabits((uint8_t *) &fields[index].b128.mask[0],
aaaaaaaaaaa1aaaaaaaaaaaaaaaabaaaaaaaaaaaaaaaaaaaaaaaaaaaa3aaaaaaaaaaaaaaaabaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaa3aaaaaaaaaaaaaaaabaaaaaaaaaaaaaaaaaaaaaaaaaaaa4aaaWIDTH_MEM_128, 0, mfd->len);
break;
case aaaaaaaaaaa1aaaaaaaaaaaaaaaabaaaaaaaaaaaaaaaaaaaaaaaaaaaa3aaaC128:
memset(temp, 0, sizeof(temp));
cam_read_field8((uint8_t *) temp, (uint8_t *) &ternary_mask[0],
mfd->start_pos, mfd->len);
num_ones = popcount128(temp);
if (num_ones != mfd->len) {
if (verbose) {
set128(set_bits, mfd->len);
char *mask_value = byte_arr_to_str(mfd->len, (uint8_t *) temp, malloc_function);
char *expect_one = byte_arr_to_str(mfd->len, (uint8_t *) set_bits, malloc_function);
               sprintf(message, "Mask check: In field %0d/bit %0d, format '%c%d' invalid mask '%s' expected '%s'\n",
index, mfd->start_pos, 'c', mfd->len, mask_value, expect_one);
a1aaaaaaaaaaaaaaaabaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaa3aaaaaaaaaaaaaaaabaaaaaaaaaaaaaaaaaaaaaaaaaaaa4aaaerror(client, message);
cam_free_func free_function = a1aaaaaaaaaaaaaaaabaaaaaaaaaaaa3aaaaaaaaaaaaaaaabaaaaaaaaaaaaaaaaaaaaaaaaaaaa3aaaaaaaaaaaaaabaaaaaaaaaaaa4aaaaaaaaaaaaaaaabaaaaaaaaaaaaaaaaaaaaaaaaaaaa4aaaaaaaaaaaaaaaabaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaa4aaa(client);
free_function(mask_value);
free_function(expect_one);
}
return CAM_ERROR_WRONG_CONST_FIELD_MASK;
}
break;
case aaaaaaaaaaa1aaaaaaaaaaaaaaaabaaaaaaaaaaaaaaaaaaaaaaaaaaaa3aaaU128:
break;
default:
assert(0);
}
return 0;
}
#endif 
#ifndef COMP_BCAM_IP
static int aaaaa1aaaaaaaaaaaaaaaabaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaa3aaaaaaaaaaaaaaaabaaaaaaaaaaaaaaaaaaaaaaaaaaaa4aaaaaaaaaaaaaaabaaaaaaaaaaaaaaaaaa5aaaaaaaaaaaaaaaabaaaaaaaaaaaaaaaaaaaaaaaaaaaa5bbbbbbbbbbbbbbbb5aaa(struct tcam *tcam, union aaaaaaaaaaa1aaa fields[], uint8_t index, const uint8_t key[])
{
aaaaaaaaaaa1aaaaaaaaaaaaaaaabaaaaaaaaaaaaaaaaaaaaaaaaaaaa3aaadesc mfd;
const int rc = a1aaaaaaaaaaaaaaaabaaaaaaaaaaaa3aaaaaaaaaaaaaaaabaaaaaaaaaaaaaaaaaaaaaaaaaaaa3aaaaaaaaaaaaaaaaaaaaa1aaa(tcam->client, index, &mfd);
assert(rc == 0);
switch (mfd.type) {
case aaaaaaaaaaa1aaaaaaaaaaaaaaaabaaaaaaaaaaaaaaaaaaaaaaaaaaaa3aaaR16:
memset(&fields[index].r16.start, 0, sizeof(fields[index].r16.start));
cam_read_field8((uint8_t *) &fields[index].r16.start,
(uint8_t *) &key[0], mfd.start_pos, mfd.len);
break;
case aaaaaaaaaaa1aaaaaaaaaaaaaaaabaaaaaaaaaaaaaaaaaaaaaaaaaaaa3aaaP128:
memset(&fields[index].p128.key[0], 0, aaaaaaaaaaa1aaaaaaaaaaaaaaaabaaaaaaaaaaaaaaaaaaaaaaaaaaaa3aaaaaaaaaaaaaaaabaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaa3aaaaaaaaaaaaaaaabaaaaaaaaaaaaaaaaaaaaaaaaaaaa4aaaWIDTH_MEM_128);
cam_read_field8((uint8_t *) &fields[index].p128.key[0],
(uint8_t *) &key[0], mfd.start_pos, mfd.len);
break;
case aaaaaaaaaaa1aaaaaaaaaaaaaaaabaaaaaaaaaaaaaaaaaaaaaaaaaaaa3aaaT64:
memset(&fields[index].t64.key[0], 0, aaaaaaaaaaa1aaaaaaaaaaaaaaaabaaaaaaaaaaaaaaaaaaaaaaaaaaaa3aaaaaaaaaaaaaaaabaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaa3aaaaaaaaaaaaaaaabaaaaaaaaaaaaaaaaaaaaaaaaaaaa4aaaWIDTH_MEM_128 / 2);
cam_read_field8((uint8_t *) &fields[index].t64.key[0],
(uint8_t *) &key[0], mfd.start_pos, mfd.len);
break;
case aaaaaaaaaaa1aaaaaaaaaaaaaaaabaaaaaaaaaaaaaaaaaaaaaaaaaaaa3aaaB128:
memset(&fields[index].b128.key[0], 0, aaaaaaaaaaa1aaaaaaaaaaaaaaaabaaaaaaaaaaaaaaaaaaaaaaaaaaaa3aaaaaaaaaaaaaaaabaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaa3aaaaaaaaaaaaaaaabaaaaaaaaaaaaaaaaaaaaaaaaaaaa4aaaWIDTH_MEM_128);
cam_read_field8((uint8_t *) &fields[index].b128.key[0],
(uint8_t *) &key[0], mfd.start_pos, mfd.len);
break;
case aaaaaaaaaaa1aaaaaaaaaaaaaaaabaaaaaaaaaaaaaaaaaaaaaaaaaaaa3aaaC128:
memset(&fields[index].c128.key[0], 0, aaaaaaaaaaa1aaaaaaaaaaaaaaaabaaaaaaaaaaaaaaaaaaaaaaaaaaaa3aaaaaaaaaaaaaaaabaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaa3aaaaaaaaaaaaaaaabaaaaaaaaaaaaaaaaaaaaaaaaaaaa4aaaWIDTH_MEM_128);
cam_read_field8((uint8_t *) &fields[index].c128.key[0],
(uint8_t *) &key[0], mfd.start_pos, mfd.len);
break;
case aaaaaaaaaaa1aaaaaaaaaaaaaaaabaaaaaaaaaaaaaaaaaaaaaaaaaaaa3aaaU128:
break;
default:
assert(0);
}
return 0;
}
#endif 
#ifndef COMP_BCAM_IP
static int check_field(struct tcam *tcam, const union aaaaaaaaaaa1aaa fields[], uint8_t index)
{
uint64_t temp[2];
uint8_t num_ones;
uint64_t key_temp = 0;
uint64_t mask_temp = 0;
aaaaaaaaaaa1aaaaaaaaaaaaaaaabaaaaaaaaaaaaaaaaaaaaaaaaaaaa3aaadesc mfd;
const int rc = a1aaaaaaaaaaaaaaaabaaaaaaaaaaaa3aaaaaaaaaaaaaaaabaaaaaaaaaaaaaaaaaaaaaaaaaaaa3aaaaaaaaaaaaaaaaaaaaa1aaa(tcam->client, index, &mfd);
assert(rc == 0);
switch (mfd.type) {
case aaaaaaaaaaa1aaaaaaaaaaaaaaaabaaaaaaaaaaaaaaaaaaaaaaaaaaaa3aaaR16:
if (fields[index].r16.end < fields[index].r16.start) {
return CAM_ERROR_WRONG_RANGE;
}
break;
case aaaaaaaaaaa1aaaaaaaaaaaaaaaabaaaaaaaaaaaaaaaaaaaaaaaaaaaa3aaaP128:
memset(temp, 0, sizeof(temp));
const uint8_t zeroes = mfd.len - fields[index].p128.len;
if (zeroes > 0) {
cam_read_field8((uint8_t *) temp, fields[index].p128.key, 0, zeroes);
num_ones = popcount128(temp);
if (num_ones != 0)
return CAM_ERROR_MASKED_KEY_BIT_IS_SET;
}
break;
case aaaaaaaaaaa1aaaaaaaaaaaaaaaabaaaaaaaaaaaaaaaaaaaaaaaaaaaa3aaaT64:
cam_read_field8((uint8_t *) &key_temp, fields[index].t64.key, 0, mfd.len);
cam_read_field8((uint8_t *) &mask_temp, fields[index].t64.mask, 0, mfd.len);
if ((key_temp & mask_temp) != key_temp)
return CAM_ERROR_MASKED_KEY_BIT_IS_SET;
break;
case aaaaaaaaaaa1aaaaaaaaaaaaaaaabaaaaaaaaaaaaaaaaaaaaaaaaaaaa3aaaB128:
memset(temp, 0, sizeof(temp));
cam_read_field8((uint8_t *) temp, (uint8_t *) fields[index].b128.key, 0, mfd.len);
num_ones = popcount128(temp);
if ((fields[index].b128.mask[0] & 1) == 0) {
if (num_ones != 0)
return CAM_ERROR_MASKED_KEY_BIT_IS_SET;
}
break;
case aaaaaaaaaaa1aaaaaaaaaaaaaaaabaaaaaaaaaaaaaaaaaaaaaaaaaaaa3aaaC128:
break;
case aaaaaaaaaaa1aaaaaaaaaaaaaaaabaaaaaaaaaaaaaaaaaaaaaaaaaaaa3aaaU128:
break;
default:
assert(0);
}
return 0;
}
#endif 
#ifndef COMP_BCAM_IP
int cam_check_fields(struct tcam *tcam, const union aaaaaaaaaaa1aaa fields[])
{
const uint8_t num_fields = a1aaaaaaaaaaaaaaaabaaaaaaaaaaaa3aaaaaaaaaaaaaaaabaaaaaaaaaaaaaaaaaaaaaaaaaaaa3aaaaaaaaaaaaaaabaaaaaaaaaaaaaaaa4aaaaaaaaaaaaaaaabaaaaaaaaaaaaaaaaaaaaaaaaaaaa4aaaaaaaaaaaaaaabaaaaaaaaaaaaaaaaaa5aaas(tcam->client);
int i;
int rc;
for (i = 0; i < num_fields; i++) {
rc = check_field(tcam, fields, i);
if (rc)
return rc;
}
return 0;
}
#endif 
#ifndef COMP_BCAM_IP
int aaaaaaaaaaa1aaas2key(struct tcam *tcam, const union aaaaaaaaaaa1aaa fields[], uint8_t key[])
{
memset(key, 0, sizeof(aaaaaaaaaaaaa1aaat));
const uint8_t num_fields = a1aaaaaaaaaaaaaaaabaaaaaaaaaaaa3aaaaaaaaaaaaaaaabaaaaaaaaaaaaaaaaaaaaaaaaaaaa3aaaaaaaaaaaaaaabaaaaaaaaaaaaaaaa4aaaaaaaaaaaaaaaabaaaaaaaaaaaaaaaaaaaaaaaaaaaa4aaaaaaaaaaaaaaabaaaaaaaaaaaaaaaaaa5aaas(tcam->client);
int i;
int rc;
for (i = 0; i < num_fields; i++) {
rc = aaaaa1aaaaaaaaaaaaaaaabaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaa3aaaaaaaaaaaaaaaabaaaaaaaaaaaaaaaaaaaaaaaaaaaa4aaaaaaaaaaaaaaaabaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaa4aaaaaaaaaaaaaaaabaaaaaaaaaaaaaaaaaaaaaaaaaaaa5bbbbbbbbbbbbbbbb5aaa(tcam, fields, i, key);
if (rc)
return rc;
}
return 0;
}
#endif 
#ifndef COMP_BCAM_IP
int aaaaaaaaaaa1aaas2mask(struct tcam *tcam, const union aaaaaaaaaaa1aaa fields[], uint8_t mask[])
{
memset(mask, 0, sizeof(aaaaaaaaaaaaa1aaat));
const uint8_t num_fields = a1aaaaaaaaaaaaaaaabaaaaaaaaaaaa3aaaaaaaaaaaaaaaabaaaaaaaaaaaaaaaaaaaaaaaaaaaa3aaaaaaaaaaaaaaabaaaaaaaaaaaaaaaa4aaaaaaaaaaaaaaaabaaaaaaaaaaaaaaaaaaaaaaaaaaaa4aaaaaaaaaaaaaaabaaaaaaaaaaaaaaaaaa5aaas(tcam->client);
int i;
int rc;
for (i = 0; i < num_fields; i++) {
rc = aaaaa1aaaaaaaaaaaaaaaabaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaa3aaaaaaaaaaaaaaaabaaaaaaaaaaaaaaaaaaaaaaaaaaaa4aaaternary_mask_copy(tcam, fields, i, mask);
if (rc)
return rc;
}
return 0;
}
#endif 
#ifndef COMP_BCAM_IP
int cam_key2fields(struct tcam *tcam, union aaaaaaaaaaa1aaa fields[], const uint8_t key[])
{
const uint8_t num_fields = a1aaaaaaaaaaaaaaaabaaaaaaaaaaaa3aaaaaaaaaaaaaaaabaaaaaaaaaaaaaaaaaaaaaaaaaaaa3aaaaaaaaaaaaaaabaaaaaaaaaaaaaaaa4aaaaaaaaaaaaaaaabaaaaaaaaaaaaaaaaaaaaaaaaaaaa4aaaaaaaaaaaaaaabaaaaaaaaaaaaaaaaaa5aaas(tcam->client);
int i;
int rc;
for (i = 0; i < num_fields; i++) {
rc = aaaaa1aaaaaaaaaaaaaaaabaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaa3aaaaaaaaaaaaaaaabaaaaaaaaaaaaaaaaaaaaaaaaaaaa4aaaaaaaaaaaaaaabaaaaaaaaaaaaaaaaaa5aaaaaaaaaaaaaaaabaaaaaaaaaaaaaaaaaaaaaaaaaaaa5bbbbbbbbbbbbbbbb5aaa(tcam, fields, i, key);
if (rc)
return rc;
}
return 0;
}
#endif 
#ifndef COMP_BCAM_IP
int cam_mask2fields(const a1aaat *client, union aaaaaaaaaaa1aaa fields[], const uint8_t mask[])
{
const uint8_t num_fields = a1aaaaaaaaaaaaaaaabaaaaaaaaaaaa3aaaaaaaaaaaaaaaabaaaaaaaaaaaaaaaaaaaaaaaaaaaa3aaaaaaaaaaaaaaabaaaaaaaaaaaaaaaa4aaaaaaaaaaaaaaaabaaaaaaaaaaaaaaaaaaaaaaaaaaaa4aaaaaaaaaaaaaaabaaaaaaaaaaaaaaaaaa5aaas(client);
int i;
int rc;
for (i = 0; i < num_fields; i++) {
aaaaaaaaaaa1aaaaaaaaaaaaaaaabaaaaaaaaaaaaaaaaaaaaaaaaaaaa3aaadesc mfd;
rc = a1aaaaaaaaaaaaaaaabaaaaaaaaaaaa3aaaaaaaaaaaaaaaabaaaaaaaaaaaaaaaaaaaaaaaaaaaa3aaaaaaaaaaaaaaaaaaaaa1aaa(client, i, &mfd);
assert(rc == 0);
rc = aaaaa1aaaaaaaaaaaaaaaabaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaa3aaaaaaaaaaaaaaaabaaaaaaaaaaaaaaaaaaaaaaaaaaaa4aaaaaaaaaaaaaaabaaaaaaaaaaaaaaaaaa5aaaaaaaaaaaaaaaabaaaaaaaaaaaaaaaaaaaaaaaaaaaa5bbbbbbbbbbbbbbbb5aaaaaaaaaaaaaaaabaaaaaaaaaaaaaaaaaaaaaaaaaaaa6aaafrom_ternary_mask(&mfd, fields, i, mask, client);
if (rc)
return rc;
}
return 0;
}
#endif 
void cam_read_field8(uint8_t *target, const uint8_t *source, uint16_t start_pos, uint16_t bit_len)
{
assert(bit_len > 0);
uint16_t i;
const uint16_t end_pos = bit_len + start_pos - 1;
uint16_t start_byte = start_pos / 8;
uint16_t start_byte_start = start_pos - start_byte * 8;
uint16_t end_byte = end_pos / 8;
uint16_t end_byte_end = end_pos - end_byte * 8;
uint16_t byte_diff = end_byte - start_byte;
switch (byte_diff) {
case 0:
target[0] = aaaaaaaa1aaaaaaaaaaaaaaaabaaaaaaaaaaaa3aaa8(source[start_byte], start_byte_start, end_byte_end - start_byte_start + 1);
break;
case 1:
target[0] = aaaaaaaa1aaaaaaaaaaaaaaaabaaaaaaaaaaaa3aaa8(source[start_byte], start_byte_start, 8 - start_byte_start);
if (bit_len <= 8) {
const uint8_t value = aaaaaaaa1aaaaaaaaaaaaaaaabaaaaaaaaaaaa3aaa8(source[end_byte], 0, end_byte_end + 1);
target[0] = aaaaaaaa1aaaaaaaaaaaaaaaabaaaaaaaaaaaaaaaaaaaaaa3aaa8(target[0], value, 8 - start_byte_start, end_byte_end + 1);
} else {
if (start_byte_start > 0) {
const uint32_t value = aaaaaaaa1aaaaaaaaaaaaaaaabaaaaaaaaaaaa3aaa8(source[end_byte], 0, start_byte_start);
target[0] = aaaaaaaa1aaaaaaaaaaaaaaaabaaaaaaaaaaaaaaaaaaaaaa3aaa8(target[0], value, 8 - start_byte_start, start_byte_start);
}
target[1] = aaaaaaaa1aaaaaaaaaaaaaaaabaaaaaaaaaaaa3aaa8(source[end_byte], start_byte_start, bit_len - 8);
}
break;
default:
target[0] = aaaaaaaa1aaaaaaaaaaaaaaaabaaaaaaaaaaaa3aaa8(source[start_byte], start_byte_start, 8 - start_byte_start);
for (i = 0; i < (byte_diff - 1); i++) {
if (start_byte_start > 0) {
const uint8_t value = aaaaaaaa1aaaaaaaaaaaaaaaabaaaaaaaaaaaa3aaa8(source[start_byte + i + 1], 0, start_byte_start);
target[i] = aaaaaaaa1aaaaaaaaaaaaaaaabaaaaaaaaaaaaaaaaaaaaaa3aaa8(target[i], value, 8 - start_byte_start, start_byte_start);
}
target[i + 1] = aaaaaaaa1aaaaaaaaaaaaaaaabaaaaaaaaaaaa3aaa8(source[start_byte + i + 1], start_byte_start, 8 - start_byte_start);
}
if ((end_byte_end + 1) <= start_byte_start) {
const uint8_t value = aaaaaaaa1aaaaaaaaaaaaaaaabaaaaaaaaaaaa3aaa8(source[end_byte], 0, end_byte_end + 1);
target[i] = aaaaaaaa1aaaaaaaaaaaaaaaabaaaaaaaaaaaaaaaaaaaaaa3aaa8(target[i], value, 8 - start_byte_start, end_byte_end + 1);
} else {
if (start_byte_start > 0) {
const uint8_t value = aaaaaaaa1aaaaaaaaaaaaaaaabaaaaaaaaaaaa3aaa8(source[end_byte], 0, start_byte_start);
target[i] = aaaaaaaa1aaaaaaaaaaaaaaaabaaaaaaaaaaaaaaaaaaaaaa3aaa8(target[i], value, 8 - start_byte_start, start_byte_start);
}
const uint8_t value = aaaaaaaa1aaaaaaaaaaaaaaaabaaaaaaaaaaaa3aaa8(source[end_byte], start_byte_start, end_byte_end - start_byte_start + 1);
target[i + 1] = aaaaaaaa1aaaaaaaaaaaaaaaabaaaaaaaaaaaaaaaaaaaaaa3aaa8(target[i + 1], value, 0, end_byte_end - start_byte_start + 1);
}
}
}
void cam_read_field(const uint32_t *source, uint16_t start_pos, uint16_t end_pos, uint32_t *target)
{
uint16_t i;
const uint16_t bit_diff = end_pos - start_pos + 1;
uint16_t start_word = start_pos / 32;
uint16_t start_word_start = start_pos - start_word * 32;
uint16_t end_word = end_pos / 32;
uint16_t end_word_end = end_pos - end_word * 32;
uint16_t word_diff = end_word - start_word;
switch (word_diff) {
case 0:
target[0] = aaaaaaaa1aaaaaaaaaaaaaaaabaaaaaaaaaaaa3aaa(source[start_word], start_word_start, end_word_end - start_word_start + 1);
break;
case 1:
target[0] = aaaaaaaa1aaaaaaaaaaaaaaaabaaaaaaaaaaaa3aaa(source[start_word], start_word_start, 32 - start_word_start);
if (bit_diff <= 32) {
const uint32_t value = aaaaaaaa1aaaaaaaaaaaaaaaabaaaaaaaaaaaa3aaa(source[end_word], 0, end_word_end + 1);
target[0] = aaaaaaaa1aaaaaaaaaaaaaaaabaaaaaaaaaaaaaaaaaaaaaa3aaa(target[0], value, 32 - start_word_start, end_word_end + 1);
} else {
if (start_word_start > 0) {
const uint32_t value = aaaaaaaa1aaaaaaaaaaaaaaaabaaaaaaaaaaaa3aaa(source[end_word], 0, start_word_start);
target[0] = aaaaaaaa1aaaaaaaaaaaaaaaabaaaaaaaaaaaaaaaaaaaaaa3aaa(target[0], value, 32 - start_word_start, start_word_start);
}
target[1] = aaaaaaaa1aaaaaaaaaaaaaaaabaaaaaaaaaaaa3aaa(source[end_word], start_word_start, bit_diff - 32);
}
break;
default:
target[0] = aaaaaaaa1aaaaaaaaaaaaaaaabaaaaaaaaaaaa3aaa(source[start_word], start_word_start, 32 - start_word_start);
for (i = 0; i < (word_diff - 1); i++) {
if (start_word_start > 0) {
const uint32_t value = aaaaaaaa1aaaaaaaaaaaaaaaabaaaaaaaaaaaa3aaa(source[start_word + i + 1], 0, start_word_start);
target[i] = aaaaaaaa1aaaaaaaaaaaaaaaabaaaaaaaaaaaaaaaaaaaaaa3aaa(target[i], value, 32 - start_word_start, start_word_start);
}
target[i + 1] = aaaaaaaa1aaaaaaaaaaaaaaaabaaaaaaaaaaaa3aaa(source[start_word + i + 1], start_word_start, 32 - start_word_start);
}
if ((end_word_end + 1) <= start_word_start) {
const uint32_t value = aaaaaaaa1aaaaaaaaaaaaaaaabaaaaaaaaaaaa3aaa(source[end_word], 0, end_word_end + 1);
target[i] = aaaaaaaa1aaaaaaaaaaaaaaaabaaaaaaaaaaaaaaaaaaaaaa3aaa(target[i], value, 32 - start_word_start, end_word_end + 1);
} else {
if (start_word_start > 0) {
const uint32_t value = aaaaaaaa1aaaaaaaaaaaaaaaabaaaaaaaaaaaa3aaa(source[end_word], 0, start_word_start);
target[i] = aaaaaaaa1aaaaaaaaaaaaaaaabaaaaaaaaaaaaaaaaaaaaaa3aaa(target[i], value, 32 - start_word_start, start_word_start);
}
const uint32_t value = aaaaaaaa1aaaaaaaaaaaaaaaabaaaaaaaaaaaa3aaa(source[end_word], start_word_start,
end_word_end - start_word_start + 1);
target[i + 1] = aaaaaaaa1aaaaaaaaaaaaaaaabaaaaaaaaaaaaaaaaaaaaaa3aaa(target[i + 1], value, 0, end_word_end - start_word_start + 1);
}
}
}
void cam_write_field(uint32_t *target, uint16_t start_pos, uint16_t end_pos, const uint32_t *source,
uint16_t prio_end_pos)
{
assert(start_pos <= prio_end_pos);
assert(end_pos <= prio_end_pos);
const uint16_t bit_diff = end_pos - start_pos + 1;
if (bit_diff == 0) {
assert(bit_diff > 0);
}
uint16_t i;
uint16_t start_word = start_pos / 32;
uint16_t start_word_start = start_pos - start_word * 32;
uint16_t end_word = end_pos / 32;
uint16_t end_word_end = end_pos - end_word * 32;
uint16_t word_diff = end_word - start_word;
uint64_t value = aaaaaaaa1aaaaaaaaaaaaaaaabaaaaaaaaaaaaaaaaaaaaaaa3aaa64(word_diff + 1);
assert(word_diff < ((prio_end_pos + 1 + 31) / 32));
switch (word_diff) {
case 0:
target[start_word] = aaaaaaaa1aaaaaaaaaaaaaaaabaaaaaaaaaaaaaaaaaaaaaa3aaa(target[start_word], source[0], start_word_start,
end_word_end - start_word_start + 1);
break;
case 1:
value = aaaaaaaa1aaaaaaaaaaaaaaaabaaaaaaaaaaaa3aaa(source[0], 0, 32 - start_word_start);
target[start_word] = aaaaaaaa1aaaaaaaaaaaaaaaabaaaaaaaaaaaaaaaaaaaaaa3aaa(target[start_word], value, start_word_start,
32 - start_word_start);
if (bit_diff <= 32) {
value = aaaaaaaa1aaaaaaaaaaaaaaaabaaaaaaaaaaaa3aaa(source[0], 32 - start_word_start, bit_diff - (32 - start_word_start));
target[end_word] = aaaaaaaa1aaaaaaaaaaaaaaaabaaaaaaaaaaaaaaaaaaaaaa3aaa(target[end_word], value, 0,
bit_diff - (32 - start_word_start));
} else {
if (start_word_start > 0) {
value = aaaaaaaa1aaaaaaaaaaaaaaaabaaaaaaaaaaaa3aaa(source[0], 32 - start_word_start, start_word_start);
target[end_word] = aaaaaaaa1aaaaaaaaaaaaaaaabaaaaaaaaaaaaaaaaaaaaaa3aaa(target[end_word], value, 0, start_word_start);
}
value = aaaaaaaa1aaaaaaaaaaaaaaaabaaaaaaaaaaaa3aaa(source[1], 0, bit_diff - 32);
target[end_word] = aaaaaaaa1aaaaaaaaaaaaaaaabaaaaaaaaaaaaaaaaaaaaaa3aaa(target[end_word], value, start_word_start, bit_diff - 32);
}
break;
default:
value = aaaaaaaa1aaaaaaaaaaaaaaaabaaaaaaaaaaaa3aaa(source[0], 0, 32 - start_word_start);
target[start_word] = aaaaaaaa1aaaaaaaaaaaaaaaabaaaaaaaaaaaaaaaaaaaaaa3aaa(target[start_word], value, start_word_start,
32 - start_word_start);
for (i = 0; i < (word_diff - 1); i++) {
if (start_word_start > 0) {
value = aaaaaaaa1aaaaaaaaaaaaaaaabaaaaaaaaaaaa3aaa(source[i], 32 - start_word_start, start_word_start);
target[start_word + 1 + i] = aaaaaaaa1aaaaaaaaaaaaaaaabaaaaaaaaaaaaaaaaaaaaaa3aaa(target[start_word + 1 + i], value, 0,
start_word_start);
}
value = aaaaaaaa1aaaaaaaaaaaaaaaabaaaaaaaaaaaa3aaa(source[i + 1], 0, 32 - start_word_start);
target[start_word + 1 + i] = aaaaaaaa1aaaaaaaaaaaaaaaabaaaaaaaaaaaaaaaaaaaaaa3aaa(target[start_word + 1 + i], value,
start_word_start, 32 - start_word_start);
}
if ((end_word_end + 1) <= start_word_start) {
value = aaaaaaaa1aaaaaaaaaaaaaaaabaaaaaaaaaaaa3aaa(source[i], 32 - start_word_start, end_word_end + 1);
target[end_word] = aaaaaaaa1aaaaaaaaaaaaaaaabaaaaaaaaaaaaaaaaaaaaaa3aaa(target[end_word], value, 0, end_word_end + 1);
} else {
if (start_word_start > 0) {
value = aaaaaaaa1aaaaaaaaaaaaaaaabaaaaaaaaaaaa3aaa(source[i], 32 - start_word_start, start_word_start);
target[end_word] = aaaaaaaa1aaaaaaaaaaaaaaaabaaaaaaaaaaaaaaaaaaaaaa3aaa(target[end_word], value, 0, start_word_start);
}
value = aaaaaaaa1aaaaaaaaaaaaaaaabaaaaaaaaaaaa3aaa(source[i + 1], 0, end_word_end - start_word_start + 1);
target[end_word] = aaaaaaaa1aaaaaaaaaaaaaaaabaaaaaaaaaaaaaaaaaaaaaa3aaa(target[end_word], value, start_word_start,
end_word_end - start_word_start + 1);
}
}
}
uint16_t cam_get_num_ones(const aaaaaaaaaaaaa1aaat *data)
{
uint16_t num_ones = 0;
for (uint8_t i = 0; i < CAM_MAX_KEY_WIDTH_MEM; i++) {
num_ones = num_ones + __builtin_popcount(data->word[i]);
}
return num_ones;
}
char *byte_arr_to_str(uint16_t bit_len, const uint8_t *src, cam_malloc_func malloc_function)
{
assert(src != NULL);
uint16_t byte_len = (bit_len + 7) / 8;
uint8_t tailbits = bit_len % 8;
if (tailbits == 0)
tailbits = 8;
uint8_t tailmask = 0xff >> (8 - tailbits);
char *str = malloc_function(sizeof(char) * 500);
assert(str != NULL);
str[0] = '\0';
   sprintf(str + strlen(str), "0x");
for (int i = byte_len - 1; i >= 0; i--) {
if ((i == byte_len - 1) && (byte_len != (bit_len + 3) / 8)) {
           sprintf(str + strlen(str), "%1x", src[i] & tailmask);
} else {
           sprintf(str + strlen(str), "%02x", src[i] & tailmask);
}
tailmask = 0xff;
}
return str;
}
void cam_mask_key(aaaaaaaaaaaaa1aaat *key, const aaaaaaaaaaaaa1aaat *mask)
{
for (uint8_t i = 0; i < CAM_MAX_KEY_WIDTH_MEM; i++) {
key->word[i] = key->word[i] & mask->word[i];
}
}
#ifndef COMP_BCAM_IP
void mask_field(struct tcam *tcam, union aaaaaaaaaaa1aaa fields[], uint8_t index)
{
uint64_t *key64;
uint64_t *mask64;
uint64_t mask128[2];
aaaaaaaaaaa1aaaaaaaaaaaaaaaabaaaaaaaaaaaaaaaaaaaaaaaaaaaa3aaadesc mfd;
const int rc = a1aaaaaaaaaaaaaaaabaaaaaaaaaaaa3aaaaaaaaaaaaaaaabaaaaaaaaaaaaaaaaaaaaaaaaaaaa3aaaaaaaaaaaaaaaaaaaaa1aaa(tcam->client, index, &mfd);
assert(rc == 0);
switch (mfd.type) {
case aaaaaaaaaaa1aaaaaaaaaaaaaaaabaaaaaaaaaaaaaaaaaaaaaaaaaaaa3aaaR16:
break;
case aaaaaaaaaaa1aaaaaaaaaaaaaaaabaaaaaaaaaaaaaaaaaaaaaaaaaaaa3aaaP128:
mask128[0] = 0;
mask128[1] = 0;
aaaaa1aaaaaaaaaaaaaaaabaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaa3aaaaaaaaaaaaaaaabaaaaaaaaaaaaaaaaaaaaaaaaaaaa4bbbbbbbbbbbbbbbbbb4aaaaaaaaaaaaaaaabaaaaaaaaaaaaaaaaaaaaaaaaaaaa5aaabits((uint8_t *) &mask128[0], 128 / 8,
mfd.len - fields[index].p128.len,
fields[index].p128.len);
key64 = (uint64_t *) fields[index].p128.key;
*key64 = *key64 & mask128[0];
key64++;
*key64 = *key64 & mask128[1];
break;
case aaaaaaaaaaa1aaaaaaaaaaaaaaaabaaaaaaaaaaaaaaaaaaaaaaaaaaaa3aaaT64:
key64 = (uint64_t *) fields[index].t64.key;
mask64 = (uint64_t *) fields[index].t64.mask;
*key64 = *key64 & *mask64;
break;
case aaaaaaaaaaa1aaaaaaaaaaaaaaaabaaaaaaaaaaaaaaaaaaaaaaaaaaaa3aaaB128:
key64 = (uint64_t *) fields[index].b128.key;
mask64 = (uint64_t *) fields[index].b128.mask;
*key64 = *key64 & *mask64;
key64++;
mask64++;
*key64 = *key64 & *mask64;
break;
case aaaaaaaaaaa1aaaaaaaaaaaaaaaabaaaaaaaaaaaaaaaaaaaaaaaaaaaa3aaaC128:
break;
case aaaaaaaaaaa1aaaaaaaaaaaaaaaabaaaaaaaaaaaaaaaaaaaaaaaaaaaa3aaaU128:
break;
default:
assert(0);
}
}
#endif 
#ifndef COMP_BCAM_IP
void cam_mask_fields(struct tcam *tcam, union aaaaaaaaaaa1aaa fields[])
{
const uint8_t num_fields = a1aaaaaaaaaaaaaaaabaaaaaaaaaaaa3aaaaaaaaaaaaaaaabaaaaaaaaaaaaaaaaaaaaaaaaaaaa3aaaaaaaaaaaaaaabaaaaaaaaaaaaaaaa4aaaaaaaaaaaaaaaabaaaaaaaaaaaaaaaaaaaaaaaaaaaa4aaaaaaaaaaaaaaabaaaaaaaaaaaaaaaaaa5aaas(tcam->client);
for (uint8_t i = 0; i < num_fields; i++) {
mask_field(tcam, fields, i);
}
}
#endif 
typedef enum {
ALL, ONLY_VALID_BITS
} flush_mode_t;
typedef struct {
uint8_t valid;
uint16_t seed;
uint8_t range_valid;
aaaaaaaaaaaaa1aaat mask;
} mask_entry_t;
struct aaaaaaaaaaaa1aaat {
mask_entry_t mask_entry;
a1aaat *client;
uint16_t unit;
uint8_t slot_number;
uint8_t mask_id;
};
size_t aaaaaaaaaaaa1aaaaaaaaaaaaaabaaaaaaaaaa3aaa(void)
{
return sizeof(aaaaaaaaaaaa1aaat);
}
const a1aaat *aaaaaaaaaaaa1aaaaaaaaaaaaaaaabaaaaaaaaaaaa3aaaaaaaaaaaaaaaabaaaaaaaaaaaaaaaaaaaaaaaaaaaa3aaaclient(const aaaaaaaaaaaa1aaat *mm)
{
assert(mm != NULL);
return mm->client;
}
uint16_t aaaaaaaaaaaa1aaaaaaaaaaaaaaaabaaaaaaaaaaaa3aaaaaaaaaaaaaaaabaaaaaaaaaaaaaaaaaaaaaaaaaaaa3aaaaaaaaaaaabaaaaaaaaaaaaaaaaa4aaa(const aaaaaaaaaaaa1aaat *mm)
{
assert(mm != NULL);
return mm->unit;
}
bool aaaaaaaaaaaa1aaaaaaaaaaaaaaabaaaaaaaaaaaa3aaaaaaaaaaaaaaaabaaaaaaaaaaaaaaaaaaaaaaaaaaaa3aaaaaaaaaaaaaaaabaaaaaaaaaaaaaaaaaaaaaaa4aaaaaaaaaaaaaaaabaaaaaaaaaaaaaaaaaaaaaaaaaaaa4aaaaaaaaaaaabaaaaaaaaaaa5aaaaaaaaaaaaaaaabaaaaaaaaaaaaaaaaaaaaaaaaaaaa5aaavalid(const aaaaaaaaaaaa1aaat *mm)
{
return mm->mask_entry.valid;
}
bool aaaaaaaaaaaa1aaaaaaaaaaaaaaabaaaaaaaaaaaa3aaaaaaaaaaaaaaaabaaaaaaaaaaaaaaaaaaaaaaaaaaaa3aaaaaaaaaaaaaaaabaaaaaaaaaaaaaaaaaaaaaaa4aaaaaaaaaaaaaaaabaaaaaaaaaaaaaaaaaaaaaaaaaaaa4aaaequal(const aaaaaaaaaaaa1aaat *mm, const aaaaaaaaaaaaa1aaat *mask, uint8_t range_valid,
uint8_t mask_id)
{
if (mm->mask_id != mask_id || mm->mask_entry.range_valid != range_valid) {
return false;
}
const int rc = memcmp(mask, &(mm->mask_entry.mask.word[0]), sizeof(aaaaaaaaaaaaa1aaat));
if (rc != 0)
return false;
return true;
}
void aaaaaaaaaaaa1aaaaaaaaaaaaaaaabaaaaaaaaaaaa3aaaaaaaaaaaaaaaabaaaaaaaaaaaaaaaaaaaaaaaaaaaa3aaaaaaaaaaaaaaaabaaaaaaaaaaaaaaaaaaaa4aaa(const aaaaaaaaaaaa1aaat *mm, uint8_t *range_valid)
{
assert(aaaaaaaaaaaa1aaaaaaaaaaaaaaabaaaaaaaaaaaa3aaaaaaaaaaaaaaaabaaaaaaaaaaaaaaaaaaaaaaaaaaaa3aaaaaaaaaaaaaaaabaaaaaaaaaaaaaaaaaaaaaaa4aaaaaaaaaaaaaaaabaaaaaaaaaaaaaaaaaaaaaaaaaaaa4aaaaaaaaaaaabaaaaaaaaaaa5aaaaaaaaaaaaaaaabaaaaaaaaaaaaaaaaaaaaaaaaaaaa5aaavalid(mm));
*range_valid = mm->mask_entry.range_valid;
}
void flush_mask_entry(const aaaaaaaaaaaa1aaat *mm, flush_mode_t flush_mode, uint64_t *hw_word_verify)
{
if (a1aaaaaaaaaaaaaaabaaaaaaaaaaaa3aaaaaaaaaaaaaaaabaaaaaaaaaaaaaaaaaaaaaaaaaaaa3aaabcam(mm->client) || a1aaaaaaaaaaaaaaabaaaaaaaaaaaa3aaaaaaaaaaaaaaaabaaaaaaaaaaaaaaaaaaaaaaaaaaaa3aaahbmbcam(mm->client))
return;
const uint16_t a1aaawidth = a1aaaaaaaaaaaaaaaabaaaaaaaaaaaa3aaaaaaaaaaaaaaaabaaaaaaaaaaaaaaaaaaaaaaaaaaaa3aaaaaaaaaaaaaaaabaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaa3aaaaaaaaaaaaaaaabaaaaaaaaaaaaaaaaaaaaaaaaaaaa4aaawidth(mm->client);
const uint32_t base = aaaaaa1aaaaaaaaaaaaaaa1aaaaaaaaaaaaaaaabaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaa3aaa + mm->unit * aaaaaa1aaaaaaaaaaaabaaaaaaaaaaaaaaaaa3aaaaaaaaaaaaaaaabaaaaaaaaaaaaaaaaaaaaaaaaaaaa3aaaaaaaaaaaaaaaabaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaa3aaa + mm->slot_number * aaaaaa1aaaaaaaaaaaaaaa1aaaWORD;
uint64_t sw[16] = { };
sw[15] = aaaaaaaa1aaaaaaaaaaaaaaaabaaaaaaaaaaaaaaaaaaaaaa3aaa64(sw[15], mm->mask_entry.seed, 32, 16);
sw[15] = aaaaaaaa1aaaaaaaaaaaaaaaabaaaaaaaaaaaaaaaaaaaaaa3aaa64(sw[15], mm->mask_entry.valid, 32 + 16, 1);
sw[15] = aaaaaaaa1aaaaaaaaaaaaaaaabaaaaaaaaaaaaaaaaaaaaaa3aaa64(sw[15], mm->mask_entry.range_valid, 32 + 16 + 1, 8);
uint8_t width32 = a1aaawidth / 32;
const uint8_t remaining_bits32 = a1aaawidth - width32 * 32;
if (remaining_bits32 > 0) {
width32++;
}
for (uint8_t i = 0; i < width32; i++) {
uint8_t dest_pos;
if ((i & 1) == 0) {
dest_pos = 0;
} else {
dest_pos = 32;
}
sw[i / 2] = aaaaaaaa1aaaaaaaaaaaaaaaabaaaaaaaaaaaaaaaaaaaaaa3aaa64(sw[i / 2], mm->mask_entry.mask.word[i], dest_pos, 32);
}
uint8_t width64 = a1aaawidth / 64;
const uint8_t remaining_bits64 = a1aaawidth - width32 * 64;
if (remaining_bits64 > 0) {
width64++;
}
assert(width64 <= 16);
if (flush_mode == ONLY_VALID_BITS) {
a1aaaaaaaaaaaaaaaabaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaa3aaaaaaaaaaaaaaaabaaaaaaaaaaaaaaaaaaaaaaaaaaaa4aaaaaaaaaaaaaaaabaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaa4aaa(mm->client, base + 15 * 0x8, sw[15]);
return;
} else if (flush_mode == ALL) {
} else {
assert(false);
}
for (uint8_t i = 0; i < width64; i++) {
if (hw_word_verify == NULL) {
a1aaaaaaaaaaaaaaaabaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaa3aaaaaaaaaaaaaaaabaaaaaaaaaaaaaaaaaaaaaaaaaaaa4aaaaaaaaaaaaaaaabaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaa4aaa(mm->client, base + i * 0x8, sw[i]);
} else {
hw_word_verify[i] = sw[i];
}
}
if (hw_word_verify == NULL) {
a1aaaaaaaaaaaaaaaabaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaa3aaaaaaaaaaaaaaaabaaaaaaaaaaaaaaaaaaaaaaaaaaaa4aaaaaaaaaaaaaaaabaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaa4aaa(mm->client, base + 15 * 0x8, sw[15]);
} else {
hw_word_verify[15] = sw[15];
}
}
void clear_mask(aaaaaaaaaaaa1aaat *mm)
{
memset(&mm->mask_entry.mask.word[0], 0, sizeof(aaaaaaaaaaaaa1aaat));
}
void aaaaaaaaaaaa1aaaaaaaaaaaaaabaaaaaaaaaaa3aaa(aaaaaaaaaaaa1aaat *mm, a1aaat *client, uint16_t unit, uint8_t slot_number)
{
assert(client != NULL);
assert(unit < aaaaaa1aaaaaaaaaaaaaaaabaaaaaaaaaaaaaaaaaaaaaaaaaa3aaaaaaaaaaaaaaaabaaaaaaaaaaaaaaaaaaaaaaaaaaaa3aaaaaaaaaaaaaaaabaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaa3aaaaaaaaaaaaaaaabaaaaaaaaaaaaaaaaaaaaaaaaaaaa4aaaaaaaaaaaabaaaaaaaaaaaaaaaaa5aaaS);
mm->client = client;
mm->unit = unit;
mm->slot_number = slot_number;
mm->mask_entry.valid = 0;
mm->mask_entry.seed = 0;
mm->mask_entry.range_valid = 0;
clear_mask(mm);
mm->mask_id = 0;
if (!(a1aaaaaaaaaaaaaaaabaaaaaaaaaaaa3aaaaaaaaaaaaaaaabaaaaaaaaaaaaaaaaaaaaaaaaaaaa3bbbbbbbbbbbbbbbbbbbbbbbbbbbbbbbbbbbbb3aaaaaaaaaaaaaaaabaaaaaaaaaaaaaaaaaaaaaaaaaaaa4aaaflags(mm->client) & CAM_DEBUG_SKIP_MEM_INIT)) {
flush_mask_entry(mm, ALL, NULL);
}
}
void aaaaaaaaaaaa1aaaread_mask(const aaaaaaaaaaaa1aaat *mm, aaaaaaaaaaaaa1aaat *mask, uint8_t *range_valid, uint8_t *mask_id)
{
*mask = mm->mask_entry.mask;
aaaaaaaaaaaa1aaaaaaaaaaaaaaaabaaaaaaaaaaaa3aaaaaaaaaaaaaaaabaaaaaaaaaaaaaaaaaaaaaaaaaaaa3aaaaaaaaaaaaaaaabaaaaaaaaaaaaaaaaaaaa4aaa(mm, range_valid);
*mask_id = mm->mask_id;
}
uint16_t aaaaaaaaaaaa1aaaaaaaaaaaaaaaabaaaaaaaaaaaa3aaaaaaaaaaaaaaaabaaaaaaaaaaaaaaaaaaaaaaaaaaaa3aaaseed(const aaaaaaaaaaaa1aaat *mm)
{
assert(aaaaaaaaaaaa1aaaaaaaaaaaaaaabaaaaaaaaaaaa3aaaaaaaaaaaaaaaabaaaaaaaaaaaaaaaaaaaaaaaaaaaa3aaaaaaaaaaaaaaaabaaaaaaaaaaaaaaaaaaaaaaa4aaaaaaaaaaaaaaaabaaaaaaaaaaaaaaaaaaaaaaaaaaaa4aaaaaaaaaaaabaaaaaaaaaaa5aaaaaaaaaaaaaaaabaaaaaaaaaaaaaaaaaaaaaaaaaaaa5aaavalid(mm));
return mm->mask_entry.seed;
}
uint8_t aaaaaaaaaaaa1aaaaaaaaaaaaaaaabaaaaaaaaaaaa3aaaaaaaaaaaaaaaabaaaaaaaaaaaaaaaaaaaaaaaaaaaa3bbbbbbbbbbbbbbbbbbbbbbbbbbbbbbbbbbbb3aaaaaaaaaaaaaaaabaaaaaaaaaaaaaaaaaaaaaaaaaaaa4aaaaaaaaaaaaaaabaaaaaaaaaaaaaaaa5aaaber(const aaaaaaaaaaaa1aaat *mm)
{
return mm->slot_number;
}
void aaaaaaaaaaaa1bbbbbbbbbbbbbbbbbb3aaaaaaaaaaaaaaaabaaaaaaaaaaaaaaaaaaaaaaaaaaaa4aaaseed(aaaaaaaaaaaa1aaat *mm, uint16_t seed)
{
assert(!aaaaaaaaaaaa1aaaaaaaaaaaaaaabaaaaaaaaaaaa3aaaaaaaaaaaaaaaabaaaaaaaaaaaaaaaaaaaaaaaaaaaa3aaaaaaaaaaaaaaaabaaaaaaaaaaaaaaaaaaaaaaa4aaaaaaaaaaaaaaaabaaaaaaaaaaaaaaaaaaaaaaaaaaaa4aaaaaaaaaaaabaaaaaaaaaaa5aaaaaaaaaaaaaaaabaaaaaaaaaaaaaaaaaaaaaaaaaaaa5aaavalid(mm));
mm->mask_entry.seed = seed;
}
void aaaaaaaaaaaa1bbbbbbbbbbbbbbbbb3aaaaaaaaaaaaaaaabaaaaaaaaaaaaaaaaaaaaaaaaaaaa4aaaaaaaaaaaaaaaabaaaaaaaaaaaaaaaaaaaaaaa5aaaaaaaaaaaaaaaabaaaaaaaaaaaaaaaaaaaaaaaaaaaa5aaaaaaaaaaaabaaaaaaaaaaa6aaa(aaaaaaaaaaaa1aaat *mm)
{
assert(aaaaaaaaaaaa1aaaaaaaaaaaaaaabaaaaaaaaaaaa3aaaaaaaaaaaaaaaabaaaaaaaaaaaaaaaaaaaaaaaaaaaa3aaaaaaaaaaaaaaaabaaaaaaaaaaaaaaaaaaaaaaa4aaaaaaaaaaaaaaaabaaaaaaaaaaaaaaaaaaaaaaaaaaaa4aaaaaaaaaaaabaaaaaaaaaaa5aaaaaaaaaaaaaaaabaaaaaaaaaaaaaaaaaaaaaaaaaaaa5aaavalid(mm));
mm->mask_entry.valid = 0;
flush_mask_entry(mm, ONLY_VALID_BITS, NULL);
}
void aaaaaaaaaaaa1bbbbbbbbbbbbbbbbbb3aaaaaaaaaaaaaaaabaaaaaaaaaaaaaaaaaaaaaaaaaaaa4aaaaaaaaaaaaaaaabaaaaaaaaaaaaaaaaaaaaaaa5aaaaaaaaaaaaaaaabaaaaaaaaaaaaaaaaaaaaaaaaaaaa5aaaaaaaaaaaabaaaaaaaaaaa6aaa(aaaaaaaaaaaa1aaat *mm)
{
assert(!aaaaaaaaaaaa1aaaaaaaaaaaaaaabaaaaaaaaaaaa3aaaaaaaaaaaaaaaabaaaaaaaaaaaaaaaaaaaaaaaaaaaa3aaaaaaaaaaaaaaaabaaaaaaaaaaaaaaaaaaaaaaa4aaaaaaaaaaaaaaaabaaaaaaaaaaaaaaaaaaaaaaaaaaaa4aaaaaaaaaaaabaaaaaaaaaaa5aaaaaaaaaaaaaaaabaaaaaaaaaaaaaaaaaaaaaaaaaaaa5aaavalid(mm));
mm->mask_entry.valid = 1;
flush_mask_entry(mm, ONLY_VALID_BITS, NULL);
}
void aaaaaaaaaaaa1aaaaaaaaaaaaaaaabaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaa3aaaaaaaaaaaaaaaabaaaaaaaaaaaaaaaaaaaaaaaaaaaa4aaaaaaaaaaaaaaaabaaaaaaaaaaaaaaaaaaaaaaa5aaaaaaaaaaaaaaaabaaaaaaaaaaaaaaaaaaaaaaaaaaaa5aaaaaaaaaaaabaaaaaaaaaaa6aaa(aaaaaaaaaaaa1aaat *mm, const aaaaaaaaaaaaa1aaat *mask, uint16_t seed,
uint8_t range_valid, uint8_t mask_id)
{
if (mask != NULL)
memcpy(&mm->mask_entry.mask, mask, sizeof(aaaaaaaaaaaaa1aaat));
mm->mask_entry.valid = 1;
mm->mask_entry.seed = seed;
assert((range_valid == 0) || a1aaaaaaaaaaaaaaabaaaaaaaaaaaa3aaaaaaaaaaaaaaaabaaaaaaaaaaaaaaaaaaaaaaaaaaaa3aaaaaaaaaaaaaaaabaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaa3aaa(mm->client));
mm->mask_entry.range_valid = range_valid;
mm->mask_id = mask_id;
flush_mask_entry(mm, ALL, NULL);
}
void aaaaaaaaaaaa1aaaaaaaaaaaaaaaabaaaaaaaaaaaaaaaaaaaaaaa3aaaaaaaaaaaaaaaabaaaaaaaaaaaaaaaaaaaaaaaaaaaa3aaaaaaaaaaaaaaaabaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaa3aaa(const aaaaaaaaaaaa1aaat *mm, const aaaaaaaaaaaaa1aaat *key, aaaaaaaaaaaaa1aaat *masked_key)
{
for (uint8_t i = 0; i < CAM_MAX_KEY_WIDTH_MEM; i++) {
masked_key->word[i] = mm->mask_entry.mask.word[i] & key->word[i];
}
}
void murmur3(const void * key, uint16_t len,
uint32_t seed, uint32_t * out)
{
const uint8_t * data = (const uint8_t*)key;
const uint16_t num_blocks = len / 4;
int i;
uint32_t hv = seed;
uint32_t c1 = 0xcc9e2d51;
uint32_t c2 = 0x1b873593;
const uint32_t * blocks = (const uint32_t *) (data + num_blocks * 4);
for (i = -num_blocks; i; i++)
{
uint32_t k1 = blocks[i];
k1 *= c1;
k1 = aaaaaaaa1aaarotate_left32(k1, 15);
k1 *= c2;
hv ^= k1;
hv = aaaaaaaa1aaarotate_left32(hv, 13);
hv = hv * 5 + 0xe6546b64;
}
const uint8_t * tail = (const uint8_t*) (data + num_blocks * 4);
uint32_t k1 = 0;
switch(len & 3)
{
case 3:
k1 ^= tail[2] << 16;
case 2:
k1 ^= tail[1] << 8;
case 1:
k1 ^= tail[0];
k1 *= c1;
k1 = aaaaaaaa1aaarotate_left32(k1, 15);
k1 *= c2;
hv ^= k1;
};
hv ^= len;
hv ^= hv >> 16;
hv *= 0x85ebca6b;
hv ^= hv >> 13;
hv *= 0xc2b2ae35;
hv ^= hv >> 16;
*out = hv;
}
void murmur3_bucket(const void *key, uint16_t keylen, uint32_t num_bkts, uint32_t *hashv, uint32_t *bucket)
{
murmur3(key, keylen, 3, hashv);
*bucket = *hashv & (num_bkts - 1);
}
#define CLOG2(N) (32 - __builtin_clz((uint32_t) ((N) - 1)))
struct aaa1aaat {
aaaa1aaat *km;
aa1aaat *bm;
aaaaaaaaaaaa1aaat *mm;
uint32_t number_of_keys;
a1aaat *client;
};
size_t aaa1aaaaaaaaaaaaaabaaaaaaaaaa3aaa(void)
{
return sizeof(aaa1aaat);
}
bool aaa1aaaaaaaaaaaaaabaaaaaaaaaaa3aaa(aaa1aaat *phm, a1aaat *client, uint16_t unit, uint8_t slot_number)
{
assert(phm != NULL);
cam_malloc_func malloc_function = a1aaaaaaaaaaaaaaaabaaaaaaaaaaaa3aaaaaaaaaaaaaaaabaaaaaaaaaaaaaaaaaaaaaaaaaaaa3aaamalloc_function(client);
phm->km = NULL;
phm->bm = NULL;
phm->mm = NULL;
phm->km = (aaaa1aaat *) malloc_function(aaaa1aaaaaaaaaaaaaabaaaaaaaaaa3aaa());
if (phm->km == NULL) {
return false;
}
if (a1aaaaaaaaaaaaaaabaaaaaaaaaaaa3aaaaaaaaaaaaaaaabaaaaaaaaaaaaaaaaaaaaaaaaaaaa3aaaaaaaaaaaaaaaabaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaa3aaa(client)) {
phm->bm = (aa1aaat *) malloc_function(aa1aaaaaaaaaaaaaabaaaaaaaaaa3aaa());
if (phm->bm == NULL) {
return false;
}
}
phm->mm = (aaaaaaaaaaaa1aaat *) malloc_function(aaaaaaaaaaaa1aaaaaaaaaaaaaabaaaaaaaaaa3aaa());
if (phm->mm == NULL) {
return false;
}
if (!aaaa1aaaaaaaaaaaaaabaaaaaaaaaaa3aaa(phm->km, client, unit, slot_number, true)) {
return false;
}
if (a1aaaaaaaaaaaaaaabaaaaaaaaaaaa3aaaaaaaaaaaaaaaabaaaaaaaaaaaaaaaaaaaaaaaaaaaa3aaaaaaaaaaaaaaaabaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaa3aaa(client)) {
if (!aa1aaaaaaaaaaaaaabaaaaaaaaaaa3aaa(phm->bm, client, unit, slot_number, malloc_function)) {
return false;
}
}
aaaaaaaaaaaa1aaaaaaaaaaaaaabaaaaaaaaaaa3aaa(phm->mm, client, unit, slot_number);
phm->number_of_keys = 0;
phm->client = client;
return true;
}
void aaa1aaaaaaaaaaaaaabaaaaaaaaaaaa3aaa(aaa1aaat *phm, cam_free_func free_function)
{
if (phm == NULL) {
return;
}
aaaa1aaaaaaaaaaaaaabaaaaaaaaaaaa3aaa(phm->km, free_function);
aa1aaaaaaaaaaaaaabaaaaaaaaaaaa3aaa(phm->bm, free_function);
free_function(phm->mm);
free_function(phm);
}
bool aaa1aaaread_element(aaa1aaat *phm, uint32_t aaaaaaaaaa1aaaaaaaaaaaaaaaabaaaaaaaaaaaaaaaaaaaaaaaaaaaa3aaaaaaaaaaaaaaabaaaaaaaaaaaaaaaa4aaaber, aaaaaaaaaaaaaaa1aaat *pointer_list, bool verify, uint8_t narrow,
uint8_t narrow_element)
{
return aaaa1aaaread_element(phm->km, aaaaaaaaaa1aaaaaaaaaaaaaaaabaaaaaaaaaaaaaaaaaaaaaaaaaaaa3aaaaaaaaaaaaaaabaaaaaaaaaaaaaaaa4aaaber, pointer_list, verify, narrow, narrow_element);
}
bool aaa1aaaaaaaaaaaaaaaabaaaaaaaaaaaaaaaaaaa3aaaaaaaaaaaaaaaabaaaaaaaaaaaaaaaaaaaaaaaaaaaa3aaaelement(aaa1aaat *phm, uint32_t aaaaaaaaaa1aaaaaaaaaaaaaaaabaaaaaaaaaaaaaaaaaaaaaaaaaaaa3aaaaaaaaaaaaaaabaaaaaaaaaaaaaaaa4aaaber, uint8_t narrow, uint8_t narrow_element)
{
if (aaaa1aaaaaaaaaaaaaaabaaaaaaaaaaaa3aaaaaaaaaaaaaaaabaaaaaaaaaaaaaaaaaaaaaaaaaaaa3aaapresent(phm->km, aaaaaaaaaa1aaaaaaaaaaaaaaaabaaaaaaaaaaaaaaaaaaaaaaaaaaaa3aaaaaaaaaaaaaaabaaaaaaaaaaaaaaaa4aaaber, narrow, narrow_element)) {
aaaa1aaaaaaaaaaaaaaaabaaaaaaaaaaaaaaaaaaa3aaaaaaaaaaaaaaaabaaaaaaaaaaaaaaaaaaaaaaaaaaaa3aaaelement(phm->km, aaaaaaaaaa1aaaaaaaaaaaaaaaabaaaaaaaaaaaaaaaaaaaaaaaaaaaa3aaaaaaaaaaaaaaabaaaaaaaaaaaaaaaa4aaaber, narrow, narrow_element);
phm->number_of_keys--;
return true;
}
return false;
}
static bool aaa1aaafind_and_read_element(const aaa1aaat *phm, uint32_t *start_value, aaaaaaaaaaaaa1aaat *key, aaaaaaaaaaaaa1aaat *ternary_mask,
aaaaaaaaaaaaaaaa1aaaaaaaaaaaaaaaabaaaaaaaaaaaaaaaaaaaaaaaaaaaa3aaat *priority, uint32_t *bucket, bool verify, uint8_t *narrow, uint8_t *narrow_element)
{
assert(narrow != NULL);
assert(narrow_element != NULL);
assert(((*narrow != 0) && (*narrow_element == 0)) || (*narrow == 0));
aaaaaaaaaaaaaaa1aaat *pointer_list = (aaaaaaaaaaaaaaa1aaat *) alloca(aaaaaaaaaaaaaaa1aaaaaaaaaaaaaabaaaaaaaaaa3aaa());
const uint32_t segment_size = a1aaaaaaaaaaaaaaaabaaaaaaaaaaaa3aaaaaaaaaaaaaaaabaaaaaaaaaaaaaaaaaaaaaaaaaaaa3aaaaaaaaaaaaaaabaaaaaaaaaaaaaaaa4aaaaaaaaaaaaaaaabaaaaaaaaaaaaaaaaaaaaaaaaaaaa4aaaaaaaaaaaaabaaaaaaaaaaaaaaaaa5aaas(phm->client);
const uint32_t max_start_value = segment_size - 1;
while (*start_value <= max_start_value) {
const uint32_t element = *start_value / segment_size;
const uint32_t aaaaaaaaaa1aaa = *start_value - element * segment_size;
if (aaaa1aaaread_element(phm->km, aaaaaaaaaa1aaa, pointer_list, verify, *narrow, *narrow_element)) {
const aaaaaaaaaaaaaaaa1aaaaaaaaaaaaaaaabaaaaaaaaaaaaaaaaaaaaaaaaaaaa3aaat *priority_ptr = aaaaaaaaaaaaaaa1aaaaaaaaaaaaaaaabaaaaaaaaaaaa3aaaaaaaaaaaaaaaabaaaaaaaaaaaaaaaaaaaaaaaaaaaa3aaaaaaaaaaaaaaabaaaaaaaaaaaaaaaaa4aaa(pointer_list, 0);
memcpy(priority, priority_ptr, sizeof(aaaaaaaaaaaaaaaa1aaaaaaaaaaaaaaaabaaaaaaaaaaaaaaaaaaaaaaaaaaaa3aaat));
const aaaaaaaaaaaaa1aaat *aaaaaaaaa1aaa = aaaaaaaaaaaaaaa1aaaaaaaaaaaaaaaabaaaaaaaaaaaa3aaaaaaaaaaaaaaaabaaaaaaaaaaaaaaaaaaaaaaaaaaaa3aaaaaaaaaaaa1aaa(pointer_list, 0);
memcpy(key, aaaaaaaaa1aaa, sizeof(aaaaaaaaaaaaa1aaat));
const aaaaaaaaaaaaa1aaat *read_ternary_mask = aaaaaaaaaaaaaaa1aaaaaaaaaaaaaaaabaaaaaaaaaaaa3aaaaaaaaaaaaaaaabaaaaaaaaaaaaaaaaaaaaaaaaaaaa3aaaternary_mask(pointer_list, 0);
memcpy(ternary_mask, read_ternary_mask, sizeof(aaaaaaaaaaaaa1aaat));
*bucket = aaaaaaaaaaaaaaa1aaaaaaaaaaaaaaaabaaaaaaaaaaaa3aaaaaaaaaaaaaaaabaaaaaaaaaaaaaaaaaaaaaaaaaaaa3aaaaaaaaaabaaaaaaaaaaa4aaa(pointer_list);
return true;
} else {
if ((*narrow) && (*narrow_element == 0)) {
*narrow_element = 1;
} else if (*narrow) {
(*start_value)++;
*narrow_element = 0;
} else {
(*start_value)++;
}
}
}
return false;
}
void aaa1aaaread_mask(const aaa1aaat *phm, aaaaaaaaaaaaa1aaat *mask, uint8_t *range_valid, uint8_t *mask_id)
{
aaaaaaaaaaaa1aaaread_mask(phm->mm, mask, range_valid, mask_id);
}
void aaa1aaaaaaaaaaaaaaaabaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaa3aaaaaaaaaaaaaaaabaaaaaaaaaaaaaaaaaaaaaaaaaaaa4aaaaaaaaaaaaaaaabaaaaaaaaaaaaaaaaaaaaaaa5aaaaaaaaaaaaaaaabaaaaaaaaaaaaaaaaaaaaaaaaaaaa5aaaaaaaaaaaabaaaaaaaaaaa6aaa(aaa1aaat *phm, const aaaaaaaaaaaaa1aaat *mask,
uint16_t seed, uint8_t range_valid, uint8_t mask_id)
{
aaaaaaaaaaaa1aaaaaaaaaaaaaaaabaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaa3aaaaaaaaaaaaaaaabaaaaaaaaaaaaaaaaaaaaaaaaaaaa4aaaaaaaaaaaaaaaabaaaaaaaaaaaaaaaaaaaaaaa5aaaaaaaaaaaaaaaabaaaaaaaaaaaaaaaaaaaaaaaaaaaa5aaaaaaaaaaaabaaaaaaaaaaa6aaa(phm->mm, mask, seed, range_valid, mask_id);
}
static uint32_t adjust_list(const aaa1aaat *phm, uint32_t list)
{
uint32_t num_lists = a1aaaaaaaaaaaaaaaabaaaaaaaaaaaa3aaaaaaaaaaaaaaaabaaaaaaaaaaaaaaaaaaaaaaaaaaaa3aaaaaaaaaaaaaaabaaaaaaaaaaaaaaaa4aaaaaaaaaaaaaaaabaaaaaaaaaaaaaaaaaaaaaaaaaaaa4aaaaaaaaaaaaabaaaaaaaaaaaaaaaaa5aaas(phm->client);
uint8_t num_lists_per_read = 1;
bool is_hbmbcam = a1aaaaaaaaaaaaaaabaaaaaaaaaaaa3aaaaaaaaaaaaaaaabaaaaaaaaaaaaaaaaaaaaaaaaaaaa3aaahbmbcam(phm->client);
if (is_hbmbcam) {
num_lists_per_read = a1aaaaaaaaaaaaaaaabaaaaaaaaaaaa3aaaaaaaaaaaaaaaabaaaaaaaaaaaaaaaaaaaaaaaaaaaa3aaaaaaaaaaaaaaabaaaaaaaaaaaaaaaa4aaaaaaaaaaaaaaaabaaaaaaaaaaaaaaaaaaaaaaaaaaaa4aaaaaaaaaaaaabaaaaaaaaaaaaaaaaa5aaas_per_read(phm->client);
num_lists = num_lists / num_lists_per_read;
}
const uint32_t max_list = num_lists - 1;
const uint32_t list_addr_mask = max_list;
uint32_t adjusted_list = list & list_addr_mask;
if (is_hbmbcam) {
adjusted_list = adjusted_list * num_lists_per_read;
}
return adjusted_list;
}
static uint32_t adjust_bucket(const aaa1aaat *phm, uint32_t bucket)
{
const uint32_t num_lists = a1aaaaaaaaaaaaaaaabaaaaaaaaaaaa3aaaaaaaaaaaaaaaabaaaaaaaaaaaaaaaaaaaaaaaaaaaa3aaaaaaaaaaaaaaabaaaaaaaaaaaaaaaa4aaaaaaaaaaaaaaaabaaaaaaaaaaaaaaaaaaaaaaaaaaaa4aaaaaaaaaaaaabaaaaaaaaaaaaaaaaa5aaas(phm->client);
const uint32_t num_buckets = aaaaaa1aaaaaaaaaabaaaaaaaaaaa3aaaaaaaaaaaaaaaabaaaaaaaaaaaaaaaaaaaaaaaaaaaa3aaaaaaaaaaaaaaaabaaaaaaaaaaaaaaaaaaaaaaaaaaaaa3aaaaaaaaaaaaaaaabaaaaaaaaaaaaaaaaaaaaaaaaaaaa4aaaaaaaaaaaaabaaaaaaaaaaaaaaaaa5aaaaaaaaaaaaaaaabaaaaaaaaaaaaaaaaaaaaaaaaaaaa5aaaRATIO * num_lists;
const uint32_t max_bucket = num_buckets - 1;
const uint32_t bucket_addr_mask = max_bucket;
const uint32_t adjusted_bucket = bucket & bucket_addr_mask;
return adjusted_bucket;
}
static bool insert_function_to_list(bool test, aaa1aaat *phm, uint32_t aaaaaaaaaa1aaaaaaaaaaaaaaaabaaaaaaaaaaaaaaaaaaaaaaaaaaaa3aaaaaaaaaaaaaaabaaaaaaaaaaaaaaaa4aaaber,
const aaaaaaaaaaaaaaa1aaat *pointer_list)
{
assert(a1aaaaaaaaaaaaaaabaaaaaaaaaaaa3aaaaaaaaaaaaaaaabaaaaaaaaaaaaaaaaaaaaaaaaaaaa3aaaaaaaaaaaaaaaabaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaa3aaa(phm->client));
assert(1 == aaaaaaaaaaaaaaa1aaaaaaaaaaaaaaaabaaaaaaaaaaaa3aaaaaaaaaaaaaaaabaaaaaaaaaaaaaaaaaaaaaaaaaaaa3aaaaaaaaaaaaaaabaaaaaaaaaaaaaaaa4aaaber_of_keys(pointer_list));
assert(false == aaaaaaaaaaaaaaa1aaaaaaaaaaaaaaabaaaaaaaaaaaa3aaaaaaaaaaaaaaaabaaaaaaaaaaaaaaaaaaaaaaaaaaaa3aaaaaaaaaaaaaaaabaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaa3aaaaaaaaaaaaaaaabaaaaaaaaaaaaaaaaaaaaaaaaaaaa4aaapointer(pointer_list));
const uint32_t end_list = a1aaaaaaaaaaaaaaaabaaaaaaaaaaaa3aaaaaaaaaaaaaaaabaaaaaaaaaaaaaaaaaaaaaaaaaaaa3aaaaaaaaaaaaaaabaaaaaaaaaaaaaaaa4aaaaaaaaaaaaaaaabaaaaaaaaaaaaaaaaaaaaaaaaaaaa4aaaaaaaaaaaaabaaaaaaaaaaaaaaaaa5aaas(phm->client) - 1;
if (aaaa1aaaaaaaaaaaaaaabaaaaaaaaaaaa3aaaaaaaaaaaaaaaabaaaaaaaaaaaaaaaaaaaaaaaaaaaa3aaaaaaaaaaaaaaaabaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaa3aaa(phm->km, aaaaaaaaaa1aaaaaaaaaaaaaaaabaaaaaaaaaaaaaaaaaaaaaaaaaaaa3aaaaaaaaaaaaaaabaaaaaaaaaaaaaaaa4aaaber)) {
aaaa1aaaaaaaaaaaaaaaabaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaa3aaa(phm->km, aaaaaaaaaa1aaaaaaaaaaaaaaaabaaaaaaaaaaaaaaaaaaaaaaaaaaaa3aaaaaaaaaaaaaaabaaaaaaaaaaaaaaaa4aaaber, pointer_list, 0, 0);
return true;
}
if (!aaaa1aaaaaaaaaaaaaaabaaaaaaaaaaaa3aaaaaaaaaaaaaaaabaaaaaaaaaaaaaaaaaaaaaaaaaaaa3aaaaaaaaaaaaaaaabaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaa3aaaaaaaaaaaaaaaabaaaaaaaaaaaaaaaaaaaaaaaaaaaa4aaapointer(phm->km, aaaaaaaaaa1aaaaaaaaaaaaaaaabaaaaaaaaaaaaaaaaaaaaaaaaaaaa3aaaaaaaaaaaaaaabaaaaaaaaaaaaaaaa4aaaber)) {
return false;
}
const uint32_t my_bucket = aaaa1aaaaaaaaaaaaaaaabaaaaaaaaaaaa3aaaaaaaaaaaaaaaabaaaaaaaaaaaaaaaaaaaaaaaaaaaa3aaaaaaaaaabaaaaaaaaaaa4aaa(phm->km, aaaaaaaaaa1aaaaaaaaaaaaaaaabaaaaaaaaaaaaaaaaaaaaaaaaaaaa3aaaaaaaaaaaaaaabaaaaaaaaaaaaaaaa4aaaber);
aaaaaaaaaaaaaaa1aaat *copy_pointer_list = (aaaaaaaaaaaaaaa1aaat *) alloca(aaaaaaaaaaaaaaa1aaaaaaaaaaaaaabaaaaaaaaaa3aaa());
aaaaaaaaaaaaaaa1aaaaaaaaaaaaaabaaaaaaaaaaa3aaa(copy_pointer_list, my_bucket, true, true);
aaaa1aaaread(phm->km, aaaaaaaaaa1aaaaaaaaaaaaaaaabaaaaaaaaaaaaaaaaaaaaaaaaaaaa3aaaaaaaaaaaaaaabaaaaaaaaaaaaaaaa4aaaber, copy_pointer_list);
uint32_t target_aaaaaaaaaa1aaaaaaaaaaaaaaaabaaaaaaaaaaaaaaaaaaaaaaaaaaaa3aaaaaaaaaaaaaaabaaaaaaaaaaaaaaaa4aaaber = aaaaaaaaaa1aaaaaaaaaaaaaaaabaaaaaaaaaaaaaaaaaaaaaaaaaaaa3aaaaaaaaaaaaaaabaaaaaaaaaaaaaaaa4aaaber + 1;
if (target_aaaaaaaaaa1aaaaaaaaaaaaaaaabaaaaaaaaaaaaaaaaaaaaaaaaaaaa3aaaaaaaaaaaaaaabaaaaaaaaaaaaaaaa4aaaber > end_list) {
target_aaaaaaaaaa1aaaaaaaaaaaaaaaabaaaaaaaaaaaaaaaaaaaaaaaaaaaa3aaaaaaaaaaaaaaabaaaaaaaaaaaaaaaa4aaaber = 0;
}
if (false
== aaaa1aaafind_first_fit_for_pointer_list(phm->km, copy_pointer_list,
&target_aaaaaaaaaa1aaaaaaaaaaaaaaaabaaaaaaaaaaaaaaaaaaaaaaaaaaaa3aaaaaaaaaaaaaaabaaaaaaaaaaaaaaaa4aaaber)) {
return false;
}
aaaa1aaaaaaaaaaaaaaaabaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaa3aaa(phm->km, target_aaaaaaaaaa1aaaaaaaaaaaaaaaabaaaaaaaaaaaaaaaaaaaaaaaaaaaa3aaaaaaaaaaaaaaabaaaaaaaaaaaaaaaa4aaaber, copy_pointer_list, 0, 0);
if (test == false) {
aa1aaaaaaaaaaaaaaaabaaaaaaaaaaaaaaaaaaaaaaaaaaaaaa3aaaaaaaaaaaaaaaabaaaaaaaaaaaaaaaaaaaaaaaaaaaa4aaaaaaaaaaaaaaaabaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaa4aaaaaaaaaaaaaaaabaaaaaaaaaaaaaaaaaaaaaaaaaaaa5aaapointer(phm->bm, my_bucket, target_aaaaaaaaaa1aaaaaaaaaaaaaaaabaaaaaaaaaaaaaaaaaaaaaaaaaaaa3aaaaaaaaaaaaaaabaaaaaaaaaaaaaaaa4aaaber);
}
aaaa1bbbbbbbbbbbbbbbbb3aaa(phm->km, aaaaaaaaaa1aaaaaaaaaaaaaaaabaaaaaaaaaaaaaaaaaaaaaaaaaaaa3aaaaaaaaaaaaaaabaaaaaaaaaaaaaaaa4aaaber);
aaaa1aaaaaaaaaaaaaaaabaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaa3aaa(phm->km, aaaaaaaaaa1aaaaaaaaaaaaaaaabaaaaaaaaaaaaaaaaaaaaaaaaaaaa3aaaaaaaaaaaaaaabaaaaaaaaaaaaaaaa4aaaber, pointer_list, 0, 0);
return true;
}
static bool insert_to_function(aaa1aaat *phm, uint32_t bucket, const aaaaaaaaaaaaaaa1aaat *pointer_list,
hash_t *hash, uint8_t *the_function)
{
assert(1 == aaaaaaaaaaaaaaa1aaaaaaaaaaaaaaaabaaaaaaaaaaaa3aaaaaaaaaaaaaaaabaaaaaaaaaaaaaaaaaaaaaaaaaaaa3aaaaaaaaaaaaaaabaaaaaaaaaaaaaaaa4aaaber_of_keys(pointer_list));
const uint8_t function = aa1aaaaaaaaaaaaaaaabaaaaaaaaaaaa3aaaaaaaaaaaaaaaabaaaaaaaaaaaaaaaaaaaaaaaaaaaa3aaaaaaaaaaaaaaaabaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaa3aaaaaaaaaaaaaaaabaaaaaaaaaaaaaaaaaaaaaaaaaaaa4aaapointer(phm->bm, bucket);
*the_function = function;
uint32_t aaaaaaaaaa1aaaaaaaaaaaaaaaabaaaaaaaaaaaaaaaaaaaaaaaaaaaa3aaaaaaaaaaaaaaabaaaaaaaaaaaaaaaa4aaaber = hash_calculate_list(hash, function);
aaaaaaaaaa1aaaaaaaaaaaaaaaabaaaaaaaaaaaaaaaaaaaaaaaaaaaa3aaaaaaaaaaaaaaabaaaaaaaaaaaaaaaa4aaaber = adjust_list(phm, aaaaaaaaaa1aaaaaaaaaaaaaaaabaaaaaaaaaaaaaaaaaaaaaaaaaaaa3aaaaaaaaaaaaaaabaaaaaaaaaaaaaaaa4aaaber);
if (false
== insert_function_to_list(false, phm, aaaaaaaaaa1aaaaaaaaaaaaaaaabaaaaaaaaaaaaaaaaaaaaaaaaaaaa3aaaaaaaaaaaaaaabaaaaaaaaaaaaaaaa4aaaber, pointer_list)) {
return false;
}
aa1aaaaaaaaaaaaaaabaaaaaaaaaaaaaaaaaaa3aaaaaaaaaaaaaaaabaaaaaaaaaaaaaaaaaaaaaaaaaaaa3aaanext_key(phm->bm, bucket);
return true;
}
static bool convert_to_function(bool test, aaa1aaat *phm, const aaaaaaaaaaaaaaa1aaat *pointer_list,
hash_t *new_key_hash, uint8_t *working_function)
{
assert(a1aaaaaaaaaaaaaaabaaaaaaaaaaaa3aaaaaaaaaaaaaaaabaaaaaaaaaaaaaaaaaaaaaaaaaaaa3aaaaaaaaaaaaaaaabaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaa3aaa(phm->client));
assert(1 == aaaaaaaaaaaaaaa1aaaaaaaaaaaaaaaabaaaaaaaaaaaa3aaaaaaaaaaaaaaaabaaaaaaaaaaaaaaaaaaaaaaaaaaaa3aaaaaaaaaaaaaaabaaaaaaaaaaaaaaaa4aaaber_of_keys(pointer_list));
assert(*working_function < aaaaaa1aaaaaaaaaaaaaaaabaaaaaaaaaaaaaaaaaaaaaaaaaa3aaaaaaaaaaaaaaaabaaaaaaaaaaaaaaaaaaaaaaaaaaaa3aaaaaaaaaaaaaaaabaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaa3aaaS);
const uint32_t bucket = aaaaaaaaaaaaaaa1aaaaaaaaaaaaaaaabaaaaaaaaaaaa3aaaaaaaaaaaaaaaabaaaaaaaaaaaaaaaaaaaaaaaaaaaa3aaaaaaaaaabaaaaaaaaaaa4aaa(pointer_list);
const uint8_t number_of_keys = aa1aaaaaaaaaaaaaaaabaaaaaaaaaaaa3aaaaaaaaaaaaaaaabaaaaaaaaaaaaaaaaaaaaaaaaaaaa3aaaaaaaaaaaaaaabaaaaaaaaaaaaaaaa4aaaber_of_keys(phm->bm, bucket);
uint32_t aaaaaaaaaa1aaaaaaaaaaaaaaaabaaaaaaaaaaaaaaaaaaaaaaaaaaaa3aaaaaaaaaaaaaaabaaaaaaaaaaaaaaaa4aaaber = aa1aaaaaaaaaaaaaaaabaaaaaaaaaaaa3aaaaaaaaaaaaaaaabaaaaaaaaaaaaaaaaaaaaaaaaaaaa3aaaaaaaaaaaaaaaabaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaa3aaaaaaaaaaaaaaaabaaaaaaaaaaaaaaaaaaaaaaaaaaaa4aaapointer(phm->bm, bucket);
aaaaaaaaaaaaaaa1aaat *read_pointer_list = (aaaaaaaaaaaaaaa1aaat *) alloca(aaaaaaaaaaaaaaa1aaaaaaaaaaaaaabaaaaaaaaaa3aaa());
aaaaaaaaaaaaaaa1aaat *insert_pointer_list = (aaaaaaaaaaaaaaa1aaat *) alloca(aaaaaaaaaaaaaaa1aaaaaaaaaaaaaabaaaaaaaaaa3aaa());
aaaa1aaat *original_km = NULL;
aaaaaaaaaaaaaaa1aaaaaaaaaaaaaabaaaaaaaaaaa3aaa(read_pointer_list, bucket, true, true);
aaaa1aaaread(phm->km, aaaaaaaaaa1aaaaaaaaaaaaaaaabaaaaaaaaaaaaaaaaaaaaaaaaaaaa3aaaaaaaaaaaaaaabaaaaaaaaaaaaaaaa4aaaber, read_pointer_list);
assert(aaaaaaaaaaaaaaa1aaaaaaaaaaaaaaaabaaaaaaaaaaaa3aaaaaaaaaaaaaaaabaaaaaaaaaaaaaaaaaaaaaaaaaaaa3aaaaaaaaaaaaaaabaaaaaaaaaaaaaaaa4aaaber_of_keys(read_pointer_list) == number_of_keys);
uint8_t function = *working_function;
uint8_t end_function;
if (test) {
original_km = phm->km;
phm->km = a1aaaaaaaaaaaaaaaabaaaaaaaaaaaa3aaaaaaaaaaaaaaaabaaaaaaaaaaaaaaaaaaaaaaaaaaaa3aaatest_km(phm->client);
if (*working_function == 0) {
end_function = aaaaaa1aaaaaaaaaaaaaaaabaaaaaaaaaaaaaaaaaaaaaaaaaa3aaaaaaaaaaaaaaaabaaaaaaaaaaaaaaaaaaaaaaaaaaaa3aaaaaaaaaaaaaaaabaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaa3aaaS - 1;
} else {
end_function = *working_function - 1;
}
} else {
if (*working_function == (aaaaaa1aaaaaaaaaaaaaaaabaaaaaaaaaaaaaaaaaaaaaaaaaa3aaaaaaaaaaaaaaaabaaaaaaaaaaaaaaaaaaaaaaaaaaaa3aaaaaaaaaaaaaaaabaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaa3aaaS - 1)) {
end_function = 0;
} else {
end_function = *working_function + 1;
}
}
while (end_function != function)
{
bool success = true;
uint8_t key_number;
if (test) {
aaaa1bbbbbbbbbbbbbbbb3aaa(phm->km, original_km);
aaaa1bbbbbbbbbbbbbbbbb3aaaaaaaaaaaaaaaabaaaaaaaaaaaaaaaaaaaaaaaaaaaa4bbbbbbbbbbbbbbbbbbb4aaa(phm->km);
}
hash_t *hash = (hash_t *) alloca(hash_size());
for (key_number = 0; key_number < number_of_keys; key_number++) {
const aaaaaaaaaaaaa1aaat *aaaaaaaaa1aaa = aaaaaaaaaaaaaaa1aaaaaaaaaaaaaaaabaaaaaaaaaaaa3aaaaaaaaaaaaaaaabaaaaaaaaaaaaaaaaaaaaaaaaaaaa3aaaaaaaaaaaa1aaa(read_pointer_list, key_number);
aaaaaaaaaaaaaaaa1aaaaaaaaaaaaaaaabaaaaaaaaaaaaaaaaaaaaaaaaaaaa3aaat prio;
const aaaaaaaaaaaaaaaa1aaaaaaaaaaaaaaaabaaaaaaaaaaaaaaaaaaaaaaaaaaaa3aaat *prio_ptr = aaaaaaaaaaaaaaa1aaaaaaaaaaaaaaaabaaaaaaaaaaaa3aaaaaaaaaaaaaaaabaaaaaaaaaaaaaaaaaaaaaaaaaaaa3aaaaaaaaaaaaaaabaaaaaaaaaaaaaaaaa4aaa(read_pointer_list, key_number);
memcpy(&prio, prio_ptr, sizeof(aaaaaaaaaaaaaaaa1aaaaaaaaaaaaaaaabaaaaaaaaaaaaaaaaaaaaaaaaaaaa3aaat));
const aaaaaaaaaaaaa1aaat *ternary_mask = NULL;
if (a1aaaaaaaaaaaaaaabaaaaaaaaaaaa3aaaaaaaaaaaaaaaabaaaaaaaaaaaaaaaaaaaaaaaaaaaa3aaaaaaaaaaaaaaaabaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaa3aaa(phm->client)) {
aaaaaaaaaaaaa1aaat masked_key;
memset(&masked_key, 0, sizeof(masked_key));
aaaaaaaaaaaa1aaaaaaaaaaaaaaaabaaaaaaaaaaaaaaaaaaaaaaa3aaaaaaaaaaaaaaaabaaaaaaaaaaaaaaaaaaaaaaaaaaaa3aaaaaaaaaaaaaaaabaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaa3aaa(phm->mm, aaaaaaaaa1aaa, &masked_key);
aaaaaaa1aaa(hash, &masked_key, phm);
ternary_mask = aaaaaaaaaaaaaaa1aaaaaaaaaaaaaaaabaaaaaaaaaaaa3aaaaaaaaaaaaaaaabaaaaaaaaaaaaaaaaaaaaaaaaaaaa3aaaternary_mask(read_pointer_list, key_number);
} else {
aaaaaaa1aaa(hash, aaaaaaaaa1aaa, phm);
}
uint32_t new_aaaaaaaaaa1aaaaaaaaaaaaaaaabaaaaaaaaaaaaaaaaaaaaaaaaaaaa3aaaaaaaaaaaaaaabaaaaaaaaaaaaaaaa4aaaber = hash_calculate_list(hash, function);
new_aaaaaaaaaa1aaaaaaaaaaaaaaaabaaaaaaaaaaaaaaaaaaaaaaaaaaaa3aaaaaaaaaaaaaaabaaaaaaaaaaaaaaaa4aaaber = adjust_list(phm, new_aaaaaaaaaa1aaaaaaaaaaaaaaaabaaaaaaaaaaaaaaaaaaaaaaaaaaaa3aaaaaaaaaaaaaaabaaaaaaaaaaaaaaaa4aaaber);
aaaaaaaaaaaaaaa1aaaaaaaaaaaaaabaaaaaaaaaaa3aaa(insert_pointer_list, bucket, false, true);
aaaaaaaaaaaaaaa1bbbbbbbbbbbbbbbbbbbbbbbbbbbbbbbb3aaa(insert_pointer_list, &prio, aaaaaaaaa1aaa, ternary_mask, false);
if (false
== insert_function_to_list(test, phm, new_aaaaaaaaaa1aaaaaaaaaaaaaaaabaaaaaaaaaaaaaaaaaaaaaaaaaaaa3aaaaaaaaaaaaaaabaaaaaaaaaaaaaaaa4aaaber,
insert_pointer_list)) {
success = false;
break;
}
}
if (success) {
uint32_t new_aaaaaaaaaa1aaaaaaaaaaaaaaaabaaaaaaaaaaaaaaaaaaaaaaaaaaaa3aaaaaaaaaaaaaaabaaaaaaaaaaaaaaaa4aaaber = hash_calculate_list(new_key_hash, function);
new_aaaaaaaaaa1aaaaaaaaaaaaaaaabaaaaaaaaaaaaaaaaaaaaaaaaaaaa3aaaaaaaaaaaaaaabaaaaaaaaaaaaaaaa4aaaber = adjust_list(phm, new_aaaaaaaaaa1aaaaaaaaaaaaaaaabaaaaaaaaaaaaaaaaaaaaaaaaaaaa3aaaaaaaaaaaaaaabaaaaaaaaaaaaaaaa4aaaber);
if (false
== insert_function_to_list(test, phm, new_aaaaaaaaaa1aaaaaaaaaaaaaaaabaaaaaaaaaaaaaaaaaaaaaaaaaaaa3aaaaaaaaaaaaaaabaaaaaaaaaaaaaaaa4aaaber,
pointer_list)) {
assert(test);
function++;
if (function == aaaaaa1aaaaaaaaaaaaaaaabaaaaaaaaaaaaaaaaaaaaaaaaaa3aaaaaaaaaaaaaaaabaaaaaaaaaaaaaaaaaaaaaaaaaaaa3aaaaaaaaaaaaaaaabaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaa3aaaS) {
function = 0;
}
continue;
}
if (test) {
phm->km = original_km;
*working_function = function;
} else {
uint32_t direct_pointer = aa1aaaaaaaaaaaaaaaabaaaaaaaaaaaa3aaaaaaaaaaaaaaaabaaaaaaaaaaaaaaaaaaaaaaaaaaaa3aaaaaaaaaaaaaaaabaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaa3aaaaaaaaaaaaaaaabaaaaaaaaaaaaaaaaaaaaaaaaaaaa4aaapointer(phm->bm, bucket);
aa1bbbbbbbbbbbbbbbbbb3aaaaaaaaaaaaaaaabaaaaaaaaaaaaaaaaaaaaaaaaaaaa4aaaaaaaaaaaaaaaabaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaa4aaaaaaaaaaaaaaaabaaaaaaaaaaaaaaaaaaaaaaaaaaaa5aaapointer(phm->bm, bucket, function);
aa1aaaaaaaaaaaaaaabaaaaaaaaaaaaaaaaaaa3aaaaaaaaaaaaaaaabaaaaaaaaaaaaaaaaaaaaaaaaaaaa3aaanext_key(phm->bm, bucket);
aaaa1bbbbbbbbbbbbbbbbb3aaa(phm->km, direct_pointer);
}
return true;
} 
assert(test);
function++;
if (function == aaaaaa1aaaaaaaaaaaaaaaabaaaaaaaaaaaaaaaaaaaaaaaaaa3aaaaaaaaaaaaaaaabaaaaaaaaaaaaaaaaaaaaaaaaaaaa3aaaaaaaaaaaaaaaabaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaa3aaaS) {
function = 0;
}
}
if (test) {
phm->km = original_km;
}
return false;
}
static void get_pending_deletes(const aaa1aaat *phm, uint32_t find_bucket, uint8_t *number_of_pending_deletes,
uint32_t pending_deletes[64])
{
assert(a1aaaaaaaaaaaaaaabaaaaaaaaaaaa3aaaaaaaaaaaaaaaabaaaaaaaaaaaaaaaaaaaaaaaaaaaa3aaaaaaaaaaaaaaaabaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaa3aaa(phm->client));
aaaaaaaaaaaaa1aaat key;
aaaaaaaaaaaaa1aaat ternary_mask;
aaaaaaaaaaaaaaaa1aaaaaaaaaaaaaaaabaaaaaaaaaaaaaaaaaaaaaaaaaaaa3aaat priority;
uint32_t bucket;
uint32_t start_value = 0;
*number_of_pending_deletes = 0;
uint8_t narrow = 0;
uint8_t narrow_element = 0;
while (aaa1aaafind_and_read_element(phm, &start_value, &key, &ternary_mask, &priority, &bucket, false, &narrow,
&narrow_element)) {
if (find_bucket == bucket) {
assert((*number_of_pending_deletes) < 64);
pending_deletes[*number_of_pending_deletes] = start_value;
(*number_of_pending_deletes)++;
}
start_value++;
}
}
static bool delete_element(aaa1aaat *phm, uint32_t *start_value)
{
assert(a1aaaaaaaaaaaaaaabaaaaaaaaaaaa3aaaaaaaaaaaaaaaabaaaaaaaaaaaaaaaaaaaaaaaaaaaa3aaaaaaaaaaaaaaaabaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaa3aaa(phm->client));
aaaaaaaaaaaaaaa1aaat *pointer_list = (aaaaaaaaaaaaaaa1aaat *) alloca(aaaaaaaaaaaaaaa1aaaaaaaaaaaaaabaaaaaaaaaa3aaa());
const uint32_t segment_size = a1aaaaaaaaaaaaaaaabaaaaaaaaaaaa3aaaaaaaaaaaaaaaabaaaaaaaaaaaaaaaaaaaaaaaaaaaa3aaaaaaaaaaaaaaabaaaaaaaaaaaaaaaa4aaaaaaaaaaaaaaaabaaaaaaaaaaaaaaaaaaaaaaaaaaaa4aaaaaaaaaaaaabaaaaaaaaaaaaaaaaa5aaas(phm->client);
const uint32_t max_start_value = segment_size - 1;
uint32_t element_counter = *start_value;
while (element_counter <= max_start_value) {
const uint32_t element = element_counter / segment_size;
const uint32_t aaaaaaaaaa1aaa = element_counter - element * segment_size ;
if (aaaa1aaaread_element(phm->km, aaaaaaaaaa1aaa, pointer_list, false, 0, 0)) {
const uint32_t bucket = aaaaaaaaaaaaaaa1aaaaaaaaaaaaaaaabaaaaaaaaaaaa3aaaaaaaaaaaaaaaabaaaaaaaaaaaaaaaaaaaaaaaaaaaa3aaaaaaaaaabaaaaaaaaaaa4aaa(pointer_list);
aa1aaaaaaaaaaaaaaaabaaaaaaaaaaaaaaaaaaa3aaaaaaaaaaaaaaaabaaaaaaaaaaaaaaaaaaaaaaaaaaaa3aaaaaaaaaaaaaaaabaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaa3aaa(phm->bm, bucket);
aaaa1aaaaaaaaaaaaaaaabaaaaaaaaaaaaaaaaaaa3aaaaaaaaaaaaaaaabaaaaaaaaaaaaaaaaaaaaaaaaaaaa3aaaelement(phm->km, aaaaaaaaaa1aaa, 0, 0);
*start_value = element_counter;
return true;
} else {
element_counter++;
}
}
return false;
}
static bool change_function(bool test, aaa1aaat *phm, const aaaaaaaaaaaaaaa1aaat *pointer_list,
hash_t *new_key_hash, uint8_t *working_function)
{
assert(a1aaaaaaaaaaaaaaabaaaaaaaaaaaa3aaaaaaaaaaaaaaaabaaaaaaaaaaaaaaaaaaaaaaaaaaaa3aaaaaaaaaaaaaaaabaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaa3aaa(phm->client));
assert(1 == aaaaaaaaaaaaaaa1aaaaaaaaaaaaaaaabaaaaaaaaaaaa3aaaaaaaaaaaaaaaabaaaaaaaaaaaaaaaaaaaaaaaaaaaa3aaaaaaaaaaaaaaabaaaaaaaaaaaaaaaa4aaaber_of_keys(pointer_list));
assert(*working_function < aaaaaa1aaaaaaaaaaaaaaaabaaaaaaaaaaaaaaaaaaaaaaaaaa3aaaaaaaaaaaaaaaabaaaaaaaaaaaaaaaaaaaaaaaaaaaa3aaaaaaaaaaaaaaaabaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaa3aaaS);
const uint32_t bucket = aaaaaaaaaaaaaaa1aaaaaaaaaaaaaaaabaaaaaaaaaaaa3aaaaaaaaaaaaaaaabaaaaaaaaaaaaaaaaaaaaaaaaaaaa3aaaaaaaaaabaaaaaaaaaaa4aaa(pointer_list);
const uint8_t number_of_keys = aa1aaaaaaaaaaaaaaaabaaaaaaaaaaaa3aaaaaaaaaaaaaaaabaaaaaaaaaaaaaaaaaaaaaaaaaaaa3aaaaaaaaaaaaaaabaaaaaaaaaaaaaaaa4aaaber_of_keys(phm->bm, bucket);
const uint32_t segment_size = a1aaaaaaaaaaaaaaaabaaaaaaaaaaaa3aaaaaaaaaaaaaaaabaaaaaaaaaaaaaaaaaaaaaaaaaaaa3aaaaaaaaaaaaaaabaaaaaaaaaaaaaaaa4aaaaaaaaaaaaaaaabaaaaaaaaaaaaaaaaaaaaaaaaaaaa4aaaaaaaaaaaaabaaaaaaaaaaaaaaaaa5aaas(phm->client);
const uint32_t end_aaaaaaaaaa1aaa = segment_size - 1;
aaaaaaaaaaaaaaa1aaat *read_pointer_list = (aaaaaaaaaaaaaaa1aaat *) alloca(aaaaaaaaaaaaaaa1aaaaaaaaaaaaaabaaaaaaaaaa3aaa());
aaaaaaaaaaaaaaa1aaat *insert_pointer_list = (aaaaaaaaaaaaaaa1aaat *) alloca(aaaaaaaaaaaaaaa1aaaaaaaaaaaaaabaaaaaaaaaa3aaa());
aaaa1aaat *original_km = NULL;
aaaaaaaaaaaaaaa1aaaaaaaaaaaaaabaaaaaaaaaaa3aaa(read_pointer_list, bucket, false, true);
for (uint32_t aaaaaaaaaa1aaaaaaaaaaaaaaaabaaaaaaaaaaaaaaaaaaaaaaaaaaaa3aaaaaaaaaaaaaaabaaaaaaaaaaaaaaaa4aaaber = 0; aaaaaaaaaa1aaaaaaaaaaaaaaaabaaaaaaaaaaaaaaaaaaaaaaaaaaaa3aaaaaaaaaaaaaaabaaaaaaaaaaaaaaaa4aaaber <= end_aaaaaaaaaa1aaa; aaaaaaaaaa1aaaaaaaaaaaaaaaabaaaaaaaaaaaaaaaaaaaaaaaaaaaa3aaaaaaaaaaaaaaabaaaaaaaaaaaaaaaa4aaaber++) {
aaaa1aaaread(phm->km, aaaaaaaaaa1aaaaaaaaaaaaaaaabaaaaaaaaaaaaaaaaaaaaaaaaaaaa3aaaaaaaaaaaaaaabaaaaaaaaaaaaaaaa4aaaber, read_pointer_list);
}
uint32_t pending_deletes[64];
uint8_t number_of_pending_deletes;
get_pending_deletes(phm, bucket, &number_of_pending_deletes, pending_deletes);
uint8_t function = *working_function;
uint8_t end_function;
if (test) {
original_km = phm->km;
phm->km = a1aaaaaaaaaaaaaaaabaaaaaaaaaaaa3aaaaaaaaaaaaaaaabaaaaaaaaaaaaaaaaaaaaaaaaaaaa3aaatest_km(phm->client);
if (function == 0) {
end_function = aaaaaa1aaaaaaaaaaaaaaaabaaaaaaaaaaaaaaaaaaaaaaaaaa3aaaaaaaaaaaaaaaabaaaaaaaaaaaaaaaaaaaaaaaaaaaa3aaaaaaaaaaaaaaaabaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaa3aaaS - 1;
} else {
end_function = function - 1;
}
} else {
if (function == (aaaaaa1aaaaaaaaaaaaaaaabaaaaaaaaaaaaaaaaaaaaaaaaaa3aaaaaaaaaaaaaaaabaaaaaaaaaaaaaaaaaaaaaaaaaaaa3aaaaaaaaaaaaaaaabaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaa3aaaS - 1)) {
end_function = 0;
} else {
end_function = function + 1;
}
}
while (end_function != function) {
bool success = true;
uint8_t key_number;
if (test) {
aaaa1bbbbbbbbbbbbbbbb3aaa(phm->km, original_km);
aaaa1bbbbbbbbbbbbbbbbb3aaaaaaaaaaaaaaaabaaaaaaaaaaaaaaaaaaaaaaaaaaaa4bbbbbbbbbbbbbbbbbbb4aaa(phm->km);
}
hash_t *hash = (hash_t *) alloca(hash_size());
for (key_number = 0; key_number < number_of_keys; key_number++) {
const aaaaaaaaaaaaa1aaat *aaaaaaaaa1aaa = aaaaaaaaaaaaaaa1aaaaaaaaaaaaaaaabaaaaaaaaaaaa3aaaaaaaaaaaaaaaabaaaaaaaaaaaaaaaaaaaaaaaaaaaa3aaaaaaaaaaaa1aaa(read_pointer_list, key_number);
aaaaaaaaaaaaaaaa1aaaaaaaaaaaaaaaabaaaaaaaaaaaaaaaaaaaaaaaaaaaa3aaat prio;
const aaaaaaaaaaaaaaaa1aaaaaaaaaaaaaaaabaaaaaaaaaaaaaaaaaaaaaaaaaaaa3aaat *prio_ptr = aaaaaaaaaaaaaaa1aaaaaaaaaaaaaaaabaaaaaaaaaaaa3aaaaaaaaaaaaaaaabaaaaaaaaaaaaaaaaaaaaaaaaaaaa3aaaaaaaaaaaaaaabaaaaaaaaaaaaaaaaa4aaa(read_pointer_list, key_number);
memcpy(&prio, prio_ptr, sizeof(aaaaaaaaaaaaaaaa1aaaaaaaaaaaaaaaabaaaaaaaaaaaaaaaaaaaaaaaaaaaa3aaat));
const aaaaaaaaaaaaa1aaat *ternary_mask = NULL;
if (a1aaaaaaaaaaaaaaabaaaaaaaaaaaa3aaaaaaaaaaaaaaaabaaaaaaaaaaaaaaaaaaaaaaaaaaaa3aaaaaaaaaaaaaaaabaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaa3aaa(phm->client)) {
aaaaaaaaaaaaa1aaat masked_key;
memset(&masked_key, 0, sizeof(masked_key));
aaaaaaaaaaaa1aaaaaaaaaaaaaaaabaaaaaaaaaaaaaaaaaaaaaaa3aaaaaaaaaaaaaaaabaaaaaaaaaaaaaaaaaaaaaaaaaaaa3aaaaaaaaaaaaaaaabaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaa3aaa(phm->mm, aaaaaaaaa1aaa, &masked_key);
aaaaaaa1aaa(hash, &masked_key, phm);
ternary_mask = aaaaaaaaaaaaaaa1aaaaaaaaaaaaaaaabaaaaaaaaaaaa3aaaaaaaaaaaaaaaabaaaaaaaaaaaaaaaaaaaaaaaaaaaa3aaaternary_mask(read_pointer_list, key_number);
} else {
aaaaaaa1aaa(hash, aaaaaaaaa1aaa, phm);
}
assert(function < aaaaaa1aaaaaaaaaaaaaaaabaaaaaaaaaaaaaaaaaaaaaaaaaa3aaaaaaaaaaaaaaaabaaaaaaaaaaaaaaaaaaaaaaaaaaaa3aaaaaaaaaaaaaaaabaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaa3aaaS);
uint32_t new_aaaaaaaaaa1aaaaaaaaaaaaaaaabaaaaaaaaaaaaaaaaaaaaaaaaaaaa3aaaaaaaaaaaaaaabaaaaaaaaaaaaaaaa4aaaber = hash_calculate_list(hash, function);
new_aaaaaaaaaa1aaaaaaaaaaaaaaaabaaaaaaaaaaaaaaaaaaaaaaaaaaaa3aaaaaaaaaaaaaaabaaaaaaaaaaaaaaaa4aaaber = adjust_list(phm, new_aaaaaaaaaa1aaaaaaaaaaaaaaaabaaaaaaaaaaaaaaaaaaaaaaaaaaaa3aaaaaaaaaaaaaaabaaaaaaaaaaaaaaaa4aaaber);
aaaaaaaaaaaaaaa1aaaaaaaaaaaaaabaaaaaaaaaaa3aaa(insert_pointer_list, bucket, false, true);
aaaaaaaaaaaaaaa1bbbbbbbbbbbbbbbbbbbbbbbbbbbbbbbb3aaa(insert_pointer_list, &prio, aaaaaaaaa1aaa, ternary_mask, false);
if (false
== insert_function_to_list(test, phm, new_aaaaaaaaaa1aaaaaaaaaaaaaaaabaaaaaaaaaaaaaaaaaaaaaaaaaaaa3aaaaaaaaaaaaaaabaaaaaaaaaaaaaaaa4aaaber,
insert_pointer_list)) {
success = false;
break;
}
}
if (success) {
assert(function < aaaaaa1aaaaaaaaaaaaaaaabaaaaaaaaaaaaaaaaaaaaaaaaaa3aaaaaaaaaaaaaaaabaaaaaaaaaaaaaaaaaaaaaaaaaaaa3aaaaaaaaaaaaaaaabaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaa3aaaS);
uint32_t new_aaaaaaaaaa1aaaaaaaaaaaaaaaabaaaaaaaaaaaaaaaaaaaaaaaaaaaa3aaaaaaaaaaaaaaabaaaaaaaaaaaaaaaa4aaaber = hash_calculate_list(new_key_hash, function);
new_aaaaaaaaaa1aaaaaaaaaaaaaaaabaaaaaaaaaaaaaaaaaaaaaaaaaaaa3aaaaaaaaaaaaaaabaaaaaaaaaaaaaaaa4aaaber = adjust_list(phm, new_aaaaaaaaaa1aaaaaaaaaaaaaaaabaaaaaaaaaaaaaaaaaaaaaaaaaaaa3aaaaaaaaaaaaaaabaaaaaaaaaaaaaaaa4aaaber);
if (false
== insert_function_to_list(test, phm, new_aaaaaaaaaa1aaaaaaaaaaaaaaaabaaaaaaaaaaaaaaaaaaaaaaaaaaaa3aaaaaaaaaaaaaaabaaaaaaaaaaaaaaaa4aaaber,
pointer_list)) {
assert(test);
function++;
if (function == aaaaaa1aaaaaaaaaaaaaaaabaaaaaaaaaaaaaaaaaaaaaaaaaa3aaaaaaaaaaaaaaaabaaaaaaaaaaaaaaaaaaaaaaaaaaaa3aaaaaaaaaaaaaaaabaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaa3aaaS) {
function = 0;
}
continue;
}
if (test) {
phm->km = original_km;
*working_function = function;
} else {
aa1bbbbbbbbbbbbbbbbbb3aaaaaaaaaaaaaaaabaaaaaaaaaaaaaaaaaaaaaaaaaaaa4aaaaaaaaaaaaaaaabaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaa4aaaaaaaaaaaaaaaabaaaaaaaaaaaaaaaaaaaaaaaaaaaa5aaapointer(phm->bm, bucket, function);
aa1aaaaaaaaaaaaaaabaaaaaaaaaaaaaaaaaaa3aaaaaaaaaaaaaaaabaaaaaaaaaaaaaaaaaaaaaaaaaaaa3aaanext_key(phm->bm, bucket);
for (uint8_t i = 0; i < number_of_pending_deletes; i++) {
uint32_t start_value = pending_deletes[i];
const bool status = delete_element(phm, &start_value);
aa1aaaaaaaaaaaaaaabaaaaaaaaaaaaaaaaaaa3aaaaaaaaaaaaaaaabaaaaaaaaaaaaaaaaaaaaaaaaaaaa3aaanext_key(phm->bm, bucket);
assert(status);
assert(start_value == pending_deletes[i]);
}
assert(aa1aaaaaaaaaaaaaaaabaaaaaaaaaaaa3aaaaaaaaaaaaaaaabaaaaaaaaaaaaaaaaaaaaaaaaaaaa3aaaaaaaaaaaaaaabaaaaaaaaaaaaaaaa4aaaber_of_keys(phm->bm, bucket) == (number_of_keys + 1));
}
return true;
} 
assert(test);
function++;
if (function == aaaaaa1aaaaaaaaaaaaaaaabaaaaaaaaaaaaaaaaaaaaaaaaaa3aaaaaaaaaaaaaaaabaaaaaaaaaaaaaaaaaaaaaaaaaaaa3aaaaaaaaaaaaaaaabaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaa3aaaS) {
function = 0;
}
}
if (test) {
phm->km = original_km;
}
return false;
}
static void delete_mask(aaa1aaat *phm)
{
assert(a1aaaaaaaaaaaaaaabaaaaaaaaaaaa3aaaaaaaaaaaaaaaabaaaaaaaaaaaaaaaaaaaaaaaaaaaa3aaaaaaaaaaaaaaaabaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaa3aaa(phm->client));
aaaaaaaaaaaa1bbbbbbbbbbbbbbbbb3aaaaaaaaaaaaaaaabaaaaaaaaaaaaaaaaaaaaaaaaaaaa4aaaaaaaaaaaaaaaabaaaaaaaaaaaaaaaaaaaaaaa5aaaaaaaaaaaaaaaabaaaaaaaaaaaaaaaaaaaaaaaaaaaa5aaaaaaaaaaaabaaaaaaaaaaa6aaa(phm->mm);
aa1aaaaaaaaaaaaaaaabaaaaaaaaaaaaaaaaaaa3aaa(phm->bm);
aaaa1aaaaaaaaaaaaaaaabaaaaaaaaaaaaaaaaaaa3aaa(phm->km);
phm->number_of_keys = 0;
}
void aaa1bbbbbbbbbbbbbbbbb3aaaaaaaaaaaaaaaabaaaaaaaaaaaaaaaaaaaaaaaaaaaa4aaaaaaaaaaaaaaaabaaaaaaaaaaaaaaaaaaaaaaa5aaaaaaaaaaaaaaaabaaaaaaaaaaaaaaaaaaaaaaaaaaaa5aaaaaaaaaaaabaaaaaaaaaaa6aaa(const aaa1aaat *phm)
{
aaaaaaaaaaaa1bbbbbbbbbbbbbbbbb3aaaaaaaaaaaaaaaabaaaaaaaaaaaaaaaaaaaaaaaaaaaa4aaaaaaaaaaaaaaaabaaaaaaaaaaaaaaaaaaaaaaa5aaaaaaaaaaaaaaaabaaaaaaaaaaaaaaaaaaaaaaaaaaaa5aaaaaaaaaaaabaaaaaaaaaaa6aaa(phm->mm);
}
static uint32_t get_max_number_of_keys(const aaa1aaat *phm)
{
const uint32_t num_lists = a1aaaaaaaaaaaaaaaabaaaaaaaaaaaa3aaaaaaaaaaaaaaaabaaaaaaaaaaaaaaaaaaaaaaaaaaaa3aaaaaaaaaaaaaaabaaaaaaaaaaaaaaaa4aaaaaaaaaaaaaaaabaaaaaaaaaaaaaaaaaaaaaaaaaaaa4aaaaaaaaaaaaabaaaaaaaaaaaaaaaaa5aaas(phm->client);
return num_lists * aaaaaa1aaaaaaaaaaaaaaaabaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaa3aaaaaaaaaaaaaaaabaaaaaaaaaaaaaaaaaaaaaaaaaaaa4bbbbbbbbbbbbbbbbbbbbbbbbbbbbbbbbbb4aaaaaaaaaaaaaaaabaaaaaaaaaaaaaaaaaaaaaaaaaaaa5aaaRATIO;
}
static void write_range_value(uint32_t *words, uint16_t start_pos, uint16_t end_pos, uint16_t range_value)
{
const uint16_t bit_diff = end_pos - start_pos + 1;
assert(bit_diff > 0);
assert(bit_diff <= 16);
uint8_t start_word = start_pos / 32;
uint8_t start_word_start = start_pos - start_word * 32;
uint8_t end_word = end_pos / 32;
uint8_t end_word_end = end_pos - end_word * 32;
uint8_t word_diff = end_word - start_word;
assert(word_diff < 2);
if (word_diff == 0) {
words[start_word] = aaaaaaaa1aaaaaaaaaaaaaaaabaaaaaaaaaaaaaaaaaaaaaa3aaa(words[start_word], range_value, start_word_start,
end_word_end - start_word_start + 1);
} else {
uint32_t value = aaaaaaaa1aaaaaaaaaaaaaaaabaaaaaaaaaaaa3aaa(range_value, 0, 32 - start_word_start);
words[start_word] = aaaaaaaa1aaaaaaaaaaaaaaaabaaaaaaaaaaaaaaaaaaaaaa3aaa(words[start_word], value, start_word_start, 32 - start_word_start);
value = aaaaaaaa1aaaaaaaaaaaaaaaabaaaaaaaaaaaa3aaa(range_value, 32 - start_word_start, bit_diff - (32 - start_word_start));
words[end_word] = aaaaaaaa1aaaaaaaaaaaaaaaabaaaaaaaaaaaaaaaaaaaaaa3aaa(words[end_word], value, 0, bit_diff - (32 - start_word_start));
}
}
static uint16_t read_range_value(const uint32_t *words, uint16_t start_pos, uint16_t end_pos)
{
assert(start_pos <= end_pos);
const uint16_t bit_diff = end_pos - start_pos + 1;
assert(bit_diff <= 16);
uint8_t start_word = start_pos / 32;
uint8_t start_word_start = start_pos - start_word * 32;
uint8_t end_word = end_pos / 32;
uint8_t end_word_end = end_pos - end_word * 32;
uint8_t word_diff = end_word - start_word;
assert(word_diff < 2);
if (word_diff == 0) {
return aaaaaaaa1aaaaaaaaaaaaaaaabaaaaaaaaaaaa3aaa(words[start_word], start_word_start, end_word_end - start_word_start + 1);
} else {
const uint32_t value0 = aaaaaaaa1aaaaaaaaaaaaaaaabaaaaaaaaaaaa3aaa(words[start_word], start_word_start, 32 - start_word_start);
const uint32_t value1 = aaaaaaaa1aaaaaaaaaaaaaaaabaaaaaaaaaaaa3aaa(words[end_word], 0, end_word_end + 1);
return aaaaaaaa1aaaaaaaaaaaaaaaabaaaaaaaaaaaaaaaaaaaaaa3aaa(value0, value1, 32 - start_word_start, end_word_end + 1);
}
}
int aaa1aaacheck_ternary_mask(const a1aaat *client, const aaaaaaaaaaaaa1aaat *key, const aaaaaaaaaaaaa1aaat *ternary_mask,
const aaaaaaaaaaaaa1aaat *mask, uint8_t range_valid)
{
if (ternary_mask == NULL) {
return CAM_ERROR_WRONG_TERNARY_MASK;
}
aaaaaaaaaaaaa1aaat copy_key;
memcpy(&copy_key, key, sizeof(copy_key));
const uint8_t num_ranges = a1aaaaaaaaaaaaaaaabaaaaaaaaaaaa3aaaaaaaaaaaaaaaabaaaaaaaaaaaaaaaaaaaaaaaaaaaa3aaaaaaaaaaaaaaabaaaaaaaaaaaaaaaa4aaaaaaaaaaaaaaaabaaaaaaaaaaaaaaaaaaaaaaaaaaaa4aaaaaaaaaaaaaaaabaaaaaaaaaaaaaaaaaaaa5aaas(client);
for (uint8_t i = 0; i < num_ranges; i++) {
uint16_t start_pos;
int rc = a1aaaaaaaaaaaaaaaabaaaaaaaaaaaa3aaaaaaaaaaaaaaaabaaaaaaaaaaaaaaaaaaaaaaaaaaaa3aaaaaaaaaaaaaaaabaaaaaaaaaaaaaaaaaaaa4aaaaaaaaaaaaaaaabaaaaaaaaaaaaaaaaaaaaaaaaaaaa4aaastart_pos(client, i, &start_pos);
assert(rc == 0);
uint8_t width;
rc = a1aaaaaaaaaaaaaaaabaaaaaaaaaaaa3aaaaaaaaaaaaaaaabaaaaaaaaaaaaaaaaaaaaaaaaaaaa3aaaaaaaaaaaaaaaabaaaaaaaaaaaaaaaaaaaa4aaaaaaaaaaaaaaaabaaaaaaaaaaaaaaaaaaaaaaaaaaaa4aaawidth(client, i, &width);
assert(rc == 0);
const uint16_t end_pos = start_pos + width - 1;
uint16_t range_start = read_range_value(&key->word[0], start_pos, end_pos);
uint16_t range_mask = read_range_value(&mask->word[0], start_pos, end_pos);
uint16_t range_end = read_range_value(&ternary_mask->word[0], start_pos, end_pos);
if (range_valid & (1 << i)) {
if (range_start > range_end)
return CAM_ERROR_WRONG_RANGE;
if (range_mask != 0)
return CAM_ERROR_WRONG_RANGE_MASK;
write_range_value(&copy_key.word[0], start_pos, end_pos, 0);
}
}
const uint16_t key_width = a1aaaaaaaaaaaaaaaabaaaaaaaaaaaa3aaaaaaaaaaaaaaaabaaaaaaaaaaaaaaaaaaaaaaaaaaaa3aaaaaaaaaaaaaaaabaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaa3aaaaaaaaaaaaaaaabaaaaaaaaaaaaaaaaaaaaaaaaaaaa4aaawidth(client);
uint16_t number_of_words = key_width / 32;
for (uint16_t i = 0; i < number_of_words; i++) {
if ((ternary_mask->word[i] & mask->word[i]) != mask->word[i])
return CAM_ERROR_WRONG_TERNARY_MASK;
if ((ternary_mask->word[i] & copy_key.word[i]) != copy_key.word[i]) {
return CAM_ERROR_MASKED_KEY_BIT_IS_SET;
}
}
const uint8_t remaining_bits = key_width - number_of_words * 32;
if (remaining_bits > 0) {
const uint32_t remaining_key_bits = aaaaaaaa1aaaaaaaaaaaaaaaabaaaaaaaaaaaa3aaa(copy_key.word[number_of_words], 0, remaining_bits);
const uint32_t remaining_mask_bits = aaaaaaaa1aaaaaaaaaaaaaaaabaaaaaaaaaaaa3aaa(mask->word[number_of_words], 0, remaining_bits);
const uint32_t remaining_ternary_mask_bits = aaaaaaaa1aaaaaaaaaaaaaaaabaaaaaaaaaaaa3aaa(ternary_mask->word[number_of_words], 0, remaining_bits);
if ((remaining_ternary_mask_bits & remaining_mask_bits) != remaining_mask_bits)
return CAM_ERROR_WRONG_TERNARY_MASK;
if ((remaining_ternary_mask_bits & remaining_key_bits) != remaining_key_bits) {
return CAM_ERROR_MASKED_KEY_BIT_IS_SET;
}
}
return 0;
}
static bool match_ternary_mask(const a1aaat *client, const aaaaaaaaaaaaa1aaat *key, const aaaaaaaaaaaaa1aaat *ternary_mask,
const aaaaaaaaaaaaa1aaat *aaaaaaaaa1aaa, uint8_t range_valid)
{
aaaaaaaaaaaaa1aaat copy_ternary_mask;
memcpy(&copy_ternary_mask, ternary_mask, sizeof(copy_ternary_mask));
const uint8_t num_ranges = a1aaaaaaaaaaaaaaaabaaaaaaaaaaaa3aaaaaaaaaaaaaaaabaaaaaaaaaaaaaaaaaaaaaaaaaaaa3aaaaaaaaaaaaaaabaaaaaaaaaaaaaaaa4aaaaaaaaaaaaaaaabaaaaaaaaaaaaaaaaaaaaaaaaaaaa4aaaaaaaaaaaaaaaabaaaaaaaaaaaaaaaaaaaa5aaas(client);
for (uint8_t i = 0; i < num_ranges; i++) {
uint16_t start_pos;
int rc = a1aaaaaaaaaaaaaaaabaaaaaaaaaaaa3aaaaaaaaaaaaaaaabaaaaaaaaaaaaaaaaaaaaaaaaaaaa3aaaaaaaaaaaaaaaabaaaaaaaaaaaaaaaaaaaa4aaaaaaaaaaaaaaaabaaaaaaaaaaaaaaaaaaaaaaaaaaaa4aaastart_pos(client, i, &start_pos);
assert(rc == 0);
uint8_t width;
rc = a1aaaaaaaaaaaaaaaabaaaaaaaaaaaa3aaaaaaaaaaaaaaaabaaaaaaaaaaaaaaaaaaaaaaaaaaaa3aaaaaaaaaaaaaaaabaaaaaaaaaaaaaaaaaaaa4aaaaaaaaaaaaaaaabaaaaaaaaaaaaaaaaaaaaaaaaaaaa4aaawidth(client, i, &width);
assert(rc == 0);
const uint16_t end_pos = start_pos + width - 1;
uint16_t range_start = read_range_value(&aaaaaaaaa1aaa->word[0], start_pos, end_pos);
uint16_t compare = read_range_value(&key->word[0], start_pos, end_pos);
uint16_t range_end = read_range_value(&ternary_mask->word[0], start_pos, end_pos);
if (range_valid & (1 << i)) {
if ((compare < range_start) || (compare > range_end)) {
return false;
}
write_range_value(&copy_ternary_mask.word[0], start_pos, end_pos, 0);
}
}
uint16_t ternary_field_size = (a1aaaaaaaaaaaaaaaabaaaaaaaaaaaa3aaaaaaaaaaaaaaaabaaaaaaaaaaaaaaaaaaaaaaaaaaaa3aaaaaaaaaaaaaaaabaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaa3aaaaaaaaaaaaaaaabaaaaaaaaaaaaaaaaaaaaaaaaaaaa4aaawidth(client) + 31) / 32;
for (uint16_t i = 0; i < ternary_field_size; i++) {
uint32_t mask_word = copy_ternary_mask.word[i];
if ((aaaaaaaaa1aaa->word[i] & mask_word) != (mask_word & key->word[i])) {
return false;
}
}
return true;
}
static bool recover(aaa1aaat *phm, const aaaaaaaaaaaaa1aaat *add_aaaaaaaaa1aaa, const aaaaaaaaaaaaa1aaat *add_ternary_mask,
const aaaaaaaaaaaaaaaa1aaaaaaaaaaaaaaaabaaaaaaaaaaaaaaaaaaaaaaaaaaaa3aaat *add_priority,
uint32_t add_bucket_hash, uint32_t add_bucket);
bool aaa1aaaaaaaaaaaaaaabaaaaaaaaaaaaaaaaaaa3aaa(aaa1aaat *phm, const aaaaaaaaaaaaa1aaat *key, const aaaaaaaaaaaaa1aaat *ternary_mask,
const aaaaaaaaaaaaaaaa1aaaaaaaaaaaaaaaabaaaaaaaaaaaaaaaaaaaaaaaaaaaa3aaat *priority,
bool true_first_fit,
uint8_t recover_start_function)
{
const int16_t margin = get_max_number_of_keys(phm) - phm->number_of_keys;
assert(margin >= 0);
if (margin == 0) {
return false;
}
uint32_t bucket;
aaaaaaaaaaaaaaa1aaat *pointer_list = (aaaaaaaaaaaaaaa1aaat *) alloca(aaaaaaaaaaaaaaa1aaaaaaaaaaaaaabaaaaaaaaaa3aaa());
hash_t *hash = (hash_t *) alloca(hash_size());
aaaaaaaaaaaaa1aaat *aaaaaaaaa1aaa; 
uint32_t bucket_hash;
aaaaaaaaaaaaa1aaat masked_key;
memset(&masked_key, 0, sizeof(masked_key));
aaaaaaaaaaaa1aaaaaaaaaaaaaaaabaaaaaaaaaaaaaaaaaaaaaaa3aaaaaaaaaaaaaaaabaaaaaaaaaaaaaaaaaaaaaaaaaaaa3aaaaaaaaaaaaaaaabaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaa3aaa(phm->mm, key, &masked_key);
aaaaaaa1aaa(hash, &masked_key, phm);
bucket_hash = hash_calculate_bucket(hash);
bucket = adjust_bucket(phm, bucket_hash);
aaaaaaaaa1aaa = (aaaaaaaaaaaaa1aaat *) key;
if (aa1aaaaaaaaaaaaaaabaaaaaaaaaaaa3aaaaaaaaaaaaaaaabaaaaaaaaaaaaaaaaaaaaaaaaaaaa3aaaaaaaaaaaaaaaabaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaa3aaa(phm->bm, bucket)) {
uint32_t aaaaaaaaaa1aaaaaaaaaaaaaaaabaaaaaaaaaaaaaaaaaaaaaaaaaaaa3aaaaaaaaaaaaaaabaaaaaaaaaaaaaaaa4aaaber;
uint32_t bucket_aaaaaaaaaa1aaaaaaaaaaaaaaaabaaaaaaaaaaaaaaaaaaaaaaaaaaaa3aaaaaaaaaaaaaaabaaaaaaaaaaaaaaaa4aaaber = UINT32_MAX;
if (true_first_fit) {
aaaaaaaaaa1aaaaaaaaaaaaaaaabaaaaaaaaaaaaaaaaaaaaaaaaaaaa3aaaaaaaaaaaaaaabaaaaaaaaaaaaaaaa4aaaber = 0;
} else {
bucket_aaaaaaaaaa1aaaaaaaaaaaaaaaabaaaaaaaaaaaaaaaaaaaaaaaaaaaa3aaaaaaaaaaaaaaabaaaaaaaaaaaaaaaa4aaaber = adjust_list(phm, bucket);
aaaaaaaaaa1aaaaaaaaaaaaaaaabaaaaaaaaaaaaaaaaaaaaaaaaaaaa3aaaaaaaaaaaaaaabaaaaaaaaaaaaaaaa4aaaber = bucket_aaaaaaaaaa1aaaaaaaaaaaaaaaabaaaaaaaaaaaaaaaaaaaaaaaaaaaa3aaaaaaaaaaaaaaabaaaaaaaaaaaaaaaa4aaaber;
}
aaaaaaaaaaaaaaa1aaaaaaaaaaaaaabaaaaaaaaaaa3aaa(pointer_list, bucket, true, true);
aaaaaaaaaaaaaaa1bbbbbbbbbbbbbbbbbbbbbbbbbbbbbbbb3aaa(pointer_list, priority, aaaaaaaaa1aaa, ternary_mask, false);
if (false == aaaa1aaafind_first_fit_for_pointer_list(phm->km, pointer_list, &aaaaaaaaaa1aaaaaaaaaaaaaaaabaaaaaaaaaaaaaaaaaaaaaaaaaaaa3aaaaaaaaaaaaaaabaaaaaaaaaaaaaaaa4aaaber)) {
return recover(phm, aaaaaaaaa1aaa, ternary_mask, priority, bucket_hash, bucket);
}
aaaa1aaaaaaaaaaaaaaaabaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaa3aaa(phm->km, aaaaaaaaaa1aaaaaaaaaaaaaaaabaaaaaaaaaaaaaaaaaaaaaaaaaaaa3aaaaaaaaaaaaaaabaaaaaaaaaaaaaaaa4aaaber, pointer_list, 0, 0);
aa1aaaaaaaaaaaaaaabaaaaaaaaaaaaaaaaaaa3aaaaaaaaaaaaaaaabaaaaaaaaaaaaaaaaaaaaaaaaaaaa3aaaaaaaaaaaaaaaabaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaa3aaaaaaaaaaaaaaaabaaaaaaaaaaaaaaaaaaaaaaaaaaaa4aaaaaaaaaaaaaaaabaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaa4aaa(phm->bm, bucket, aaaaaaaaaa1aaaaaaaaaaaaaaaabaaaaaaaaaaaaaaaaaaaaaaaaaaaa3aaaaaaaaaaaaaaabaaaaaaaaaaaaaaaa4aaaber);
} else if (aa1aaaaaaaaaaaaaaabaaaaaaaaaaaa3aaaaaaaaaaaaaaaabaaaaaaaaaaaaaaaaaaaaaaaaaaaa3aaaaaaaaaaaaaaaabaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaa3aaaaaaaaaaaaaaaabaaaaaaaaaaaaaaaaaaaaaaaaaaaa4aaapointer(phm->bm, bucket)) {
if (2 > margin) {
return recover(phm, aaaaaaaaa1aaa, ternary_mask, priority, bucket_hash, bucket);
}
aaaaaaaaaaaaaaa1aaaaaaaaaaaaaabaaaaaaaaaaa3aaa(pointer_list, bucket, false, true);
aaaaaaaaaaaaaaa1bbbbbbbbbbbbbbbbbbbbbbbbbbbbbbbb3aaa(pointer_list, priority, aaaaaaaaa1aaa, ternary_mask, false);
uint8_t working_function = recover_start_function;
if (false == convert_to_function(true, phm, pointer_list, hash, &working_function)) {
return recover(phm, aaaaaaaaa1aaa, ternary_mask, priority, bucket_hash, bucket);
}
if (false == convert_to_function(false, phm, pointer_list, hash, &working_function)) {
assert(false);
}
} else if (aa1aaaaaaaaaaaaaaabaaaaaaaaaaaa3aaaaaaaaaaaaaaaabaaaaaaaaaaaaaaaaaaaaaaaaaaaa3aaaaaaaaaaaaaaaabaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaa3aaaaaaaaaaaaaaaabaaaaaaaaaaaaaaaaaaaaaaaaaaaa4aaapointer(phm->bm, bucket)) {
aaaaaaaaaaaaaaa1aaaaaaaaaaaaaabaaaaaaaaaaa3aaa(pointer_list, bucket, false, true);
aaaaaaaaaaaaaaa1bbbbbbbbbbbbbbbbbbbbbbbbbbbbbbbb3aaa(pointer_list, priority, aaaaaaaaa1aaa, ternary_mask, false);
uint8_t the_function;
if (false == insert_to_function(phm, bucket, pointer_list, hash, &the_function)) {
const uint8_t number_of_keys = aaaaaaaaaaaaaaa1aaaaaaaaaaaaaaaabaaaaaaaaaaaa3aaaaaaaaaaaaaaaabaaaaaaaaaaaaaaaaaaaaaaaaaaaa3aaaaaaaaaaaaaaabaaaaaaaaaaaaaaaa4aaaber_of_keys(pointer_list);
if ((number_of_keys) > margin) {
return recover(phm, aaaaaaaaa1aaa, ternary_mask, priority, bucket_hash, bucket);
}
the_function++;
if (the_function == aaaaaa1aaaaaaaaaaaaaaaabaaaaaaaaaaaaaaaaaaaaaaaaaa3aaaaaaaaaaaaaaaabaaaaaaaaaaaaaaaaaaaaaaaaaaaa3aaaaaaaaaaaaaaaabaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaa3aaaS) {
the_function = 0;
}
if (false == change_function(true, phm, pointer_list, hash, &the_function)) {
return recover(phm, aaaaaaaaa1aaa, ternary_mask, priority, bucket_hash, bucket);
} else {
const bool status = change_function(false, phm, pointer_list, hash, &the_function);
assert(status);
phm->number_of_keys++;
return true;
}
}
} else {
assert(false);
}
phm->number_of_keys++;
return true;
}
static inline uint32_t swap_murmur_bucket(const aaa1aaat *phm, uint32_t murmur_bucket)
{
const uint8_t murmur_slice = aaaaaaaaaaaa1aaaaaaaaaaaaaaaabaaaaaaaaaaaa3aaaaaaaaaaaaaaaabaaaaaaaaaaaaaaaaaaaaaaaaaaaa3aaaseed(phm->mm) & 3;
if (murmur_slice == 0)
return murmur_bucket;
if (murmur_slice == 1) {
return __builtin_bswap32(murmur_bucket);
}
const uint32_t low_temp = murmur_bucket & 0xffff;
const uint32_t high_temp = murmur_bucket >> 16;
const uint16_t swapped_low_temp = __builtin_bswap16(low_temp);
const uint16_t swapped_high_temp = __builtin_bswap16(high_temp);
const uint32_t double_swapped_temp = swapped_high_temp << 16 | swapped_low_temp;
if (murmur_slice == 2)
return double_swapped_temp;
if (murmur_slice == 3)
return __builtin_bswap32(double_swapped_temp);
assert(false);
return 0;
}
uint32_t aaa1aaaaaaaaaaaaaaaabaaaaaaaaaaaa3aaaaaaaaaaaaaaaabaaaaaaaaaaaaaaaaaaaaaaaaaaaa3aaaaaaaaaaaaabaaaaaaaaaaaaaaaaa4aaaaaaaaaaaaaaaabaaaaaaaaaaaaaaaaaaaaaaaaaaaa4aaafrom_murmur(const aaa1aaat *phm, uint32_t murmur_bucket)
{
const uint32_t swapped_murmur_bucket = swap_murmur_bucket(phm, murmur_bucket);
return adjust_list(phm, swapped_murmur_bucket);
}
bool aaa1bbbbbbbbbbbbbbbbbbbbbbbbbbbbbbbbbbbbbb3aaaaaaaaaaaaaaaabaaaaaaaaaaaaaaaaaaaaaaaaaaaa4aaaaaaaaaaaaaaabaaaaaaaaaaaaaaaaaaa5aaa(aaa1aaat *phm, const aaaaaaaaaaaaa1aaat *key, const aaaaaaaaaaaaaaaa1aaaaaaaaaaaaaaaabaaaaaaaaaaaaaaaaaaaaaaaaaaaa3aaat *response,
uint32_t murmur_bucket,
aaaaaaaaaaaaaaa1aaat *evicted_entry, bool narrow_key)
{
aaaaaaaaaaaaaaa1aaat *pointer_list = (aaaaaaaaaaaaaaa1aaat *) alloca(aaaaaaaaaaaaaaa1aaaaaaaaaaaaaabaaaaaaaaaa3aaa());
uint32_t aaaaaaaaaa1aaaaaaaaaaaaaaaabaaaaaaaaaaaaaaaaaaaaaaaaaaaa3aaaaaaaaaaaaaaabaaaaaaaaaaaaaaaa4aaaber;
const aaaaaaaaaaaaa1aaat *masked_key;
aaaaaaaaaaaaa1aaat m_key;
const bool is_hbmbcam = a1aaaaaaaaaaaaaaabaaaaaaaaaaaa3aaaaaaaaaaaaaaaabaaaaaaaaaaaaaaaaaaaaaaaaaaaa3aaahbmbcam(phm->client);
if (!(is_hbmbcam || a1aaaaaaaaaaaaaaabaaaaaaaaaaaa3aaaaaaaaaaaaaaaabaaaaaaaaaaaaaaaaaaaaaaaaaaaa3aaabcam(phm->client))) {
memset(&m_key, 0, sizeof(m_key));
aaaaaaaaaaaa1aaaaaaaaaaaaaaaabaaaaaaaaaaaaaaaaaaaaaaa3aaaaaaaaaaaaaaaabaaaaaaaaaaaaaaaaaaaaaaaaaaaa3aaaaaaaaaaaaaaaabaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaa3aaa(phm->mm, key, &m_key);
masked_key = &m_key;
} else {
masked_key = key;
}
if (is_hbmbcam) {
const uint32_t swapped_murmur_bucket = swap_murmur_bucket(phm, murmur_bucket);
aaaaaaaaaa1aaaaaaaaaaaaaaaabaaaaaaaaaaaaaaaaaaaaaaaaaaaa3aaaaaaaaaaaaaaabaaaaaaaaaaaaaaaa4aaaber = adjust_list(phm, swapped_murmur_bucket);
} else {
hash_t *hash = (hash_t *) alloca(hash_size());
uint32_t bucket_hash;
aaaaaaa1aaa(hash, masked_key, phm);
bucket_hash = hash_calculate_bucket(hash);
aaaaaaaaaa1aaaaaaaaaaaaaaaabaaaaaaaaaaaaaaaaaaaaaaaaaaaa3aaaaaaaaaaaaaaabaaaaaaaaaaaaaaaa4aaaber = adjust_list(phm, bucket_hash);
}
aaaaaaaaaaaaaaa1aaaaaaaaaaaaaabaaaaaaaaaaa3aaa(pointer_list, murmur_bucket, true, false);
aaaaaaaaaaaaaaa1bbbbbbbbbbbbbbbbbbbbbbbbbbbbbbbb3aaa(pointer_list, response, masked_key, NULL, narrow_key);
uint8_t picked_list = 0;
uint8_t picked_narrow_element = 0;
const bool mixed = a1aaaaaaaaaaaaaaabaaaaaaaaaaaa3aaaaaaaaaaaaaaaabaaaaaaaaaaaaaaaaaaaaaaaaaaaa3aaamixed_mode(phm->client);
if (is_hbmbcam) {
const uint8_t num_lists_per_read = a1aaaaaaaaaaaaaaaabaaaaaaaaaaaa3aaaaaaaaaaaaaaaabaaaaaaaaaaaaaaaaaaaaaaaaaaaa3aaaaaaaaaaaaaaabaaaaaaaaaaaaaaaa4aaaaaaaaaaaaaaaabaaaaaaaaaaaaaaaaaaaaaaaaaaaa4aaaaaaaaaaaaabaaaaaaaaaaaaaaaaa5aaas_per_read(phm->client);
const uint8_t random = rand();
picked_list = random - random / num_lists_per_read * num_lists_per_read;
if (mixed && (num_lists_per_read > 1) && !narrow_key) {
bool wide_valid, narrow1_valid, narrow0_valid;
aaaa1aaaaaaaaaaaaaaaabaaaaaaaaaaaa3aaaaaaaaaaaaaaaabaaaaaaaaaaaaaaaaaaaaaaaaaaaa3aaaaaaaaaaaaaaaabaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaa3aaaaaaaaaaaaaaaabaaaaaaaaaaaaaaaaaaaaaaaaaaaa4aaabits(phm->km, aaaaaaaaaa1aaaaaaaaaaaaaaaabaaaaaaaaaaaaaaaaaaaaaaaaaaaa3aaaaaaaaaaaaaaabaaaaaaaaaaaaaaaa4aaaber + picked_list, &wide_valid, &narrow1_valid, &narrow0_valid);
bool succ = a1aaaaaaaaaaaaaaabaaaaaaaaaaaa3aaaaaaaaaaaaaaaabaaaaaaaaaaaaaaaaaaaaaaaaaaaa3aaaoverwritten(phm->client, phm, aaaaaaaaaa1aaaaaaaaaaaaaaaabaaaaaaaaaaaaaaaaaaaaaaaaaaaa3aaaaaaaaaaaaaaabaaaaaaaaaaaaaaaa4aaaber + picked_list);
if ((narrow1_valid && narrow0_valid) || succ) { 
for (picked_list = 0; picked_list < num_lists_per_read; picked_list++) {
aaaa1aaaaaaaaaaaaaaaabaaaaaaaaaaaa3aaaaaaaaaaaaaaaabaaaaaaaaaaaaaaaaaaaaaaaaaaaa3aaaaaaaaaaaaaaaabaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaa3aaaaaaaaaaaaaaaabaaaaaaaaaaaaaaaaaaaaaaaaaaaa4aaabits(phm->km, aaaaaaaaaa1aaaaaaaaaaaaaaaabaaaaaaaaaaaaaaaaaaaaaaaaaaaa3aaaaaaaaaaaaaaabaaaaaaaaaaaaaaaa4aaaber + picked_list, &wide_valid, &narrow1_valid,
&narrow0_valid);
const bool succ = a1aaaaaaaaaaaaaaabaaaaaaaaaaaa3aaaaaaaaaaaaaaaabaaaaaaaaaaaaaaaaaaaaaaaaaaaa3aaaoverwritten(phm->client, phm, aaaaaaaaaa1aaaaaaaaaaaaaaaabaaaaaaaaaaaaaaaaaaaaaaaaaaaa3aaaaaaaaaaaaaaabaaaaaaaaaaaaaaaa4aaaber + picked_list);
if (!((narrow1_valid && narrow0_valid) || succ))
break;
}
if (picked_list == num_lists_per_read) { 
return false;
}
}
}
else if (num_lists_per_read > 1) {
bool succ = a1aaaaaaaaaaaaaaabaaaaaaaaaaaa3aaaaaaaaaaaaaaaabaaaaaaaaaaaaaaaaaaaaaaaaaaaa3aaaoverwritten(phm->client, phm, aaaaaaaaaa1aaaaaaaaaaaaaaaabaaaaaaaaaaaaaaaaaaaaaaaaaaaa3aaaaaaaaaaaaaaabaaaaaaaaaaaaaaaa4aaaber + picked_list);
if (succ) { 
for (picked_list = 0; picked_list < num_lists_per_read; picked_list++) {
succ = a1aaaaaaaaaaaaaaabaaaaaaaaaaaa3aaaaaaaaaaaaaaaabaaaaaaaaaaaaaaaaaaaaaaaaaaaa3aaaoverwritten(phm->client, phm, aaaaaaaaaa1aaaaaaaaaaaaaaaabaaaaaaaaaaaaaaaaaaaaaaaaaaaa3aaaaaaaaaaaaaaabaaaaaaaaaaaaaaaa4aaaber + picked_list);
if (!succ)
break;
}
if (picked_list == num_lists_per_read) { 
return false;
}
}
}
picked_narrow_element = random - random / 2 * 2; 
assert(picked_list < num_lists_per_read);
}
uint8_t narrow, narrow_element;
if (narrow_key) {
narrow = 1;
narrow_element = picked_narrow_element;
} else {
narrow = 0;
narrow_element = 0;
}
const bool overwritten = a1aaaaaaaaaaaaaaabaaaaaaaaaaaa3aaaaaaaaaaaaaaaabaaaaaaaaaaaaaaaaaaaaaaaaaaaa3aaaoverwritten(phm->client, phm, aaaaaaaaaa1aaaaaaaaaaaaaaaabaaaaaaaaaaaaaaaaaaaaaaaaaaaa3aaaaaaaaaaaaaaabaaaaaaaaaaaaaaaa4aaaber + picked_list);
if (overwritten) {
return false;
}
bool success = false;
if (!mixed) {
success = aaaa1aaaread_element(phm->km, aaaaaaaaaa1aaaaaaaaaaaaaaaabaaaaaaaaaaaaaaaaaaaaaaaaaaaa3aaaaaaaaaaaaaaabaaaaaaaaaaaaaaaa4aaaber + picked_list, evicted_entry, false, 0, 0);
} else {
bool wide_valid, narrow1_valid, narrow0_valid;
narrow = 0;
narrow_element = 0;
aaaa1aaaaaaaaaaaaaaaabaaaaaaaaaaaa3aaaaaaaaaaaaaaaabaaaaaaaaaaaaaaaaaaaaaaaaaaaa3aaaaaaaaaaaaaaaabaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaa3aaaaaaaaaaaaaaaabaaaaaaaaaaaaaaaaaaaaaaaaaaaa4aaabits(phm->km, aaaaaaaaaa1aaaaaaaaaaaaaaaabaaaaaaaaaaaaaaaaaaaaaaaaaaaa3aaaaaaaaaaaaaaabaaaaaaaaaaaaaaaa4aaaber + picked_list, &wide_valid, &narrow1_valid, &narrow0_valid);
assert(wide_valid || narrow1_valid || narrow0_valid); 
if (!narrow_key && wide_valid) 
success = aaaa1aaaread_element(phm->km, aaaaaaaaaa1aaaaaaaaaaaaaaaabaaaaaaaaaaaaaaaaaaaaaaaaaaaa3aaaaaaaaaaaaaaabaaaaaaaaaaaaaaaa4aaaber + picked_list, evicted_entry, false, 0, 0);
else if (!narrow_key && !wide_valid && !narrow0_valid && narrow1_valid) { 
narrow = 1;
narrow_element = 1;
success = aaaa1aaaread_element(phm->km, aaaaaaaaaa1aaaaaaaaaaaaaaaabaaaaaaaaaaaaaaaaaaaaaaaaaaaa3aaaaaaaaaaaaaaabaaaaaaaaaaaaaaaa4aaaber + picked_list, evicted_entry, false, narrow,
narrow_element);
} else if (!narrow_key && !wide_valid && !narrow1_valid && narrow0_valid) { 
narrow = 1;
success = aaaa1aaaread_element(phm->km, aaaaaaaaaa1aaaaaaaaaaaaaaaabaaaaaaaaaaaaaaaaaaaaaaaaaaaa3aaaaaaaaaaaaaaabaaaaaaaaaaaaaaaa4aaaber + picked_list, evicted_entry, false, narrow,
narrow_element);
} else if (narrow_key && !wide_valid) { 
assert(narrow0_valid && narrow1_valid);
narrow = 1;
narrow_element = picked_narrow_element;
success = aaaa1aaaread_element(phm->km, aaaaaaaaaa1aaaaaaaaaaaaaaaabaaaaaaaaaaaaaaaaaaaaaaaaaaaa3aaaaaaaaaaaaaaabaaaaaaaaaaaaaaaa4aaaber + picked_list, evicted_entry, false, narrow,
narrow_element);
} else if (!narrow_key && !wide_valid) { 
return false;
} else if (narrow_key && wide_valid) { 
narrow = 1;
narrow_element = 0;
success = aaaa1aaaread_element(phm->km, aaaaaaaaaa1aaaaaaaaaaaaaaaabaaaaaaaaaaaaaaaaaaaaaaaaaaaa3aaaaaaaaaaaaaaabaaaaaaaaaaaaaaaa4aaaber + picked_list, evicted_entry, false, 0, 0);
}
else {
assert(false);
}
}
if (success) {
if (!narrow_key) {
narrow = 0;
narrow_element = 0;
}
a1bbbbbbbbbbbbbbbbbbbbbbbbbbbbbbbb3aaaaaaaaaaaaaaaabaaaaaaaaaaaaaaaaaaaaaaaaaaaa4aaaoverwrite(phm->client, phm, aaaaaaaaaa1aaaaaaaaaaaaaaaabaaaaaaaaaaaaaaaaaaaaaaaaaaaa3aaaaaaaaaaaaaaabaaaaaaaaaaaaaaaa4aaaber + picked_list, pointer_list, narrow, narrow_element);
} else {
assert(false);
}
return true;
}
bool aaa1aaaif_invalid_insert(aaa1aaat *phm, const aaaaaaaaaaaaa1aaat *key, const aaaaaaaaaaaaaaaa1aaaaaaaaaaaaaaaabaaaaaaaaaaaaaaaaaaaaaaaaaaaa3aaat *response, uint32_t murmur_bucket,
bool narrow_key)
{
aaaaaaaaaaaaaaa1aaat *pointer_list = (aaaaaaaaaaaaaaa1aaat *) alloca(aaaaaaaaaaaaaaa1aaaaaaaaaaaaaabaaaaaaaaaa3aaa());
uint32_t aaaaaaaaaa1aaaaaaaaaaaaaaaabaaaaaaaaaaaaaaaaaaaaaaaaaaaa3aaaaaaaaaaaaaaabaaaaaaaaaaaaaaaa4aaaber;
const aaaaaaaaaaaaa1aaat *masked_key;
aaaaaaaaaaaaa1aaat m_key;
const bool is_hbmbcam = a1aaaaaaaaaaaaaaabaaaaaaaaaaaa3aaaaaaaaaaaaaaaabaaaaaaaaaaaaaaaaaaaaaaaaaaaa3aaahbmbcam(phm->client);
if (!(is_hbmbcam || a1aaaaaaaaaaaaaaabaaaaaaaaaaaa3aaaaaaaaaaaaaaaabaaaaaaaaaaaaaaaaaaaaaaaaaaaa3aaabcam(phm->client))) {
memset(&m_key, 0, sizeof(m_key));
aaaaaaaaaaaa1aaaaaaaaaaaaaaaabaaaaaaaaaaaaaaaaaaaaaaa3aaaaaaaaaaaaaaaabaaaaaaaaaaaaaaaaaaaaaaaaaaaa3aaaaaaaaaaaaaaaabaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaa3aaa(phm->mm, key, &m_key);
masked_key = &m_key;
} else {
masked_key = key;
}
if (is_hbmbcam) {
const uint32_t swapped_murmur_bucket = swap_murmur_bucket(phm, murmur_bucket);
aaaaaaaaaa1aaaaaaaaaaaaaaaabaaaaaaaaaaaaaaaaaaaaaaaaaaaa3aaaaaaaaaaaaaaabaaaaaaaaaaaaaaaa4aaaber = adjust_list(phm, swapped_murmur_bucket);
} else {
hash_t *hash = (hash_t *) alloca(hash_size());
uint32_t bucket_hash;
aaaaaaa1aaa(hash, masked_key, phm);
bucket_hash = hash_calculate_bucket(hash);
aaaaaaaaaa1aaaaaaaaaaaaaaaabaaaaaaaaaaaaaaaaaaaaaaaaaaaa3aaaaaaaaaaaaaaabaaaaaaaaaaaaaaaa4aaaber = adjust_list(phm, bucket_hash);
}
aaaaaaaaaaaaaaa1aaaaaaaaaaaaaabaaaaaaaaaaa3aaa(pointer_list, murmur_bucket, true, false);
aaaaaaaaaaaaaaa1bbbbbbbbbbbbbbbbbbbbbbbbbbbbbbbb3aaa(pointer_list, response, masked_key, NULL, narrow_key);
uint8_t i = 0;
uint8_t loop = 1;
if (a1aaaaaaaaaaaaaaabaaaaaaaaaaaa3aaaaaaaaaaaaaaaabaaaaaaaaaaaaaaaaaaaaaaaaaaaa3aaahbmbcam(phm->client)) {
loop = a1aaaaaaaaaaaaaaaabaaaaaaaaaaaa3aaaaaaaaaaaaaaaabaaaaaaaaaaaaaaaaaaaaaaaaaaaa3aaaaaaaaaaaaaaabaaaaaaaaaaaaaaaa4aaaaaaaaaaaaaaaabaaaaaaaaaaaaaaaaaaaaaaaaaaaa4aaaaaaaaaaaaabaaaaaaaaaaaaaaaaa5aaas_per_read(phm->client);
}
uint8_t narrow = 0;
uint8_t narrow_element = 0;
const bool mixed_mode = a1aaaaaaaaaaaaaaabaaaaaaaaaaaa3aaaaaaaaaaaaaaaabaaaaaaaaaaaaaaaaaaaaaaaaaaaa3aaamixed_mode(phm->client);
assert(!narrow_key || (narrow_key && mixed_mode));
if (narrow_key) {
narrow = 1;
for (i = 0; i < loop; i++) {
const bool overwritten = a1aaaaaaaaaaaaaaabaaaaaaaaaaaa3aaaaaaaaaaaaaaaabaaaaaaaaaaaaaaaaaaaaaaaaaaaa3aaaoverwritten(phm->client, phm, aaaaaaaaaa1aaaaaaaaaaaaaaaabaaaaaaaaaaaaaaaaaaaaaaaaaaaa3aaaaaaaaaaaaaaabaaaaaaaaaaaaaaaa4aaaber + i);
if (overwritten)
continue;
bool wide_valid, narrow1_valid, narrow0_valid;
aaaa1aaaaaaaaaaaaaaaabaaaaaaaaaaaa3aaaaaaaaaaaaaaaabaaaaaaaaaaaaaaaaaaaaaaaaaaaa3aaaaaaaaaaaaaaaabaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaa3aaaaaaaaaaaaaaaabaaaaaaaaaaaaaaaaaaaaaaaaaaaa4aaabits(phm->km, aaaaaaaaaa1aaaaaaaaaaaaaaaabaaaaaaaaaaaaaaaaaaaaaaaaaaaa3aaaaaaaaaaaaaaabaaaaaaaaaaaaaaaa4aaaber + i, &wide_valid, &narrow1_valid, &narrow0_valid);
if (wide_valid)
continue;
narrow_element = 0;
if (!narrow0_valid) {
break;
}
narrow_element = 1;
if (!narrow1_valid) {
break;
}
}
}
else {
for (i = 0; i < loop; i++) {
const bool overwritten = a1aaaaaaaaaaaaaaabaaaaaaaaaaaa3aaaaaaaaaaaaaaaabaaaaaaaaaaaaaaaaaaaaaaaaaaaa3aaaoverwritten(phm->client, phm, aaaaaaaaaa1aaaaaaaaaaaaaaaabaaaaaaaaaaaaaaaaaaaaaaaaaaaa3aaaaaaaaaaaaaaabaaaaaaaaaaaaaaaa4aaaber + i);
if (overwritten)
continue;
if (mixed_mode) {
bool wide_valid, narrow1_valid, narrow0_valid;
aaaa1aaaaaaaaaaaaaaaabaaaaaaaaaaaa3aaaaaaaaaaaaaaaabaaaaaaaaaaaaaaaaaaaaaaaaaaaa3aaaaaaaaaaaaaaaabaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaa3aaaaaaaaaaaaaaaabaaaaaaaaaaaaaaaaaaaaaaaaaaaa4aaabits(phm->km, aaaaaaaaaa1aaaaaaaaaaaaaaaabaaaaaaaaaaaaaaaaaaaaaaaaaaaa3aaaaaaaaaaaaaaabaaaaaaaaaaaaaaaa4aaaber + i, &wide_valid, &narrow1_valid, &narrow0_valid);
if (!(wide_valid || narrow0_valid || narrow1_valid))
break;
} else if (aaaa1aaaaaaaaaaaaaaabaaaaaaaaaaaa3aaaaaaaaaaaaaaaabaaaaaaaaaaaaaaaaaaaaaaaaaaaa3aaaaaaaaaaaaaaaabaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaa3aaa(phm->km, aaaaaaaaaa1aaaaaaaaaaaaaaaabaaaaaaaaaaaaaaaaaaaaaaaaaaaa3aaaaaaaaaaaaaaabaaaaaaaaaaaaaaaa4aaaber + i)) {
break;
}
}
}
if (i == loop)
return false;
aaaa1aaaaaaaaaaaaaaaabaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaa3aaa(phm->km, aaaaaaaaaa1aaaaaaaaaaaaaaaabaaaaaaaaaaaaaaaaaaaaaaaaaaaa3aaaaaaaaaaaaaaabaaaaaaaaaaaaaaaa4aaaber + i, pointer_list, narrow, narrow_element);
phm->number_of_keys++;
return true;
}
void aaa1aaaaaaaaaaaaaaaabaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaa3aaa(const aaa1aaat *phm)
{
assert(a1aaaaaaaaaaaaaaabaaaaaaaaaaaa3aaaaaaaaaaaaaaaabaaaaaaaaaaaaaaaaaaaaaaaaaaaa3aaaaaaaaaaaaaaaabaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaa3aaa(phm->client));
   printf("\nStart PHM");
const uint16_t unit = aaaaaaaaaaaa1aaaaaaaaaaaaaaaabaaaaaaaaaaaa3aaaaaaaaaaaaaaaabaaaaaaaaaaaaaaaaaaaaaaaaaaaa3aaaaaaaaaaaabaaaaaaaaaaaaaaaaa4aaa(phm->mm);
const uint8_t max_slots = a1aaaaaaaaaaaaaaaabaaaaaaaaaaaa3aaaaaaaaaaaaaaaabaaaaaaaaaaaaaaaaaaaaaaaaaaaa3aaaaaaaaaaaaaaabaaaaaaaaaaaaaaaa4aaaaaaaaaaaaaaaabaaaaaaaaaaaaaaaaaaaaaaaaaaaa4bbbbbbbbbbbbbbbbbbbbbbbbbbbbbbbbbbbb4aaas(phm->client);
const uint8_t slot_number = aaaaaaaaaaaa1aaaaaaaaaaaaaaaabaaaaaaaaaaaa3aaaaaaaaaaaaaaaabaaaaaaaaaaaaaaaaaaaaaaaaaaaa3bbbbbbbbbbbbbbbbbbbbbbbbbbbbbbbbbbbb3aaaaaaaaaaaaaaaabaaaaaaaaaaaaaaaaaaaaaaaaaaaa4aaaaaaaaaaaaaaabaaaaaaaaaaaaaaaa5aaaber(phm->mm);
   printf("\nUnit = %d, Max slots = %d, Slot number = %d", unit, max_slots,
slot_number);
if (aaaaaaaaaaaa1aaaaaaaaaaaaaaabaaaaaaaaaaaa3aaaaaaaaaaaaaaaabaaaaaaaaaaaaaaaaaaaaaaaaaaaa3aaaaaaaaaaaaaaaabaaaaaaaaaaaaaaaaaaaaaaa4aaaaaaaaaaaaaaaabaaaaaaaaaaaaaaaaaaaaaaaaaaaa4aaaaaaaaaaaabaaaaaaaaaaa5aaaaaaaaaaaaaaaabaaaaaaaaaaaaaaaaaaaaaaaaaaaa5aaavalid(phm->mm)) {
aaaaaaaaaaaaaaa1aaat *pointer_list = (aaaaaaaaaaaaaaa1aaat *) alloca(aaaaaaaaaaaaaaa1aaaaaaaaaaaaaabaaaaaaaaaa3aaa());
const uint32_t segment_size = a1aaaaaaaaaaaaaaaabaaaaaaaaaaaa3aaaaaaaaaaaaaaaabaaaaaaaaaaaaaaaaaaaaaaaaaaaa3aaaaaaaaaaaaaaabaaaaaaaaaaaaaaaa4aaaaaaaaaaaaaaaabaaaaaaaaaaaaaaaaaaaaaaaaaaaa4aaaaaaaaaaaaabaaaaaaaaaaaaaaaaa5aaas(phm->client);
const uint32_t end_aaaaaaaaaa1aaa = segment_size - 1;
uint8_t range_valid, mask_id;
aaaaaaaaaaaaa1aaat mask;
memset(&mask, 0, sizeof(aaaaaaaaaaaaa1aaat));
aaa1aaaread_mask(phm, &mask, &range_valid, &mask_id);
const uint16_t key_width = a1aaaaaaaaaaaaaaaabaaaaaaaaaaaa3aaaaaaaaaaaaaaaabaaaaaaaaaaaaaaaaaaaaaaaaaaaa3aaaaaaaaaaaaaaaabaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaa3aaaaaaaaaaaaaaaabaaaaaaaaaaaaaaaaaaaaaaaaaaaa4aaawidth(phm->client);
printf(
                   "\nRange valid = %d, Mask id = %d\nKey Width = %d Mask = ", range_valid,
mask_id, key_width);
for (int8_t j = 9; j >= 0; j--) {
           printf("%08x", mask.word[j]);
}
const uint32_t num_lists = a1aaaaaaaaaaaaaaaabaaaaaaaaaaaa3aaaaaaaaaaaaaaaabaaaaaaaaaaaaaaaaaaaaaaaaaaaa3aaaaaaaaaaaaaaabaaaaaaaaaaaaaaaa4aaaaaaaaaaaaaaaabaaaaaaaaaaaaaaaaaaaaaaaaaaaa4aaaaaaaaaaaaabaaaaaaaaaaaaaaaaa5aaas(phm->client);
const uint32_t end_bucket = num_lists * aaaaaa1aaaaaaaaaabaaaaaaaaaaa3aaaaaaaaaaaaaaaabaaaaaaaaaaaaaaaaaaaaaaaaaaaa3aaaaaaaaaaaaaaaabaaaaaaaaaaaaaaaaaaaaaaaaaaaaa3aaaaaaaaaaaaaaaabaaaaaaaaaaaaaaaaaaaaaaaaaaaa4aaaaaaaaaaaaabaaaaaaaaaaaaaaaaa5aaaaaaaaaaaaaaaabaaaaaaaaaaaaaaaaaaaaaaaaaaaa5aaaRATIO - 1;
uint32_t number_of_keys = 0;
uint32_t reverse_counter = 0;
       printf("\nBucket, mode number_of_keys, bloom");
for (uint32_t bucket = 0; bucket <= end_bucket; bucket++) {
number_of_keys = number_of_keys + aa1aaaaaaaaaaaaaaaabaaaaaaaaaaaa3aaaaaaaaaaaaaaaabaaaaaaaaaaaaaaaaaaaaaaaaaaaa3aaaaaaaaaaaaaaabaaaaaaaaaaaaaaaa4aaaber_of_keys(phm->bm, bucket);
if ((bucket % 16) == 0) {
               printf("\n%d-%d\t", bucket, bucket + 15);
}
if (aa1aaaaaaaaaaaaaaabaaaaaaaaaaaa3aaaaaaaaaaaaaaaabaaaaaaaaaaaaaaaaaaaaaaaaaaaa3aaaaaaaaaaaaaaaabaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaa3aaa(phm->bm, bucket)) {
               printf("I,\t");
} else if (aa1aaaaaaaaaaaaaaabaaaaaaaaaaaa3aaaaaaaaaaaaaaaabaaaaaaaaaaaaaaaaaaaaaaaaaaaa3aaaaaaaaaaaaaaaabaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaa3aaaaaaaaaaaaaaaabaaaaaaaaaaaaaaaaaaaaaaaaaaaa4aaapointer(phm->bm, bucket)) {
               printf("P%d, ", aa1aaaaaaaaaaaaaaaabaaaaaaaaaaaa3aaaaaaaaaaaaaaaabaaaaaaaaaaaaaaaaaaaaaaaaaaaa3aaaaaaaaaaaaaaabaaaaaaaaaaaaaaaa4aaaber_of_keys(phm->bm, bucket));
} else if (aa1aaaaaaaaaaaaaaabaaaaaaaaaaaa3aaaaaaaaaaaaaaaabaaaaaaaaaaaaaaaaaaaaaaaaaaaa3aaaaaaaaaaaaaaaabaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaa3aaaaaaaaaaaaaaaabaaaaaaaaaaaaaaaaaaaaaaaaaaaa4aaapointer(phm->bm, bucket)) {
               printf("F%d, ", aa1aaaaaaaaaaaaaaaabaaaaaaaaaaaa3aaaaaaaaaaaaaaaabaaaaaaaaaaaaaaaaaaaaaaaaaaaa3aaaaaaaaaaaaaaabaaaaaaaaaaaaaaaa4aaaber_of_keys(phm->bm, bucket));
} else {
assert(false);
}
}
printf(
               "\nNumber of keys in bucket memory = %d, number of keys using bloom filter = %d, ratio = %d",
number_of_keys, reverse_counter, (reverse_counter * 100) / number_of_keys);
number_of_keys = 0;
       printf("\nAddr, no keys, (source bucket, function number, key, prio, ternary mask....");
for (uint32_t aaaaaaaaaa1aaa = 0; aaaaaaaaaa1aaa <= end_aaaaaaaaaa1aaa; aaaaaaaaaa1aaa++) {
           printf("\n%03d, ", aaaaaaaaaa1aaa);
if (aaaa1aaaaaaaaaaaaaaabaaaaaaaaaaaa3aaaaaaaaaaaaaaaabaaaaaaaaaaaaaaaaaaaaaaaaaaaa3aaaaaaaaaaaaaaaabaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaa3aaa(phm->km, aaaaaaaaaa1aaa)) {
               printf("0");
} else {
               printf("1");
number_of_keys++;
if (aaaa1aaaaaaaaaaaaaaabaaaaaaaaaaaa3aaaaaaaaaaaaaaaabaaaaaaaaaaaaaaaaaaaaaaaaaaaa3aaaaaaaaaaaaaaaabaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaa3aaaaaaaaaaaaaaaabaaaaaaaaaaaaaaaaaaaaaaaaaaaa4aaapointer(phm->km, aaaaaaaaaa1aaa)) {
                   printf(", P");
                   printf("%04d,     ", aaaa1aaaaaaaaaaaaaaaabaaaaaaaaaaaa3aaaaaaaaaaaaaaaabaaaaaaaaaaaaaaaaaaaaaaaaaaaa3aaaaaaaaaabaaaaaaaaaaa4aaa(phm->km, aaaaaaaaaa1aaa));
const bool success = aaaa1aaaread_element(phm->km, aaaaaaaaaa1aaa, pointer_list, false, 0, 0);
assert(success);
const aaaaaaaaaaaaa1aaat *aaaaaaaaa1aaa = aaaaaaaaaaaaaaa1aaaaaaaaaaaaaaaabaaaaaaaaaaaa3aaaaaaaaaaaaaaaabaaaaaaaaaaaaaaaaaaaaaaaaaaaa3aaaaaaaaaaaa1aaa(pointer_list, 0);
const aaaaaaaaaaaaaaaa1aaaaaaaaaaaaaaaabaaaaaaaaaaaaaaaaaaaaaaaaaaaa3aaat *prio_ptr = aaaaaaaaaaaaaaa1aaaaaaaaaaaaaaaabaaaaaaaaaaaa3aaaaaaaaaaaaaaaabaaaaaaaaaaaaaaaaaaaaaaaaaaaa3aaaaaaaaaaaaaaabaaaaaaaaaaaaaaaaa4aaa(pointer_list, 0);
for (int8_t j = 9; j >= 0; j--) {
                       printf("%08x", aaaaaaaaa1aaa->word[j]);
}
                   printf(", %08x", prio_ptr->word[0]);
if (a1aaaaaaaaaaaaaaabaaaaaaaaaaaa3aaaaaaaaaaaaaaaabaaaaaaaaaaaaaaaaaaaaaaaaaaaa3aaaaaaaaaaaaaaaabaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaa3aaa(phm->client)) {
                       printf(",  ");
const aaaaaaaaaaaaa1aaat *ternary_mask = aaaaaaaaaaaaaaa1aaaaaaaaaaaaaaaabaaaaaaaaaaaa3aaaaaaaaaaaaaaaabaaaaaaaaaaaaaaaaaaaaaaaaaaaa3aaaternary_mask(pointer_list, 0);
for (int8_t j = 9; j >= 0; j--) {
                           printf("%08x", ternary_mask->word[j]);
}
}
} else {
                   printf(", F");
const uint32_t bucket = aaaa1aaaaaaaaaaaaaaaabaaaaaaaaaaaa3aaaaaaaaaaaaaaaabaaaaaaaaaaaaaaaaaaaaaaaaaaaa3aaaaaaaaaabaaaaaaaaaaa4aaa(phm->km, aaaaaaaaaa1aaa);
                   printf("%04d, ", bucket);
const uint8_t function = aa1aaaaaaaaaaaaaaaabaaaaaaaaaaaa3aaaaaaaaaaaaaaaabaaaaaaaaaaaaaaaaaaaaaaaaaaaa3aaaaaaaaaaaaaaaabaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaa3aaaaaaaaaaaaaaaabaaaaaaaaaaaaaaaaaaaaaaaaaaaa4aaapointer(phm->bm, bucket);
                   printf("%02d, ", function);
const bool success = aaaa1aaaread_element(phm->km, aaaaaaaaaa1aaa, pointer_list, false, 0, 0);
assert(success);
const aaaaaaaaaaaaa1aaat *aaaaaaaaa1aaa = aaaaaaaaaaaaaaa1aaaaaaaaaaaaaaaabaaaaaaaaaaaa3aaaaaaaaaaaaaaaabaaaaaaaaaaaaaaaaaaaaaaaaaaaa3aaaaaaaaaaaa1aaa(pointer_list, 0);
const aaaaaaaaaaaaaaaa1aaaaaaaaaaaaaaaabaaaaaaaaaaaaaaaaaaaaaaaaaaaa3aaat *prio_ptr = aaaaaaaaaaaaaaa1aaaaaaaaaaaaaaaabaaaaaaaaaaaa3aaaaaaaaaaaaaaaabaaaaaaaaaaaaaaaaaaaaaaaaaaaa3aaaaaaaaaaaaaaabaaaaaaaaaaaaaaaaa4aaa(pointer_list, 0);
for (int8_t j = 9; j >= 0; j--) {
                       printf("%08x", aaaaaaaaa1aaa->word[j]);
}
                   printf(", %08x", prio_ptr->word[0]);
if (a1aaaaaaaaaaaaaaabaaaaaaaaaaaa3aaaaaaaaaaaaaaaabaaaaaaaaaaaaaaaaaaaaaaaaaaaa3aaaaaaaaaaaaaaaabaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaa3aaa(phm->client)) {
                       printf(",  ");
const aaaaaaaaaaaaa1aaat *ternary_mask = aaaaaaaaaaaaaaa1aaaaaaaaaaaaaaaabaaaaaaaaaaaa3aaaaaaaaaaaaaaaabaaaaaaaaaaaaaaaaaaaaaaaaaaaa3aaaternary_mask(pointer_list, 0);
for (int8_t j = 9; j >= 0; j--) {
                           printf("%08x", ternary_mask->word[j]);
}
}
}
}
}
       printf("\nNumber of keys in key memory = %d", number_of_keys);
} else {
       printf("\nUnit not used");
}
   printf("\nEnd PHM\n");
}
void aaa1bbbbbbbbbbbbbbbbbbbbbbbbbbbbbbbbbbbbbb3aaaaaaaaaaaaaaaabaaaaaaaaaaaaaaaaaaaaaaaaaaaa4aaaaaaaaaaaaaaaabaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaa4aaa(const aaa1aaat *phm)
{
   printf("\nStart PHM, Unit = %d", aaa1aaaaaaaaaaaaaaaabaaaaaaaaaaaa3aaaaaaaaaaaaaaaabaaaaaaaaaaaaaaaaaaaaaaaaaaaa3aaaaaaaaaaaabaaaaaaaaaaaaaaaaa4aaa(phm));
aaaaaaaaaaaaaaa1aaat *pointer_list = (aaaaaaaaaaaaaaa1aaat *) alloca(aaaaaaaaaaaaaaa1aaaaaaaaaaaaaabaaaaaaaaaa3aaa());
const uint32_t num_lists = a1aaaaaaaaaaaaaaaabaaaaaaaaaaaa3aaaaaaaaaaaaaaaabaaaaaaaaaaaaaaaaaaaaaaaaaaaa3aaaaaaaaaaaaaaabaaaaaaaaaaaaaaaa4aaaaaaaaaaaaaaaabaaaaaaaaaaaaaaaaaaaaaaaaaaaa4aaaaaaaaaaaaabaaaaaaaaaaaaaaaaa5aaas(phm->client);
const uint32_t end_aaaaaaaaaa1aaa = num_lists - 1;
   printf("\nList, W N1N0, key1,     response1; (key0,     response0;)");
uint32_t num_keys = 0;
for (uint32_t aaaaaaaaaa1aaa = 0; aaaaaaaaaa1aaa <= end_aaaaaaaaaa1aaa; aaaaaaaaaa1aaa++) {
       printf("\n%03d , ", aaaaaaaaaa1aaa);
bool wide_valid, narrow1_valid, narrow0_valid;
aaaa1aaaaaaaaaaaaaaaabaaaaaaaaaaaa3aaaaaaaaaaaaaaaabaaaaaaaaaaaaaaaaaaaaaaaaaaaa3aaaaaaaaaaaaaaaabaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaa3aaaaaaaaaaaaaaaabaaaaaaaaaaaaaaaaaaaaaaaaaaaa4aaabits(phm->km, aaaaaaaaaa1aaa, &wide_valid, &narrow1_valid, &narrow0_valid);
       printf("%d %d %d , ", wide_valid, narrow1_valid, narrow0_valid);
uint8_t start_element = 1;
uint8_t narrow = 1;
if (wide_valid) {
start_element = 0;
narrow = 0;
}
for (int8_t narrow_element = start_element; narrow_element >= 0; narrow_element--) {
const bool success = aaaa1aaaread_element(phm->km, aaaaaaaaaa1aaa, pointer_list, false, narrow, narrow_element);
if (success) {
num_keys++;
const aaaaaaaaaaaaa1aaat *aaaaaaaaa1aaa = aaaaaaaaaaaaaaa1aaaaaaaaaaaaaaaabaaaaaaaaaaaa3aaaaaaaaaaaaaaaabaaaaaaaaaaaaaaaaaaaaaaaaaaaa3aaaaaaaaaaaa1aaa(pointer_list, 0);
const aaaaaaaaaaaaaaaa1aaaaaaaaaaaaaaaabaaaaaaaaaaaaaaaaaaaaaaaaaaaa3aaat *prio_ptr = aaaaaaaaaaaaaaa1aaaaaaaaaaaaaaaabaaaaaaaaaaaa3aaaaaaaaaaaaaaaabaaaaaaaaaaaaaaaaaaaaaaaaaaaa3aaaaaaaaaaaaaaabaaaaaaaaaaaaaaaaa4aaa(pointer_list, 0);
for (int8_t j = 0; j >= 0; j--) {
                   printf("%08x", aaaaaaaaa1aaa->word[j]);
}
               printf(", %08x;   ", prio_ptr->word[0]);
} else {
               printf("NA                ;   ");
}
}
}
   printf("\nNumber of keys = %d", num_keys);
   printf("\nEnd PHM\n");
}
uint32_t aaa1aaaaaaaaaaaaaaaabaaaaaaaaaaaa3aaaaaaaaaaaaaaaabaaaaaaaaaaaaaaaaaaaaaaaaaaaa3aaaaaaaaaaaaaaabaaaaaaaaaaaaaaaa4aaaber_of_keys(const aaa1aaat *phm)
{
return phm->number_of_keys;
}
uint8_t aaa1aaaaaaaaaaaaaaaabaaaaaaaaaaaa3aaaaaaaaaaaaaaaabaaaaaaaaaaaaaaaaaaaaaaaaaaaa3bbbbbbbbbbbbbbbbbbbbbbbbbbbbbbbbbbbb3aaaaaaaaaaaaaaaabaaaaaaaaaaaaaaaaaaaaaaaaaaaa4aaaaaaaaaaaaaaabaaaaaaaaaaaaaaaa5aaaber(const aaa1aaat *phm)
{
return aaaaaaaaaaaa1aaaaaaaaaaaaaaaabaaaaaaaaaaaa3aaaaaaaaaaaaaaaabaaaaaaaaaaaaaaaaaaaaaaaaaaaa3bbbbbbbbbbbbbbbbbbbbbbbbbbbbbbbbbbbb3aaaaaaaaaaaaaaaabaaaaaaaaaaaaaaaaaaaaaaaaaaaa4aaaaaaaaaaaaaaabaaaaaaaaaaaaaaaa5aaaber(phm->mm);
}
uint16_t aaa1aaaaaaaaaaaaaaaabaaaaaaaaaaaa3aaaaaaaaaaaaaaaabaaaaaaaaaaaaaaaaaaaaaaaaaaaa3aaaaaaaaaaaabaaaaaaaaaaaaaaaaa4aaa(const aaa1aaat *phm)
{
return aaaaaaaaaaaa1aaaaaaaaaaaaaaaabaaaaaaaaaaaa3aaaaaaaaaaaaaaaabaaaaaaaaaaaaaaaaaaaaaaaaaaaa3aaaaaaaaaaaabaaaaaaaaaaaaaaaaa4aaa(phm->mm);
}
bool aaa1aaaaaaaaaaaaaaabaaaaaaaaaaaa3aaaaaaaaaaaaaaaabaaaaaaaaaaaaaaaaaaaaaaaaaaaa3aaaaaaaaaaaaaaaabaaaaaaaaaaaaaaaaaaaaaaa4aaaaaaaaaaaaaaaabaaaaaaaaaaaaaaaaaaaaaaaaaaaa4aaaequal(const aaa1aaat *phm, const aaaaaaaaaaaaa1aaat *mask, uint8_t range_valid,
uint8_t mask_id)
{
return aaaaaaaaaaaa1aaaaaaaaaaaaaaabaaaaaaaaaaaa3aaaaaaaaaaaaaaaabaaaaaaaaaaaaaaaaaaaaaaaaaaaa3aaaaaaaaaaaaaaaabaaaaaaaaaaaaaaaaaaaaaaa4aaaaaaaaaaaaaaaabaaaaaaaaaaaaaaaaaaaaaaaaaaaa4aaaequal(phm->mm, mask, range_valid, mask_id);
}
bool aaa1bbbbbbbbbbbbbbbbbbbbbbbbbbbb3aaa(aaa1aaat *phm, const aaaaaaaaaaaaa1aaat *key, const aaaaaaaaaaaaa1aaat *ternary_mask, aaa1bbbbbbbbbbbbbbbbbbbbbbbbbbbb3aaaaaaaaaaaaaaaabaaaaaaaaaaaaaaaaaaaaaaaaaaaa4aaat execute,
bool *unresolvable_collision_found,
bool match_prio,
aaaaaaaaaaaaaaaa1aaaaaaaaaaaaaaaabaaaaaaaaaaaaaaaaaaaaaaaaaaaa3aaat *comp_prio)
{
assert(a1aaaaaaaaaaaaaaabaaaaaaaaaaaa3aaaaaaaaaaaaaaaabaaaaaaaaaaaaaaaaaaaaaaaaaaaa3aaaaaaaaaaaaaaaabaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaa3aaa(phm->client));
uint32_t bucket;
aaaaaaaaaaaaa1aaat masked_key;
memset(&masked_key, 0, sizeof(masked_key));
aaaaaaaaaaaa1aaaaaaaaaaaaaaaabaaaaaaaaaaaaaaaaaaaaaaa3aaaaaaaaaaaaaaaabaaaaaaaaaaaaaaaaaaaaaaaaaaaa3aaaaaaaaaaaaaaaabaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaa3aaa(phm->mm, key, &masked_key);
hash_t *hash = (hash_t *) alloca(hash_size());
aaaaaaa1aaa(hash, &masked_key, phm);
uint32_t aaaaaaaaaa1aaaaaaaaaaaaaaaabaaaaaaaaaaaaaaaaaaaaaaaaaaaa3aaaaaaaaaaaaaaabaaaaaaaaaaaaaaaa4aaaber = 0;
const uint32_t bucket_hash = hash_calculate_bucket(hash);
bucket = adjust_bucket(phm, bucket_hash);
if (aa1aaaaaaaaaaaaaaabaaaaaaaaaaaa3aaaaaaaaaaaaaaaabaaaaaaaaaaaaaaaaaaaaaaaaaaaa3aaaaaaaaaaaaaaaabaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaa3aaa(phm->bm, bucket)) {
*unresolvable_collision_found = false;
return false;
} else if (aa1aaaaaaaaaaaaaaabaaaaaaaaaaaa3aaaaaaaaaaaaaaaabaaaaaaaaaaaaaaaaaaaaaaaaaaaa3aaaaaaaaaaaaaaaabaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaa3aaaaaaaaaaaaaaaabaaaaaaaaaaaaaaaaaaaaaaaaaaaa4aaapointer(phm->bm, bucket)) {
aaaaaaaaaa1aaaaaaaaaaaaaaaabaaaaaaaaaaaaaaaaaaaaaaaaaaaa3aaaaaaaaaaaaaaabaaaaaaaaaaaaaaaa4aaaber = aa1aaaaaaaaaaaaaaaabaaaaaaaaaaaa3aaaaaaaaaaaaaaaabaaaaaaaaaaaaaaaaaaaaaaaaaaaa3aaaaaaaaaaaaaaaabaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaa3aaaaaaaaaaaaaaaabaaaaaaaaaaaaaaaaaaaaaaaaaaaa4aaapointer(phm->bm, bucket);
} else if (aa1aaaaaaaaaaaaaaabaaaaaaaaaaaa3aaaaaaaaaaaaaaaabaaaaaaaaaaaaaaaaaaaaaaaaaaaa3aaaaaaaaaaaaaaaabaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaa3aaaaaaaaaaaaaaaabaaaaaaaaaaaaaaaaaaaaaaaaaaaa4aaapointer(phm->bm, bucket)) {
const uint8_t function = aa1aaaaaaaaaaaaaaaabaaaaaaaaaaaa3aaaaaaaaaaaaaaaabaaaaaaaaaaaaaaaaaaaaaaaaaaaa3aaaaaaaaaaaaaaaabaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaa3aaaaaaaaaaaaaaaabaaaaaaaaaaaaaaaaaaaaaaaaaaaa4aaapointer(phm->bm, bucket);
aaaaaaaaaa1aaaaaaaaaaaaaaaabaaaaaaaaaaaaaaaaaaaaaaaaaaaa3aaaaaaaaaaaaaaabaaaaaaaaaaaaaaaa4aaaber = hash_calculate_list(hash, function);
aaaaaaaaaa1aaaaaaaaaaaaaaaabaaaaaaaaaaaaaaaaaaaaaaaaaaaa3aaaaaaaaaaaaaaabaaaaaaaaaaaaaaaa4aaaber = adjust_list(phm, aaaaaaaaaa1aaaaaaaaaaaaaaaabaaaaaaaaaaaaaaaaaaaaaaaaaaaa3aaaaaaaaaaaaaaabaaaaaaaaaaaaaaaa4aaaber);
} else {
assert(false);
}
aaaaaaaaaaaaaaa1aaat *read_pointer_list = (aaaaaaaaaaaaaaa1aaat *) alloca(aaaaaaaaaaaaaaa1aaaaaaaaaaaaaabaaaaaaaaaa3aaa());
bool unresolvable_collision = false;
const bool verify = ((a1aaaaaaaaaaaaaaaabaaaaaaaaaaaa3aaaaaaaaaaaaaaaabaaaaaaaaaaaaaaaaaaaaaaaaaaaa3bbbbbbbbbbbbbbbbbbbbbbbbbbbbbbbbbbbbb3aaaaaaaaaaaaaaaabaaaaaaaaaaaaaaaaaaaaaaaaaaaa4aaaflags(phm->client) & CAM_DEBUG_VERIFY_SHADOW) != 0) && (execute == aaa1aaaREAD);
if (aaaa1aaaread_element(phm->km, aaaaaaaaaa1aaaaaaaaaaaaaaaabaaaaaaaaaaaaaaaaaaaaaaaaaaaa3aaaaaaaaaaaaaaabaaaaaaaaaaaaaaaa4aaaber, read_pointer_list, verify, 0, 0)) {
if (bucket != aaaaaaaaaaaaaaa1aaaaaaaaaaaaaaaabaaaaaaaaaaaa3aaaaaaaaaaaaaaaabaaaaaaaaaaaaaaaaaaaaaaaaaaaa3aaaaaaaaaabaaaaaaaaaaa4aaa(read_pointer_list)) {
*unresolvable_collision_found = false;
return false;
}
const aaaaaaaaaaaaa1aaat *stored_key = aaaaaaaaaaaaaaa1aaaaaaaaaaaaaaaabaaaaaaaaaaaa3aaaaaaaaaaaaaaaabaaaaaaaaaaaaaaaaaaaaaaaaaaaa3aaaaaaaaaaaa1aaa(read_pointer_list, 0);
const aaaaaaaaaaaaa1aaat *stored_ternary_mask = aaaaaaaaaaaaaaa1aaaaaaaaaaaaaaaabaaaaaaaaaaaa3aaaaaaaaaaaaaaaabaaaaaaaaaaaaaaaaaaaaaaaaaaaa3aaaternary_mask(read_pointer_list, 0);
const aaaaaaaaaaaaaaaa1aaaaaaaaaaaaaaaabaaaaaaaaaaaaaaaaaaaaaaaaaaaa3aaat *prio_ptr = aaaaaaaaaaaaaaa1aaaaaaaaaaaaaaaabaaaaaaaaaaaa3aaaaaaaaaaaaaaaabaaaaaaaaaaaaaaaaaaaaaaaaaaaa3aaaaaaaaaaaaaaabaaaaaaaaaaaaaaaaa4aaa(read_pointer_list, 0);
aaaaaaaaaaaaa1aaat masked_stored_key;
memset(&masked_stored_key, 0, sizeof(masked_stored_key));
aaaaaaaaaaaa1aaaaaaaaaaaaaaaabaaaaaaaaaaaaaaaaaaaaaaa3aaaaaaaaaaaaaaaabaaaaaaaaaaaaaaaaaaaaaaaaaaaa3aaaaaaaaaaaaaaaabaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaa3aaa(phm->mm, stored_key, &masked_stored_key);
unresolvable_collision = true;
for (uint8_t j = 0; j < CAM_MAX_KEY_WIDTH_MEM; j++) {
if (masked_stored_key.word[j] != masked_key.word[j]) {
unresolvable_collision = false;
break;
}
}
bool exact_match = unresolvable_collision;
assert(ternary_mask != NULL);
const uint16_t ternary_field_size_word32 = a1aaaaaaaaaaaaaaaabaaaaaaaaaaaa3aaaaaaaaaaaaaaaabaaaaaaaaaaaaaaaaaaaaaaaaaaaa3aaaaaaaaaaaaaaaabaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaa3aaaaaaaaaaaaaaaabaaaaaaaaaaaaaaaaaaaaaaaaaaaa4aaawidth(phm->client) / 32;
for (uint8_t k = 0; k < ternary_field_size_word32; k++) {
if (!((stored_key->word[k] == key->word[k]) && (stored_ternary_mask->word[k] == ternary_mask->word[k]))) {
exact_match = false;
break;
}
}
if (match_prio) {
const int prio_memcmp_rc = memcmp(prio_ptr, comp_prio, sizeof(aaaaaaaaaaaaaaaa1aaaaaaaaaaaaaaaabaaaaaaaaaaaaaaaaaaaaaaaaaaaa3aaat));
if (prio_memcmp_rc != 0)
exact_match = false;
}
if (exact_match) {
if (execute == aaa1aaaaaaaaaaaaaaaabaaaaaaaaaaaaaaaaaaa3aaa) {
aa1aaaaaaaaaaaaaaaabaaaaaaaaaaaaaaaaaaa3aaaaaaaaaaaaaaaabaaaaaaaaaaaaaaaaaaaaaaaaaaaa3aaaaaaaaaaaaaaaabaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaa3aaa(phm->bm, bucket);
aaaa1aaaaaaaaaaaaaaaabaaaaaaaaaaaaaaaaaaa3aaaaaaaaaaaaaaaabaaaaaaaaaaaaaaaaaaaaaaaaaaaa3aaaelement(phm->km, aaaaaaaaaa1aaaaaaaaaaaaaaaabaaaaaaaaaaaaaaaaaaaaaaaaaaaa3aaaaaaaaaaaaaaabaaaaaaaaaaaaaaaa4aaaber, 0, 0);
assert(phm->number_of_keys > 0);
phm->number_of_keys--;
return true;
} else if (execute == aaa1aaaREAD) {
if (match_prio == false) {
*comp_prio = *prio_ptr;
}
return true;
} else if (execute == aaa1bbbbbbbbbbbbbbbbbbbb3aaa) {
aaaa1bbbbbbbbbbbbbbbbbbbb3aaaaaaaaaaaaaaaabaaaaaaaaaaaaaaaaaaaaaaaaaaaa4aaaaaaaaaaaaaaaaa1aaaaaaaaaaaaaaaabaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaa3aaa(phm->km, aaaaaaaaaa1aaaaaaaaaaaaaaaabaaaaaaaaaaaaaaaaaaaaaaaaaaaa3aaaaaaaaaaaaaaabaaaaaaaaaaaaaaaa4aaaber, comp_prio, 0, 0);
return true;
}
assert(false);
}
}
if (unresolvable_collision) {
*unresolvable_collision_found = true;
}
else {
*unresolvable_collision_found = false;
}
return false;
}
bool aaa1bbbbbbbbbbbbbbbbbbbbbbbbbbbbbbbbbbbbbb3aaaaaaaaaaaaaaaabaaaaaaaaaaaaaaaaaaaaaaaaaaaa4bbbbbbbbbbbbbbbbbbbbbbbbbbbb4aaa(aaa1aaat *phm, const aaaaaaaaaaaaa1aaat *key, aaa1bbbbbbbbbbbbbbbbbbbbbbbbbbbb3aaaaaaaaaaaaaaaabaaaaaaaaaaaaaaaaaaaaaaaaaaaa4aaat execute,
bool match_prio, aaaaaaaaaaaaaaaa1aaaaaaaaaaaaaaaabaaaaaaaaaaaaaaaaaaaaaaaaaaaa3aaat *comp_prio, uint32_t murmur_bucket, bool narrow_key)
{
uint32_t aaaaaaaaaa1aaaaaaaaaaaaaaaabaaaaaaaaaaaaaaaaaaaaaaaaaaaa3aaaaaaaaaaaaaaabaaaaaaaaaaaaaaaa4aaaber;
const aaaaaaaaaaaaa1aaat *masked_key;
aaaaaaaaaaaaa1aaat m_key;
const bool verify = ((a1aaaaaaaaaaaaaaaabaaaaaaaaaaaa3aaaaaaaaaaaaaaaabaaaaaaaaaaaaaaaaaaaaaaaaaaaa3bbbbbbbbbbbbbbbbbbbbbbbbbbbbbbbbbbbbb3aaaaaaaaaaaaaaaabaaaaaaaaaaaaaaaaaaaaaaaaaaaa4aaaflags(phm->client) & CAM_DEBUG_VERIFY_SHADOW) != 0) && (execute == aaa1aaaREAD);
const bool is_hbmbcam = a1aaaaaaaaaaaaaaabaaaaaaaaaaaa3aaaaaaaaaaaaaaaabaaaaaaaaaaaaaaaaaaaaaaaaaaaa3aaahbmbcam(phm->client);
const bool is_bcam = a1aaaaaaaaaaaaaaabaaaaaaaaaaaa3aaaaaaaaaaaaaaaabaaaaaaaaaaaaaaaaaaaaaaaaaaaa3aaabcam(phm->client);
if (!(is_hbmbcam || is_bcam)) {
memset(&m_key, 0, sizeof(m_key));
aaaaaaaaaaaa1aaaaaaaaaaaaaaaabaaaaaaaaaaaaaaaaaaaaaaa3aaaaaaaaaaaaaaaabaaaaaaaaaaaaaaaaaaaaaaaaaaaa3aaaaaaaaaaaaaaaabaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaa3aaa(phm->mm, key, &m_key);
masked_key = &m_key;
} else {
masked_key = key;
}
if (is_hbmbcam) {
const uint32_t swapped_murmur_bucket = swap_murmur_bucket(phm, murmur_bucket);
aaaaaaaaaa1aaaaaaaaaaaaaaaabaaaaaaaaaaaaaaaaaaaaaaaaaaaa3aaaaaaaaaaaaaaabaaaaaaaaaaaaaaaa4aaaber = adjust_list(phm, swapped_murmur_bucket);
} else {
hash_t *hash = (hash_t *) alloca(hash_size());
aaaaaaa1aaa(hash, masked_key, phm);
const uint32_t bucket_hash = hash_calculate_bucket(hash);
aaaaaaaaaa1aaaaaaaaaaaaaaaabaaaaaaaaaaaaaaaaaaaaaaaaaaaa3aaaaaaaaaaaaaaabaaaaaaaaaaaaaaaa4aaaber = adjust_list(phm, bucket_hash);
}
aaaaaaaaaaaaaaa1aaat *read_pointer_list = (aaaaaaaaaaaaaaa1aaat *) alloca(aaaaaaaaaaaaaaa1aaaaaaaaaaaaaabaaaaaaaaaa3aaa());
uint8_t loop = 1;
if (is_hbmbcam)
loop = a1aaaaaaaaaaaaaaaabaaaaaaaaaaaa3aaaaaaaaaaaaaaaabaaaaaaaaaaaaaaaaaaaaaaaaaaaa3aaaaaaaaaaaaaaabaaaaaaaaaaaaaaaa4aaaaaaaaaaaaaaaabaaaaaaaaaaaaaaaaaaaaaaaaaaaa4aaaaaaaaaaaaabaaaaaaaaaaaaaaaaa5aaas_per_read(phm->client);
uint8_t max_elements = 1;
uint8_t narrow = 0;
const bool mixed_mode = a1aaaaaaaaaaaaaaabaaaaaaaaaaaa3aaaaaaaaaaaaaaaabaaaaaaaaaaaaaaaaaaaaaaaaaaaa3aaamixed_mode(phm->client);
assert(!narrow_key || (narrow_key && mixed_mode));
if (mixed_mode) {
if (narrow_key) {
max_elements = 2;
narrow = 1;
}
}
for (uint8_t i = 0; i < loop; i++)
{
for (uint8_t element = 0; element < max_elements; element++) {
if (aaaa1aaaread_element(phm->km, aaaaaaaaaa1aaaaaaaaaaaaaaaabaaaaaaaaaaaaaaaaaaaaaaaaaaaa3aaaaaaaaaaaaaaabaaaaaaaaaaaaaaaa4aaaber + i, read_pointer_list, verify, narrow, element)) {
const aaaaaaaaaaaaa1aaat *stored_key = aaaaaaaaaaaaaaa1aaaaaaaaaaaaaaaabaaaaaaaaaaaa3aaaaaaaaaaaaaaaabaaaaaaaaaaaaaaaaaaaaaaaaaaaa3aaaaaaaaaaaa1aaa(read_pointer_list, 0);
const aaaaaaaaaaaaaaaa1aaaaaaaaaaaaaaaabaaaaaaaaaaaaaaaaaaaaaaaaaaaa3aaat *prio_ptr = aaaaaaaaaaaaaaa1aaaaaaaaaaaaaaaabaaaaaaaaaaaa3aaaaaaaaaaaaaaaabaaaaaaaaaaaaaaaaaaaaaaaaaaaa3aaaaaaaaaaaaaaabaaaaaaaaaaaaaaaaa4aaa(read_pointer_list, 0);
const aaaaaaaaaaaaa1aaat *masked_stored_key;
if (is_bcam || is_hbmbcam) {
masked_stored_key = stored_key;
} else {
aaaaaaaaaaaaa1aaat m_stored_key;
memset(&m_stored_key, 0, sizeof(m_stored_key));
aaaaaaaaaaaa1aaaaaaaaaaaaaaaabaaaaaaaaaaaaaaaaaaaaaaa3aaaaaaaaaaaaaaaabaaaaaaaaaaaaaaaaaaaaaaaaaaaa3aaaaaaaaaaaaaaaabaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaa3aaa(phm->mm, stored_key, &m_stored_key);
masked_stored_key = &m_stored_key;
}
uint8_t j;
for (j = 0; j < CAM_MAX_KEY_WIDTH_MEM; j++) {
if (masked_stored_key->word[j] != masked_key->word[j]) {
break;
}
}
if (j != CAM_MAX_KEY_WIDTH_MEM)
continue;
assert(comp_prio != NULL);
if (match_prio) {
const int prio_memcmp_rc = memcmp(prio_ptr, comp_prio, sizeof(aaaaaaaaaaaaaaaa1aaaaaaaaaaaaaaaabaaaaaaaaaaaaaaaaaaaaaaaaaaaa3aaat));
if (prio_memcmp_rc != 0)
continue;
}
if (execute == aaa1aaaaaaaaaaaaaaaabaaaaaaaaaaaaaaaaaaa3aaa) {
aaaa1aaaaaaaaaaaaaaaabaaaaaaaaaaaaaaaaaaa3aaaaaaaaaaaaaaaabaaaaaaaaaaaaaaaaaaaaaaaaaaaa3aaaelement(phm->km, aaaaaaaaaa1aaaaaaaaaaaaaaaabaaaaaaaaaaaaaaaaaaaaaaaaaaaa3aaaaaaaaaaaaaaabaaaaaaaaaaaaaaaa4aaaber + i, narrow, element);
assert(phm->number_of_keys > 0);
phm->number_of_keys--;
return true;
} else if (execute == aaa1aaaREAD) {
if (match_prio == false) {
*comp_prio = *prio_ptr;
}
return true;
} else if (execute == aaa1bbbbbbbbbbbbbbbbbbbb3aaa) {
aaaa1bbbbbbbbbbbbbbbbbbbb3aaaaaaaaaaaaaaaabaaaaaaaaaaaaaaaaaaaaaaaaaaaa4aaaaaaaaaaaaaaaabaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaa4aaa(phm->km, aaaaaaaaaa1aaaaaaaaaaaaaaaabaaaaaaaaaaaaaaaaaaaaaaaaaaaa3aaaaaaaaaaaaaaabaaaaaaaaaaaaaaaa4aaaber + i, comp_prio, narrow, element);
return true;
}
assert(false);
}
}
}
return false;
}
bool aaa1bbbbbbbbbbbbbbbbbbbbbb3aaaokup(const aaa1aaat *phm, const aaaaaaaaaaaaa1aaat *key, aaaaaaaaaaaaaaaa1aaaaaaaaaaaaaaaabaaaaaaaaaaaaaaaaaaaaaaaaaaaa3aaat *out_prio_resp)
{
assert(a1aaaaaaaaaaaaaaabaaaaaaaaaaaa3aaaaaaaaaaaaaaaabaaaaaaaaaaaaaaaaaaaaaaaaaaaa3aaaaaaaaaaaaaaaabaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaa3aaa(phm->client));
uint32_t bucket;
uint8_t range_valid;
aaaaaaaaaaaa1aaaaaaaaaaaaaaaabaaaaaaaaaaaa3aaaaaaaaaaaaaaaabaaaaaaaaaaaaaaaaaaaaaaaaaaaa3aaaaaaaaaaaaaaaabaaaaaaaaaaaaaaaaaaaa4aaa(phm->mm, &range_valid);
aaaaaaaaaaaaa1aaat masked_key;
memset(&masked_key, 0, sizeof(masked_key));
aaaaaaaaaaaa1aaaaaaaaaaaaaaaabaaaaaaaaaaaaaaaaaaaaaaa3aaaaaaaaaaaaaaaabaaaaaaaaaaaaaaaaaaaaaaaaaaaa3aaaaaaaaaaaaaaaabaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaa3aaa(phm->mm, key, &masked_key);
hash_t *hash = (hash_t *) alloca(hash_size());
aaaaaaa1aaa(hash, &masked_key, phm);
uint32_t aaaaaaaaaa1aaaaaaaaaaaaaaaabaaaaaaaaaaaaaaaaaaaaaaaaaaaa3aaaaaaaaaaaaaaabaaaaaaaaaaaaaaaa4aaaber = 0;
const uint32_t bucket_hash = hash_calculate_bucket(hash);
bucket = adjust_bucket(phm, bucket_hash);
if (aa1aaaaaaaaaaaaaaabaaaaaaaaaaaa3aaaaaaaaaaaaaaaabaaaaaaaaaaaaaaaaaaaaaaaaaaaa3aaaaaaaaaaaaaaaabaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaa3aaa(phm->bm, bucket)) {
return false;
} else if (aa1aaaaaaaaaaaaaaabaaaaaaaaaaaa3aaaaaaaaaaaaaaaabaaaaaaaaaaaaaaaaaaaaaaaaaaaa3aaaaaaaaaaaaaaaabaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaa3aaaaaaaaaaaaaaaabaaaaaaaaaaaaaaaaaaaaaaaaaaaa4aaapointer(phm->bm, bucket)) {
aaaaaaaaaa1aaaaaaaaaaaaaaaabaaaaaaaaaaaaaaaaaaaaaaaaaaaa3aaaaaaaaaaaaaaabaaaaaaaaaaaaaaaa4aaaber = aa1aaaaaaaaaaaaaaaabaaaaaaaaaaaa3aaaaaaaaaaaaaaaabaaaaaaaaaaaaaaaaaaaaaaaaaaaa3aaaaaaaaaaaaaaaabaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaa3aaaaaaaaaaaaaaaabaaaaaaaaaaaaaaaaaaaaaaaaaaaa4aaapointer(phm->bm, bucket);
} else if (aa1aaaaaaaaaaaaaaabaaaaaaaaaaaa3aaaaaaaaaaaaaaaabaaaaaaaaaaaaaaaaaaaaaaaaaaaa3aaaaaaaaaaaaaaaabaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaa3aaaaaaaaaaaaaaaabaaaaaaaaaaaaaaaaaaaaaaaaaaaa4aaapointer(phm->bm, bucket)) {
const uint8_t function = aa1aaaaaaaaaaaaaaaabaaaaaaaaaaaa3aaaaaaaaaaaaaaaabaaaaaaaaaaaaaaaaaaaaaaaaaaaa3aaaaaaaaaaaaaaaabaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaa3aaaaaaaaaaaaaaaabaaaaaaaaaaaaaaaaaaaaaaaaaaaa4aaapointer(phm->bm, bucket);
aaaaaaaaaa1aaaaaaaaaaaaaaaabaaaaaaaaaaaaaaaaaaaaaaaaaaaa3aaaaaaaaaaaaaaabaaaaaaaaaaaaaaaa4aaaber = hash_calculate_list(hash, function);
aaaaaaaaaa1aaaaaaaaaaaaaaaabaaaaaaaaaaaaaaaaaaaaaaaaaaaa3aaaaaaaaaaaaaaabaaaaaaaaaaaaaaaa4aaaber = adjust_list(phm, aaaaaaaaaa1aaaaaaaaaaaaaaaabaaaaaaaaaaaaaaaaaaaaaaaaaaaa3aaaaaaaaaaaaaaabaaaaaaaaaaaaaaaa4aaaber);
} else {
assert(false);
}
aaaaaaaaaaaaaaa1aaat *read_pointer_list = (aaaaaaaaaaaaaaa1aaat *) alloca(aaaaaaaaaaaaaaa1aaaaaaaaaaaaaabaaaaaaaaaa3aaa());
if (aaaa1aaaread_element(phm->km, aaaaaaaaaa1aaaaaaaaaaaaaaaabaaaaaaaaaaaaaaaaaaaaaaaaaaaa3aaaaaaaaaaaaaaabaaaaaaaaaaaaaaaa4aaaber, read_pointer_list, false, 0, 0)) {
const aaaaaaaaaaaaa1aaat *aaaaaaaaa1aaa = aaaaaaaaaaaaaaa1aaaaaaaaaaaaaaaabaaaaaaaaaaaa3aaaaaaaaaaaaaaaabaaaaaaaaaaaaaaaaaaaaaaaaaaaa3aaaaaaaaaaaa1aaa(read_pointer_list, 0);
const aaaaaaaaaaaaaaaa1aaaaaaaaaaaaaaaabaaaaaaaaaaaaaaaaaaaaaaaaaaaa3aaat *prio_ptr = aaaaaaaaaaaaaaa1aaaaaaaaaaaaaaaabaaaaaaaaaaaa3aaaaaaaaaaaaaaaabaaaaaaaaaaaaaaaaaaaaaaaaaaaa3aaaaaaaaaaaaaaabaaaaaaaaaaaaaaaaa4aaa(read_pointer_list, 0);
const aaaaaaaaaaaaa1aaat *ternary_mask = aaaaaaaaaaaaaaa1aaaaaaaaaaaaaaaabaaaaaaaaaaaa3aaaaaaaaaaaaaaaabaaaaaaaaaaaaaaaaaaaaaaaaaaaa3aaaternary_mask(read_pointer_list, 0);
bool match = match_ternary_mask(phm->client, key, ternary_mask, aaaaaaaaa1aaa, range_valid);
if (match == true) {
*out_prio_resp = *prio_ptr;
return true;
}
} 
return false;
}
bool aaa1bbbbbbbbbbbbbbbbbbbbbbbbbbbbbbbbbbbbbb3aaaaaaaaaaaaaaaabaaaaaaaaaaaaaaaaaaaaaaaaaaaa4bbbbbbbbbbbbbbbbbbbbbb4aaaokup(const aaa1aaat *phm, const aaaaaaaaaaaaa1aaat *key, aaaaaaaaaaaaaaaa1aaaaaaaaaaaaaaaabaaaaaaaaaaaaaaaaaaaaaaaaaaaa3aaat *out_prio_resp, bool narrow_key)
{
uint32_t aaaaaaaaaa1aaaaaaaaaaaaaaaabaaaaaaaaaaaaaaaaaaaaaaaaaaaa3aaaaaaaaaaaaaaabaaaaaaaaaaaaaaaa4aaaber;
const aaaaaaaaaaaaa1aaat *masked_key;
aaaaaaaaaaaaa1aaat m_key;
const bool is_hbmbcam = a1aaaaaaaaaaaaaaabaaaaaaaaaaaa3aaaaaaaaaaaaaaaabaaaaaaaaaaaaaaaaaaaaaaaaaaaa3aaahbmbcam(phm->client);
const bool is_bcam = a1aaaaaaaaaaaaaaabaaaaaaaaaaaa3aaaaaaaaaaaaaaaabaaaaaaaaaaaaaaaaaaaaaaaaaaaa3aaabcam(phm->client);
if (is_hbmbcam || is_bcam) {
masked_key = key;
} else {
memset(&m_key, 0, sizeof(m_key));
aaaaaaaaaaaa1aaaaaaaaaaaaaaaabaaaaaaaaaaaaaaaaaaaaaaa3aaaaaaaaaaaaaaaabaaaaaaaaaaaaaaaaaaaaaaaaaaaa3aaaaaaaaaaaaaaaabaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaa3aaa(phm->mm, key, &m_key);
masked_key = &m_key;
}
if (is_hbmbcam) {
uint16_t num_bytes;
if (narrow_key)
num_bytes = (a1aaaaaaaaaaaaaaaabaaaaaaaaaaaa3aaaaaaaaaaaaaaaabaaaaaaaaaaaaaaaaaaaaaaaaaaaa3aaanarrow_key_width(phm->client) + 7) / 8;
else
num_bytes = (a1aaaaaaaaaaaaaaaabaaaaaaaaaaaa3aaaaaaaaaaaaaaaabaaaaaaaaaaaaaaaaaaaaaaaaaaaa3aaaaaaaaaaaaaaaabaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaa3aaaaaaaaaaaaaaaabaaaaaaaaaaaaaaaaaaaaaaaaaaaa4aaawidth(phm->client) + 7) / 8;
uint32_t hash_value;
murmur3((const void *) masked_key, num_bytes, 3, &hash_value);
const uint32_t swapped_murmur_bucket = swap_murmur_bucket(phm, hash_value);
aaaaaaaaaa1aaaaaaaaaaaaaaaabaaaaaaaaaaaaaaaaaaaaaaaaaaaa3aaaaaaaaaaaaaaabaaaaaaaaaaaaaaaa4aaaber = adjust_list(phm, swapped_murmur_bucket);
} else {
hash_t *hash = (hash_t *) alloca(hash_size());
aaaaaaa1aaa(hash, masked_key, phm);
const uint32_t bucket_hash = hash_calculate_bucket(hash);
aaaaaaaaaa1aaaaaaaaaaaaaaaabaaaaaaaaaaaaaaaaaaaaaaaaaaaa3aaaaaaaaaaaaaaabaaaaaaaaaaaaaaaa4aaaber = adjust_list(phm, bucket_hash);
}
aaaaaaaaaaaaaaa1aaat *read_pointer_list = (aaaaaaaaaaaaaaa1aaat *) alloca(aaaaaaaaaaaaaaa1aaaaaaaaaaaaaabaaaaaaaaaa3aaa());
uint8_t loop = 1;
if (is_hbmbcam)
loop = a1aaaaaaaaaaaaaaaabaaaaaaaaaaaa3aaaaaaaaaaaaaaaabaaaaaaaaaaaaaaaaaaaaaaaaaaaa3aaaaaaaaaaaaaaabaaaaaaaaaaaaaaaa4aaaaaaaaaaaaaaaabaaaaaaaaaaaaaaaaaaaaaaaaaaaa4aaaaaaaaaaaaabaaaaaaaaaaaaaaaaa5aaas_per_read(phm->client);
const bool mixed_mode = a1aaaaaaaaaaaaaaabaaaaaaaaaaaa3aaaaaaaaaaaaaaaabaaaaaaaaaaaaaaaaaaaaaaaaaaaa3aaamixed_mode(phm->client);
assert(!narrow_key || (narrow_key && mixed_mode));
uint8_t max_elements = 1;
uint8_t narrow = 0;
if (mixed_mode) {
if (narrow_key) {
max_elements = 2;
narrow = 1;
}
}
for (uint8_t i = 0; i < loop; i++) {
for (uint8_t element = 0; element < max_elements; element++) {
if (aaaa1aaaread_element(phm->km, aaaaaaaaaa1aaaaaaaaaaaaaaaabaaaaaaaaaaaaaaaaaaaaaaaaaaaa3aaaaaaaaaaaaaaabaaaaaaaaaaaaaaaa4aaaber + i, read_pointer_list, false, narrow, element)) {
const aaaaaaaaaaaaa1aaat *stored_key = aaaaaaaaaaaaaaa1aaaaaaaaaaaaaaaabaaaaaaaaaaaa3aaaaaaaaaaaaaaaabaaaaaaaaaaaaaaaaaaaaaaaaaaaa3aaaaaaaaaaaa1aaa(read_pointer_list, 0);
const aaaaaaaaaaaaa1aaat *masked_stored_key;
if (is_hbmbcam || is_bcam) {
masked_stored_key = stored_key;
} else {
aaaaaaaaaaaaa1aaat m_stored_key;
memset(&m_stored_key, 0, sizeof(m_stored_key));
aaaaaaaaaaaa1aaaaaaaaaaaaaaaabaaaaaaaaaaaaaaaaaaaaaaa3aaaaaaaaaaaaaaaabaaaaaaaaaaaaaaaaaaaaaaaaaaaa3aaaaaaaaaaaaaaaabaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaa3aaa(phm->mm, stored_key, &m_stored_key);
masked_stored_key = &m_stored_key;
}
uint8_t j;
for (j = 0; j < CAM_MAX_KEY_WIDTH_MEM; j++) {
if (masked_stored_key->word[j] != masked_key->word[j]) {
break;
}
}
if (j != CAM_MAX_KEY_WIDTH_MEM)
continue;
const aaaaaaaaaaaaaaaa1aaaaaaaaaaaaaaaabaaaaaaaaaaaaaaaaaaaaaaaaaaaa3aaat *prio_ptr = aaaaaaaaaaaaaaa1aaaaaaaaaaaaaaaabaaaaaaaaaaaa3aaaaaaaaaaaaaaaabaaaaaaaaaaaaaaaaaaaaaaaaaaaa3aaaaaaaaaaaaaaabaaaaaaaaaaaaaaaaa4aaa(read_pointer_list, 0);
*out_prio_resp = *prio_ptr;
return true;
} 
}
} 
return false;
}
bool aaa1aaaaaaaaaaaaaaabaaaaaaaaaaaa3aaaaaaaaaaaaaaaabaaaaaaaaaaaaaaaaaaaaaaaaaaaa3aaaaaaaaaaaaaaaabaaaaaaaaaaaaaaaaaaaaaaa4aaaaaaaaaaaaaaaabaaaaaaaaaaaaaaaaaaaaaaaaaaaa4aaaaaaaaaaaabaaaaaaaaaaa5aaaaaaaaaaaaaaaabaaaaaaaaaaaaaaaaaaaaaaaaaaaa5aaavalid(const aaa1aaat *phm)
{
return aaaaaaaaaaaa1aaaaaaaaaaaaaaabaaaaaaaaaaaa3aaaaaaaaaaaaaaaabaaaaaaaaaaaaaaaaaaaaaaaaaaaa3aaaaaaaaaaaaaaaabaaaaaaaaaaaaaaaaaaaaaaa4aaaaaaaaaaaaaaaabaaaaaaaaaaaaaaaaaaaaaaaaaaaa4aaaaaaaaaaaabaaaaaaaaaaa5aaaaaaaaaaaaaaaabaaaaaaaaaaaaaaaaaaaaaaaaaaaa5aaavalid(phm->mm);
}
bool aaa1bbbbbbbbbbbbbbbbbbbbbbbb3aaaaaaaaaaaaaaaabaaaaaaaaaaaaaaaaaaaaaaaaaaaa4aaaone_element(aaa1aaat *target_phm, aaa1aaat *source_phm)
{
assert(a1aaaaaaaaaaaaaaabaaaaaaaaaaaa3aaaaaaaaaaaaaaaabaaaaaaaaaaaaaaaaaaaaaaaaaaaa3aaaaaaaaaaaaaaaabaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaa3aaa(target_phm->client));
assert(target_phm != source_phm);
aaaaaaaaaaaaa1aaat aaaaaaaaa1aaa;
aaaaaaaaaaaaaaaa1aaaaaaaaaaaaaaaabaaaaaaaaaaaaaaaaaaaaaaaaaaaa3aaat priority;
uint32_t bucket;
aaaaaaaaaaaaa1aaat ternary_mask;
uint32_t start_value = 0;
if (!aaa1aaafind_and_read_element(source_phm, &start_value, &aaaaaaaaa1aaa, &ternary_mask, &priority,
&bucket, false, 0, 0)) {
assert(false);
}
if (!aaa1aaaaaaaaaaaaaaabaaaaaaaaaaaaaaaaaaa3aaa(target_phm, &aaaaaaaaa1aaa, &ternary_mask, &priority, false, 0)) {
return false;
}
uint32_t new_start_value = start_value;
if (!delete_element(source_phm, &new_start_value)) {
assert(false);
}
assert(start_value == new_start_value);
assert(source_phm->number_of_keys > 0);
source_phm->number_of_keys--;
return true;
}
bool aaa1aaafind_response(aaa1aaat *phm, const aaaaaaaaaaaaaaaa1aaaaaaaaaaaaaaaabaaaaaaaaaaaaaaaaaaaaaaaaaaaa3aaat *response, const aaaaaaaaaaaaaaaa1aaaaaaaaaaaaaaaabaaaaaaaaaaaaaaaaaaaaaaaaaaaa3aaat *response_mask,
uint32_t *start_value,
aaaaaaaaaaaaa1aaat *aaaaaaaaa1aaa,
aaaaaaaaaaaaa1aaat *ternary_mask, uint8_t *narrow,
uint8_t *narrow_element, bool narrow_key)
{
uint32_t bucket;
const uint32_t number_of_keys = aaa1aaaaaaaaaaaaaaaabaaaaaaaaaaaa3aaaaaaaaaaaaaaaabaaaaaaaaaaaaaaaaaaaaaaaaaaaa3aaaaaaaaaaaaaaabaaaaaaaaaaaaaaaa4aaaber_of_keys(phm);
if (number_of_keys == 0) {
return false;
}
aaaaaaaaaaaaaaaa1aaaaaaaaaaaaaaaabaaaaaaaaaaaaaaaaaaaaaaaaaaaa3aaat priority;
bool verify = (a1aaaaaaaaaaaaaaaabaaaaaaaaaaaa3aaaaaaaaaaaaaaaabaaaaaaaaaaaaaaaaaaaaaaaaaaaa3bbbbbbbbbbbbbbbbbbbbbbbbbbbbbbbbbbbbb3aaaaaaaaaaaaaaaabaaaaaaaaaaaaaaaaaaaaaaaaaaaa4aaaflags(phm->client) & CAM_DEBUG_VERIFY_SHADOW) != 0;
assert((narrow_key && (*narrow != 0)) || !narrow_key);
while (aaa1aaafind_and_read_element(phm, start_value, aaaaaaaaa1aaa, ternary_mask, &priority, &bucket, verify, narrow,
narrow_element)) {
assert((narrow_key && (*narrow != 0)) || !narrow_key);
bool match = true;
for (uint16_t i = 0; i < CAM_MAX_aaaaaaaaaaaaaa1aaaaaaaaaaaaaaaabaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaa3aaaaaaaaaaaaaaaabaaaaaaaaaaaaaaaaaaaaaaaaaaaa4aaaWIDTH_MEM; i++) {
if ((priority.word[i] & response_mask->word[i]) != (response->word[i] & response_mask->word[i])) {
match = false;
}
}
if (match)
return true;
if ((*narrow != 0) && ((*narrow_element) == 0) && narrow_key) {
*narrow_element = 1;
} else {
(*start_value)++;
*narrow_element = 0;
}
}
return false;
}
static bool write_list(aaa1aaat *target_phm, aaaaaaaaaaaaaaa1aaat *read_pointer_list, uint8_t attempt,
uint16_t source_seed)
{
const uint8_t largest_len = aaaaaaaaaaaaaaa1aaaaaaaaaaaaaaaabaaaaaaaaaaaa3aaaaaaaaaaaaaaaabaaaaaaaaaaaaaaaaaaaaaaaaaaaa3aaaaaaaaaaaaaaabaaaaaaaaaaaaaaaa4aaaber_of_keys(read_pointer_list);
for (uint8_t i = 0; i < largest_len; i++) {
const aaaaaaaaaaaaaaaa1aaaaaaaaaaaaaaaabaaaaaaaaaaaaaaaaaaaaaaaaaaaa3aaat *priority = aaaaaaaaaaaaaaa1aaaaaaaaaaaaaaaabaaaaaaaaaaaa3aaaaaaaaaaaaaaaabaaaaaaaaaaaaaaaaaaaaaaaaaaaa3aaaaaaaaaaaaaaabaaaaaaaaaaaaaaaaa4aaa(read_pointer_list, i);
const aaaaaaaaaaaaa1aaat *aaaaaaaaa1aaa = aaaaaaaaaaaaaaa1aaaaaaaaaaaaaaaabaaaaaaaaaaaa3aaaaaaaaaaaaaaaabaaaaaaaaaaaaaaaaaaaaaaaaaaaa3aaaaaaaaaaaa1aaa(read_pointer_list, i);
const aaaaaaaaaaaaa1aaat *ternary_mask = aaaaaaaaaaaaaaa1aaaaaaaaaaaaaaaabaaaaaaaaaaaa3aaaaaaaaaaaaaaaabaaaaaaaaaaaaaaaaaaaaaaaaaaaa3aaaternary_mask(read_pointer_list, i);
if (false
== aaa1aaaaaaaaaaaaaaabaaaaaaaaaaaaaaaaaaa3aaa(target_phm, aaaaaaaaa1aaa, ternary_mask, priority,
true, attempt)) {
return false;
}
}
return true;
}
static bool find_and_read_list(const aaa1aaat *source_phm, bool add_key,
const aaaaaaaaaaaaa1aaat *add_aaaaaaaaa1aaa,
const aaaaaaaaaaaaa1aaat *add_ternary_mask, const aaaaaaaaaaaaaaaa1aaaaaaaaaaaaaaaabaaaaaaaaaaaaaaaaaaaaaaaaaaaa3aaat *add_priority, uint32_t add_bucket,
uint32_t *start_value, uint8_t *list_len, aaaaaaaaaaaaaaa1aaat *read_pointer_list)
{
assert(a1aaaaaaaaaaaaaaabaaaaaaaaaaaa3aaaaaaaaaaaaaaaabaaaaaaaaaaaaaaaaaaaaaaaaaaaa3aaaaaaaaaaaaaaaabaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaa3aaa(source_phm->client));
const uint32_t segment_size = a1aaaaaaaaaaaaaaaabaaaaaaaaaaaa3aaaaaaaaaaaaaaaabaaaaaaaaaaaaaaaaaaaaaaaaaaaa3aaaaaaaaaaaaaaabaaaaaaaaaaaaaaaa4aaaaaaaaaaaaaaaabaaaaaaaaaaaaaaaaaaaaaaaaaaaa4aaaaaaaaaaaaabaaaaaaaaaaaaaaaaa5aaas(source_phm->client);
const uint32_t num_lists = a1aaaaaaaaaaaaaaaabaaaaaaaaaaaa3aaaaaaaaaaaaaaaabaaaaaaaaaaaaaaaaaaaaaaaaaaaa3aaaaaaaaaaaaaaabaaaaaaaaaaaaaaaa4aaaaaaaaaaaaaaaabaaaaaaaaaaaaaaaaaaaaaaaaaaaa4aaaaaaaaaaaaabaaaaaaaaaaaaaaaaa5aaas(source_phm->client);
const uint32_t bucket_end_value = num_lists * aaaaaa1aaaaaaaaaabaaaaaaaaaaa3aaaaaaaaaaaaaaaabaaaaaaaaaaaaaaaaaaaaaaaaaaaa3aaaaaaaaaaaaaaaabaaaaaaaaaaaaaaaaaaaaaaaaaaaaa3aaaaaaaaaaaaaaaabaaaaaaaaaaaaaaaaaaaaaaaaaaaa4aaaaaaaaaaaaabaaaaaaaaaaaaaaaaa5aaaaaaaaaaaaaaaabaaaaaaaaaaaaaaaaaaaaaaaaaaaa5aaaRATIO;
const uint32_t bucket_start_value = *start_value;
uint8_t largest_len = 0;
uint32_t largest_bucket = 0;
for (uint32_t bucket = bucket_start_value; bucket < bucket_end_value; bucket++) {
uint8_t number_of_keys = aa1aaaaaaaaaaaaaaaabaaaaaaaaaaaa3aaaaaaaaaaaaaaaabaaaaaaaaaaaaaaaaaaaaaaaaaaaa3aaaaaaaaaaaaaaabaaaaaaaaaaaaaaaa4aaaber_of_keys(source_phm->bm, bucket);
if ((bucket == add_bucket) && add_key) {
number_of_keys++;
}
if (*start_value > 0) {
if (number_of_keys == *list_len) {
largest_len = number_of_keys;
largest_bucket = bucket;
break;
}
}
else {
if (number_of_keys <= *list_len) {
if (number_of_keys > largest_len) {
largest_len = number_of_keys;
largest_bucket = bucket;
}
}
}
}
if (largest_len == 0) {
return false;
}
if (aa1aaaaaaaaaaaaaaabaaaaaaaaaaaa3aaaaaaaaaaaaaaaabaaaaaaaaaaaaaaaaaaaaaaaaaaaa3aaaaaaaaaaaaaaaabaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaa3aaaaaaaaaaaaaaaabaaaaaaaaaaaaaaaaaaaaaaaaaaaa4aaapointer(source_phm->bm, largest_bucket)) {
aaaaaaaaaaaaaaa1aaaaaaaaaaaaaabaaaaaaaaaaa3aaa(read_pointer_list, largest_bucket, false, true);
const uint32_t end_aaaaaaaaaa1aaa = segment_size - 1;
for (uint32_t aaaaaaaaaa1aaaaaaaaaaaaaaaabaaaaaaaaaaaaaaaaaaaaaaaaaaaa3aaaaaaaaaaaaaaabaaaaaaaaaaaaaaaa4aaaber = 0; aaaaaaaaaa1aaaaaaaaaaaaaaaabaaaaaaaaaaaaaaaaaaaaaaaaaaaa3aaaaaaaaaaaaaaabaaaaaaaaaaaaaaaa4aaaber <= end_aaaaaaaaaa1aaa; aaaaaaaaaa1aaaaaaaaaaaaaaaabaaaaaaaaaaaaaaaaaaaaaaaaaaaa3aaaaaaaaaaaaaaabaaaaaaaaaaaaaaaa4aaaber++) {
aaaa1aaaread(source_phm->km, aaaaaaaaaa1aaaaaaaaaaaaaaaabaaaaaaaaaaaaaaaaaaaaaaaaaaaa3aaaaaaaaaaaaaaabaaaaaaaaaaaaaaaa4aaaber, read_pointer_list);
}
} else {
aaaaaaaaaaaaaaa1aaaaaaaaaaaaaabaaaaaaaaaaa3aaa(read_pointer_list, largest_bucket, true, true);
uint32_t aaaaaaaaaa1aaaaaaaaaaaaaaaabaaaaaaaaaaaaaaaaaaaaaaaaaaaa3aaaaaaaaaaaaaaabaaaaaaaaaaaaaaaa4aaaber;
aaaaaaaaaa1aaaaaaaaaaaaaaaabaaaaaaaaaaaaaaaaaaaaaaaaaaaa3aaaaaaaaaaaaaaabaaaaaaaaaaaaaaaa4aaaber = aa1aaaaaaaaaaaaaaaabaaaaaaaaaaaa3aaaaaaaaaaaaaaaabaaaaaaaaaaaaaaaaaaaaaaaaaaaa3aaaaaaaaaaaaaaaabaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaa3aaaaaaaaaaaaaaaabaaaaaaaaaaaaaaaaaaaaaaaaaaaa4aaapointer(source_phm->bm, largest_bucket);
aaaa1aaaread(source_phm->km, aaaaaaaaaa1aaaaaaaaaaaaaaaabaaaaaaaaaaaaaaaaaaaaaaaaaaaa3aaaaaaaaaaaaaaabaaaaaaaaaaaaaaaa4aaaber, read_pointer_list);
}
if ((largest_bucket == add_bucket) && add_key) {
aaaaaaaaaaaaaaa1bbbbbbbbbbbbbbbbbbbbbbbbbbbbbbbb3aaa(read_pointer_list, add_priority, add_aaaaaaaaa1aaa, add_ternary_mask, false);
}
assert(largest_len == aaaaaaaaaaaaaaa1aaaaaaaaaaaaaaaabaaaaaaaaaaaa3aaaaaaaaaaaaaaaabaaaaaaaaaaaaaaaaaaaaaaaaaaaa3aaaaaaaaaaaaaaabaaaaaaaaaaaaaaaa4aaaber_of_keys(read_pointer_list));
*list_len = largest_len;
*start_value = largest_bucket;
return true;
}
#define SEED_ATTEMPTS 256
static bool move_longest_list_first(aaa1aaat *target_phm, aaa1aaat *source_phm, bool add_key,
const aaaaaaaaaaaaa1aaat *add_aaaaaaaaa1aaa,
const aaaaaaaaaaaaa1aaat *add_ternary_mask, const aaaaaaaaaaaaaaaa1aaaaaaaaaaaaaaaabaaaaaaaaaaaaaaaaaaaaaaaaaaaa3aaat *add_priority,
uint32_t add_bucket,
uint8_t first_function_to_try, uint16_t seed_increment)
{
assert(!aaaaaaaaaaaa1aaaaaaaaaaaaaaabaaaaaaaaaaaa3aaaaaaaaaaaaaaaabaaaaaaaaaaaaaaaaaaaaaaaaaaaa3aaaaaaaaaaaaaaaabaaaaaaaaaaaaaaaaaaaaaaa4aaaaaaaaaaaaaaaabaaaaaaaaaaaaaaaaaaaaaaaaaaaa4aaaaaaaaaaaabaaaaaaaaaaa5aaaaaaaaaaaaaaaabaaaaaaaaaaaaaaaaaaaaaaaaaaaa5aaavalid(target_phm->mm));
aaaaaaaaaaaaa1aaat mask;
memset(&mask, 0, sizeof(aaaaaaaaaaaaa1aaat));
uint8_t range_valid;
uint8_t mask_id;
aaaaaaaaaaaa1aaaread_mask(source_phm->mm, &mask, &range_valid, &mask_id);
uint16_t source_seed = aaaaaaaaaaaa1aaaaaaaaaaaaaaaabaaaaaaaaaaaa3aaaaaaaaaaaaaaaabaaaaaaaaaaaaaaaaaaaaaaaaaaaa3aaaseed(source_phm->mm);
uint16_t source_seed_lo = source_seed & 0xff;
source_seed_lo = (source_seed_lo + seed_increment) & 0xff;
uint16_t source_seed_hi = source_seed >> 8;
source_seed_hi = (source_seed_hi + seed_increment) & 0xff;
source_seed = source_seed_hi << 8;
source_seed = source_seed + source_seed_lo;
aaa1aaaaaaaaaaaaaaaabaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaa3aaaaaaaaaaaaaaaabaaaaaaaaaaaaaaaaaaaaaaaaaaaa4aaaaaaaaaaaaaaaabaaaaaaaaaaaaaaaaaaaaaaa5aaaaaaaaaaaaaaaabaaaaaaaaaaaaaaaaaaaaaaaaaaaa5aaaaaaaaaaaabaaaaaaaaaaa6aaa(target_phm, &mask, source_seed,
range_valid, mask_id);
uint32_t start_value = 0;
uint8_t list_len = UINT8_MAX;
aaaaaaaaaaaaaaa1aaat *read_pointer_list = alloca(aaaaaaaaaaaaaaa1aaaaaaaaaaaaaabaaaaaaaaaa3aaa());
while (list_len > 0) {
aaaaaaaaaaaaaaa1aaaaaaaaaaaaaaaabaaaaaaaaaaaaaaaaaaa3aaaaaaaaaaaaaaaabaaaaaaaaaaaaaaaaaaaaaaaaaaaa3aaaall(read_pointer_list);
while (find_and_read_list(source_phm, add_key, add_aaaaaaaaa1aaa, add_ternary_mask,
add_priority, add_bucket,
&start_value, &list_len,
read_pointer_list)) {
const bool success = write_list(target_phm, read_pointer_list, first_function_to_try,
source_seed);
if (!success) {
delete_mask(target_phm);
return false;
}
aaaaaaaaaaaaaaa1aaaaaaaaaaaaaaaabaaaaaaaaaaaaaaaaaaa3aaaaaaaaaaaaaaaabaaaaaaaaaaaaaaaaaaaaaaaaaaaa3aaaall(read_pointer_list);
start_value++; 
}
start_value = 0;
list_len--; 
}
return true;
}
uint8_t highest_function = 0;
uint8_t highest_seed_increment = 0;
uint32_t num_rec = 0;
void aaa1aaaread_and_clear_recover_stats(uint8_t *highest_recover_function, uint8_t *highest_recover_seed_increment,
uint32_t *num_recovers)
{
*highest_recover_function = highest_function;
*highest_recover_seed_increment = highest_seed_increment;
*num_recovers = num_rec;
highest_function = 0;
highest_seed_increment = 0;
num_rec = 0;
}
static bool recover(aaa1aaat *phm, const aaaaaaaaaaaaa1aaat *add_aaaaaaaaa1aaa, const aaaaaaaaaaaaa1aaat *add_ternary_mask,
const aaaaaaaaaaaaaaaa1aaaaaaaaaaaaaaaabaaaaaaaaaaaaaaaaaaaaaaaaaaaa3aaat *add_priority,
uint32_t add_precomp_bucket_hash, uint32_t add_bucket)
{
assert(a1aaaaaaaaaaaaaaabaaaaaaaaaaaa3aaaaaaaaaaaaaaaabaaaaaaaaaaaaaaaaaaaaaaaaaaaa3aaaaaaaaaaaaaaaabaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaa3aaa(phm->client));
aaa1aaat *recover_phm = a1aaaaaaaaaaaaaaaabaaaaaaaaaaaa3aaaaaaaaaaaaaaaabaaaaaaaaaaaaaaaaaaaaaaaaaaaa3aaarecover_phm(phm->client);
if (phm == recover_phm) {
return false;
}
if (aaaaaaaaaaaa1aaaaaaaaaaaaaaabaaaaaaaaaaaa3aaaaaaaaaaaaaaaabaaaaaaaaaaaaaaaaaaaaaaaaaaaa3aaaaaaaaaaaaaaaabaaaaaaaaaaaaaaaaaaaaaaa4aaaaaaaaaaaaaaaabaaaaaaaaaaaaaaaaaaaaaaaaaaaa4aaaaaaaaaaaabaaaaaaaaaaa5aaaaaaaaaaaaaaaabaaaaaaaaaaaaaaaaaaaaaaaaaaaa5aaavalid(recover_phm->mm)) {
return false;
}
bool success = false;
uint8_t i;
num_rec++;
for (uint16_t seed_increment = 0; seed_increment < SEED_ATTEMPTS; seed_increment++) {
if (seed_increment > highest_seed_increment)
highest_seed_increment = seed_increment;
for (i = 0; i < aaaaaa1aaaaaaaaaaaaaaaabaaaaaaaaaaaaaaaaaaaaaaaaaa3aaaaaaaaaaaaaaaabaaaaaaaaaaaaaaaaaaaaaaaaaaaa3aaaaaaaaaaaaaaaabaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaa3aaaS; i++) {
if (i > highest_function) {
highest_function = i;
}
success = move_longest_list_first(recover_phm, phm, true, add_aaaaaaaaa1aaa,
add_ternary_mask, add_priority,
add_bucket, i, seed_increment);
if (success) {
break;
} 
}
if (success)
break;
}
assert(success);
aaaaaaaaaaaa1bbbbbbbbbbbbbbbbb3aaaaaaaaaaaaaaaabaaaaaaaaaaaaaaaaaaaaaaaaaaaa4aaaaaaaaaaaaaaaabaaaaaaaaaaaaaaaaaaaaaaa5aaaaaaaaaaaaaaaabaaaaaaaaaaaaaaaaaaaaaaaaaaaa5aaaaaaaaaaaabaaaaaaaaaaa6aaa(phm->mm);
const uint32_t segment_size = a1aaaaaaaaaaaaaaaabaaaaaaaaaaaa3aaaaaaaaaaaaaaaabaaaaaaaaaaaaaaaaaaaaaaaaaaaa3aaaaaaaaaaaaaaabaaaaaaaaaaaaaaaa4aaaaaaaaaaaaaaaabaaaaaaaaaaaaaaaaaaaaaaaaaaaa4aaaaaaaaaaaaabaaaaaaaaaaaaaaaaa5aaas(phm->client);
const uint32_t num_lists = a1aaaaaaaaaaaaaaaabaaaaaaaaaaaa3aaaaaaaaaaaaaaaabaaaaaaaaaaaaaaaaaaaaaaaaaaaa3aaaaaaaaaaaaaaabaaaaaaaaaaaaaaaa4aaaaaaaaaaaaaaaabaaaaaaaaaaaaaaaaaaaaaaaaaaaa4aaaaaaaaaaaaabaaaaaaaaaaaaaaaaa5aaas(phm->client);
const uint32_t end_bucket = num_lists * aaaaaa1aaaaaaaaaabaaaaaaaaaaa3aaaaaaaaaaaaaaaabaaaaaaaaaaaaaaaaaaaaaaaaaaaa3aaaaaaaaaaaaaaaabaaaaaaaaaaaaaaaaaaaaaaaaaaaaa3aaaaaaaaaaaaaaaabaaaaaaaaaaaaaaaaaaaaaaaaaaaa4aaaaaaaaaaaaabaaaaaaaaaaaaaaaaa5aaaaaaaaaaaaaaaabaaaaaaaaaaaaaaaaaaaaaaaaaaaa5aaaRATIO - 1;
for (uint32_t bucket = 0; bucket <= end_bucket; bucket++) {
aa1bbbbbbbbbbbbbbbb3aaaaaaaaaaaaaaaabaaaaaaaaaaaaaaaaaaaaaaaaaaaa4aaaand_flush(phm->bm, recover_phm->bm, bucket);
}
const uint32_t end_list = segment_size - 1;
for (uint32_t list = 0; list <= end_list; list++) {
aaaa1bbbbbbbbbbbbbbbb3aaaaaaaaaaaaaaaabaaaaaaaaaaaaaaaaaaaaaaaaaaaa4aaaand_flush(phm->km, recover_phm->km, list);
}
const uint16_t seed = aaaaaaaaaaaa1aaaaaaaaaaaaaaaabaaaaaaaaaaaa3aaaaaaaaaaaaaaaabaaaaaaaaaaaaaaaaaaaaaaaaaaaa3aaaseed(recover_phm->mm);
aaaaaaaaaaaa1bbbbbbbbbbbbbbbbbb3aaaaaaaaaaaaaaaabaaaaaaaaaaaaaaaaaaaaaaaaaaaa4aaaseed(phm->mm, seed);
aaaaaaaaaaaa1bbbbbbbbbbbbbbbbbb3aaaaaaaaaaaaaaaabaaaaaaaaaaaaaaaaaaaaaaaaaaaa4aaaaaaaaaaaaaaaabaaaaaaaaaaaaaaaaaaaaaaa5aaaaaaaaaaaaaaaabaaaaaaaaaaaaaaaaaaaaaaaaaaaa5aaaaaaaaaaaabaaaaaaaaaaa6aaa(phm->mm);
phm->number_of_keys = recover_phm->number_of_keys;
delete_mask(recover_phm);
return true;
}
uint16_t aaa1aaaaaaaaaaaaaaaabaaaaaaaaaaaa3aaaaaaaaaaaaaaaabaaaaaaaaaaaaaaaaaaaaaaaaaaaa3aaaseed(const aaa1aaat *phm)
{
return aaaaaaaaaaaa1aaaaaaaaaaaaaaaabaaaaaaaaaaaa3aaaaaaaaaaaaaaaabaaaaaaaaaaaaaaaaaaaaaaaaaaaa3aaaseed(phm->mm);
}
aaaa1aaat* aaa1aaaaaaaaaaaaaaaabaaaaaaaaaaaa3aaaaaaaaaaaaaaaabaaaaaaaaaaaaaaaaaaaaaaaaaaaa3aaakm(const aaa1aaat *phm)
{
return phm->km;
}
void aaa1aaaaaaaaaaaaaaaabaaaaaaaaaaaaaaaaaaaaaaa3aaaaaaaaaaaaaaaabaaaaaaaaaaaaaaaaaaaaaaaaaaaa3aaaaaaaaaaaaaaaabaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaa3aaa(const aaa1aaat *phm, const aaaaaaaaaaaaa1aaat *key, aaaaaaaaaaaaa1aaat *masked_key)
{
aaaaaaaaaaaa1aaaaaaaaaaaaaaaabaaaaaaaaaaaaaaaaaaaaaaa3aaaaaaaaaaaaaaaabaaaaaaaaaaaaaaaaaaaaaaaaaaaa3aaaaaaaaaaaaaaaabaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaa3aaa(phm->mm, key, masked_key);
}
const a1aaat *aaa1aaaaaaaaaaaaaaaabaaaaaaaaaaaa3aaaaaaaaaaaaaaaabaaaaaaaaaaaaaaaaaaaaaaaaaaaa3aaaclient(const aaa1aaat *phm)
{
return phm->client;
}
void aaa1bbbbbbbbbbbbbbbbbbb3aaa(const aaa1aaat *phm, const a1aaat *client)
{
assert(phm != NULL);
aaaa1bbbbbbbbbbbbbbbbbbb3aaaaaaaaaaaaaaaabaaaaaaaaaaaaaaaaaaaaaaaaaaaa4aaaall(phm->km);
if (a1aaaaaaaaaaaaaaabaaaaaaaaaaaa3aaaaaaaaaaaaaaaabaaaaaaaaaaaaaaaaaaaaaaaaaaaa3aaaaaaaaaaaaaaaabaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaa3aaa(client)) {
aa1bbbbbbbbbbbbbbbbbbb3aaaaaaaaaaaaaaaabaaaaaaaaaaaaaaaaaaaaaaaaaaaa4aaaall(phm->bm);
}
}
uint64_t aaa1aaaread_and_clear_ecc_addresses(const aaa1aaat *phm)
{
return aaaa1aaaread_and_clear_ecc_addresses(phm->km);
}
#define MAX_ELEMENTS 32
struct aaaaaaaaaaaaaaa1aaat {
bool is_direct_pointer;
uint8_t number_of_keys;
uint32_t bucket;
aaaaaaaaaaaaa1aaat aaaaaaaaa1aaas[MAX_ELEMENTS];
aaaaaaaaaaaaaaaa1aaaaaaaaaaaaaaaabaaaaaaaaaaaaaaaaaaaaaaaaaaaa3aaat prios[MAX_ELEMENTS];
aaaaaaaaaaaaa1aaat ternary_masks[MAX_ELEMENTS];
bool narrow_keys[MAX_ELEMENTS];
};
size_t aaaaaaaaaaaaaaa1aaaaaaaaaaaaaabaaaaaaaaaa3aaa(void)
{
return sizeof(aaaaaaaaaaaaaaa1aaat);
}
void aaaaaaaaaaaaaaa1aaaaaaaaaaaaaabaaaaaaaaaaa3aaa(aaaaaaaaaaaaaaa1aaat *pointer_list, uint32_t bucket, bool is_direct_pointer, bool ternary_list)
{
pointer_list->bucket = bucket;
pointer_list->is_direct_pointer = is_direct_pointer;
pointer_list->number_of_keys = 0;
if (ternary_list) {
for (uint8_t i = 0; i < MAX_ELEMENTS; i++) {
memset(&(pointer_list->ternary_masks[i].word[0]), 0xff, sizeof(pointer_list->ternary_masks[i]));
}
}
}
void aaaaaaaaaaaaaaa1bbbbbbbbbbbbbbbbbbbbbbbbbbbbbbbb3aaa(aaaaaaaaaaaaaaa1aaat *pointer_list, const aaaaaaaaaaaaaaaa1aaaaaaaaaaaaaaaabaaaaaaaaaaaaaaaaaaaaaaaaaaaa3aaat *prio, const aaaaaaaaaaaaa1aaat *aaaaaaaaa1aaa,
const aaaaaaaaaaaaa1aaat *ternary_mask, bool narrow_key)
{
uint8_t number_of_keys = pointer_list->number_of_keys;
assert(number_of_keys < MAX_ELEMENTS);
pointer_list->prios[number_of_keys] = *prio;
memcpy(&pointer_list->aaaaaaaaa1aaas[number_of_keys], aaaaaaaaa1aaa, sizeof(aaaaaaaaaaaaa1aaat));
if (ternary_mask != NULL) {
memcpy(&pointer_list->ternary_masks[number_of_keys], ternary_mask, sizeof(aaaaaaaaaaaaa1aaat));
}
pointer_list->narrow_keys[number_of_keys] = narrow_key;
pointer_list->number_of_keys++;
}
void aaaaaaaaaaaaaaa1aaaaaaaaaaaaaaaabaaaaaaaaaaaaaaaaaaa3aaaaaaaaaaaaaaaabaaaaaaaaaaaaaaaaaaaaaaaaaaaa3aaaall(aaaaaaaaaaaaaaa1aaat *pointer_list)
{
pointer_list->number_of_keys = 0;
}
uint8_t aaaaaaaaaaaaaaa1aaaaaaaaaaaaaaaabaaaaaaaaaaaa3aaaaaaaaaaaaaaaabaaaaaaaaaaaaaaaaaaaaaaaaaaaa3aaaaaaaaaaaaaaabaaaaaaaaaaaaaaaa4aaaber_of_keys(const aaaaaaaaaaaaaaa1aaat *pointer_list)
{
return pointer_list->number_of_keys;
}
const aaaaaaaaaaaaa1aaat *aaaaaaaaaaaaaaa1aaaaaaaaaaaaaaaabaaaaaaaaaaaa3aaaaaaaaaaaaaaaabaaaaaaaaaaaaaaaaaaaaaaaaaaaa3aaaaaaaaaaaa1aaa(const aaaaaaaaaaaaaaa1aaat *pointer_list, uint8_t key_number)
{
assert(key_number < pointer_list->number_of_keys);
return &(pointer_list->aaaaaaaaa1aaas[key_number]);
}
const aaaaaaaaaaaaa1aaat *aaaaaaaaaaaaaaa1aaaaaaaaaaaaaaaabaaaaaaaaaaaa3aaaaaaaaaaaaaaaabaaaaaaaaaaaaaaaaaaaaaaaaaaaa3aaaternary_mask(const aaaaaaaaaaaaaaa1aaat *pointer_list, uint8_t key_number)
{
assert(key_number < pointer_list->number_of_keys);
return &(pointer_list->ternary_masks[key_number]);
}
const aaaaaaaaaaaaaaaa1aaaaaaaaaaaaaaaabaaaaaaaaaaaaaaaaaaaaaaaaaaaa3aaat *aaaaaaaaaaaaaaa1aaaaaaaaaaaaaaaabaaaaaaaaaaaa3aaaaaaaaaaaaaaaabaaaaaaaaaaaaaaaaaaaaaaaaaaaa3aaaaaaaaaaaaaaabaaaaaaaaaaaaaaaaa4aaa(const aaaaaaaaaaaaaaa1aaat *pointer_list, uint8_t key_number)
{
assert(key_number < pointer_list->number_of_keys);
return &(pointer_list->prios[key_number]);
}
bool aaaaaaaaaaaaaaa1aaaaaaaaaaaaaaabaaaaaaaaaaaa3aaaaaaaaaaaaaaaabaaaaaaaaaaaaaaaaaaaaaaaaaaaa3aaanarrow_key(const aaaaaaaaaaaaaaa1aaat *pointer_list, uint8_t key_number)
{
assert(key_number < pointer_list->number_of_keys);
return pointer_list->narrow_keys[key_number];
}
uint32_t aaaaaaaaaaaaaaa1aaaaaaaaaaaaaaaabaaaaaaaaaaaa3aaaaaaaaaaaaaaaabaaaaaaaaaaaaaaaaaaaaaaaaaaaa3aaaaaaaaaabaaaaaaaaaaa4aaa(const aaaaaaaaaaaaaaa1aaat *pointer_list)
{
return pointer_list->bucket;
}
bool aaaaaaaaaaaaaaa1aaaaaaaaaaaaaaabaaaaaaaaaaaa3aaaaaaaaaaaaaaaabaaaaaaaaaaaaaaaaaaaaaaaaaaaa3aaaaaaaaaaaaaaaabaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaa3aaaaaaaaaaaaaaaabaaaaaaaaaaaaaaaaaaaaaaaaaaaa4aaapointer(const aaaaaaaaaaaaaaa1aaat *pointer_list)
{
return pointer_list->is_direct_pointer;
}
#ifndef _STCAM_H_
#define _STCAM_H_
#ifdef __cplusplus
extern "C" {
#endif
struct stcam;
int
stcam_create(const cam_arg_t *cam_arg, struct stcam **out_stcam);
int stcam_insert(struct stcam *stcam, const uint8_t key[], const uint8_t mask[], uint32_t priority,
const uint8_t response[]);
int stcam_update(struct stcam *stcam, const uint8_t key[], const uint8_t mask[], const uint8_t response[]);
int stcam_get_by_response(struct stcam *stcam, const uint8_t response[], const uint8_t response_mask[], uint32_t *pos,
uint8_t out_key[], uint8_t out_mask[]);
int stcam_get_by_key(struct stcam *stcam, const uint8_t key[], const uint8_t mask[], uint32_t *priority,
uint8_t response[]);
int stcam_delete(struct stcam *stcam, const uint8_t key[], const uint8_t mask[]);
int stcam_lookup(struct stcam *stcam, const uint8_t key[], uint8_t response[]);
int stcam_read_and_clear_ecc_counters(struct stcam *stcam, uint32_t *corrected_single_bit_errors,
uint32_t *detected_double_bit_errors);
int stcam_read_and_clear_ecc_addresses(struct stcam *stcam, uint32_t *failing_address_single_bit_error,
uint32_t *failing_address_double_bit_error);
void stcam_destroy(struct stcam *stcam);
#ifdef __cplusplus
}
#endif
#endif
typedef struct a1aaat stcam;
static void stcam_print_entry(int error_code, char *function, struct stcam *stcam,
const uint8_t key[], const uint8_t mask[],
uint32_t *prio, const uint8_t response[], char *match)
{
a1aaat * client = (a1aaat *) stcam;
if (a1aaaaaaaaaaaaaaaabaaaaaaaaaaaa3aaaaaaaaaaaaaaaabaaaaaaaaaaaaaaaaaaaaaaaaaaaa3bbbbbbbbbbbbbbbbbbbbbbbbbbbbbbbbbbbbb3aaaaaaaaaaaaaaaabaaaaaaaaaaaaaaaaaaaaaaaaaaaa4aaaflags(client) & CAM_DEBUG_NO_ERROR_MSG)
return;
if (!error_code && !(a1aaaaaaaaaaaaaaaabaaaaaaaaaaaa3aaaaaaaaaaaaaaaabaaaaaaaaaaaaaaaaaaaaaaaaaaaa3bbbbbbbbbbbbbbbbbbbbbbbbbbbbbbbbbbbbb3aaaaaaaaaaaaaaaabaaaaaaaaaaaaaaaaaaaaaaaaaaaa4aaaflags(client) & CAM_DEBUG_ARGS))
return;
const uint16_t key_width = a1aaaaaaaaaaaaaaaabaaaaaaaaaaaa3aaaaaaaaaaaaaaaabaaaaaaaaaaaaaaaaaaaaaaaaaaaa3aaaaaaaaaaaaaaaabaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaa3aaaaaaaaaaaaaaaabaaaaaaaaaaaaaaaaaaaaaaaaaaaa4aaawidth(client);
const uint16_t prio_width = a1aaaaaaaaaaaaaaaabaaaaaaaaaaaa3aaaaaaaaaaaaaaaabaaaaaaaaaaaaaaaaaaaaaaaaaaaa3aaaaaaaaaaaaaaabaaaaaaaaaaaaaaaaa4aaaaaaaaaaaaaaaabaaaaaaaaaaaaaaaaaaaaaaaaaaaa4aaawidth(client);
const uint16_t response_width = a1aaaaaaaaaaaaaaaabaaaaaaaaaaaa3aaaaaaaaaaaaaaaabaaaaaaaaaaaaaaaaaaaaaaaaaaaa3aaaaaaaaaaaaaaaabaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaa3aaaaaaaaaaaaaaaabaaaaaaaaaaaaaaaaaaaaaaaaaaaa4aaawidth(client);
char message[1000];
cam_free_func free_function = a1aaaaaaaaaaaaaaaabaaaaaaaaaaaa3aaaaaaaaaaaaaaaabaaaaaaaaaaaaaaaaaaaaaaaaaaaa3aaaaaaaaaaaaaabaaaaaaaaaaaa4aaaaaaaaaaaaaaaabaaaaaaaaaaaaaaaaaaaaaaaaaaaa4aaaaaaaaaaaaaaaabaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaa4aaa((a1aaat*) (client));
cam_malloc_func malloc_function = a1aaaaaaaaaaaaaaaabaaaaaaaaaaaa3aaaaaaaaaaaaaaaabaaaaaaaaaaaaaaaaaaaaaaaaaaaa3aaamalloc_function(client);
char *key_str;
if (key != NULL) {
key_str = byte_arr_to_str(key_width, key, malloc_function);
} else {
       key_str = "N/A";
}
char *mask_str;
if (mask != NULL) {
mask_str = byte_arr_to_str(key_width, mask, malloc_function);
} else {
       mask_str = "N/A";
}
char *prio_str;
if (prio != NULL) {
prio_str = byte_arr_to_str(prio_width, (uint8_t *) prio, malloc_function);
} else {
       prio_str = "N/A";
}
char *response_str;
if (response != NULL) {
response_str = byte_arr_to_str(response_width, response, malloc_function);
} else {
       response_str = "N/A";
}
if (!error_code && (a1aaaaaaaaaaaaaaaabaaaaaaaaaaaa3aaaaaaaaaaaaaaaabaaaaaaaaaaaaaaaaaaaaaaaaaaaa3bbbbbbbbbbbbbbbbbbbbbbbbbbbbbbbbbbbbb3aaaaaaaaaaaaaaaabaaaaaaaaaaaaaaaaaaaaaaaaaaaa4aaaflags(client) & CAM_DEBUG_ARGS)) {
       sprintf(message, "%-22s key  = %s  response = %s  priority = %s  %8s\n%32s mask = %s",
               function, key_str, response_str, prio_str, match, " ", mask_str);
a1aaaaaaaaaaaaaaaabaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaa3aaaaaaaaaaaaaaaabaaaaaaaaaaaaaaaaaaaaaaaaaaaa4aaainfo(client, message);
}
if (error_code) {
       sprintf(message, "%-22s key  = %s  response = %s  priority = %s   %8s\n%32s mask = %s\n\n%10s%-22s num_entries = %0d   (%0d used)\n%32s num_masks = %0d\n%32s num_units = %0d  (%0d used)",
function, key_str, response_str, prio_str, cam_error_string(error_code),
               " ", mask_str,
               " ",
               "stcam resources", a1aaaaaaaaaaaaaaaabaaaaaaaaaaaa3aaaaaaaaaaaaaaaabaaaaaaaaaaaaaaaaaaaaaaaaaaaa3aaaaaaaaaaaaaaabaaaaaaaaaaaaaaaa4aaaaaaaaaaaaaaaabaaaaaaaaaaaaaaaaaaaaaaaaaaaa4aaaaaaaaaaaaaaaabaaaaaaaaaaaaaaaaaaaaa5aaa(client), a1aaaaaaaaaaaaaaaabaaaaaaaaaaaa3aaaaaaaaaaaaaaaabaaaaaaaaaaaaaaaaaaaaaaaaaaaa3aaacurrent_num_entries(client),
               " ", a1aaaaaaaaaaaaaaaabaaaaaaaaaaaa3aaaaaaaaaaaaaaaabaaaaaaaaaaaaaaaaaaaaaaaaaaaa3aaaaaaaaaaaaaaabaaaaaaaaaaaaaaaa4aaaaaaaaaaaaaaaabaaaaaaaaaaaaaaaaaaaaaaaaaaaa4aaaaaaaaaaaaaaaabaaaaaaaaaaaaaaaaaaaaaaa5aaas(client),
               " ", a1aaaaaaaaaaaaaaaabaaaaaaaaaaaa3aaaaaaaaaaaaaaaabaaaaaaaaaaaaaaaaaaaaaaaaaaaa3aaaaaaaaaaaaaaabaaaaaaaaaaaaaaaa4aaaaaaaaaaaaaaaabaaaaaaaaaaaaaaaaaaaaaaaaaaaa4aaaaaaaaaaaabaaaaaaaaaaaaaaaaa5aaas(client), a1aaaaaaaaaaaaaaaabaaaaaaaaaaaa3aaaaaaaaaaaaaaaabaaaaaaaaaaaaaaaaaaaaaaaaaaaa3aaacurrent_num_units(client));
a1aaaaaaaaaaaaaaaabaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaa3aaaaaaaaaaaaaaaabaaaaaaaaaaaaaaaaaaaaaaaaaaaa4aaaerror(client, message);
}
if (prio != NULL)
free_function(prio_str);
if (response != NULL)
free_function(response_str);
if (mask != NULL)
free_function(mask_str);
if (key != NULL)
free_function(key_str);
}
int
stcam_create(const cam_arg_t *cam_arg, struct stcam **out_stcam)
{
int rc;
cam_arg_t cam_arg_copy = *cam_arg;
a1aaat *client;
rc = a1bbbbbbbbbbbbbbbbbbbbbbbbbbbbbbbbbbbbbbb3aaaeate(&cam_arg_copy, STCAM, &client);
if (rc) {
if ((cam_arg->debug_flags & CAM_DEBUG_NO_ERROR_MSG) == 0) {
cam_print_error(rc);
}
return rc;
}
*out_stcam = (struct stcam*) client;
return 0;
}
int
stcam_update(struct stcam *stcam, const uint8_t key[], const uint8_t mask[], const uint8_t response[])
{
   stcam_print_entry(0, "stcam_update", stcam, key, mask, NULL, response, "");
aaaaaaaaaaaaa1aaat new_mask;
aaaaaaaaaaaaa1aaat new_key;
memset(&new_key, 0, sizeof(aaaaaaaaaaaaa1aaat));
memset(&new_mask, 0, sizeof(aaaaaaaaaaaaa1aaat));
const uint16_t key_width = a1aaaaaaaaaaaaaaaabaaaaaaaaaaaa3aaaaaaaaaaaaaaaabaaaaaaaaaaaaaaaaaaaaaaaaaaaa3aaaaaaaaaaaaaaaabaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaa3aaaaaaaaaaaaaaaabaaaaaaaaaaaaaaaaaaaaaaaaaaaa4aaawidth((a1aaat *) stcam);
cam_copy_bits((uint8_t *) &new_key.word[0], key, key_width);
cam_copy_bits((uint8_t *) &new_mask.word[0], mask, key_width);
if ((a1aaaaaaaaaaaaaaaabaaaaaaaaaaaa3aaaaaaaaaaaaaaaabaaaaaaaaaaaaaaaaaaaaaaaaaaaa3bbbbbbbbbbbbbbbbbbbbbbbbbbbbbbbbbbbbb3aaaaaaaaaaaaaaaabaaaaaaaaaaaaaaaaaaaaaaaaaaaa4aaaflags((a1aaat *) stcam) & CAM_DEBUG_KEY_MASKING) == 0) {
cam_mask_key(&new_key, &new_mask);
}
aaaaaaaaaaaaaaaa1aaaaaaaaaaaaaaaabaaaaaaaaaaaaaaaaaaaaaaaaaaaa3aaat new_response;
memset(&new_response, 0, sizeof(aaaaaaaaaaaaaaaa1aaaaaaaaaaaaaaaabaaaaaaaaaaaaaaaaaaaaaaaaaaaa3aaat));
const uint16_t response_width = a1aaaaaaaaaaaaaaaabaaaaaaaaaaaa3aaaaaaaaaaaaaaaabaaaaaaaaaaaaaaaaaaaaaaaaaaaa3aaaaaaaaaaaaaaaabaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaa3aaaaaaaaaaaaaaaabaaaaaaaaaaaaaaaaaaaaaaaaaaaa4aaawidth((a1aaat *) stcam);
cam_copy_bits((uint8_t *) &new_response.word[0], response, response_width);
cam_options_t *options = (cam_options_t *) alloca(cam_options_size());
cam_options_init(options);
const int rc = a1bbbbbbbbbbbbbbbbbbbb3aaaaaaaaaaaaaaaabaaaaaaaaaaaaaaaaaaaaaaaaaaaa4aaaaaaaaaaaaaaaabaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaa4aaa((a1aaat *) stcam, &new_key, &new_response, &new_mask, options);
if (rc) {
       stcam_print_entry(rc, "stcam_update", stcam, key, mask, NULL, response, "");
}
return rc;
}
int stcam_insert(struct stcam *stcam, const uint8_t key[], const uint8_t mask[], uint32_t priority,
const uint8_t response[])
{
   stcam_print_entry(0, "stcam_insert", stcam, key, mask, &priority, response, "");
const uint8_t prio_width = a1aaaaaaaaaaaaaaaabaaaaaaaaaaaa3aaaaaaaaaaaaaaaabaaaaaaaaaaaaaaaaaaaaaaaaaaaa3aaaaaaaaaaaaaaabaaaaaaaaaaaaaaaaa4aaaaaaaaaaaaaaaabaaaaaaaaaaaaaaaaaaaaaaaaaaaa4aaawidth((a1aaat *) stcam);
const uint64_t prio_range = ((uint64_t) priority) >> prio_width;
if (prio_range > 0) {
       stcam_print_entry(CAM_ERROR_WRONG_PRIO_WIDTH, "stcam_insert", stcam, key, mask, &priority, response, "");
return CAM_ERROR_WRONG_PRIO_WIDTH;
}
aaaaaaaaaaaaa1aaat new_mask;
aaaaaaaaaaaaa1aaat new_key;
memset(&new_key, 0, sizeof(aaaaaaaaaaaaa1aaat));
memset(&new_mask, 0, sizeof(aaaaaaaaaaaaa1aaat));
const uint16_t key_width = a1aaaaaaaaaaaaaaaabaaaaaaaaaaaa3aaaaaaaaaaaaaaaabaaaaaaaaaaaaaaaaaaaaaaaaaaaa3aaaaaaaaaaaaaaaabaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaa3aaaaaaaaaaaaaaaabaaaaaaaaaaaaaaaaaaaaaaaaaaaa4aaawidth((a1aaat *) stcam);
cam_copy_bits((uint8_t *) &new_key.word[0], key, key_width);
cam_copy_bits((uint8_t *) &new_mask.word[0], mask, key_width);
if ((a1aaaaaaaaaaaaaaaabaaaaaaaaaaaa3aaaaaaaaaaaaaaaabaaaaaaaaaaaaaaaaaaaaaaaaaaaa3bbbbbbbbbbbbbbbbbbbbbbbbbbbbbbbbbbbbb3aaaaaaaaaaaaaaaabaaaaaaaaaaaaaaaaaaaaaaaaaaaa4aaaflags((a1aaat *) stcam) & CAM_DEBUG_KEY_MASKING) == 0) {
cam_mask_key(&new_key, &new_mask);
}
aaaaaaaaaaaaaaaa1aaaaaaaaaaaaaaaabaaaaaaaaaaaaaaaaaaaaaaaaaaaa3aaat prio_resp;
const uint16_t response_width = a1aaaaaaaaaaaaaaaabaaaaaaaaaaaa3aaaaaaaaaaaaaaaabaaaaaaaaaaaaaaaaaaaaaaaaaaaa3aaaaaaaaaaaaaaaabaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaa3aaaaaaaaaaaaaaaabaaaaaaaaaaaaaaaaaaaaaaaaaaaa4aaawidth((a1aaat *) stcam);
memset(&prio_resp, 0, sizeof(aaaaaaaaaaaaaaaa1aaaaaaaaaaaaaaaabaaaaaaaaaaaaaaaaaaaaaaaaaaaa3aaat));
cam_copy_bits((uint8_t *) &prio_resp.word[0], response, response_width);
if (prio_width > 0) {
const uint32_t new_prio = priority;
cam_write_field((uint32_t *) &prio_resp, response_width, response_width + prio_width - 1, &new_prio,
CAM_MAX_aaaaaaaaaaaaaa1aaaaaaaaaaaaaaaabaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaa3aaaaaaaaaaaaaaaabaaaaaaaaaaaaaaaaaaaaaaaaaaaa4aaaWIDTH - 1);
}
cam_options_t *options = (cam_options_t *) alloca(cam_options_size());
cam_options_init(options);
const int rc = a1aaaaaaaaaaaaaaabaaaaaaaaaaaaaaaaaaa3aaaaaaaaaaaaaaaabaaaaaaaaaaaaaaaaaaaaaaaaaaaa3aaaaaaaaaaaaaaaabaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaa3aaa((a1aaat *) stcam, &new_key, &prio_resp, &new_mask, options);
if (rc) {
       stcam_print_entry(rc, "stcam_insert", stcam, key, mask, &priority, response, "");
}
return rc;
}
int
stcam_get_by_response(struct stcam *stcam, const uint8_t response[], const uint8_t response_mask[], uint32_t *pos,
uint8_t out_key[],
uint8_t out_mask[])
{
aaaaaaaaaaaaa1aaat old_mask, old_key;
aaaaaaaaaaaaaaaa1aaaaaaaaaaaaaaaabaaaaaaaaaaaaaaaaaaaaaaaaaaaa3aaat new_response;
memset(&new_response, 0, sizeof(aaaaaaaaaaaaaaaa1aaaaaaaaaaaaaaaabaaaaaaaaaaaaaaaaaaaaaaaaaaaa3aaat));
const uint16_t response_width = a1aaaaaaaaaaaaaaaabaaaaaaaaaaaa3aaaaaaaaaaaaaaaabaaaaaaaaaaaaaaaaaaaaaaaaaaaa3aaaaaaaaaaaaaaaabaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaa3aaaaaaaaaaaaaaaabaaaaaaaaaaaaaaaaaaaaaaaaaaaa4aaawidth((a1aaat *) stcam);
cam_copy_bits((uint8_t *) &new_response.word[0], response, response_width);
aaaaaaaaaaaaaaaa1aaaaaaaaaaaaaaaabaaaaaaaaaaaaaaaaaaaaaaaaaaaa3aaat new_response_mask;
memset(&new_response_mask, 0, sizeof(aaaaaaaaaaaaaaaa1aaaaaaaaaaaaaaaabaaaaaaaaaaaaaaaaaaaaaaaaaaaa3aaat));
cam_copy_bits((uint8_t *) &new_response_mask.word[0], response_mask, response_width);
const int rc = a1aaaread_response_for_key((a1aaat *) stcam, &new_response, &new_response_mask, pos, &old_key,
&old_mask, false);
if (rc) {
       stcam_print_entry(rc, "stcam_get_by_response", stcam, NULL, NULL, NULL, response, "");
return rc;
}
const uint16_t key_width = a1aaaaaaaaaaaaaaaabaaaaaaaaaaaa3aaaaaaaaaaaaaaaabaaaaaaaaaaaaaaaaaaaaaaaaaaaa3aaaaaaaaaaaaaaaabaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaa3aaaaaaaaaaaaaaaabaaaaaaaaaaaaaaaaaaaaaaaaaaaa4aaawidth((a1aaat *) stcam);
uint8_t num_bytes = key_width / 8;
const uint16_t remaining_bits = key_width - num_bytes * 8;
if (remaining_bits > 0) {
out_key[num_bytes] = aaaaaaaa1aaaaaaaaaaaaaaaabaaaaaaaaaaaaaaaaaaaaaa3aaa8(out_key[num_bytes], *((uint8_t *) &old_key + num_bytes), 0, remaining_bits);
out_mask[num_bytes] = aaaaaaaa1aaaaaaaaaaaaaaaabaaaaaaaaaaaaaaaaaaaaaa3aaa8(out_mask[num_bytes], *((uint8_t *) &old_mask + num_bytes), 0, remaining_bits);
}
memcpy(out_key, &old_key, num_bytes);
memcpy(out_mask, &old_mask, num_bytes);
   stcam_print_entry(0, "stcam_get_by_response", stcam, out_key, out_mask, NULL, response, "");
return 0;
}
int
stcam_get_by_key(struct stcam *stcam, const uint8_t key[], const uint8_t mask[], uint32_t *priority,
uint8_t response[])
{
aaaaaaaaaaaaa1aaat new_mask;
aaaaaaaaaaaaa1aaat new_key;
memset(&new_key, 0, sizeof(aaaaaaaaaaaaa1aaat));
memset(&new_mask, 0, sizeof(aaaaaaaaaaaaa1aaat));
const uint16_t key_width = a1aaaaaaaaaaaaaaaabaaaaaaaaaaaa3aaaaaaaaaaaaaaaabaaaaaaaaaaaaaaaaaaaaaaaaaaaa3aaaaaaaaaaaaaaaabaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaa3aaaaaaaaaaaaaaaabaaaaaaaaaaaaaaaaaaaaaaaaaaaa4aaawidth((a1aaat *) stcam);
cam_copy_bits((uint8_t *) &new_key.word[0], key, key_width);
cam_copy_bits((uint8_t *) &new_mask.word[0], mask, key_width);
if ((a1aaaaaaaaaaaaaaaabaaaaaaaaaaaa3aaaaaaaaaaaaaaaabaaaaaaaaaaaaaaaaaaaaaaaaaaaa3bbbbbbbbbbbbbbbbbbbbbbbbbbbbbbbbbbbbb3aaaaaaaaaaaaaaaabaaaaaaaaaaaaaaaaaaaaaaaaaaaa4aaaflags((a1aaat *) stcam) & CAM_DEBUG_KEY_MASKING) == 0) {
cam_mask_key(&new_key, &new_mask);
}
aaaaaaaaaaaaaaaa1aaaaaaaaaaaaaaaabaaaaaaaaaaaaaaaaaaaaaaaaaaaa3aaat old_response;
cam_options_t *options = (cam_options_t *) alloca(cam_options_size());
cam_options_init(options);
int rc = a1aaaread_key((a1aaat *) stcam, &new_key, &old_response, &new_mask, options);
if (rc) {
       stcam_print_entry(rc, "stcam_get_by_key", stcam, key, mask, NULL, NULL, "");
return rc;
}
const uint16_t response_width = a1aaaaaaaaaaaaaaaabaaaaaaaaaaaa3aaaaaaaaaaaaaaaabaaaaaaaaaaaaaaaaaaaaaaaaaaaa3aaaaaaaaaaaaaaaabaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaa3aaaaaaaaaaaaaaaabaaaaaaaaaaaaaaaaaaaaaaaaaaaa4aaawidth((a1aaat *) stcam);
const uint8_t prio_width = a1aaaaaaaaaaaaaaaabaaaaaaaaaaaa3aaaaaaaaaaaaaaaabaaaaaaaaaaaaaaaaaaaaaaaaaaaa3aaaaaaaaaaaaaaabaaaaaaaaaaaaaaaaa4aaaaaaaaaaaaaaaabaaaaaaaaaaaaaaaaaaaaaaaaaaaa4aaawidth((a1aaat *) stcam);
if (prio_width) {
cam_read_field((uint32_t *) &old_response, response_width, response_width + prio_width - 1, priority);
} else {
*priority = 0;
}
const uint8_t num_bytes = response_width / 8;
const uint16_t remaining_bits = response_width - num_bytes * 8;
if (remaining_bits > 0) {
response[num_bytes] = aaaaaaaa1aaaaaaaaaaaaaaaabaaaaaaaaaaaaaaaaaaaaaa3aaa8(response[num_bytes], *((uint8_t *) &old_response + num_bytes), 0,
remaining_bits);
}
memcpy(response, &old_response, num_bytes);
   stcam_print_entry(0, "stcam_get_by_key", stcam, key, mask, priority, response, "");
return 0;
}
int
stcam_delete(struct stcam *stcam, const uint8_t key[], const uint8_t mask[])
{
   stcam_print_entry(0, "stcam_delete", stcam, key, mask, NULL, NULL, "");
aaaaaaaaaaaaa1aaat new_mask;
aaaaaaaaaaaaa1aaat new_key;
memset(&new_key, 0, sizeof(aaaaaaaaaaaaa1aaat));
memset(&new_mask, 0, sizeof(aaaaaaaaaaaaa1aaat));
const uint16_t key_width = a1aaaaaaaaaaaaaaaabaaaaaaaaaaaa3aaaaaaaaaaaaaaaabaaaaaaaaaaaaaaaaaaaaaaaaaaaa3aaaaaaaaaaaaaaaabaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaa3aaaaaaaaaaaaaaaabaaaaaaaaaaaaaaaaaaaaaaaaaaaa4aaawidth((a1aaat *) stcam);
cam_copy_bits((uint8_t *) &new_key.word[0], key, key_width);
cam_copy_bits((uint8_t *) &new_mask.word[0], mask, key_width);
if ((a1aaaaaaaaaaaaaaaabaaaaaaaaaaaa3aaaaaaaaaaaaaaaabaaaaaaaaaaaaaaaaaaaaaaaaaaaa3bbbbbbbbbbbbbbbbbbbbbbbbbbbbbbbbbbbbb3aaaaaaaaaaaaaaaabaaaaaaaaaaaaaaaaaaaaaaaaaaaa4aaaflags((a1aaat *) stcam) & CAM_DEBUG_KEY_MASKING) == 0) {
cam_mask_key(&new_key, &new_mask);
}
cam_options_t *options = (cam_options_t *) alloca(cam_options_size());
cam_options_init(options);
const int rc = a1aaaaaaaaaaaaaaaabaaaaaaaaaaaaaaaaaaa3aaaaaaaaaaaaaaaabaaaaaaaaaaaaaaaaaaaaaaaaaaaa3aaaaaaaaaaaaaaaabaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaa3aaa((a1aaat *) stcam, &new_key, &new_mask, options);
if (rc) {
       stcam_print_entry(rc, "stcam_delete", stcam, key, mask, NULL, NULL, "");
}
return rc;
}
int stcam_lookup(struct stcam *stcam, const uint8_t key[], uint8_t response[])
{
int rc;
aaaaaaaaaaaaa1aaat new_key;
memset(&new_key, 0, sizeof(aaaaaaaaaaaaa1aaat));
const uint16_t key_width = a1aaaaaaaaaaaaaaaabaaaaaaaaaaaa3aaaaaaaaaaaaaaaabaaaaaaaaaaaaaaaaaaaaaaaaaaaa3aaaaaaaaaaaaaaaabaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaa3aaaaaaaaaaaaaaaabaaaaaaaaaaaaaaaaaaaaaaaaaaaa4aaawidth((a1aaat *) stcam);
cam_copy_bits((uint8_t *) &new_key.word[0], key, key_width);
aaaaaaaaaaaaaaaa1aaaaaaaaaaaaaaaabaaaaaaaaaaaaaaaaaaaaaaaaaaaa3aaat prio_resp;
rc = a1bbbbbbbbbbbbbbbbbbbbbb3aaaokup((a1aaat *) stcam, &new_key, &prio_resp, false);
if (rc == CAM_ERROR_KEY_NOT_FOUND) {
a1aaaaaaaaaaaaaaaabaaaaaaaaaaaa3aaaaaaaaaaaaaaaabaaaaaaaaaaaaaaaaaaaaaaaaaaaa3aaadefault_response((a1aaat *) stcam, (uint8_t *) &prio_resp, false);
}
else if (rc) {
       stcam_print_entry(rc, "stcam_lookup", stcam, key, NULL, NULL, NULL, "");
return rc;
}
const uint16_t response_width = a1aaaaaaaaaaaaaaaabaaaaaaaaaaaa3aaaaaaaaaaaaaaaabaaaaaaaaaaaaaaaaaaaaaaaaaaaa3aaaaaaaaaaaaaaaabaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaa3aaaaaaaaaaaaaaaabaaaaaaaaaaaaaaaaaaaaaaaaaaaa4aaawidth((a1aaat *) stcam);
const uint8_t num_bytes = response_width / 8;
const uint16_t remaining_bits = response_width - num_bytes * 8;
if (remaining_bits > 0) {
response[num_bytes] = aaaaaaaa1aaaaaaaaaaaaaaaabaaaaaaaaaaaaaaaaaaaaaa3aaa8(response[num_bytes], *((uint8_t *) &prio_resp + num_bytes), 0, remaining_bits);
}
memcpy(response, &prio_resp, num_bytes);
uint32_t prio;
const uint8_t prio_width = a1aaaaaaaaaaaaaaaabaaaaaaaaaaaa3aaaaaaaaaaaaaaaabaaaaaaaaaaaaaaaaaaaaaaaaaaaa3aaaaaaaaaaaaaaabaaaaaaaaaaaaaaaaa4aaaaaaaaaaaaaaaabaaaaaaaaaaaaaaaaaaaaaaaaaaaa4aaawidth((a1aaat *) stcam);
if (prio_width) {
cam_read_field((uint32_t *) &prio_resp, response_width, response_width + prio_width - 1, &prio);
} else {
prio = 0;
}
   stcam_print_entry(0, "stcam_lookup", stcam, key, NULL, &prio, response, rc ? "NO_MATCH" : "MATCH");
return rc;
}
int stcam_read_and_clear_ecc_counters(struct stcam *stcam, uint32_t *corrected_single_bit_errors,
uint32_t *detected_double_bit_errors)
{
return a1aaaread_and_clear_ecc_counters((a1aaat *) stcam, corrected_single_bit_errors,
detected_double_bit_errors);
}
int stcam_read_and_clear_ecc_addresses(struct stcam *stcam, uint32_t *failing_address_single_bit_error,
uint32_t *failing_address_double_bit_error)
{
return a1aaaread_and_clear_ecc_addresses((a1aaat *) stcam, failing_address_single_bit_error,
failing_address_double_bit_error);
}
void
stcam_destroy(struct stcam *stcam)
{
a1aaaaaaaaaaaaaaaabaaaaaaaaaaaaaaaaaaaaaaaaa3aaa((a1aaat *) stcam);
}
static void tcam_print_entry(int error_code, char *function, struct tcam *tcam,
const uint8_t key[], const uint8_t mask[],
uint32_t *prio, const uint8_t response[], char *match)
{
if (a1aaaaaaaaaaaaaaaabaaaaaaaaaaaa3aaaaaaaaaaaaaaaabaaaaaaaaaaaaaaaaaaaaaaaaaaaa3bbbbbbbbbbbbbbbbbbbbbbbbbbbbbbbbbbbbb3aaaaaaaaaaaaaaaabaaaaaaaaaaaaaaaaaaaaaaaaaaaa4aaaflags(tcam->client) & CAM_DEBUG_NO_ERROR_MSG)
return;
if (!error_code && !(a1aaaaaaaaaaaaaaaabaaaaaaaaaaaa3aaaaaaaaaaaaaaaabaaaaaaaaaaaaaaaaaaaaaaaaaaaa3bbbbbbbbbbbbbbbbbbbbbbbbbbbbbbbbbbbbb3aaaaaaaaaaaaaaaabaaaaaaaaaaaaaaaaaaaaaaaaaaaa4aaaflags(tcam->client) & CAM_DEBUG_ARGS))
return;
const uint16_t key_width = a1aaaaaaaaaaaaaaaabaaaaaaaaaaaa3aaaaaaaaaaaaaaaabaaaaaaaaaaaaaaaaaaaaaaaaaaaa3aaaaaaaaaaaaaaaabaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaa3aaaaaaaaaaaaaaaabaaaaaaaaaaaaaaaaaaaaaaaaaaaa4aaawidth(tcam->client);
const uint16_t prio_width = a1aaaaaaaaaaaaaaaabaaaaaaaaaaaa3aaaaaaaaaaaaaaaabaaaaaaaaaaaaaaaaaaaaaaaaaaaa3aaaaaaaaaaaaaaabaaaaaaaaaaaaaaaaa4aaaaaaaaaaaaaaaabaaaaaaaaaaaaaaaaaaaaaaaaaaaa4aaawidth(tcam->client);
const uint16_t response_width = a1aaaaaaaaaaaaaaaabaaaaaaaaaaaa3aaaaaaaaaaaaaaaabaaaaaaaaaaaaaaaaaaaaaaaaaaaa3aaaaaaaaaaaaaaaabaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaa3aaaaaaaaaaaaaaaabaaaaaaaaaaaaaaaaaaaaaaaaaaaa4aaawidth(tcam->client);
char message[1000];
cam_free_func free_function = a1aaaaaaaaaaaaaaaabaaaaaaaaaaaa3aaaaaaaaaaaaaaaabaaaaaaaaaaaaaaaaaaaaaaaaaaaa3aaaaaaaaaaaaaabaaaaaaaaaaaa4aaaaaaaaaaaaaaaabaaaaaaaaaaaaaaaaaaaaaaaaaaaa4aaaaaaaaaaaaaaaabaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaa4aaa(tcam->client);
cam_malloc_func malloc_function = a1aaaaaaaaaaaaaaaabaaaaaaaaaaaa3aaaaaaaaaaaaaaaabaaaaaaaaaaaaaaaaaaaaaaaaaaaa3aaamalloc_function(tcam->client);
char *key_str;
if (key != NULL) {
key_str = byte_arr_to_str(key_width, key, malloc_function);
} else {
       key_str = "N/A";
}
char *mask_str;
if (mask != NULL) {
mask_str = byte_arr_to_str(key_width, mask, malloc_function);
} else {
       mask_str = "N/A";
}
char *prio_str;
if (prio != NULL) {
prio_str = byte_arr_to_str(prio_width, (uint8_t *) prio, malloc_function);
} else {
       prio_str = "N/A";
}
char *response_str;
if (response != NULL) {
response_str = byte_arr_to_str(response_width, response, malloc_function);
} else {
       response_str = "N/A";
}
if (!error_code && (a1aaaaaaaaaaaaaaaabaaaaaaaaaaaa3aaaaaaaaaaaaaaaabaaaaaaaaaaaaaaaaaaaaaaaaaaaa3bbbbbbbbbbbbbbbbbbbbbbbbbbbbbbbbbbbbb3aaaaaaaaaaaaaaaabaaaaaaaaaaaaaaaaaaaaaaaaaaaa4aaaflags(tcam->client) & CAM_DEBUG_ARGS)) {
       sprintf(message, "%-22s key  = %s  response = %s  priority = %s  %8s\n%32s mask = %s",
               function, key_str, response_str, prio_str, match, " ", mask_str);
a1aaaaaaaaaaaaaaaabaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaa3aaaaaaaaaaaaaaaabaaaaaaaaaaaaaaaaaaaaaaaaaaaa4aaainfo(tcam->client, message);
}
if (error_code && ((a1aaaaaaaaaaaaaaaabaaaaaaaaaaaa3aaaaaaaaaaaaaaaabaaaaaaaaaaaaaaaaaaaaaaaaaaaa3bbbbbbbbbbbbbbbbbbbbbbbbbbbbbbbbbbbbb3aaaaaaaaaaaaaaaabaaaaaaaaaaaaaaaaaaaaaaaaaaaa4aaaflags(tcam->client) & CAM_DEBUG_NO_ERROR_MSG) == 0)) {
       sprintf(message, "%-22s key  = %s  response = %s  priority = %s  %8s\n%32s mask = %s",
               function, key_str, response_str, prio_str, cam_error_string(error_code), " ", mask_str);
a1aaaaaaaaaaaaaaaabaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaa3aaaaaaaaaaaaaaaabaaaaaaaaaaaaaaaaaaaaaaaaaaaa4aaaerror(tcam->client, message);
}
if (prio != NULL)
free_function(prio_str);
if (response != NULL)
free_function(response_str);
if (mask != NULL)
free_function(mask_str);
if (key != NULL)
free_function(key_str);
}
int
tcam_create(const cam_arg_t *cam_arg, struct tcam **out_tcam)
{
int rc;
cam_arg_t cam_arg_copy = *cam_arg;
struct tcam *tcam;
a1aaat *client;
rc = a1bbbbbbbbbbbbbbbbbbbbbbbbbbbbbbbbbbbbbbb3aaaeate(&cam_arg_copy, TCAM, &client);
if (rc) {
if ((cam_arg->debug_flags & CAM_DEBUG_NO_ERROR_MSG) == 0) {
cam_print_error(rc);
}
return rc;
}
rc = aaaaa1aaaaaaaa1bbbbbbbbbbbbbbbbbbbbbbbbbbbbbbbbbbbbbbb3aaaeate(client, &tcam);
if (rc) {
if ((a1aaaaaaaaaaaaaaaabaaaaaaaaaaaa3aaaaaaaaaaaaaaaabaaaaaaaaaaaaaaaaaaaaaaaaaaaa3bbbbbbbbbbbbbbbbbbbbbbbbbbbbbbbbbbbbb3aaaaaaaaaaaaaaaabaaaaaaaaaaaaaaaaaaaaaaaaaaaa4aaaflags(client) & CAM_DEBUG_NO_ERROR_MSG) == 0) {
cam_print_error(rc);
}
return rc;
}
if ((a1aaaaaaaaaaaaaaaabaaaaaaaaaaaa3aaaaaaaaaaaaaaaabaaaaaaaaaaaaaaaaaaaaaaaaaaaa3bbbbbbbbbbbbbbbbbbbbbbbbbbbbbbbbbbbbb3aaaaaaaaaaaaaaaabaaaaaaaaaaaaaaaaaaaaaaaaaaaa4aaaflags(client) & CAM_DEBUG_NO_ERROR_MSG) == 0) {
rc = aaaaa1bbbbbbbbbbbbbbbbbbbbbbbbbbbbbbbbbbbbb3aaaaaaaaaaaaaaaabaaaaaaaaaaaaaaaaaaaaaaaaaaaa4bbbbbbbbbbbbbbbbbb4aaaaaaaaaaaaaaaabaaaaaaaaaaaaaaaaaaaaaaaaaaaa5aaaaaaaaaaaaaaaabaaaaaaaaaaaaaaaaaaaaaaa6aaa(tcam, aaaaa1bbbbbbbbbbbbbbbbbbbbbbbbbbbbbbbbbbbbb3aaaaaaaaaaaaaaaabaaaaaaaaaaaaaaaaaaaaaaaaaaaa4aaaTEST | aaaaa1bbbbbbbbbbbbbbbbbbbbbbbbbbbbbbbbbbbbb3aaaaaaaaaaaaaaaabaaaaaaaaaaaaaaaaaaaaaaaaaaaa4bbbbbbbbbbbbbbbbbbbbbbbbbbbbbbbb4aaaaaaaaaaaaaaaabaaaaaaaaaaaaaaaaaaaaaaaaaaaa5aaaDEL);
} else {
rc = aaaaa1bbbbbbbbbbbbbbbbbbbbbbbbbbbbbbbbbbbbb3aaaaaaaaaaaaaaaabaaaaaaaaaaaaaaaaaaaaaaaaaaaa4bbbbbbbbbbbbbbbbbb4aaaaaaaaaaaaaaaabaaaaaaaaaaaaaaaaaaaaaaaaaaaa5aaaaaaaaaaaaaaaabaaaaaaaaaaaaaaaaaaaaaaa6aaa(tcam, aaaaa1bbbbbbbbbbbbbbbbbbbbbbbbbbbbbbbbbbbbb3aaaaaaaaaaaaaaaabaaaaaaaaaaaaaaaaaaaaaaaaaaaa4aaaTEST);
}
if (rc)
return rc;
*out_tcam = tcam;
return 0;
}
int
tcam_insert(struct tcam *tcam, const uint8_t key[], const uint8_t mask[], uint32_t prio,
const uint8_t response[])
{
   tcam_print_entry(0, "tcam_insert", tcam, key, mask, &prio, response, "");
int rc;
union aaaaaaaaaaa1aaa fields[CAM_MAX_NUM_FIELDS];
memset(fields, 0, sizeof(union aaaaaaaaaaa1aaa) * CAM_MAX_NUM_FIELDS);
rc = cam_key2fields(tcam, &fields[0], key);
if (rc) {
       tcam_print_entry(rc, "tcam_insert", tcam, key, mask, &prio, response, "");
return rc;
}
rc = cam_mask2fields(tcam->client, &fields[0], mask);
if (rc) {
       tcam_print_entry(rc, "tcam_insert", tcam, key, mask, &prio, response, "");
return rc;
}
if ((a1aaaaaaaaaaaaaaaabaaaaaaaaaaaa3aaaaaaaaaaaaaaaabaaaaaaaaaaaaaaaaaaaaaaaaaaaa3bbbbbbbbbbbbbbbbbbbbbbbbbbbbbbbbbbbbb3aaaaaaaaaaaaaaaabaaaaaaaaaaaaaaaaaaaaaaaaaaaa4aaaflags(tcam->client) & CAM_DEBUG_KEY_MASKING) == 0) {
cam_mask_fields(tcam, fields);
}
rc = cam_check_fields(tcam, fields);
if (rc) {
       tcam_print_entry(rc, "tcam_insert", tcam, key, mask, &prio, response, "");
return rc;
}
const uint8_t prio_width = a1aaaaaaaaaaaaaaaabaaaaaaaaaaaa3aaaaaaaaaaaaaaaabaaaaaaaaaaaaaaaaaaaaaaaaaaaa3aaaaaaaaaaaaaaabaaaaaaaaaaaaaaaaa4aaaaaaaaaaaaaaaabaaaaaaaaaaaaaaaaaaaaaaaaaaaa4aaawidth(tcam->client);
const uint64_t prio_range = ((uint64_t) prio) >> prio_width;
if (prio_range > 0) {
rc = CAM_ERROR_WRONG_PRIO_WIDTH;
       tcam_print_entry(rc, "tcam_insert", tcam, key, mask, &prio, response, "");
return rc;
}
const uint32_t max_num_entries = a1aaaaaaaaaaaaaaaabaaaaaaaaaaaa3aaaaaaaaaaaaaaaabaaaaaaaaaaaaaaaaaaaaaaaaaaaa3aaaaaaaaaaaaaaabaaaaaaaaaaaaaaaa4aaaaaaaaaaaaaaaabaaaaaaaaaaaaaaaaaaaaaaaaaaaa4aaaaaaaaaaaaaaaabaaaaaaaaaaaaaaaaaaaaa5aaa(tcam->client);
if (tcam->num_entries == max_num_entries) {
rc = CAM_ERROR_FULL;
       tcam_print_entry(rc, "tcam_insert", tcam, key, mask, &prio, response, "");
return rc;
}
struct aaaaa1aaaaaaaaaaaabaaaaaaaaaaa3aaa *me;
const uint8_t num_fields = a1aaaaaaaaaaaaaaaabaaaaaaaaaaaa3aaaaaaaaaaaaaaaabaaaaaaaaaaaaaaaaaaaaaaaaaaaa3aaaaaaaaaaaaaaabaaaaaaaaaaaaaaaa4aaaaaaaaaaaaaaaabaaaaaaaaaaaaaaaaaaaaaaaaaaaa4aaaaaaaaaaaaaaabaaaaaaaaaaaaaaaaaa5aaas(tcam->client);
MH_FIND(mh_handle, tcam->entry_by_fields, fields, num_fields * sizeof(union aaaaaaaaaaa1aaa), me);
if (me != NULL) {
rc = CAM_ERROR_DUPLICATE_FOUND;
       tcam_print_entry(rc, "tcam_insert", tcam, key, mask, &prio, response, "");
return rc;
}
uint16_t id;
for (id = 0; id < max_num_entries; id++) {
if (tcam->entries[id] == 0)
break;
}
aaaaaaaaaaaaaaaa1aaaaaaaaaaaaaaaabaaaaaaaaaaaaaaaaaaaaaaaaaaaa3aaat prio_resp;
const uint16_t response_width = a1aaaaaaaaaaaaaaaabaaaaaaaaaaaa3aaaaaaaaaaaaaaaabaaaaaaaaaaaaaaaaaaaaaaaaaaaa3aaaaaaaaaaaaaaaabaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaa3aaaaaaaaaaaaaaaabaaaaaaaaaaaaaaaaaaaaaaaaaaaa4aaawidth(tcam->client);
memset(&prio_resp, 0, sizeof(aaaaaaaaaaaaaaaa1aaaaaaaaaaaaaaaabaaaaaaaaaaaaaaaaaaaaaaaaaaaa3aaat));
cam_copy_bits((uint8_t *) &prio_resp.word[0], response, response_width);
if (prio_width > 0) {
const uint32_t new_prio = prio;
cam_write_field((uint32_t *) &prio_resp, response_width, response_width + prio_width - 1, &new_prio,
CAM_MAX_aaaaaaaaaaaaaa1aaaaaaaaaaaaaaaabaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaa3aaaaaaaaaaaaaaaabaaaaaaaaaaaaaaaaaaaaaaaaaaaa4aaaWIDTH - 1);
}
rc = aaaaa1aaaaaaaaaaaabaaaaaaaaaaa3aaaaaaaaaaaaaaaabaaaaaaaaaaaaaaaaaaaaaaaaaaaa3bbbbbbbbbbbbbbbbbbbbbbbbbbbbbbbbbbbbbbb3aaaeate(tcam, id, &fields[0], &prio_resp, &me);
if (rc) {
       tcam_print_entry(rc, "tcam_insert", tcam, key, mask, &prio, response, "");
return rc;
}
tcam->entries[me->id] = me;
tcam->num_entries++;
rc = aaaaa1aaaaaaaaaaaaaaaabaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaa3aaaaaaaaaaaaaaaabaaaaaaaaaaaaaaaaaaaaaaaaaaaa4bbbbbbbbbbbbbbbbbbbbbbbbbbbbbbbb4aaa(tcam, me);
if (rc)
goto error;
tcam->stats.curr_num_entries++;
tcam->stats.max_num_entries = MAX(tcam->stats.curr_num_entries,
tcam->stats.max_num_entries);
return rc;
error: (void) aaaaa1aaaaaaaaaaaabaaaaaaaaaaa3aaaaaaaaaaaaaaaabaaaaaaaaaaaaaaaaaaaaaaaaaaaa3aaaaaaaaaaaaaaaabaaaaaaaaaaaaaaaaaaaaaaaaa4aaa(tcam, me);
tcam->num_entries--;
   tcam_print_entry(rc, "tcam_insert", tcam, key, mask, &prio, response, "");
return rc;
}
int
tcam_update(struct tcam *tcam, const uint8_t key[], const uint8_t mask[], const uint8_t response[])
{
   tcam_print_entry(0, "tcam_update", tcam, key, mask, NULL, response, "");
int rc;
union aaaaaaaaaaa1aaa fields[CAM_MAX_NUM_FIELDS];
memset(fields, 0, sizeof(union aaaaaaaaaaa1aaa) * CAM_MAX_NUM_FIELDS);
rc = cam_key2fields(tcam, fields, key);
if (rc) {
       tcam_print_entry(rc, "tcam_update", tcam, key, mask, NULL, response, "");
return rc;
}
rc = cam_mask2fields(tcam->client, fields, mask);
if (rc) {
       tcam_print_entry(rc, "tcam_update", tcam, key, mask, NULL, response, "");
return rc;
}
if ((a1aaaaaaaaaaaaaaaabaaaaaaaaaaaa3aaaaaaaaaaaaaaaabaaaaaaaaaaaaaaaaaaaaaaaaaaaa3bbbbbbbbbbbbbbbbbbbbbbbbbbbbbbbbbbbbb3aaaaaaaaaaaaaaaabaaaaaaaaaaaaaaaaaaaaaaaaaaaa4aaaflags(tcam->client) & CAM_DEBUG_KEY_MASKING) == 0) {
cam_mask_fields(tcam, fields);
}
rc = cam_check_fields(tcam, fields);
if (rc) {
       tcam_print_entry(rc, "tcam_update", tcam, key, mask, NULL, response, "");
return rc;
}
struct aaaaa1aaaaaaaaaaaabaaaaaaaaaaa3aaa *me;
const uint8_t num_fields = a1aaaaaaaaaaaaaaaabaaaaaaaaaaaa3aaaaaaaaaaaaaaaabaaaaaaaaaaaaaaaaaaaaaaaaaaaa3aaaaaaaaaaaaaaabaaaaaaaaaaaaaaaa4aaaaaaaaaaaaaaaabaaaaaaaaaaaaaaaaaaaaaaaaaaaa4aaaaaaaaaaaaaaabaaaaaaaaaaaaaaaaaa5aaas(tcam->client);
MH_FIND(mh_handle, tcam->entry_by_fields, fields, num_fields * sizeof(union aaaaaaaaaaa1aaa), me);
if (me == NULL) {
rc = CAM_ERROR_KEY_NOT_FOUND;
       tcam_print_entry(rc, "tcam_update", tcam, key, mask, NULL, response, "");
return rc;
}
const uint16_t response_width = a1aaaaaaaaaaaaaaaabaaaaaaaaaaaa3aaaaaaaaaaaaaaaabaaaaaaaaaaaaaaaaaaaaaaaaaaaa3aaaaaaaaaaaaaaaabaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaa3aaaaaaaaaaaaaaaabaaaaaaaaaaaaaaaaaaaaaaaaaaaa4aaawidth(tcam->client);
cam_write_field((uint32_t *) &me->priority.word[0], 0, response_width - 1, (uint32_t *) response, 
CAM_MAX_aaaaaaaaaaaaaa1aaaaaaaaaaaaaaaabaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaa3aaaaaaaaaaaaaaaabaaaaaaaaaaaaaaaaaaaaaaaaaaaa4aaaWIDTH - 1);
rc = aaaaa1aaaaaaaaaaaaaaaabaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaa3aaaaaaaaaaaaaaaabaaaaaaaaaaaaaaaaaaaaaaaaaaaa4bbbbbbbbbbbbbbbbbbbbbbbbbbbbbbbb4aaa(tcam, me, me->current_entryset.mes,
me->current_entryset.instance,
me->current_entryset.collset);
if (rc) {
       tcam_print_entry(rc, "tcam_update", tcam, key, mask, NULL, response, "");
return rc;
}
return 0;
}
int
tcam_get_by_response(struct tcam *tcam, const uint8_t response[], const uint8_t response_mask[],
uint32_t *pos, uint8_t out_key[], uint8_t out_mask[])
{
int rc;
aaaaaaaaaaaaa1aaat old_key;
aaaaaaaaaaaaa1aaat ternary_mask;
aaaaaaaaaaaaa1aaat relaxed_mask;
uint8_t range_valid;
uint8_t mask_id;
aaaaaaaaaaaaaaaa1aaaaaaaaaaaaaaaabaaaaaaaaaaaaaaaaaaaaaaaaaaaa3aaat new_response;
memset(&new_response, 0, sizeof(aaaaaaaaaaaaaaaa1aaaaaaaaaaaaaaaabaaaaaaaaaaaaaaaaaaaaaaaaaaaa3aaat));
const uint16_t response_width = a1aaaaaaaaaaaaaaaabaaaaaaaaaaaa3aaaaaaaaaaaaaaaabaaaaaaaaaaaaaaaaaaaaaaaaaaaa3aaaaaaaaaaaaaaaabaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaa3aaaaaaaaaaaaaaaabaaaaaaaaaaaaaaaaaaaaaaaaaaaa4aaawidth(tcam->client);
cam_copy_bits((uint8_t *) &new_response.word[0], response, response_width);
aaaaaaaaaaaaaaaa1aaaaaaaaaaaaaaaabaaaaaaaaaaaaaaaaaaaaaaaaaaaa3aaat new_response_mask;
memset(&new_response_mask, 0, sizeof(aaaaaaaaaaaaaaaa1aaaaaaaaaaaaaaaabaaaaaaaaaaaaaaaaaaaaaaaaaaaa3aaat));
cam_copy_bits((uint8_t *) &new_response_mask.word[0], response_mask, response_width);
rc = a1aaaread_prio_for_range_key(tcam->client, &new_response, &new_response_mask, pos, &old_key, &ternary_mask,
&relaxed_mask, &range_valid, &mask_id);
if (rc)
return rc;
const uint8_t num_fields = a1aaaaaaaaaaaaaaaabaaaaaaaaaaaa3aaaaaaaaaaaaaaaabaaaaaaaaaaaaaaaaaaaaaaaaaaaa3aaaaaaaaaaaaaaabaaaaaaaaaaaaaaaa4aaaaaaaaaaaaaaaabaaaaaaaaaaaaaaaaaaaaaaaaaaaa4aaaaaaaaaaaaaaabaaaaaaaaaaaaaaaaaa5aaas(tcam->client);
const uint32_t num_entries = a1aaaaaaaaaaaaaaaabaaaaaaaaaaaa3aaaaaaaaaaaaaaaabaaaaaaaaaaaaaaaaaaaaaaaaaaaa3aaaaaaaaaaaaaaabaaaaaaaaaaaaaaaa4aaaaaaaaaaaaaaaabaaaaaaaaaaaaaaaaaaaaaaaaaaaa4aaaaaaaaaaaaaaaabaaaaaaaaaaaaaaaaaaaaa5aaa(tcam->client);
int i;
int found = 0;
struct aaaaa1aaaaaaaaaaaabaaaaaaaaaaa3aaa *me;
for (i = 0; i < num_entries; i++) {
if (tcam->entries[i] == 0)
continue;
me = tcam->entries[i];
bool match = true;
for (uint16_t i = 0; i < CAM_MAX_aaaaaaaaaaaaaa1aaaaaaaaaaaaaaaabaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaa3aaaaaaaaaaaaaaaabaaaaaaaaaaaaaaaaaaaaaaaaaaaa4aaaWIDTH_MEM; i++) {
if ((me->priority.word[i] & new_response_mask.word[i])
!= (new_response.word[i] & new_response_mask.word[i])) {
match = false;
}
}
if (match == false)
continue;
if (memcmp(&me->current_entryset.mes->mask.mask.word[0], &relaxed_mask, sizeof(aaaaaaaaaaaaa1aaat)))
continue;
if (me->current_entryset.instance != mask_id)
continue;
if (memcmp(&me->exact_key.word[0], &old_key, sizeof(aaaaaaaaaaaaa1aaat)))
continue;
if (me->current_entryset.mes->mask.use_range != range_valid)
continue;
int field;
for (field = 0; field < num_fields; field++) {
aaaaaaaaaaa1aaaaaaaaaaaaaaaabaaaaaaaaaaaaaaaaaaaaaaaaaaaa3aaadesc mfd;
rc = a1aaaaaaaaaaaaaaaabaaaaaaaaaaaa3aaaaaaaaaaaaaaaabaaaaaaaaaaaaaaaaaaaaaaaaaaaa3aaaaaaaaaaaaaaaaaaaaa1aaa(tcam->client, field, &mfd);
assert(rc == 0);
if (mfd.type != aaaaaaaaaaa1aaaaaaaaaaaaaaaabaaaaaaaaaaaaaaaaaaaaaaaaaaaa3aaaR16 || (range_valid & 1 << mfd.instance) == 0)
continue;
uint16_t end = 0;
cam_read_field8((uint8_t *) &end, (uint8_t *) &ternary_mask.word[0], mfd.start_pos,
mfd.len);
if (me->fields[field].r16.end != end)
goto cont;
}
found = 1;
break;
cont: continue;
}
if (!found)
return CAM_ERROR_KEY_NOT_FOUND;
uint8_t temp_ternary_mask[CAM_MAX_KEY_WIDTH / 8 + 1];
uint8_t temp_key[CAM_MAX_KEY_WIDTH / 8 + 1];
memset(temp_key, 0, CAM_MAX_KEY_WIDTH / 8 + 1);
memset(temp_ternary_mask, 0, CAM_MAX_KEY_WIDTH / 8 + 1);
rc = aaaaaaaaaaa1aaas2key(tcam, me->fields, temp_key);
assert(rc == 0);
rc = aaaaaaaaaaa1aaas2mask(tcam, me->fields, temp_ternary_mask);
assert(rc == 0);
const uint16_t key_width = a1aaaaaaaaaaaaaaaabaaaaaaaaaaaa3aaaaaaaaaaaaaaaabaaaaaaaaaaaaaaaaaaaaaaaaaaaa3aaaaaaaaaaaaaaaabaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaa3aaaaaaaaaaaaaaaabaaaaaaaaaaaaaaaaaaaaaaaaaaaa4aaawidth(tcam->client);
uint8_t num_bytes = key_width / 8;
assert(num_bytes > 0);
uint8_t rem_bits = key_width - num_bytes * 8;
if (rem_bits) {
out_key[num_bytes] = aaaaaaaa1aaaaaaaaaaaaaaaabaaaaaaaaaaaaaaaaaaaaaa3aaa8(out_key[num_bytes], temp_key[num_bytes], 0, rem_bits);
out_mask[num_bytes] = aaaaaaaa1aaaaaaaaaaaaaaaabaaaaaaaaaaaaaaaaaaaaaa3aaa8(out_mask[num_bytes], temp_ternary_mask[num_bytes], 0, rem_bits);
}
memcpy(out_key, temp_key, num_bytes);
memcpy(out_mask, temp_ternary_mask, num_bytes);
   tcam_print_entry(0, "tcam_get_by_response", tcam, out_key, out_mask, NULL, response, "");
return 0;
}
int
tcam_get_by_key(struct tcam *tcam, const uint8_t key[], const uint8_t mask[], uint32_t * prio, uint8_t response[])
{
int rc;
union aaaaaaaaaaa1aaa fields[CAM_MAX_NUM_FIELDS];
memset(fields, 0, sizeof(union aaaaaaaaaaa1aaa) * CAM_MAX_NUM_FIELDS);
rc = cam_key2fields(tcam, fields, key);
if (rc) {
       tcam_print_entry(rc, "tcam_get_by_key", tcam, key, mask, NULL, NULL, "");
return rc;
}
rc = cam_mask2fields(tcam->client, fields, mask);
if (rc) {
       tcam_print_entry(rc, "tcam_get_by_key", tcam, key, mask, NULL, NULL, "");
return rc;
}
if ((a1aaaaaaaaaaaaaaaabaaaaaaaaaaaa3aaaaaaaaaaaaaaaabaaaaaaaaaaaaaaaaaaaaaaaaaaaa3bbbbbbbbbbbbbbbbbbbbbbbbbbbbbbbbbbbbb3aaaaaaaaaaaaaaaabaaaaaaaaaaaaaaaaaaaaaaaaaaaa4aaaflags(tcam->client) & CAM_DEBUG_KEY_MASKING) == 0) {
cam_mask_fields(tcam, fields);
}
rc = cam_check_fields(tcam, fields);
if (rc) {
       tcam_print_entry(rc, "tcam_get_by_key", tcam, key, mask, NULL, NULL, "");
return rc;
}
struct aaaaa1aaaaaaaaaaaabaaaaaaaaaaa3aaa *me;
struct aaaaa1aaaaaaaaaaaabaaaaaaaaaaa3bbbbbbbbbbbbbbbbbb3aaa *mes;
const uint8_t num_fields = a1aaaaaaaaaaaaaaaabaaaaaaaaaaaa3aaaaaaaaaaaaaaaabaaaaaaaaaaaaaaaaaaaaaaaaaaaa3aaaaaaaaaaaaaaabaaaaaaaaaaaaaaaa4aaaaaaaaaaaaaaaabaaaaaaaaaaaaaaaaaaaaaaaaaaaa4aaaaaaaaaaaaaaabaaaaaaaaaaaaaaaaaa5aaas(tcam->client);
MH_FIND(mh_handle, tcam->entry_by_fields, fields, num_fields * sizeof(union aaaaaaaaaaa1aaa), me);
if (me == NULL) {
rc = CAM_ERROR_KEY_NOT_FOUND;
       tcam_print_entry(rc, "tcam_get_by_key", tcam, key, mask, NULL, NULL, "");
return rc;
}
mes = me->current_entryset.mes;
aaaaaaaaaaaaa1aaat new_key;
aaaaaaaaaaaaa1aaat relaxed_mask;
aaaaaaaaaaaaa1aaat ternary_mask;
memset(&new_key, 0, sizeof(new_key));
memset(&relaxed_mask, 0, sizeof(relaxed_mask));
memset(&ternary_mask, 0, sizeof(ternary_mask));
memcpy(&new_key, &me->exact_key.word[0], sizeof(aaaaaaaaaaaaa1aaat));
memcpy(&relaxed_mask, &mes->mask.mask.word[0], sizeof(aaaaaaaaaaaaa1aaat));
memcpy(&ternary_mask, &me->exact_mask.mask.word[0],
sizeof(aaaaaaaaaaaaa1aaat));
int field;
for (field = 0; field < num_fields; field++) {
aaaaaaaaaaa1aaaaaaaaaaaaaaaabaaaaaaaaaaaaaaaaaaaaaaaaaaaa3aaadesc mfd;
rc = a1aaaaaaaaaaaaaaaabaaaaaaaaaaaa3aaaaaaaaaaaaaaaabaaaaaaaaaaaaaaaaaaaaaaaaaaaa3aaaaaaaaaaaaaaaaaaaaa1aaa(tcam->client, field, &mfd);
assert(rc == 0);
if (mfd.type != aaaaaaaaaaa1aaaaaaaaaaaaaaaabaaaaaaaaaaaaaaaaaaaaaaaaaaaa3aaaR16 ||
(me->exact_mask.use_range & 1 << mfd.instance) == 0) {
continue;
}
if (mes->mask.use_range & 1 << mfd.instance) {
cam_write_field((uint32_t *) &ternary_mask.word[0], mfd.start_pos, mfd.len + mfd.start_pos - 1,
(uint32_t *) &me->fields[field].r16.end,
CAM_MAX_KEY_WIDTH - 1);
} else {
aaaaa1aaaaaaaaaaaaaaaabaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaa3aaaaaaaaaaaaaaaabaaaaaaaaaaaaaaaaaaaaaaaaaaaa4bbbbbbbbbbbbbbbbbb4aaaaaaaaaaaaaaaabaaaaaaaaaaaaaaaaaaaaaaaaaaaa5aaabits((uint8_t *) &ternary_mask.word[0],
sizeof(aaaaaaaaaaaaa1aaat),
mfd.start_pos, mfd.len);
}
}
aaaaaaaaaaaaaaaa1aaaaaaaaaaaaaaaabaaaaaaaaaaaaaaaaaaaaaaaaaaaa3aaat key_prio;
rc = a1aaaread_range_key(tcam->client, &new_key, &ternary_mask, &key_prio, &relaxed_mask, mes->mask.use_range,
me->current_entryset.instance);
if (rc) {
       tcam_print_entry(rc, "tcam_get_by_key", tcam, key, mask, NULL, NULL, "");
return rc;
}
const uint16_t response_width = a1aaaaaaaaaaaaaaaabaaaaaaaaaaaa3aaaaaaaaaaaaaaaabaaaaaaaaaaaaaaaaaaaaaaaaaaaa3aaaaaaaaaaaaaaaabaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaa3aaaaaaaaaaaaaaaabaaaaaaaaaaaaaaaaaaaaaaaaaaaa4aaawidth(tcam->client);
const uint8_t prio_width = a1aaaaaaaaaaaaaaaabaaaaaaaaaaaa3aaaaaaaaaaaaaaaabaaaaaaaaaaaaaaaaaaaaaaaaaaaa3aaaaaaaaaaaaaaabaaaaaaaaaaaaaaaaa4aaaaaaaaaaaaaaaabaaaaaaaaaaaaaaaaaaaaaaaaaaaa4aaawidth(tcam->client);
if (prio_width) {
cam_read_field((uint32_t *) &key_prio, response_width, response_width + prio_width - 1, prio);
} else {
*prio = 0;
}
const uint8_t num_bytes = response_width / 8;
const uint16_t remaining_bits = response_width - num_bytes * 8;
if (remaining_bits > 0) {
response[num_bytes] = aaaaaaaa1aaaaaaaaaaaaaaaabaaaaaaaaaaaaaaaaaaaaaa3aaa8(response[num_bytes], *((uint8_t *) &key_prio + num_bytes), 0, remaining_bits);
}
memcpy(response, &key_prio, num_bytes);
   tcam_print_entry(0, "tcam_get_by_key", tcam, key, mask, prio, response, "");
return 0;
}
int
tcam_lookup(struct tcam *tcam, const uint8_t key[], uint8_t response[])
{
int rc;
aaaaaaaaaaaaa1aaat new_key;
memset(&new_key, 0, sizeof(aaaaaaaaaaaaa1aaat));
const uint16_t key_width = a1aaaaaaaaaaaaaaaabaaaaaaaaaaaa3aaaaaaaaaaaaaaaabaaaaaaaaaaaaaaaaaaaaaaaaaaaa3aaaaaaaaaaaaaaaabaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaa3aaaaaaaaaaaaaaaabaaaaaaaaaaaaaaaaaaaaaaaaaaaa4aaawidth(tcam->client);
cam_copy_bits((uint8_t *) &new_key.word[0], key, key_width);
aaaaaaaaaaaaaaaa1aaaaaaaaaaaaaaaabaaaaaaaaaaaaaaaaaaaaaaaaaaaa3aaat prio_resp;
rc = a1bbbbbbbbbbbbbbbbbbbbbb3aaaokup(tcam->client, &new_key, &prio_resp, false);
if (rc == CAM_ERROR_KEY_NOT_FOUND) {
a1aaaaaaaaaaaaaaaabaaaaaaaaaaaa3aaaaaaaaaaaaaaaabaaaaaaaaaaaaaaaaaaaaaaaaaaaa3aaadefault_response(tcam->client, (uint8_t *) &prio_resp, false);
}
else if (rc) {
       tcam_print_entry(rc, "tcam_lookup", tcam, key, NULL, NULL, NULL, "");
return rc;
}
const uint16_t response_width = a1aaaaaaaaaaaaaaaabaaaaaaaaaaaa3aaaaaaaaaaaaaaaabaaaaaaaaaaaaaaaaaaaaaaaaaaaa3aaaaaaaaaaaaaaaabaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaa3aaaaaaaaaaaaaaaabaaaaaaaaaaaaaaaaaaaaaaaaaaaa4aaawidth(tcam->client);
const uint8_t num_bytes = response_width / 8;
const uint16_t remaining_bits = response_width - num_bytes * 8;
if (remaining_bits > 0) {
response[num_bytes] = aaaaaaaa1aaaaaaaaaaaaaaaabaaaaaaaaaaaaaaaaaaaaaa3aaa8(response[num_bytes], *((uint8_t *) &prio_resp + num_bytes), 0, remaining_bits);
}
memcpy(response, &prio_resp, num_bytes);
uint32_t prio;
const uint8_t prio_width = a1aaaaaaaaaaaaaaaabaaaaaaaaaaaa3aaaaaaaaaaaaaaaabaaaaaaaaaaaaaaaaaaaaaaaaaaaa3aaaaaaaaaaaaaaabaaaaaaaaaaaaaaaaa4aaaaaaaaaaaaaaaabaaaaaaaaaaaaaaaaaaaaaaaaaaaa4aaawidth(tcam->client);
if (prio_width) {
cam_read_field((uint32_t *) &prio_resp, response_width, response_width + prio_width - 1, &prio);
} else {
prio = 0;
}
   tcam_print_entry(0, "tcam_lookup", tcam, key, NULL, &prio, response, rc ? "NO_MATCH" : "MATCH");
return rc;
}
int
tcam_delete(struct tcam *tcam, const uint8_t key[], const uint8_t mask[])
{
   tcam_print_entry(0, "tcam_delete", tcam, key, mask, NULL, NULL, "");
int rc;
union aaaaaaaaaaa1aaa fields[CAM_MAX_NUM_FIELDS];
memset(fields, 0, sizeof(union aaaaaaaaaaa1aaa) * CAM_MAX_NUM_FIELDS);
rc = cam_key2fields(tcam, fields, key);
if (rc) {
       tcam_print_entry(rc, "tcam_delete", tcam, key, mask, NULL, NULL, "");
return rc;
}
rc = cam_mask2fields(tcam->client, fields, mask);
if (rc) {
       tcam_print_entry(rc, "tcam_delete", tcam, key, mask, NULL, NULL, "");
return rc;
}
if ((a1aaaaaaaaaaaaaaaabaaaaaaaaaaaa3aaaaaaaaaaaaaaaabaaaaaaaaaaaaaaaaaaaaaaaaaaaa3bbbbbbbbbbbbbbbbbbbbbbbbbbbbbbbbbbbbb3aaaaaaaaaaaaaaaabaaaaaaaaaaaaaaaaaaaaaaaaaaaa4aaaflags(tcam->client) & CAM_DEBUG_KEY_MASKING) == 0) {
cam_mask_fields(tcam, fields);
}
rc = cam_check_fields(tcam, fields);
if (rc) {
       tcam_print_entry(rc, "tcam_delete", tcam, key, mask, NULL, NULL, "");
return rc;
}
struct aaaaa1aaaaaaaaaaaabaaaaaaaaaaa3aaa *me;
const uint8_t num_fields = a1aaaaaaaaaaaaaaaabaaaaaaaaaaaa3aaaaaaaaaaaaaaaabaaaaaaaaaaaaaaaaaaaaaaaaaaaa3aaaaaaaaaaaaaaabaaaaaaaaaaaaaaaa4aaaaaaaaaaaaaaaabaaaaaaaaaaaaaaaaaaaaaaaaaaaa4aaaaaaaaaaaaaaabaaaaaaaaaaaaaaaaaa5aaas(tcam->client);
MH_FIND(mh_handle, tcam->entry_by_fields, fields, num_fields * sizeof(union aaaaaaaaaaa1aaa), me);
if (me == NULL) {
rc = CAM_ERROR_KEY_NOT_FOUND;
       tcam_print_entry(rc, "tcam_delete", tcam, key, mask, NULL, NULL, "");
return rc;
}
rc = aaaaa1aaaaaaaaaaaaaaaabaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaa3aaaaaaaaaaaaaaaabaaaaaaaaaaaaaaaaaaaaaaaaaaaa4aaaaaaaaaaaaaaaabaaaaaaaaaaaaaaaaaaa5aaa(tcam, me, me->current_entryset.mes, me->current_entryset.instance);
if (rc) {
       tcam_print_entry(rc, "tcam_delete", tcam, key, mask, NULL, NULL, "");
return rc;
}
tcam->num_entries--;
tcam->stats.curr_num_entries--;
rc = aaaaa1aaaaaaaaaaaaaaaabaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaa3aaaaaaaaaaaaaaaabaaaaaaaaaaaaaaaaaaaaaaaaaaaa4aaaaaaaaaaaaaaaabaaaaaaaaaaaaaaaaaaa5aaa(tcam, me);
if (rc) {
       tcam_print_entry(rc, "tcam_delete", tcam, key, mask, NULL, NULL, "");
return rc;
}
assert(me->num_collsets == 0);
rc = aaaaa1aaaaaaaaaaaabaaaaaaaaaaa3aaaaaaaaaaaaaaaabaaaaaaaaaaaaaaaaaaaaaaaaaaaa3aaaaaaaaaaaaaaaabaaaaaaaaaaaaaaaaaaaaaaaaa4aaa(tcam, me);
if (rc) {
       tcam_print_entry(rc, "tcam_delete", tcam, key, mask, NULL, NULL, "");
return rc;
}
return 0;
}
static int
aaaaa1aaaaaaaaaaaaaaaabaaaaaaaaaaaaaaaaaaaaaaaaa3aaaaaaaaaaaaaaaabaaaaaaaaaaaaaaaaaaaaaaaaaaaa3aaaaaaaaaaaabaaaaaaaaaaa4aaa(struct tcam *tcam, uint32_t id)
{
int rc;
struct aaaaa1aaaaaaaaaaaabaaaaaaaaaaa3aaa *me;
me = tcam->entries[id];
tcam->num_entries--;
tcam->stats.curr_num_entries--;
rc = aaaaa1aaaaaaaaaaaabaaaaaaaaaaa3aaaaaaaaaaaaaaaabaaaaaaaaaaaaaaaaaaaaaaaaaaaa3aaaaaaaaaaaaaaaabaaaaaaaaaaaaaaaaaaaaaaaaa4aaa(tcam, me);
if (rc)
return rc;
return rc;
}
int tcam_read_and_clear_ecc_counters(struct tcam *tcam,
uint32_t *corrected_single_bit_errors,
uint32_t *detected_double_bit_errors)
{
return a1aaaread_and_clear_ecc_counters(tcam->client, corrected_single_bit_errors,
detected_double_bit_errors);
}
int tcam_read_and_clear_ecc_addresses(struct tcam *tcam,
uint32_t *failing_address_single_bit_error,
uint32_t *failing_address_double_bit_error)
{
return a1aaaread_and_clear_ecc_addresses(tcam->client,
failing_address_single_bit_error,
failing_address_double_bit_error);
}
int
tcam_destroy(struct tcam *tcam)
{
uint16_t i;
const uint32_t num_entries = a1aaaaaaaaaaaaaaaabaaaaaaaaaaaa3aaaaaaaaaaaaaaaabaaaaaaaaaaaaaaaaaaaaaaaaaaaa3aaaaaaaaaaaaaaabaaaaaaaaaaaaaaaa4aaaaaaaaaaaaaaaabaaaaaaaaaaaaaaaaaaaaaaaaaaaa4aaaaaaaaaaaaaaaabaaaaaaaaaaaaaaaaaaaaa5aaa(tcam->client);
for (i = 0; i < num_entries; i++)
if (tcam->entries[i] != NULL)
(void) aaaaa1aaaaaaaaaaaaaaaabaaaaaaaaaaaaaaaaaaaaaaaaa3aaaaaaaaaaaaaaaabaaaaaaaaaaaaaaaaaaaaaaaaaaaa3aaaaaaaaaaaabaaaaaaaaaaa4aaa(tcam, i);
return aaaaa1aaaaaaaa1aaaaaaaaaaaaaaaabaaaaaaaaaaaaaaaaaaaaaaaaa3aaa(tcam);
}
int
tcam_get_stats(struct tcam *tcam, struct aaaaa1aaastats *stats)
{
*stats = tcam->stats;
return 0;
}
#ifndef VC_HBMDEF_H
#define VC_HBMDEF_H
#define Haa1aaaBCAM_BASE_CNF_VC_CMD_VIRTUAL_CONTAINER_OFFSET (0x90) 
#define Haa1aaaBCAM_BASE_CNF_VC_WRITE_DATA_REG_OFFSET (0x94) 
#define Haa1aaaBCAM_NUMBER_SEGMENTS 256
#define Haa1aaaBCAM_BASE_CNF_VC_CMD_RD (0x1)
#define Haa1aaaBCAM_BASE_CNF_VC_CMD_WR (0x0)
#define Haa1aaaBCAM_BASE_CNF_VC_WRITE_DATA_REG_SHIFT_SEG_0 (0)
#define Haa1aaaBCAM_BASE_CNF_VC_WRITE_DATA_REG_SHIFT_SEG_1 (8)
#define Haa1aaaBCAM_BASE_CNF_VC_WRITE_DATA_REG_SHIFT_SEG_2 (16)
#define Haa1aaaBCAM_BASE_CNF_VC_WRITE_DATA_REG_SHIFT_SEG_3 (24)
#define Haa1aaaBCAM_BASE_CNF_VC_WRITE_NUM_SEGS (4)
#define Haa1aaaBCAM_BASE_CNF_VC_CMD_REG_OFFSET (0x90) 
#define Haa1aaaBCAM_BASE_CNF_VC_CMD_REG_MASK (0xffffffff)
#define Haa1aaaBCAM_BASE_CNF_VC_CMD_REG_SHIFT (0)
#define Haa1aaaBCAM_BASE_CNF_VC_CMD_CNF_VC_CMD_OFFSET (0x90) 
#define Haa1aaaBCAM_BASE_CNF_VC_CMD_CNF_VC_CMD_ACCESS (XLNX_RW)
#define Haa1aaaBCAM_BASE_CNF_VC_CMD_REG_NUM (0x1)
#define Haa1aaaBCAM_BASE_CNF_VC_CMD_CNF_VC_CMD_MASK (0xffffff)
#define Haa1aaaBCAM_BASE_CNF_VC_CMD_CNF_VC_CMD_SHIFT (0)
#define Haa1aaaBCAM_BASE_CNF_VC_CMD_REG_OFFSET (0x90) 
#define Haa1aaaBCAM_BASE_CNF_VC_CMD_REG_MASK (0xffffffff)
#define Haa1aaaBCAM_BASE_CNF_VC_CMD_REG_SHIFT (0)
#define Haa1aaaBCAM_BASE_CNF_VC_CMD_INPUT_OUTPUT_SPEC_OFFSET (0x90) 
#define Haa1aaaBCAM_BASE_CNF_VC_CMD_INPUT_OUTPUT_SPEC_ACCESS (XLNX_RW)
#define Haa1aaaBCAM_BASE_CNF_VC_CMD_INPUT_OUTPUT_SPEC_MASK (0x1)
#define Haa1aaaBCAM_BASE_CNF_VC_CMD_INPUT_OUTPUT_SPEC_SHIFT (0)
#define Haa1aaaBCAM_BASE_CNF_VC_CMD_SEGMENT_ADDRESS_OFFSET (0x90) 
#define Haa1aaaBCAM_BASE_CNF_VC_CMD_SEGMENT_ADDRESS_ACCESS (XLNX_RW)
#define Haa1aaaBCAM_BASE_CNF_VC_CMD_SEGMENT_ADDRESS_MASK (0x1f00)
#define Haa1aaaBCAM_BASE_CNF_VC_CMD_SEGMENT_ADDRESS_SHIFT (8)
#define Haa1aaaBCAM_BASE_CNF_VC_CMD_VIRTUAL_CONTAINER_OFFSET (0x90) 
#define Haa1aaaBCAM_BASE_CNF_VC_CMD_VIRTUAL_CONTAINER_ACCESS (XLNX_RW)
#define Haa1aaaBCAM_BASE_CNF_VC_CMD_VIRTUAL_CONTAINER_MASK (0xff0000)
#define Haa1aaaBCAM_BASE_CNF_VC_CMD_VIRTUAL_CONTAINER_SHIFT (16)
#define Haa1aaaBCAM_BASE_CNF_VC_WRITE_DATA_REG_OFFSET (0x94) 
#define Haa1aaaBCAM_BASE_CNF_VC_WRITE_DATA_REG_MASK (0xffffffff)
#define Haa1aaaBCAM_BASE_CNF_VC_WRITE_DATA_REG_SHIFT (0)
#define Haa1aaaBCAM_BASE_CNF_VC_WRITE_DATA_CNF_VC_WRITE_DATA_OFFSET (0x94) 
#define Haa1aaaBCAM_BASE_CNF_VC_WRITE_DATA_CNF_VC_WRITE_DATA_ACCESS (XLNX_RW)
#define Haa1aaaBCAM_BASE_CNF_VC_WRITE_DATA_REG_NUM (0x1)
#define Haa1aaaBCAM_BASE_CNF_VC_WRITE_DATA_CNF_VC_WRITE_DATA_MASK (0xffffffff)
#define Haa1aaaBCAM_BASE_CNF_VC_WRITE_DATA_CNF_VC_WRITE_DATA_SHIFT (0)
#endif
typedef struct vbcam
{
cam_config_t *conf;
uint16_t seg_map[CAM_MAX_SEGMENT_HASH_ENTRIES]; 
struct bcam* bcam_hdl[CAM_MAX_VC_SEGMENTS]; 
segment_ctx_t *segment_ctx[CAM_MAX_VC_SEGMENTS]; 
} vbcam;
static void setup_segment_table(vbcam *vbcam);
static void download_segment_table(const vbcam *vbcam);
static struct bcam* get_bcam_handle(const vbcam* vbcam, const uint8_t key[], cam_options_t *options);
static bool is_segment_used(const vbcam* vbcam, uint16_t segment)
{
const uint8_t byte = segment / 8;
const uint8_t bit = segment % 8;
return (0 < (vbcam->conf->arg.vc_seg_map.bit_map[byte] & (1 << bit)));
}
static void setup_segment_table(vbcam* vbcam)
{
uint16_t num_segs = 0; 
uint32_t allocated_segs[CAM_MAX_VC_SEGMENTS]; 
for (uint32_t seg_count = 0; seg_count < CAM_MAX_VC_SEGMENTS; seg_count++)
{
if (is_segment_used(vbcam, seg_count))
{
allocated_segs[num_segs] = seg_count;
num_segs++;
}
}
uint32_t num = 0;
for (uint32_t hash_entry_count = 0; hash_entry_count < CAM_MAX_SEGMENT_HASH_ENTRIES; hash_entry_count++)
{
num = num % num_segs;
vbcam->seg_map[hash_entry_count] = allocated_segs[num];
num++;
}
}
static void download_segment_table(const vbcam* vbcam)
{
uint32_t vc_id, u32Byte;
uint32_t entry_addr = 0x00;
vc_id = vbcam->conf->arg.vc_seg_map.vcid << Haa1aaaBCAM_BASE_CNF_VC_CMD_VIRTUAL_CONTAINER_SHIFT;
u32Byte = vc_id | entry_addr | Haa1aaaBCAM_BASE_CNF_VC_CMD_WR;
vbcam->conf->arg.hw_write_function(vbcam->conf->ctx, Haa1aaaBCAM_BASE_CNF_VC_CMD_REG_OFFSET, u32Byte);
for (uint16_t entry_count = 0; entry_count < CAM_MAX_SEGMENT_HASH_ENTRIES; entry_count += Haa1aaaBCAM_BASE_CNF_VC_WRITE_NUM_SEGS)
{
u32Byte = ((vbcam->seg_map[entry_count] << Haa1aaaBCAM_BASE_CNF_VC_WRITE_DATA_REG_SHIFT_SEG_0)
| (vbcam->seg_map[entry_count + 1] << Haa1aaaBCAM_BASE_CNF_VC_WRITE_DATA_REG_SHIFT_SEG_1)
| (vbcam->seg_map[entry_count + 2] << Haa1aaaBCAM_BASE_CNF_VC_WRITE_DATA_REG_SHIFT_SEG_2)
| (vbcam->seg_map[entry_count + 3] << Haa1aaaBCAM_BASE_CNF_VC_WRITE_DATA_REG_SHIFT_SEG_3));
vbcam->conf->arg.hw_write_function(vbcam->conf->ctx, Haa1aaaBCAM_BASE_CNF_VC_WRITE_DATA_REG_OFFSET,
u32Byte);
}
}
static struct bcam* get_bcam_handle(const vbcam* vbcam, const uint8_t key[], cam_options_t *options)
{
uint8_t hash_value[32];
uint16_t segment;
if (options->precomp_hash)
memcpy(hash_value, &(options->hash_value), 4);
else
{
vbcam_compute_hash_value(vbcam, key, hash_value, options);
cam_options_set_precomputed_hash_value(options, hash_value);
}
vbcam_get_segment(vbcam, hash_value, &segment);
struct bcam* bcam_hdl = vbcam->bcam_hdl[segment];
assert(bcam_hdl != NULL);
return bcam_hdl;
}
int vbcam_create(const cam_arg_t* cam_arg, struct vbcam** out_vbcam)
{
NULL_CHECK(cam_arg);
uint16_t hdl_seg_create;
vbcam *new_vbcam = cam_arg->calloc_function(1, sizeof(vbcam)); 
if (new_vbcam == NULL)
{
return CAM_ERROR_MALLOC_FAILED;
}
cam_arg_t* cam_arg_bcam_hdl = alloca(cam_arg_size());
cam_arg_init(cam_arg_bcam_hdl);
cam_config_t *cam_conf;
int rc = cam_config_create(cam_arg, HBMBCAM, &cam_conf);
if (rc != CAM_OK)
{
cam_arg->free_function(new_vbcam);
return rc;
}
new_vbcam->conf = cam_conf;
setup_segment_table(new_vbcam);
download_segment_table(new_vbcam);
*cam_arg_bcam_hdl = *cam_arg;
cam_arg_set_ram_size(cam_arg_bcam_hdl, (cam_arg->ram_size / CAM_MAX_VC_SEGMENTS)); 
cam_arg_set_num_entries(cam_arg_bcam_hdl, (cam_arg->num_entries / CAM_MAX_VC_SEGMENTS));
uint32_t hdl_count = 0;
camp_arg_set_vcid(cam_arg_bcam_hdl, cam_arg_bcam_hdl->vc_seg_map.vcid);
cam_arg_bcam_hdl->vc_seg_map.vcid = -1;
cam_arg_enable_options(cam_arg_bcam_hdl); 
for (hdl_seg_create = 0; hdl_seg_create < CAM_MAX_VC_SEGMENTS; hdl_seg_create++)
{
if (is_segment_used(new_vbcam, hdl_seg_create))
{
if (hdl_count > 0)
{
cam_arg_bcam_hdl->debug_flags &= ~CAM_DEBUG_VERIFY_CONFIG;
}
hdl_count++;
camp_arg_set_seg(cam_arg_bcam_hdl, hdl_seg_create);
rc = bcam_create(cam_arg_bcam_hdl, &(new_vbcam->bcam_hdl[hdl_seg_create]));
if (rc != CAM_OK)
{
cam_arg->free_function(new_vbcam->segment_ctx[hdl_seg_create]);
goto vc_cleanup;
}
}
}
*out_vbcam = new_vbcam;
return CAM_OK;
vc_cleanup:
for (uint16_t hdl_seg_destroy = 0; hdl_seg_destroy < hdl_seg_create; hdl_seg_destroy++)
{
if (is_segment_used(new_vbcam, hdl_seg_destroy))
{
if (new_vbcam->bcam_hdl[hdl_seg_destroy] != NULL)
{
bcam_destroy(new_vbcam->bcam_hdl[hdl_seg_destroy]);
cam_arg->free_function(new_vbcam->segment_ctx[hdl_seg_destroy]);
}
}
}
cam_arg->free_function(cam_conf);
cam_arg->free_function(new_vbcam);
return rc;
}
int vbcam_destroy(struct vbcam* vbcam)
{
NULL_CHECK(vbcam);
int return_rc = CAM_OK;
for (uint32_t segment = 0; segment < CAM_MAX_VC_SEGMENTS; segment++)
{
if (is_segment_used(vbcam, segment))
{
if (vbcam->bcam_hdl[segment] != NULL)
{
int rc = bcam_destroy(vbcam->bcam_hdl[segment]);
if (rc)
return_rc = rc;
vbcam->conf->arg.free_function(vbcam->segment_ctx[segment]);
}
}
}
cam_free_func free_function = vbcam->conf->arg.free_function;
cam_config_destroy(vbcam->conf);
free_function(vbcam);
return return_rc;
}
int vbcam_insert(struct vbcam* vbcam, const uint8_t key[], const uint8_t response[], const cam_options_t *options)
{
cam_options_t new_options = *options;
struct bcam *bcam_hdl = get_bcam_handle(vbcam, key, &new_options);
const int rc = bcam_insert(bcam_hdl, key, response, &new_options);
return rc;
}
int vbcam_compute_hash_value(const struct vbcam* vbcam, const uint8_t key[], uint8_t hash_value[32],
const cam_options_t *options)
{
NULL_CHECK(vbcam);
aaaaaaaaaaaaa1aaat new_key;
memset(&new_key, 0, sizeof(aaaaaaaaaaaaa1aaat));
uint16_t key_width;
if (options->narrow)
key_width = vbcam->conf->arg.narrow_key_width;
else
key_width = vbcam->conf->arg.key_width;
cam_copy_bits((uint8_t *) &new_key.word[0], key, key_width);
const uint16_t num_bytes = (key_width + 7) / 8;
memset(hash_value, 0, 32);
murmur3((const void*) &new_key.word[0], num_bytes, 3, (uint32_t *) hash_value);
return 0;
}
int vbcam_get_segment(const struct vbcam* vbcam, const uint8_t hash_value[32], uint16_t* segment)
{
NULL_CHECK(vbcam);
uint32_t murmur_hash_value = *((uint32_t *) &hash_value[0]);
assert(CAM_MAX_SEGMENT_HASH_ENTRIES_WIDTH == 8);
const uint32_t segment_hash_entry = (murmur_hash_value & 0x000000ff) ^ ((murmur_hash_value & 0x0000ff00) >> 8)
^ ((murmur_hash_value & 0x00ff0000) >> 16) ^ ((murmur_hash_value & 0xff000000) >> 24);
*segment = vbcam->seg_map[segment_hash_entry]; 
return 0;
}
int vbcam_update(struct vbcam* vbcam, const uint8_t key[], const uint8_t response[], const cam_options_t *options)
{
NULL_CHECK(vbcam);
cam_options_t new_options = *options;
struct bcam* bcam_hdl = get_bcam_handle(vbcam, key, &new_options);
int rc = bcam_update(bcam_hdl, key, response, &new_options);
return rc;
}
int vbcam_get_by_response(struct vbcam* vbcam, const uint8_t response[], const uint8_t response_mask[], uint32_t* pos,
uint8_t out_key[], const cam_options_t *options)
{
NULL_CHECK(vbcam);
NULL_CHECK(response);
NULL_CHECK(response_mask);
NULL_CHECK(pos);
uint32_t rc = CAM_OK;
struct bcam* bcam_hdl;
for (uint16_t seg_num = 0; seg_num < CAM_MAX_VC_SEGMENTS; seg_num++)
{
if (is_segment_used(vbcam, seg_num))
{
bcam_hdl = vbcam->bcam_hdl[seg_num];
rc = bcam_get_by_response(bcam_hdl, response, response_mask, pos, out_key, options);
if (rc != CAM_ERROR_KEY_NOT_FOUND)
{
break;
}
}
}
return rc;
}
int vbcam_get_by_key(struct vbcam* vbcam, const uint8_t key[], uint8_t response[], const cam_options_t *options)
{
NULL_CHECK(vbcam);
cam_options_t new_options = *options;
struct bcam* bcam_hdl = get_bcam_handle(vbcam, key, &new_options);
int rc = bcam_get_by_key(bcam_hdl, key, response, &new_options);
return rc;
}
int vbcam_delete(struct vbcam* vbcam, const uint8_t key[], const cam_options_t *options)
{
NULL_CHECK(vbcam);
cam_options_t new_options = *options;
struct bcam* bcam_hdl = get_bcam_handle(vbcam, key, &new_options);
int rc = bcam_delete(bcam_hdl, key, &new_options);
return rc;
}
int vbcam_read_and_clear_ecc_counters(struct vbcam* vbcam, uint32_t* corrected_single_bit_errors,
uint32_t* detected_double_bit_errors)
{
NULL_CHECK(vbcam);
uint32_t rc = CAM_OK;
return rc;
}
int vbcam_read_and_clear_ecc_addresses(struct vbcam* vbcam, uint32_t* failing_address_single_bit_error,
uint32_t* failing_address_double_bit_error)
{
NULL_CHECK(vbcam);
uint32_t rc = CAM_OK;
return rc;
}
